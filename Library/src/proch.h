#ifndef PROCH_H
#define PROCH_H

/* Generated by kstructs */
#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>

struct ks__vm_map;
typedef struct ks__vm_map ks__vm_map;
struct ks_buf;
typedef struct ks_buf ks_buf;
struct ks_doc_tombstone;
typedef struct ks_doc_tombstone ks_doc_tombstone;
struct ks_dtrace_difv;
typedef struct ks_dtrace_difv ks_dtrace_difv;
struct ks_dtrace_dstate_percpu;
typedef struct ks_dtrace_dstate_percpu ks_dtrace_dstate_percpu;
struct ks_dtrace_dynhash;
typedef struct ks_dtrace_dynhash ks_dtrace_dynhash;
struct ks_dtrace_helper_action;
typedef struct ks_dtrace_helper_action ks_dtrace_helper_action;
struct ks_dtrace_helper_provider;
typedef struct ks_dtrace_helper_provider ks_dtrace_helper_provider;
struct ks_dtrace_state;
typedef struct ks_dtrace_state ks_dtrace_state;
struct ks_dtrace_statvar;
typedef struct ks_dtrace_statvar ks_dtrace_statvar;
struct ks_fifoinfo;
typedef struct ks_fifoinfo ks_fifoinfo;
struct ks_file_lease;
typedef struct ks_file_lease ks_file_lease;
struct ks_fileproc;
typedef struct ks_fileproc ks_fileproc;
struct ks_image_params;
typedef struct ks_image_params ks_image_params;
struct ks_internal_state;
typedef struct ks_internal_state ks_internal_state;
struct ks_kaudit_record;
typedef struct ks_kaudit_record ks_kaudit_record;
struct ks_knote;
typedef struct ks_knote ks_knote;
struct ks_knote_lock_ctx;
typedef struct ks_knote_lock_ctx ks_knote_lock_ctx;
struct ks_kqworkloop;
typedef struct ks_kqworkloop ks_kqworkloop;
struct ks_label;
typedef struct ks_label ks_label;
struct ks_lockf;
typedef struct ks_lockf ks_lockf;
struct ks_mount;
typedef struct ks_mount ks_mount;
struct ks_namecache;
typedef struct ks_namecache ks_namecache;
struct ks_pollfd;
typedef struct ks_pollfd ks_pollfd;
struct ks_select_nocancel_args;
typedef struct ks_select_nocancel_args ks_select_nocancel_args;
struct ks_select_set;
typedef struct ks_select_set ks_select_set;
struct ks_session;
typedef struct ks_session ks_session;
struct ks_socket;
typedef struct ks_socket ks_socket;
struct ks_specinfo;
typedef struct ks_specinfo ks_specinfo;
struct ks_task;
typedef struct ks_task ks_task;
struct ks_thread;
typedef struct ks_thread ks_thread;
struct ks_thread_call;
typedef struct ks_thread_call ks_thread_call;
struct ks_turnstile;
typedef struct ks_turnstile ks_turnstile;
struct ks_ubc_info;
typedef struct ks_ubc_info ks_ubc_info;
struct ks_ucred;
typedef struct ks_ucred ks_ucred;
struct ks_ull;
typedef struct ks_ull ks_ull;
struct ks_vnode_resolve;
typedef struct ks_vnode_resolve ks_vnode_resolve;
struct ks_wait4_nocancel_args;
typedef struct ks_wait4_nocancel_args ks_wait4_nocancel_args;
struct ks_waitid_nocancel_args;
typedef struct ks_waitid_nocancel_args ks_waitid_nocancel_args;
struct ks_work_interval;
typedef struct ks_work_interval ks_work_interval;

enum {
    AIO_READ = 1,
    AIO_WRITE = 2,
    AIO_FSYNC = 4,
    AIO_DSYNC = 8,
    AIO_LIO = 16,
    AIO_LIO_WAIT = 32,
    AIO_COMPLETED = 256,
    AIO_CANCELLED = 512,
    AIO_CLOSE_WAIT = 16384,
    AIO_EXIT_WAIT = 32768,
};

enum {
    DTRACE_DSTATE_CLEAN = 0,
    DTRACE_DSTATE_EMPTY = 1,
    DTRACE_DSTATE_DIRTY = 2,
    DTRACE_DSTATE_RINSING = 3,
};

enum {
    FD_CHROOT = 1,
    FD_WORKLOOP = 2,
};

enum {
    KCD_CD_FLAG_IN_MARK = 1,
    KCD_CD_FLAG_FINALIZE = 2,
};

enum {
    KCDCT_NONE = 0,
    KCDCT_ZLIB = 1,
};

enum {
    KQ_SLEEP = 2,
    KQ_PROCWAIT = 4,
    KQ_KEV32 = 8,
    KQ_KEV64 = 16,
    KQ_KEV_QOS = 32,
    KQ_WORKQ = 64,
    KQ_WORKLOOP = 128,
    KQ_PROCESSING = 256,
    KQ_DRAIN = 512,
    KQ_DYNAMIC = 2048,
    KQ_R2K_ARMED = 4096,
    KQ_HAS_TURNSTILE = 8192,
};

enum {
    PERSONA_INVALID = 0,
    PERSONA_GUEST = 1,
    PERSONA_MANAGED = 2,
    PERSONA_PRIV = 3,
    PERSONA_SYSTEM = 4,
    PERSONA_DEFAULT = 5,
    PERSONA_SYSTEM_PROXY = 6,
    PERSONA_SYS_EXT = 7,
    PERSONA_ENTERPRISE = 8,
    PERSONA_TYPE_MAX = 8,
};

enum {
    TASK_CONTROL_PORT_OPTIONS_INVALID = 0,
    TASK_CONTROL_PORT_OPTIONS_NONE = 1,
    TASK_CONTROL_PORT_IMMOVABLE_HARD = 2,
    TASK_CONTROL_PORT_IMMOVABLE_MASK = 2,
};

enum {
    WQ_EXITING = 1,
    WQ_PROC_SUSPENDED = 2,
    WQ_DEATH_CALL_SCHEDULED = 4,
    WQ_DELAYED_CALL_SCHEDULED = 16,
    WQ_DELAYED_CALL_PENDED = 32,
    WQ_IMMEDIATE_CALL_SCHEDULED = 64,
    WQ_IMMEDIATE_CALL_PENDED = 128,
};

enum {
    WORKQ_TR_FLAG_KEVENT = 1,
    WORKQ_TR_FLAG_WORKLOOP = 2,
    WORKQ_TR_FLAG_OVERCOMMIT = 4,
    WORKQ_TR_FLAG_WL_PARAMS = 8,
    WORKQ_TR_FLAG_WL_OUTSIDE_QOS = 16,
    WORKQ_TR_FLAG_COOPERATIVE = 32,
    WORKQ_TR_FLAG_PERMANENT_BIND = 64,
};

enum {
    WORKQ_TR_STATE_IDLE = 0,
    WORKQ_TR_STATE_NEW = 1,
    WORKQ_TR_STATE_QUEUED = 2,
    WORKQ_TR_STATE_CANCELED = 3,
    WORKQ_TR_STATE_BINDING = 4,
    WORKQ_TR_STATE_BOUND = 5,
};

union ks_sigval {
    int sival_int;
    void *sival_ptr;
};
_Static_assert(offsetof(union ks_sigval, sival_int) == 0x0, "ks_sigval.sival_int offset");
_Static_assert(offsetof(union ks_sigval, sival_ptr) == 0x0, "ks_sigval.sival_ptr offset");

struct ks___siginfo {
    int si_signo;
    int si_errno;
    int si_code;
    int si_pid;
    unsigned int si_uid;
    int si_status;
    void *si_addr;
    union ks_sigval si_value;
    long si_band;
    unsigned long __pad[7];
};
_Static_assert(offsetof(struct ks___siginfo, si_signo) == 0x0, "ks___siginfo.si_signo offset");
_Static_assert(offsetof(struct ks___siginfo, si_errno) == 0x4, "ks___siginfo.si_errno offset");
_Static_assert(offsetof(struct ks___siginfo, si_code) == 0x8, "ks___siginfo.si_code offset");
_Static_assert(offsetof(struct ks___siginfo, si_pid) == 0xc, "ks___siginfo.si_pid offset");
_Static_assert(offsetof(struct ks___siginfo, si_uid) == 0x10, "ks___siginfo.si_uid offset");
_Static_assert(offsetof(struct ks___siginfo, si_status) == 0x14, "ks___siginfo.si_status offset");
_Static_assert(offsetof(struct ks___siginfo, si_addr) == 0x18, "ks___siginfo.si_addr offset");
_Static_assert(offsetof(struct ks___siginfo, si_value) == 0x20, "ks___siginfo.si_value offset");
_Static_assert(offsetof(struct ks___siginfo, si_band) == 0x28, "ks___siginfo.si_band offset");
_Static_assert(offsetof(struct ks___siginfo, __pad) == 0x30, "ks___siginfo.__pad offset");

struct ks___smrq_slink_t {
    volatile struct ks_smrq_slink *__smr_ptr;
};
_Static_assert(offsetof(struct ks___smrq_slink_t, __smr_ptr) == 0x0, "ks___smrq_slink_t.__smr_ptr offset");

struct ks___tds {
    unsigned char _t_dtrace_on;
    unsigned char _t_dtrace_step;
    unsigned char _t_dtrace_ret;
    unsigned char _t_dtrace_ast;
    unsigned char _t_dtrace_reg;
};
_Static_assert(offsetof(struct ks___tds, _t_dtrace_on) == 0x0, "ks___tds._t_dtrace_on offset");
_Static_assert(offsetof(struct ks___tds, _t_dtrace_step) == 0x1, "ks___tds._t_dtrace_step offset");
_Static_assert(offsetof(struct ks___tds, _t_dtrace_ret) == 0x2, "ks___tds._t_dtrace_ret offset");
_Static_assert(offsetof(struct ks___tds, _t_dtrace_ast) == 0x3, "ks___tds._t_dtrace_ast offset");
_Static_assert(offsetof(struct ks___tds, _t_dtrace_reg) == 0x4, "ks___tds._t_dtrace_reg offset");

struct ks__bsdthread_terminate {
    unsigned long long ulock_addr;
    unsigned int kport;
};
_Static_assert(offsetof(struct ks__bsdthread_terminate, ulock_addr) == 0x0, "ks__bsdthread_terminate.ulock_addr offset");
_Static_assert(offsetof(struct ks__bsdthread_terminate, kport) == 0x8, "ks__bsdthread_terminate.kport offset");

struct ks__exec_data {
    struct ks_image_params *imgp;
};
_Static_assert(offsetof(struct ks__exec_data, imgp) == 0x0, "ks__exec_data.imgp offset");

struct ks__kauth {
    unsigned long long message;
};
_Static_assert(offsetof(struct ks__kauth, message) == 0x0, "ks__kauth.message offset");

struct ks_kevent_qos_s {
    unsigned long long ident;
    short filter;
    unsigned short flags;
    int qos;
    unsigned long long udata;
    unsigned int fflags;
    unsigned int xflags;
    long long data;
    unsigned long long ext[4];
};
_Static_assert(offsetof(struct ks_kevent_qos_s, ident) == 0x0, "ks_kevent_qos_s.ident offset");
_Static_assert(offsetof(struct ks_kevent_qos_s, filter) == 0x8, "ks_kevent_qos_s.filter offset");
_Static_assert(offsetof(struct ks_kevent_qos_s, flags) == 0xa, "ks_kevent_qos_s.flags offset");
_Static_assert(offsetof(struct ks_kevent_qos_s, qos) == 0xc, "ks_kevent_qos_s.qos offset");
_Static_assert(offsetof(struct ks_kevent_qos_s, udata) == 0x10, "ks_kevent_qos_s.udata offset");
_Static_assert(offsetof(struct ks_kevent_qos_s, fflags) == 0x18, "ks_kevent_qos_s.fflags offset");
_Static_assert(offsetof(struct ks_kevent_qos_s, xflags) == 0x1c, "ks_kevent_qos_s.xflags offset");
_Static_assert(offsetof(struct ks_kevent_qos_s, data) == 0x20, "ks_kevent_qos_s.data offset");
_Static_assert(offsetof(struct ks_kevent_qos_s, ext) == 0x28, "ks_kevent_qos_s.ext offset");

struct ks__kevent_register {
    struct ks_kevent_qos_s kev;
    struct ks_thread *handoff_thread;
    struct ks_kqworkloop *kqwl;
    int eventout;
    unsigned long long ueventlist;
};
_Static_assert(offsetof(struct ks__kevent_register, kev) == 0x0, "ks__kevent_register.kev offset");
_Static_assert(offsetof(struct ks__kevent_register, handoff_thread) == 0x48, "ks__kevent_register.handoff_thread offset");
_Static_assert(offsetof(struct ks__kevent_register, kqwl) == 0x50, "ks__kevent_register.kqwl offset");
_Static_assert(offsetof(struct ks__kevent_register, eventout) == 0x58, "ks__kevent_register.eventout offset");
_Static_assert(offsetof(struct ks__kevent_register, ueventlist) == 0x60, "ks__kevent_register.ueventlist offset");

struct ks__select {
    unsigned int *ibits;
    unsigned int *obits;
    unsigned int nbytes;
};
_Static_assert(offsetof(struct ks__select, ibits) == 0x0, "ks__select.ibits offset");
_Static_assert(offsetof(struct ks__select, obits) == 0x8, "ks__select.obits offset");
_Static_assert(offsetof(struct ks__select, nbytes) == 0x10, "ks__select.nbytes offset");

struct ks__select_data {
    unsigned long long abstime;
    int count;
    struct ks_select_nocancel_args *args;
    int *retval;
};
_Static_assert(offsetof(struct ks__select_data, abstime) == 0x0, "ks__select_data.abstime offset");
_Static_assert(offsetof(struct ks__select_data, count) == 0x8, "ks__select_data.count offset");
_Static_assert(offsetof(struct ks__select_data, args) == 0x10, "ks__select_data.args offset");
_Static_assert(offsetof(struct ks__select_data, retval) == 0x18, "ks__select_data.retval offset");

struct ks__ulock_wait_data {
    struct ks_ull *ull;
    struct ks_thread *owner_thread;
    struct ks_thread *old_owner;
    int *retval;
    unsigned int flags;
};
_Static_assert(offsetof(struct ks__ulock_wait_data, ull) == 0x0, "ks__ulock_wait_data.ull offset");
_Static_assert(offsetof(struct ks__ulock_wait_data, owner_thread) == 0x8, "ks__ulock_wait_data.owner_thread offset");
_Static_assert(offsetof(struct ks__ulock_wait_data, old_owner) == 0x10, "ks__ulock_wait_data.old_owner offset");
_Static_assert(offsetof(struct ks__ulock_wait_data, retval) == 0x18, "ks__ulock_wait_data.retval offset");
_Static_assert(offsetof(struct ks__ulock_wait_data, flags) == 0x20, "ks__ulock_wait_data.flags offset");

struct ks__wait4_data {
    struct ks_wait4_nocancel_args *args;
    int *retval;
};
_Static_assert(offsetof(struct ks__wait4_data, args) == 0x0, "ks__wait4_data.args offset");
_Static_assert(offsetof(struct ks__wait4_data, retval) == 0x8, "ks__wait4_data.retval offset");

struct ks__waitid_data {
    struct ks_waitid_nocancel_args *args;
    int *retval;
};
_Static_assert(offsetof(struct ks__waitid_data, args) == 0x0, "ks__waitid_data.args offset");
_Static_assert(offsetof(struct ks__waitid_data, retval) == 0x8, "ks__waitid_data.retval offset");

struct ks__workq_park_data {
    unsigned long long idle_stamp;
    unsigned long long workloop_params;
    unsigned int fulfilled_snapshot;
    unsigned int yields;
    void *thread_request;
    unsigned int upcall_flags;
    _Bool has_stack;
    unsigned char qos;
};
_Static_assert(offsetof(struct ks__workq_park_data, idle_stamp) == 0x0, "ks__workq_park_data.idle_stamp offset");
_Static_assert(offsetof(struct ks__workq_park_data, workloop_params) == 0x8, "ks__workq_park_data.workloop_params offset");
_Static_assert(offsetof(struct ks__workq_park_data, fulfilled_snapshot) == 0x10, "ks__workq_park_data.fulfilled_snapshot offset");
_Static_assert(offsetof(struct ks__workq_park_data, yields) == 0x14, "ks__workq_park_data.yields offset");
_Static_assert(offsetof(struct ks__workq_park_data, thread_request) == 0x18, "ks__workq_park_data.thread_request offset");
_Static_assert(offsetof(struct ks__workq_park_data, upcall_flags) == 0x20, "ks__workq_park_data.upcall_flags offset");
_Static_assert(offsetof(struct ks__workq_park_data, has_stack) == 0x24, "ks__workq_park_data.has_stack offset");
_Static_assert(offsetof(struct ks__workq_park_data, qos) == 0x25, "ks__workq_park_data.qos offset");

struct ks_aio_workq_entry_aio_proc_link {
    struct ks_aio_workq_entry *tqe_next;
    struct ks_aio_workq_entry **tqe_prev;
};
_Static_assert(offsetof(struct ks_aio_workq_entry_aio_proc_link, tqe_next) == 0x0, "ks_aio_workq_entry_aio_proc_link.tqe_next offset");
_Static_assert(offsetof(struct ks_aio_workq_entry_aio_proc_link, tqe_prev) == 0x8, "ks_aio_workq_entry_aio_proc_link.tqe_prev offset");

struct ks_aio_workq_entry_aio_workq_link {
    struct ks_aio_workq_entry *tqe_next;
    struct ks_aio_workq_entry **tqe_prev;
};
_Static_assert(offsetof(struct ks_aio_workq_entry_aio_workq_link, tqe_next) == 0x0, "ks_aio_workq_entry_aio_workq_link.tqe_next offset");
_Static_assert(offsetof(struct ks_aio_workq_entry_aio_workq_link, tqe_prev) == 0x8, "ks_aio_workq_entry_aio_workq_link.tqe_prev offset");

struct ks_os_refcnt {
    unsigned int ref_count;
};
_Static_assert(offsetof(struct ks_os_refcnt, ref_count) == 0x0, "ks_os_refcnt.ref_count offset");

struct ks_user_sigval_size_equivalent {
    unsigned int pad;
    int sival_int;
};
_Static_assert(offsetof(struct ks_user_sigval_size_equivalent, pad) == 0x0, "ks_user_sigval_size_equivalent.pad offset");
_Static_assert(offsetof(struct ks_user_sigval_size_equivalent, sival_int) == 0x4, "ks_user_sigval_size_equivalent.sival_int offset");

union ks_user_sigval {
    struct ks_user_sigval_size_equivalent size_equivalent;
    unsigned long long sival_ptr;
};
_Static_assert(offsetof(union ks_user_sigval, size_equivalent) == 0x0, "ks_user_sigval.size_equivalent offset");
_Static_assert(offsetof(union ks_user_sigval, sival_ptr) == 0x0, "ks_user_sigval.sival_ptr offset");

struct ks_user_sigevent {
    int sigev_notify;
    int sigev_signo;
    union ks_user_sigval sigev_value;
    unsigned long long sigev_notify_function;
    unsigned long long sigev_notify_attributes;
};
_Static_assert(offsetof(struct ks_user_sigevent, sigev_notify) == 0x0, "ks_user_sigevent.sigev_notify offset");
_Static_assert(offsetof(struct ks_user_sigevent, sigev_signo) == 0x4, "ks_user_sigevent.sigev_signo offset");
_Static_assert(offsetof(struct ks_user_sigevent, sigev_value) == 0x8, "ks_user_sigevent.sigev_value offset");
_Static_assert(offsetof(struct ks_user_sigevent, sigev_notify_function) == 0x10, "ks_user_sigevent.sigev_notify_function offset");
_Static_assert(offsetof(struct ks_user_sigevent, sigev_notify_attributes) == 0x18, "ks_user_sigevent.sigev_notify_attributes offset");

struct ks_user_aiocb {
    int aio_fildes;
    long long aio_offset;
    unsigned long long aio_buf;
    unsigned long long aio_nbytes;
    int aio_reqprio;
    struct ks_user_sigevent aio_sigevent;
    int aio_lio_opcode;
};
_Static_assert(offsetof(struct ks_user_aiocb, aio_fildes) == 0x0, "ks_user_aiocb.aio_fildes offset");
_Static_assert(offsetof(struct ks_user_aiocb, aio_offset) == 0x8, "ks_user_aiocb.aio_offset offset");
_Static_assert(offsetof(struct ks_user_aiocb, aio_buf) == 0x10, "ks_user_aiocb.aio_buf offset");
_Static_assert(offsetof(struct ks_user_aiocb, aio_nbytes) == 0x18, "ks_user_aiocb.aio_nbytes offset");
_Static_assert(offsetof(struct ks_user_aiocb, aio_reqprio) == 0x20, "ks_user_aiocb.aio_reqprio offset");
_Static_assert(offsetof(struct ks_user_aiocb, aio_sigevent) == 0x28, "ks_user_aiocb.aio_sigevent offset");
_Static_assert(offsetof(struct ks_user_aiocb, aio_lio_opcode) == 0x48, "ks_user_aiocb.aio_lio_opcode offset");

struct ks_vfs_context {
    struct ks_thread *vc_thread;
    struct ks_ucred *vc_ucred;
};
_Static_assert(offsetof(struct ks_vfs_context, vc_thread) == 0x0, "ks_vfs_context.vc_thread offset");
_Static_assert(offsetof(struct ks_vfs_context, vc_ucred) == 0x8, "ks_vfs_context.vc_ucred offset");

struct ks_aio_workq_entry {
    struct ks_aio_workq_entry_aio_workq_link aio_workq_link;
    struct ks_aio_workq_entry_aio_proc_link aio_proc_link;
    long long returnval;
    int errorval;
    struct ks_os_refcnt aio_refcount;
    unsigned int flags;
    int lio_pending;
    struct ks_aio_workq_entry *lio_leader;
    struct ks_proc *procp;
    unsigned long long uaiocbp;
    struct ks_user_aiocb aiocb;
    struct ks_vfs_context context;
    struct ks__vm_map *aio_map;
};
_Static_assert(offsetof(struct ks_aio_workq_entry, aio_workq_link) == 0x0, "ks_aio_workq_entry.aio_workq_link offset");
_Static_assert(offsetof(struct ks_aio_workq_entry, aio_proc_link) == 0x10, "ks_aio_workq_entry.aio_proc_link offset");
_Static_assert(offsetof(struct ks_aio_workq_entry, returnval) == 0x20, "ks_aio_workq_entry.returnval offset");
_Static_assert(offsetof(struct ks_aio_workq_entry, errorval) == 0x28, "ks_aio_workq_entry.errorval offset");
_Static_assert(offsetof(struct ks_aio_workq_entry, aio_refcount) == 0x2c, "ks_aio_workq_entry.aio_refcount offset");
_Static_assert(offsetof(struct ks_aio_workq_entry, flags) == 0x30, "ks_aio_workq_entry.flags offset");
_Static_assert(offsetof(struct ks_aio_workq_entry, lio_pending) == 0x34, "ks_aio_workq_entry.lio_pending offset");
_Static_assert(offsetof(struct ks_aio_workq_entry, lio_leader) == 0x38, "ks_aio_workq_entry.lio_leader offset");
_Static_assert(offsetof(struct ks_aio_workq_entry, procp) == 0x40, "ks_aio_workq_entry.procp offset");
_Static_assert(offsetof(struct ks_aio_workq_entry, uaiocbp) == 0x48, "ks_aio_workq_entry.uaiocbp offset");
_Static_assert(offsetof(struct ks_aio_workq_entry, aiocb) == 0x50, "ks_aio_workq_entry.aiocb offset");
_Static_assert(offsetof(struct ks_aio_workq_entry, context) == 0xa0, "ks_aio_workq_entry.context offset");
_Static_assert(offsetof(struct ks_aio_workq_entry, aio_map) == 0xb0, "ks_aio_workq_entry.aio_map offset");

struct ks_audit_token_t {
    unsigned int val[8];
};
_Static_assert(offsetof(struct ks_audit_token_t, val) == 0x0, "ks_audit_token_t.val offset");

struct ks_buflists {
    struct ks_buf *lh_first;
};
_Static_assert(offsetof(struct ks_buflists, lh_first) == 0x0, "ks_buflists.lh_first offset");

struct ks_dof_helper {
    char dofhp_mod[64];
    unsigned long long dofhp_addr;
    unsigned long long dofhp_dof;
};
_Static_assert(offsetof(struct ks_dof_helper, dofhp_mod) == 0x0, "ks_dof_helper.dofhp_mod offset");
_Static_assert(offsetof(struct ks_dof_helper, dofhp_addr) == 0x40, "ks_dof_helper.dofhp_addr offset");
_Static_assert(offsetof(struct ks_dof_helper, dofhp_dof) == 0x48, "ks_dof_helper.dofhp_dof offset");

struct ks_dof_ioctl_data {
    unsigned long long dofiod_count;
    struct ks_dof_helper dofiod_helpers[1];
};
_Static_assert(offsetof(struct ks_dof_ioctl_data, dofiod_count) == 0x0, "ks_dof_ioctl_data.dofiod_count offset");
_Static_assert(offsetof(struct ks_dof_ioctl_data, dofiod_helpers) == 0x8, "ks_dof_ioctl_data.dofiod_helpers offset");

struct ks_dtrace_dstate {
    void *dtds_base;
    unsigned long dtds_size;
    unsigned long dtds_hashsize;
    unsigned long dtds_chunksize;
    struct ks_dtrace_dynhash *dtds_hash;
    unsigned int dtds_state;
    struct ks_dtrace_dstate_percpu *dtds_percpu;
};
_Static_assert(offsetof(struct ks_dtrace_dstate, dtds_base) == 0x0, "ks_dtrace_dstate.dtds_base offset");
_Static_assert(offsetof(struct ks_dtrace_dstate, dtds_size) == 0x8, "ks_dtrace_dstate.dtds_size offset");
_Static_assert(offsetof(struct ks_dtrace_dstate, dtds_hashsize) == 0x10, "ks_dtrace_dstate.dtds_hashsize offset");
_Static_assert(offsetof(struct ks_dtrace_dstate, dtds_chunksize) == 0x18, "ks_dtrace_dstate.dtds_chunksize offset");
_Static_assert(offsetof(struct ks_dtrace_dstate, dtds_hash) == 0x20, "ks_dtrace_dstate.dtds_hash offset");
_Static_assert(offsetof(struct ks_dtrace_dstate, dtds_state) == 0x28, "ks_dtrace_dstate.dtds_state offset");
_Static_assert(offsetof(struct ks_dtrace_dstate, dtds_percpu) == 0x30, "ks_dtrace_dstate.dtds_percpu offset");

struct ks_dtrace_vstate {
    struct ks_dtrace_state *dtvs_state;
    struct ks_dtrace_statvar **dtvs_globals;
    int dtvs_nglobals;
    struct ks_dtrace_difv *dtvs_tlocals;
    int dtvs_ntlocals;
    struct ks_dtrace_statvar **dtvs_locals;
    int dtvs_nlocals;
    struct ks_dtrace_dstate dtvs_dynvars;
};
_Static_assert(offsetof(struct ks_dtrace_vstate, dtvs_state) == 0x0, "ks_dtrace_vstate.dtvs_state offset");
_Static_assert(offsetof(struct ks_dtrace_vstate, dtvs_globals) == 0x8, "ks_dtrace_vstate.dtvs_globals offset");
_Static_assert(offsetof(struct ks_dtrace_vstate, dtvs_nglobals) == 0x10, "ks_dtrace_vstate.dtvs_nglobals offset");
_Static_assert(offsetof(struct ks_dtrace_vstate, dtvs_tlocals) == 0x18, "ks_dtrace_vstate.dtvs_tlocals offset");
_Static_assert(offsetof(struct ks_dtrace_vstate, dtvs_ntlocals) == 0x20, "ks_dtrace_vstate.dtvs_ntlocals offset");
_Static_assert(offsetof(struct ks_dtrace_vstate, dtvs_locals) == 0x28, "ks_dtrace_vstate.dtvs_locals offset");
_Static_assert(offsetof(struct ks_dtrace_vstate, dtvs_nlocals) == 0x30, "ks_dtrace_vstate.dtvs_nlocals offset");
_Static_assert(offsetof(struct ks_dtrace_vstate, dtvs_dynvars) == 0x38, "ks_dtrace_vstate.dtvs_dynvars offset");

struct ks_dtrace_helpers {
    struct ks_dtrace_helper_action **dthps_actions;
    struct ks_dtrace_vstate dthps_vstate;
    struct ks_dtrace_helper_provider **dthps_provs;
    unsigned int dthps_nprovs;
    unsigned int dthps_maxprovs;
    int dthps_generation;
    int dthps_pid;
    int dthps_deferred;
    struct ks_dtrace_helpers *dthps_next;
    struct ks_dtrace_helpers *dthps_prev;
};
_Static_assert(offsetof(struct ks_dtrace_helpers, dthps_actions) == 0x0, "ks_dtrace_helpers.dthps_actions offset");
_Static_assert(offsetof(struct ks_dtrace_helpers, dthps_vstate) == 0x8, "ks_dtrace_helpers.dthps_vstate offset");
_Static_assert(offsetof(struct ks_dtrace_helpers, dthps_provs) == 0x78, "ks_dtrace_helpers.dthps_provs offset");
_Static_assert(offsetof(struct ks_dtrace_helpers, dthps_nprovs) == 0x80, "ks_dtrace_helpers.dthps_nprovs offset");
_Static_assert(offsetof(struct ks_dtrace_helpers, dthps_maxprovs) == 0x84, "ks_dtrace_helpers.dthps_maxprovs offset");
_Static_assert(offsetof(struct ks_dtrace_helpers, dthps_generation) == 0x88, "ks_dtrace_helpers.dthps_generation offset");
_Static_assert(offsetof(struct ks_dtrace_helpers, dthps_pid) == 0x8c, "ks_dtrace_helpers.dthps_pid offset");
_Static_assert(offsetof(struct ks_dtrace_helpers, dthps_deferred) == 0x90, "ks_dtrace_helpers.dthps_deferred offset");
_Static_assert(offsetof(struct ks_dtrace_helpers, dthps_next) == 0x98, "ks_dtrace_helpers.dthps_next offset");
_Static_assert(offsetof(struct ks_dtrace_helpers, dthps_prev) == 0xa0, "ks_dtrace_helpers.dthps_prev offset");

struct ks_dtrace_ptss_page_entry {
    struct ks_dtrace_ptss_page_entry *next;
    unsigned long long addr;
    unsigned long long write_addr;
};
_Static_assert(offsetof(struct ks_dtrace_ptss_page_entry, next) == 0x0, "ks_dtrace_ptss_page_entry.next offset");
_Static_assert(offsetof(struct ks_dtrace_ptss_page_entry, addr) == 0x8, "ks_dtrace_ptss_page_entry.addr offset");
_Static_assert(offsetof(struct ks_dtrace_ptss_page_entry, write_addr) == 0x10, "ks_dtrace_ptss_page_entry.write_addr offset");

struct ks_dtrace_ptss_page {
    struct ks_dtrace_ptss_page *next;
    struct ks_dtrace_ptss_page_entry entries[256];
};
_Static_assert(offsetof(struct ks_dtrace_ptss_page, next) == 0x0, "ks_dtrace_ptss_page.next offset");
_Static_assert(offsetof(struct ks_dtrace_ptss_page, entries) == 0x8, "ks_dtrace_ptss_page.entries offset");

struct ks_lck_mtx_t {
    unsigned long opaque[2];
};
_Static_assert(offsetof(struct ks_lck_mtx_t, opaque) == 0x0, "ks_lck_mtx_t.opaque offset");

struct ks_lck_rw_t {
    unsigned long opaque[2];
};
_Static_assert(offsetof(struct ks_lck_rw_t, opaque) == 0x0, "ks_lck_rw_t.opaque offset");

struct ks_filedesc {
    struct ks_lck_mtx_t fd_lock;
    unsigned char fd_fpdrainwait;
    unsigned char fd_flags;
    unsigned short fd_cmask;
    int fd_nfiles;
    int fd_afterlast;
    int fd_freefile;
    int fd_knlistsize;
    int unused_padding;
    struct ks_fileproc **fd_ofiles;
    char *fd_ofileflags;
    struct ks_klist *fd_knlist;
    struct ks_kqworkq *fd_wqkqueue;
    struct ks_vnode *fd_cdir;
    struct ks_vnode *fd_rdir;
    struct ks_lck_rw_t fd_dirs_lock;
    struct ks_lck_mtx_t fd_kqhashlock;
    unsigned long fd_kqhashmask;
    struct ks_kqwllist *fd_kqhash;
    struct ks_lck_mtx_t fd_knhashlock;
    unsigned long fd_knhashmask;
    struct ks_klist *fd_knhash;
};
_Static_assert(offsetof(struct ks_filedesc, fd_lock) == 0x0, "ks_filedesc.fd_lock offset");
_Static_assert(offsetof(struct ks_filedesc, fd_fpdrainwait) == 0x10, "ks_filedesc.fd_fpdrainwait offset");
_Static_assert(offsetof(struct ks_filedesc, fd_flags) == 0x11, "ks_filedesc.fd_flags offset");
_Static_assert(offsetof(struct ks_filedesc, fd_cmask) == 0x12, "ks_filedesc.fd_cmask offset");
_Static_assert(offsetof(struct ks_filedesc, fd_nfiles) == 0x14, "ks_filedesc.fd_nfiles offset");
_Static_assert(offsetof(struct ks_filedesc, fd_afterlast) == 0x18, "ks_filedesc.fd_afterlast offset");
_Static_assert(offsetof(struct ks_filedesc, fd_freefile) == 0x1c, "ks_filedesc.fd_freefile offset");
_Static_assert(offsetof(struct ks_filedesc, fd_knlistsize) == 0x20, "ks_filedesc.fd_knlistsize offset");
_Static_assert(offsetof(struct ks_filedesc, unused_padding) == 0x24, "ks_filedesc.unused_padding offset");
_Static_assert(offsetof(struct ks_filedesc, fd_ofiles) == 0x28, "ks_filedesc.fd_ofiles offset");
_Static_assert(offsetof(struct ks_filedesc, fd_ofileflags) == 0x30, "ks_filedesc.fd_ofileflags offset");
_Static_assert(offsetof(struct ks_filedesc, fd_knlist) == 0x38, "ks_filedesc.fd_knlist offset");
_Static_assert(offsetof(struct ks_filedesc, fd_wqkqueue) == 0x40, "ks_filedesc.fd_wqkqueue offset");
_Static_assert(offsetof(struct ks_filedesc, fd_cdir) == 0x48, "ks_filedesc.fd_cdir offset");
_Static_assert(offsetof(struct ks_filedesc, fd_rdir) == 0x50, "ks_filedesc.fd_rdir offset");
_Static_assert(offsetof(struct ks_filedesc, fd_dirs_lock) == 0x58, "ks_filedesc.fd_dirs_lock offset");
_Static_assert(offsetof(struct ks_filedesc, fd_kqhashlock) == 0x68, "ks_filedesc.fd_kqhashlock offset");
_Static_assert(offsetof(struct ks_filedesc, fd_kqhashmask) == 0x78, "ks_filedesc.fd_kqhashmask offset");
_Static_assert(offsetof(struct ks_filedesc, fd_kqhash) == 0x80, "ks_filedesc.fd_kqhash offset");
_Static_assert(offsetof(struct ks_filedesc, fd_knhashlock) == 0x88, "ks_filedesc.fd_knhashlock offset");
_Static_assert(offsetof(struct ks_filedesc, fd_knhashmask) == 0x98, "ks_filedesc.fd_knhashmask offset");
_Static_assert(offsetof(struct ks_filedesc, fd_knhash) == 0xa0, "ks_filedesc.fd_knhash offset");

struct ks_fl_head {
    struct ks_file_lease *lh_first;
};
_Static_assert(offsetof(struct ks_fl_head, lh_first) == 0x0, "ks_fl_head.lh_first offset");

struct ks_timeval {
    long tv_sec;
    int tv_usec;
};
_Static_assert(offsetof(struct ks_timeval, tv_sec) == 0x0, "ks_timeval.tv_sec offset");
_Static_assert(offsetof(struct ks_timeval, tv_usec) == 0x8, "ks_timeval.tv_usec offset");

struct ks_itimerval {
    struct ks_timeval it_interval;
    struct ks_timeval it_value;
};
_Static_assert(offsetof(struct ks_itimerval, it_interval) == 0x0, "ks_itimerval.it_interval offset");
_Static_assert(offsetof(struct ks_itimerval, it_value) == 0x10, "ks_itimerval.it_value offset");

struct ks_z_stream_s {
    unsigned char *next_in;
    unsigned int avail_in;
    unsigned long total_in;
    unsigned char *next_out;
    unsigned int avail_out;
    unsigned long total_out;
    char *msg;
    struct ks_internal_state *state;
    void **zalloc;
    void *zfree;
    void *opaque;
    int data_type;
    unsigned long adler;
    unsigned long reserved;
};
_Static_assert(offsetof(struct ks_z_stream_s, next_in) == 0x0, "ks_z_stream_s.next_in offset");
_Static_assert(offsetof(struct ks_z_stream_s, avail_in) == 0x8, "ks_z_stream_s.avail_in offset");
_Static_assert(offsetof(struct ks_z_stream_s, total_in) == 0x10, "ks_z_stream_s.total_in offset");
_Static_assert(offsetof(struct ks_z_stream_s, next_out) == 0x18, "ks_z_stream_s.next_out offset");
_Static_assert(offsetof(struct ks_z_stream_s, avail_out) == 0x20, "ks_z_stream_s.avail_out offset");
_Static_assert(offsetof(struct ks_z_stream_s, total_out) == 0x28, "ks_z_stream_s.total_out offset");
_Static_assert(offsetof(struct ks_z_stream_s, msg) == 0x30, "ks_z_stream_s.msg offset");
_Static_assert(offsetof(struct ks_z_stream_s, state) == 0x38, "ks_z_stream_s.state offset");
_Static_assert(offsetof(struct ks_z_stream_s, zalloc) == 0x40, "ks_z_stream_s.zalloc offset");
_Static_assert(offsetof(struct ks_z_stream_s, zfree) == 0x48, "ks_z_stream_s.zfree offset");
_Static_assert(offsetof(struct ks_z_stream_s, opaque) == 0x50, "ks_z_stream_s.opaque offset");
_Static_assert(offsetof(struct ks_z_stream_s, data_type) == 0x58, "ks_z_stream_s.data_type offset");
_Static_assert(offsetof(struct ks_z_stream_s, adler) == 0x60, "ks_z_stream_s.adler offset");
_Static_assert(offsetof(struct ks_z_stream_s, reserved) == 0x68, "ks_z_stream_s.reserved offset");

struct ks_kcdata_compress_descriptor {
    struct ks_z_stream_s kcd_cd_zs;
    void *kcd_cd_base;
    unsigned long long kcd_cd_offset;
    unsigned long kcd_cd_maxoffset;
    unsigned long long kcd_cd_mark_begin;
    unsigned long long kcd_cd_flags;
    unsigned long long kcd_cd_compression_type;
    void *kcd_cd_memcpy_f;
    unsigned long long kcd_cd_totalout_addr;
    unsigned long long kcd_cd_totalin_addr;
};
_Static_assert(offsetof(struct ks_kcdata_compress_descriptor, kcd_cd_zs) == 0x0, "ks_kcdata_compress_descriptor.kcd_cd_zs offset");
_Static_assert(offsetof(struct ks_kcdata_compress_descriptor, kcd_cd_base) == 0x70, "ks_kcdata_compress_descriptor.kcd_cd_base offset");
_Static_assert(offsetof(struct ks_kcdata_compress_descriptor, kcd_cd_offset) == 0x78, "ks_kcdata_compress_descriptor.kcd_cd_offset offset");
_Static_assert(offsetof(struct ks_kcdata_compress_descriptor, kcd_cd_maxoffset) == 0x80, "ks_kcdata_compress_descriptor.kcd_cd_maxoffset offset");
_Static_assert(offsetof(struct ks_kcdata_compress_descriptor, kcd_cd_mark_begin) == 0x88, "ks_kcdata_compress_descriptor.kcd_cd_mark_begin offset");
_Static_assert(offsetof(struct ks_kcdata_compress_descriptor, kcd_cd_flags) == 0x90, "ks_kcdata_compress_descriptor.kcd_cd_flags offset");
_Static_assert(offsetof(struct ks_kcdata_compress_descriptor, kcd_cd_compression_type) == 0x98, "ks_kcdata_compress_descriptor.kcd_cd_compression_type offset");
_Static_assert(offsetof(struct ks_kcdata_compress_descriptor, kcd_cd_memcpy_f) == 0xa0, "ks_kcdata_compress_descriptor.kcd_cd_memcpy_f offset");
_Static_assert(offsetof(struct ks_kcdata_compress_descriptor, kcd_cd_totalout_addr) == 0xa8, "ks_kcdata_compress_descriptor.kcd_cd_totalout_addr offset");
_Static_assert(offsetof(struct ks_kcdata_compress_descriptor, kcd_cd_totalin_addr) == 0xb0, "ks_kcdata_compress_descriptor.kcd_cd_totalin_addr offset");

struct ks_kcdata_descriptor {
    unsigned int kcd_length;
    unsigned short kcd_flags;
    unsigned short kcd_user_flags;
    unsigned long long kcd_addr_begin;
    unsigned long long kcd_addr_end;
    struct ks_kcdata_compress_descriptor kcd_comp_d;
    unsigned int kcd_endalloced;
    struct ks_kcdata_descriptor **kcd_alloc_callback;
};
_Static_assert(offsetof(struct ks_kcdata_descriptor, kcd_length) == 0x0, "ks_kcdata_descriptor.kcd_length offset");
_Static_assert(offsetof(struct ks_kcdata_descriptor, kcd_flags) == 0x4, "ks_kcdata_descriptor.kcd_flags offset");
_Static_assert(offsetof(struct ks_kcdata_descriptor, kcd_user_flags) == 0x6, "ks_kcdata_descriptor.kcd_user_flags offset");
_Static_assert(offsetof(struct ks_kcdata_descriptor, kcd_addr_begin) == 0x8, "ks_kcdata_descriptor.kcd_addr_begin offset");
_Static_assert(offsetof(struct ks_kcdata_descriptor, kcd_addr_end) == 0x10, "ks_kcdata_descriptor.kcd_addr_end offset");
_Static_assert(offsetof(struct ks_kcdata_descriptor, kcd_comp_d) == 0x18, "ks_kcdata_descriptor.kcd_comp_d offset");
_Static_assert(offsetof(struct ks_kcdata_descriptor, kcd_endalloced) == 0xd0, "ks_kcdata_descriptor.kcd_endalloced offset");
_Static_assert(offsetof(struct ks_kcdata_descriptor, kcd_alloc_callback) == 0xd8, "ks_kcdata_descriptor.kcd_alloc_callback offset");

struct ks_kern_sigaltstack {
    unsigned long long ss_sp;
    unsigned long long ss_size;
    int ss_flags;
};
_Static_assert(offsetof(struct ks_kern_sigaltstack, ss_sp) == 0x0, "ks_kern_sigaltstack.ss_sp offset");
_Static_assert(offsetof(struct ks_kern_sigaltstack, ss_size) == 0x8, "ks_kern_sigaltstack.ss_size offset");
_Static_assert(offsetof(struct ks_kern_sigaltstack, ss_flags) == 0x10, "ks_kern_sigaltstack.ss_flags offset");

struct ks_kevent_ctx_s {
    unsigned long long kec_data_avail;
    union {
        unsigned long long kec_data_out;
        struct ks_pollfd *kec_poll_fds;
    };
    unsigned long long kec_data_size;
    unsigned long long kec_data_resid;
    unsigned long long kec_deadline;
    struct ks_fileproc *kec_fp;
    int kec_fd;
    int kec_process_nevents;
    int kec_process_noutputs;
    unsigned int kec_process_flags;
    unsigned long long kec_process_eventlist;
};
_Static_assert(offsetof(struct ks_kevent_ctx_s, kec_data_avail) == 0x0, "ks_kevent_ctx_s.kec_data_avail offset");
_Static_assert(offsetof(struct ks_kevent_ctx_s, kec_data_size) == 0x10, "ks_kevent_ctx_s.kec_data_size offset");
_Static_assert(offsetof(struct ks_kevent_ctx_s, kec_data_resid) == 0x18, "ks_kevent_ctx_s.kec_data_resid offset");
_Static_assert(offsetof(struct ks_kevent_ctx_s, kec_deadline) == 0x20, "ks_kevent_ctx_s.kec_deadline offset");
_Static_assert(offsetof(struct ks_kevent_ctx_s, kec_fp) == 0x28, "ks_kevent_ctx_s.kec_fp offset");
_Static_assert(offsetof(struct ks_kevent_ctx_s, kec_fd) == 0x30, "ks_kevent_ctx_s.kec_fd offset");
_Static_assert(offsetof(struct ks_kevent_ctx_s, kec_process_nevents) == 0x34, "ks_kevent_ctx_s.kec_process_nevents offset");
_Static_assert(offsetof(struct ks_kevent_ctx_s, kec_process_noutputs) == 0x38, "ks_kevent_ctx_s.kec_process_noutputs offset");
_Static_assert(offsetof(struct ks_kevent_ctx_s, kec_process_flags) == 0x3c, "ks_kevent_ctx_s.kec_process_flags offset");
_Static_assert(offsetof(struct ks_kevent_ctx_s, kec_process_eventlist) == 0x40, "ks_kevent_ctx_s.kec_process_eventlist offset");
_Static_assert(offsetof(struct ks_kevent_ctx_s, kec_data_out) == 0x8, "ks_kevent_ctx_s.kec_data_out offset");
_Static_assert(offsetof(struct ks_kevent_ctx_s, kec_poll_fds) == 0x8, "ks_kevent_ctx_s.kec_poll_fds offset");

struct ks_klist {
    struct ks_knote *slh_first;
};
_Static_assert(offsetof(struct ks_klist, slh_first) == 0x0, "ks_klist.slh_first offset");

struct ks_knote_locks {
    struct ks_knote_lock_ctx *lh_first;
};
_Static_assert(offsetof(struct ks_knote_locks, lh_first) == 0x0, "ks_knote_locks.lh_first offset");

struct ks_kqtailq {
    struct ks_knote *tqh_first;
    struct ks_knote **tqh_last;
};
_Static_assert(offsetof(struct ks_kqtailq, tqh_first) == 0x0, "ks_kqtailq.tqh_first offset");
_Static_assert(offsetof(struct ks_kqtailq, tqh_last) == 0x8, "ks_kqtailq.tqh_last offset");

struct ks_lck_spin_t {
    unsigned long opaque[2];
};
_Static_assert(offsetof(struct ks_lck_spin_t, opaque) == 0x0, "ks_lck_spin_t.opaque offset");

struct ks_kqueue {
    struct ks_lck_spin_t kq_lock;
    unsigned short kq_state;
    unsigned short kq_level;
    unsigned int kq_count;
    struct ks_proc *kq_p;
    struct ks_knote_locks kq_knlocks;
};
_Static_assert(offsetof(struct ks_kqueue, kq_lock) == 0x0, "ks_kqueue.kq_lock offset");
_Static_assert(offsetof(struct ks_kqueue, kq_state) == 0x10, "ks_kqueue.kq_state offset");
_Static_assert(offsetof(struct ks_kqueue, kq_level) == 0x12, "ks_kqueue.kq_level offset");
_Static_assert(offsetof(struct ks_kqueue, kq_count) == 0x14, "ks_kqueue.kq_count offset");
_Static_assert(offsetof(struct ks_kqueue, kq_p) == 0x18, "ks_kqueue.kq_p offset");
_Static_assert(offsetof(struct ks_kqueue, kq_knlocks) == 0x20, "ks_kqueue.kq_knlocks offset");

struct ks_kqwllist {
    struct ks_kqworkloop *lh_first;
};
_Static_assert(offsetof(struct ks_kqwllist, lh_first) == 0x0, "ks_kqwllist.lh_first offset");

struct ks_priority_queue_entry_sched {
    struct ks_priority_queue_entry_sched *next;
    struct ks_priority_queue_entry_sched *prev;
    long key : 16; /* bit offset 128 */
    long child : 48; /* bit offset 144 */
};
_Static_assert(offsetof(struct ks_priority_queue_entry_sched, next) == 0x0, "ks_priority_queue_entry_sched.next offset");
_Static_assert(offsetof(struct ks_priority_queue_entry_sched, prev) == 0x8, "ks_priority_queue_entry_sched.prev offset");

struct ks_workq_threadreq_s___anon_member_8___anon_member_9 {
    struct ks_thread *tr_thread;
    struct ks_work_interval *tr_work_interval;
};
_Static_assert(offsetof(struct ks_workq_threadreq_s___anon_member_8___anon_member_9, tr_thread) == 0x0, "ks_workq_threadreq_s___anon_member_8___anon_member_9.tr_thread offset");
_Static_assert(offsetof(struct ks_workq_threadreq_s___anon_member_8___anon_member_9, tr_work_interval) == 0x8, "ks_workq_threadreq_s___anon_member_8___anon_member_9.tr_work_interval offset");

struct ks_workq_threadreq_s___anon_member_8_tr_link {
    struct ks_workq_threadreq_s *stqe_next;
};
_Static_assert(offsetof(struct ks_workq_threadreq_s___anon_member_8_tr_link, stqe_next) == 0x0, "ks_workq_threadreq_s___anon_member_8_tr_link.stqe_next offset");

struct ks_workq_threadreq_s {
    union {
        struct ks_priority_queue_entry_sched tr_entry;
        struct ks_workq_threadreq_s___anon_member_8_tr_link tr_link;
        struct ks_workq_threadreq_s___anon_member_8___anon_member_9 __anon_member_9;
    };
    unsigned short tr_count;
    unsigned char tr_flags;
    unsigned char tr_state;
    unsigned char tr_qos;
    unsigned char tr_kq_override_index;
    unsigned char tr_kq_qos_index;
};
_Static_assert(offsetof(struct ks_workq_threadreq_s, tr_count) == 0x18, "ks_workq_threadreq_s.tr_count offset");
_Static_assert(offsetof(struct ks_workq_threadreq_s, tr_flags) == 0x1a, "ks_workq_threadreq_s.tr_flags offset");
_Static_assert(offsetof(struct ks_workq_threadreq_s, tr_state) == 0x1b, "ks_workq_threadreq_s.tr_state offset");
_Static_assert(offsetof(struct ks_workq_threadreq_s, tr_qos) == 0x1c, "ks_workq_threadreq_s.tr_qos offset");
_Static_assert(offsetof(struct ks_workq_threadreq_s, tr_kq_override_index) == 0x1d, "ks_workq_threadreq_s.tr_kq_override_index offset");
_Static_assert(offsetof(struct ks_workq_threadreq_s, tr_kq_qos_index) == 0x1e, "ks_workq_threadreq_s.tr_kq_qos_index offset");
_Static_assert(offsetof(struct ks_workq_threadreq_s, tr_entry) == 0x0, "ks_workq_threadreq_s.tr_entry offset");
_Static_assert(offsetof(struct ks_workq_threadreq_s, tr_link) == 0x0, "ks_workq_threadreq_s.tr_link offset");
_Static_assert(offsetof(struct ks_workq_threadreq_s, __anon_member_9) == 0x0, "ks_workq_threadreq_s.__anon_member_9 offset");

struct ks_kqworkq {
    struct ks_kqueue kqwq_kqueue;
    struct ks_kqtailq kqwq_queue[7];
    struct ks_kqtailq kqwq_suppressed[7];
    struct ks_workq_threadreq_s kqwq_request[7];
};
_Static_assert(offsetof(struct ks_kqworkq, kqwq_kqueue) == 0x0, "ks_kqworkq.kqwq_kqueue offset");
_Static_assert(offsetof(struct ks_kqworkq, kqwq_queue) == 0x28, "ks_kqworkq.kqwq_queue offset");
_Static_assert(offsetof(struct ks_kqworkq, kqwq_suppressed) == 0x98, "ks_kqworkq.kqwq_suppressed offset");
_Static_assert(offsetof(struct ks_kqworkq, kqwq_request) == 0x108, "ks_kqworkq.kqwq_request offset");

struct ks_ksyn_waitq_element {
    char opaque[48];
};
_Static_assert(offsetof(struct ks_ksyn_waitq_element, opaque) == 0x0, "ks_ksyn_waitq_element.opaque offset");

struct ks_lck_ticket_t {
    unsigned int opaque0;
    unsigned int opaque1;
    unsigned int opaque2;
    unsigned int opaque3;
};
_Static_assert(offsetof(struct ks_lck_ticket_t, opaque0) == 0x0, "ks_lck_ticket_t.opaque0 offset");
_Static_assert(offsetof(struct ks_lck_ticket_t, opaque1) == 0x4, "ks_lck_ticket_t.opaque1 offset");
_Static_assert(offsetof(struct ks_lck_ticket_t, opaque2) == 0x8, "ks_lck_ticket_t.opaque2 offset");
_Static_assert(offsetof(struct ks_lck_ticket_t, opaque3) == 0xc, "ks_lck_ticket_t.opaque3 offset");

struct ks_mpsc_queue_chain {
    struct ks_mpsc_queue_chain * _Atomic mpqc_next;
};
_Static_assert(offsetof(struct ks_mpsc_queue_chain, mpqc_next) == 0x0, "ks_mpsc_queue_chain.mpqc_next offset");

struct ks_os_reason {
    struct ks_lck_mtx_t osr_lock;
    struct ks_os_refcnt osr_refcount;
    unsigned int osr_namespace;
    unsigned long long osr_code;
    unsigned long long osr_flags;
    unsigned int osr_bufsize;
    struct ks_kcdata_descriptor osr_kcd_descriptor;
    char *osr_kcd_buf;
};
_Static_assert(offsetof(struct ks_os_reason, osr_lock) == 0x0, "ks_os_reason.osr_lock offset");
_Static_assert(offsetof(struct ks_os_reason, osr_refcount) == 0x10, "ks_os_reason.osr_refcount offset");
_Static_assert(offsetof(struct ks_os_reason, osr_namespace) == 0x14, "ks_os_reason.osr_namespace offset");
_Static_assert(offsetof(struct ks_os_reason, osr_code) == 0x18, "ks_os_reason.osr_code offset");
_Static_assert(offsetof(struct ks_os_reason, osr_flags) == 0x20, "ks_os_reason.osr_flags offset");
_Static_assert(offsetof(struct ks_os_reason, osr_bufsize) == 0x28, "ks_os_reason.osr_bufsize offset");
_Static_assert(offsetof(struct ks_os_reason, osr_kcd_descriptor) == 0x30, "ks_os_reason.osr_kcd_descriptor offset");
_Static_assert(offsetof(struct ks_os_reason, osr_kcd_buf) == 0x110, "ks_os_reason.osr_kcd_buf offset");

struct ks_persona_pna_list {
    struct ks_persona *le_next;
    struct ks_persona **le_prev;
};
_Static_assert(offsetof(struct ks_persona_pna_list, le_next) == 0x0, "ks_persona_pna_list.le_next offset");
_Static_assert(offsetof(struct ks_persona_pna_list, le_prev) == 0x8, "ks_persona_pna_list.le_prev offset");

struct ks_persona_pna_members {
    struct ks_proc *lh_first;
};
_Static_assert(offsetof(struct ks_persona_pna_members, lh_first) == 0x0, "ks_persona_pna_members.lh_first offset");

struct ks_persona {
    struct ks_os_refcnt pna_refcount;
    int pna_valid;
    unsigned int pna_id;
    int pna_type;
    char pna_login[256];
    char *pna_path;
    unsigned int pna_uid;
    struct {
        struct ks_persona *le_next;
        struct ks_persona **le_prev;
    } pna_list;
    struct ks_persona_pna_members pna_members;
    struct ks_lck_mtx_t pna_lock;
};
_Static_assert(offsetof(struct ks_persona, pna_refcount) == 0x0, "ks_persona.pna_refcount offset");
_Static_assert(offsetof(struct ks_persona, pna_valid) == 0x4, "ks_persona.pna_valid offset");
_Static_assert(offsetof(struct ks_persona, pna_id) == 0x8, "ks_persona.pna_id offset");
_Static_assert(offsetof(struct ks_persona, pna_type) == 0xc, "ks_persona.pna_type offset");
_Static_assert(offsetof(struct ks_persona, pna_login) == 0x10, "ks_persona.pna_login offset");
_Static_assert(offsetof(struct ks_persona, pna_path) == 0x110, "ks_persona.pna_path offset");
_Static_assert(offsetof(struct ks_persona, pna_uid) == 0x118, "ks_persona.pna_uid offset");
_Static_assert(offsetof(struct ks_persona, pna_list) == 0x120, "ks_persona.pna_list offset");
_Static_assert(offsetof(struct ks_persona, pna_members) == 0x130, "ks_persona.pna_members offset");
_Static_assert(offsetof(struct ks_persona, pna_lock) == 0x138, "ks_persona.pna_lock offset");

struct ks_pgrp_pg_members {
    struct ks_proc *lh_first;
};
_Static_assert(offsetof(struct ks_pgrp_pg_members, lh_first) == 0x0, "ks_pgrp_pg_members.lh_first offset");

struct ks_smr_node {
    struct ks_smr_node *smrn_next;
    void *smrn_cb;
};
_Static_assert(offsetof(struct ks_smr_node, smrn_next) == 0x0, "ks_smr_node.smrn_next offset");
_Static_assert(offsetof(struct ks_smr_node, smrn_cb) == 0x8, "ks_smr_node.smrn_cb offset");

struct ks_smrq_slink {
    struct ks___smrq_slink_t next;
};
_Static_assert(offsetof(struct ks_smrq_slink, next) == 0x0, "ks_smrq_slink.next offset");

struct ks_pgrp {
    union {
        struct ks_lck_mtx_t pg_mlock;
        struct ks_smr_node pg_smr_node;
    };
    struct ks_smrq_slink pg_hash;
    struct ks_pgrp_pg_members pg_members;
    struct ks_session *pg_session;
    int pg_id;
    int pg_jobc;
    unsigned int pg_refcount;
    unsigned int pg_hashref;
};
_Static_assert(offsetof(struct ks_pgrp, pg_hash) == 0x10, "ks_pgrp.pg_hash offset");
_Static_assert(offsetof(struct ks_pgrp, pg_members) == 0x18, "ks_pgrp.pg_members offset");
_Static_assert(offsetof(struct ks_pgrp, pg_session) == 0x20, "ks_pgrp.pg_session offset");
_Static_assert(offsetof(struct ks_pgrp, pg_id) == 0x28, "ks_pgrp.pg_id offset");
_Static_assert(offsetof(struct ks_pgrp, pg_jobc) == 0x2c, "ks_pgrp.pg_jobc offset");
_Static_assert(offsetof(struct ks_pgrp, pg_refcount) == 0x30, "ks_pgrp.pg_refcount offset");
_Static_assert(offsetof(struct ks_pgrp, pg_hashref) == 0x34, "ks_pgrp.pg_hashref offset");
_Static_assert(offsetof(struct ks_pgrp, pg_mlock) == 0x0, "ks_pgrp.pg_mlock offset");
_Static_assert(offsetof(struct ks_pgrp, pg_smr_node) == 0x0, "ks_pgrp.pg_smr_node offset");

struct ks_rlimit {
    unsigned long long rlim_cur;
    unsigned long long rlim_max;
};
_Static_assert(offsetof(struct ks_rlimit, rlim_cur) == 0x0, "ks_rlimit.rlim_cur offset");
_Static_assert(offsetof(struct ks_rlimit, rlim_max) == 0x8, "ks_rlimit.rlim_max offset");

struct ks_plimit {
    struct ks_smr_node pl_node;
    struct ks_rlimit pl_rlimit[9];
    struct ks_os_refcnt pl_refcnt;
};
_Static_assert(offsetof(struct ks_plimit, pl_node) == 0x0, "ks_plimit.pl_node offset");
_Static_assert(offsetof(struct ks_plimit, pl_rlimit) == 0x10, "ks_plimit.pl_rlimit offset");
_Static_assert(offsetof(struct ks_plimit, pl_refcnt) == 0xa0, "ks_plimit.pl_refcnt offset");

struct ks_priority_queue_sched_max {
    struct ks_priority_queue_entry_sched *pq_root;
};
_Static_assert(offsetof(struct ks_priority_queue_sched_max, pq_root) == 0x0, "ks_priority_queue_sched_max.pq_root offset");

struct ks_proc___anon_member_1_p_list {
    struct ks_proc *le_next;
    struct ks_proc **le_prev;
};
_Static_assert(offsetof(struct ks_proc___anon_member_1_p_list, le_next) == 0x0, "ks_proc___anon_member_1_p_list.le_next offset");
_Static_assert(offsetof(struct ks_proc___anon_member_1_p_list, le_prev) == 0x8, "ks_proc___anon_member_1_p_list.le_prev offset");

struct ks_proc_forkcopy_data {
    unsigned int p_argslen;
    int p_argc;
    unsigned long long user_stack;
    struct ks_vnode *p_textvp;
    long long p_textoff;
    unsigned int p_sigmask;
    unsigned int p_sigignore;
    unsigned int p_sigcatch;
    unsigned int p_workq_allow_sigmask;
    unsigned char p_priority;
    unsigned char p_resv0;
    char p_nice;
    unsigned char p_resv1;
    char p_comm[17];
    char p_name[33];
    unsigned char p_xhighbits;
    int p_contproc;
    unsigned int p_pcaction;
    unsigned char p_uuid[16];
    unsigned char p_responsible_uuid[16];
    int p_cputype;
    int p_cpusubtype;
};
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_argslen) == 0x0, "ks_proc_forkcopy_data.p_argslen offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_argc) == 0x4, "ks_proc_forkcopy_data.p_argc offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, user_stack) == 0x8, "ks_proc_forkcopy_data.user_stack offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_textvp) == 0x10, "ks_proc_forkcopy_data.p_textvp offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_textoff) == 0x18, "ks_proc_forkcopy_data.p_textoff offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_sigmask) == 0x20, "ks_proc_forkcopy_data.p_sigmask offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_sigignore) == 0x24, "ks_proc_forkcopy_data.p_sigignore offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_sigcatch) == 0x28, "ks_proc_forkcopy_data.p_sigcatch offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_workq_allow_sigmask) == 0x2c, "ks_proc_forkcopy_data.p_workq_allow_sigmask offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_priority) == 0x30, "ks_proc_forkcopy_data.p_priority offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_resv0) == 0x31, "ks_proc_forkcopy_data.p_resv0 offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_nice) == 0x32, "ks_proc_forkcopy_data.p_nice offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_resv1) == 0x33, "ks_proc_forkcopy_data.p_resv1 offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_comm) == 0x34, "ks_proc_forkcopy_data.p_comm offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_name) == 0x45, "ks_proc_forkcopy_data.p_name offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_xhighbits) == 0x66, "ks_proc_forkcopy_data.p_xhighbits offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_contproc) == 0x68, "ks_proc_forkcopy_data.p_contproc offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_pcaction) == 0x6c, "ks_proc_forkcopy_data.p_pcaction offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_uuid) == 0x70, "ks_proc_forkcopy_data.p_uuid offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_responsible_uuid) == 0x80, "ks_proc_forkcopy_data.p_responsible_uuid offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_cputype) == 0x90, "ks_proc_forkcopy_data.p_cputype offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_cpusubtype) == 0x94, "ks_proc_forkcopy_data.p_cpusubtype offset");

struct ks_proc_p_aio_activeq {
    struct ks_aio_workq_entry *tqh_first;
    struct ks_aio_workq_entry **tqh_last;
};
_Static_assert(offsetof(struct ks_proc_p_aio_activeq, tqh_first) == 0x0, "ks_proc_p_aio_activeq.tqh_first offset");
_Static_assert(offsetof(struct ks_proc_p_aio_activeq, tqh_last) == 0x8, "ks_proc_p_aio_activeq.tqh_last offset");

struct ks_proc_p_aio_doneq {
    struct ks_aio_workq_entry *tqh_first;
    struct ks_aio_workq_entry **tqh_last;
};
_Static_assert(offsetof(struct ks_proc_p_aio_doneq, tqh_first) == 0x0, "ks_proc_p_aio_doneq.tqh_first offset");
_Static_assert(offsetof(struct ks_proc_p_aio_doneq, tqh_last) == 0x8, "ks_proc_p_aio_doneq.tqh_last offset");

struct ks_proc_p_children {
    struct ks_proc *lh_first;
};
_Static_assert(offsetof(struct ks_proc_p_children, lh_first) == 0x0, "ks_proc_p_children.lh_first offset");

struct ks_proc_p_limit {
    volatile struct ks_plimit *__smr_ptr;
};
_Static_assert(offsetof(struct ks_proc_p_limit, __smr_ptr) == 0x0, "ks_proc_p_limit.__smr_ptr offset");

struct ks_proc_p_memstat_list {
    struct ks_proc *tqe_next;
    struct ks_proc **tqe_prev;
};
_Static_assert(offsetof(struct ks_proc_p_memstat_list, tqe_next) == 0x0, "ks_proc_p_memstat_list.tqe_next offset");
_Static_assert(offsetof(struct ks_proc_p_memstat_list, tqe_prev) == 0x8, "ks_proc_p_memstat_list.tqe_prev offset");

struct ks_proc_p_persona_list {
    struct ks_proc *le_next;
    struct ks_proc **le_prev;
};
_Static_assert(offsetof(struct ks_proc_p_persona_list, le_next) == 0x0, "ks_proc_p_persona_list.le_next offset");
_Static_assert(offsetof(struct ks_proc_p_persona_list, le_prev) == 0x8, "ks_proc_p_persona_list.le_prev offset");

struct ks_proc_p_pglist {
    struct ks_proc *le_next;
    struct ks_proc **le_prev;
};
_Static_assert(offsetof(struct ks_proc_p_pglist, le_next) == 0x0, "ks_proc_p_pglist.le_next offset");
_Static_assert(offsetof(struct ks_proc_p_pglist, le_prev) == 0x8, "ks_proc_p_pglist.le_prev offset");

struct ks_proc_p_pgrp {
    volatile struct ks_pgrp *__smr_ptr;
};
_Static_assert(offsetof(struct ks_proc_p_pgrp, __smr_ptr) == 0x0, "ks_proc_p_pgrp.__smr_ptr offset");

struct ks_proc_p_sibling {
    struct ks_proc *le_next;
    struct ks_proc **le_prev;
};
_Static_assert(offsetof(struct ks_proc_p_sibling, le_next) == 0x0, "ks_proc_p_sibling.le_next offset");
_Static_assert(offsetof(struct ks_proc_p_sibling, le_prev) == 0x8, "ks_proc_p_sibling.le_prev offset");

struct ks_proc_p_uthlist {
    struct ks_uthread *tqh_first;
    struct ks_uthread **tqh_last;
};
_Static_assert(offsetof(struct ks_proc_p_uthlist, tqh_first) == 0x0, "ks_proc_p_uthlist.tqh_first offset");
_Static_assert(offsetof(struct ks_proc_p_uthlist, tqh_last) == 0x8, "ks_proc_p_uthlist.tqh_last offset");

struct ks_sigacts {
    unsigned long long ps_sigact[32];
    unsigned long long ps_trampact[32];
    unsigned int ps_catchmask[32];
    unsigned int ps_sigonstack;
    unsigned int ps_sigintr;
    unsigned int ps_sigreset;
    unsigned int ps_signodefer;
    unsigned int ps_siginfo;
    unsigned int ps_oldmask;
    unsigned int ps_sigreturn_validation;
    int ps_flags;
    int ps_sig;
    int ps_code;
    int ps_addr;
};
_Static_assert(offsetof(struct ks_sigacts, ps_sigact) == 0x0, "ks_sigacts.ps_sigact offset");
_Static_assert(offsetof(struct ks_sigacts, ps_trampact) == 0x100, "ks_sigacts.ps_trampact offset");
_Static_assert(offsetof(struct ks_sigacts, ps_catchmask) == 0x200, "ks_sigacts.ps_catchmask offset");
_Static_assert(offsetof(struct ks_sigacts, ps_sigonstack) == 0x280, "ks_sigacts.ps_sigonstack offset");
_Static_assert(offsetof(struct ks_sigacts, ps_sigintr) == 0x284, "ks_sigacts.ps_sigintr offset");
_Static_assert(offsetof(struct ks_sigacts, ps_sigreset) == 0x288, "ks_sigacts.ps_sigreset offset");
_Static_assert(offsetof(struct ks_sigacts, ps_signodefer) == 0x28c, "ks_sigacts.ps_signodefer offset");
_Static_assert(offsetof(struct ks_sigacts, ps_siginfo) == 0x290, "ks_sigacts.ps_siginfo offset");
_Static_assert(offsetof(struct ks_sigacts, ps_oldmask) == 0x294, "ks_sigacts.ps_oldmask offset");
_Static_assert(offsetof(struct ks_sigacts, ps_sigreturn_validation) == 0x298, "ks_sigacts.ps_sigreturn_validation offset");
_Static_assert(offsetof(struct ks_sigacts, ps_flags) == 0x29c, "ks_sigacts.ps_flags offset");
_Static_assert(offsetof(struct ks_sigacts, ps_sig) == 0x2a0, "ks_sigacts.ps_sig offset");
_Static_assert(offsetof(struct ks_sigacts, ps_code) == 0x2a4, "ks_sigacts.ps_code offset");
_Static_assert(offsetof(struct ks_sigacts, ps_addr) == 0x2a8, "ks_sigacts.ps_addr offset");

struct ks_proc {
    union {
        struct {
            struct ks_proc *le_next;
            struct ks_proc **le_prev;
        } p_list;
        struct ks_smr_node p_smr_node;
    };
    struct ks_proc *p_pptr;
    struct ks_proc_ro *p_proc_ro;
    int p_ppid;
    int p_pgrpid;
    unsigned int p_uid;
    unsigned int p_gid;
    unsigned int p_ruid;
    unsigned int p_rgid;
    unsigned int p_svuid;
    unsigned int p_svgid;
    int p_sessionid;
    unsigned long long p_puniqueid;
    struct ks_lck_mtx_t p_mlock;
    int p_pid;
    char p_stat;
    char p_shutdownstate;
    char p_kdebug;
    char p_btrace;
    struct {
        struct ks_proc *le_next;
        struct ks_proc **le_prev;
    } p_pglist;
    struct {
        struct ks_proc *le_next;
        struct ks_proc **le_prev;
    } p_sibling;
    struct ks_proc_p_children p_children;
    struct ks_proc_p_uthlist p_uthlist;
    struct ks_smrq_slink p_hash;
    struct ks_persona *p_persona;
    struct {
        struct ks_proc *le_next;
        struct ks_proc **le_prev;
    } p_persona_list;
    struct ks_lck_mtx_t p_ucred_mlock;
    struct ks_lck_mtx_t p_audit_mlock;
    struct ks_filedesc p_fd;
    struct ks_pstats *p_stats;
    struct ks_proc_p_limit p_limit;
    struct ks_proc_p_pgrp p_pgrp;
    struct ks_sigacts p_sigacts;
    struct ks_lck_spin_t p_slock;
    int p_siglist;
    unsigned int p_flag;
    unsigned int p_lflag;
    unsigned int p_listflag;
    unsigned int p_ladvflag;
    unsigned int p_refcount;
    unsigned int p_waitref;
    int p_childrencnt;
    int p_parentref;
    int p_oppid;
    unsigned int p_xstat;
    int p_aio_total_count;
    struct ks_itimerval p_realtimer;
    struct ks_timeval p_rtime;
    struct ks_itimerval p_vtimer_user;
    struct ks_itimerval p_vtimer_prof;
    struct ks_timeval p_rlim_cpu;
    int p_debugger;
    int sigwait;
    void *sigwait_thread;
    void *exit_thread;
    int si_pid;
    unsigned int si_status;
    unsigned int si_code;
    unsigned int si_uid;
    void *vm_shm;
    int p_ractive;
    int p_responsible_pid;
    int p_dtrace_probes;
    unsigned int p_dtrace_count;
    unsigned char p_dtrace_stop;
    unsigned long long p_dtrace_argv;
    unsigned long long p_dtrace_envp;
    struct ks_lck_mtx_t p_dtrace_sprlock;
    struct ks_dtrace_ptss_page *p_dtrace_ptss_pages;
    struct ks_dtrace_ptss_page_entry *p_dtrace_ptss_free_list;
    struct ks_dtrace_helpers *p_dtrace_helpers;
    struct ks_dof_ioctl_data *p_dtrace_lazy_dofs;
    struct ks_proc_forkcopy_data p_forkcopy;
    struct ks_proc_p_aio_activeq p_aio_activeq;
    struct ks_proc_p_aio_doneq p_aio_doneq;
    struct ks_klist p_klist;
    struct ks_rusage_superset *p_ru;
    struct ks_thread *p_signalholder;
    struct ks_thread *p_transholder;
    int p_sigwaitcnt;
    unsigned short p_acflag;
    unsigned short p_vfs_iopolicy;
    unsigned long long p_threadstart;
    unsigned long long p_wqthread;
    int p_pthsize;
    unsigned int p_pth_tsd_offset;
    unsigned long long p_stack_addr_hint;
    struct ks_workqueue * _Atomic p_wqptr;
    struct ks_workq_aio_s * _Atomic p_aio_wqptr;
    struct ks_timeval p_start;
    void *p_rcall;
    void *p_pthhash;
    unsigned long long was_throttled __attribute__((aligned(8)));
    unsigned long long did_throttle __attribute__((aligned(8)));
    unsigned long long p_dispatchqueue_offset;
    unsigned long long p_dispatchqueue_serialno_offset;
    unsigned long long p_dispatchqueue_label_offset;
    unsigned long long p_return_to_kernel_offset;
    unsigned long long p_mach_thread_self_offset;
    unsigned long long p_pthread_wq_quantum_offset;
    struct ks_timeval vm_pressure_last_notify_tstamp;
    unsigned char p_crash_behavior;
    _Bool p_posix_spawn_failed;
    _Bool p_disallow_map_with_linking;
    unsigned int p_memstat_state;
    int p_memstat_effectivepriority;
    int p_memstat_requestedpriority;
    int p_memstat_assertionpriority;
    unsigned int p_memstat_dirty;
    struct ks_proc_p_memstat_list p_memstat_list;
    unsigned long long p_memstat_userdata;
    unsigned long long p_memstat_idledeadline;
    unsigned long long p_memstat_prio_start;
    unsigned long long p_memstat_idle_delta;
    int p_memstat_memlimit;
    int p_memstat_memlimit_active;
    int p_memstat_memlimit_inactive;
    int p_memstat_relaunch_flags;
    unsigned int p_user_faults;
    unsigned int p_memlimit_increase;
    unsigned long long p_crash_behavior_deadline;
    unsigned int p_crash_count;
    unsigned int p_throttle_timeout;
    struct ks_os_reason *p_exit_reason;
    unsigned long long p_user_data;
    char *p_subsystem_root_path;
};
_Static_assert(offsetof(struct ks_proc, p_pptr) == 0x10, "ks_proc.p_pptr offset");
_Static_assert(offsetof(struct ks_proc, p_proc_ro) == 0x18, "ks_proc.p_proc_ro offset");
_Static_assert(offsetof(struct ks_proc, p_ppid) == 0x20, "ks_proc.p_ppid offset");
_Static_assert(offsetof(struct ks_proc, p_pgrpid) == 0x24, "ks_proc.p_pgrpid offset");
_Static_assert(offsetof(struct ks_proc, p_uid) == 0x28, "ks_proc.p_uid offset");
_Static_assert(offsetof(struct ks_proc, p_gid) == 0x2c, "ks_proc.p_gid offset");
_Static_assert(offsetof(struct ks_proc, p_ruid) == 0x30, "ks_proc.p_ruid offset");
_Static_assert(offsetof(struct ks_proc, p_rgid) == 0x34, "ks_proc.p_rgid offset");
_Static_assert(offsetof(struct ks_proc, p_svuid) == 0x38, "ks_proc.p_svuid offset");
_Static_assert(offsetof(struct ks_proc, p_svgid) == 0x3c, "ks_proc.p_svgid offset");
_Static_assert(offsetof(struct ks_proc, p_sessionid) == 0x40, "ks_proc.p_sessionid offset");
_Static_assert(offsetof(struct ks_proc, p_puniqueid) == 0x48, "ks_proc.p_puniqueid offset");
_Static_assert(offsetof(struct ks_proc, p_mlock) == 0x50, "ks_proc.p_mlock offset");
_Static_assert(offsetof(struct ks_proc, p_pid) == 0x60, "ks_proc.p_pid offset");
_Static_assert(offsetof(struct ks_proc, p_stat) == 0x64, "ks_proc.p_stat offset");
_Static_assert(offsetof(struct ks_proc, p_shutdownstate) == 0x65, "ks_proc.p_shutdownstate offset");
_Static_assert(offsetof(struct ks_proc, p_kdebug) == 0x66, "ks_proc.p_kdebug offset");
_Static_assert(offsetof(struct ks_proc, p_btrace) == 0x67, "ks_proc.p_btrace offset");
_Static_assert(offsetof(struct ks_proc, p_pglist) == 0x68, "ks_proc.p_pglist offset");
_Static_assert(offsetof(struct ks_proc, p_sibling) == 0x78, "ks_proc.p_sibling offset");
_Static_assert(offsetof(struct ks_proc, p_children) == 0x88, "ks_proc.p_children offset");
_Static_assert(offsetof(struct ks_proc, p_uthlist) == 0x90, "ks_proc.p_uthlist offset");
_Static_assert(offsetof(struct ks_proc, p_hash) == 0xa0, "ks_proc.p_hash offset");
_Static_assert(offsetof(struct ks_proc, p_persona) == 0xa8, "ks_proc.p_persona offset");
_Static_assert(offsetof(struct ks_proc, p_persona_list) == 0xb0, "ks_proc.p_persona_list offset");
_Static_assert(offsetof(struct ks_proc, p_ucred_mlock) == 0xc0, "ks_proc.p_ucred_mlock offset");
_Static_assert(offsetof(struct ks_proc, p_audit_mlock) == 0xd0, "ks_proc.p_audit_mlock offset");
_Static_assert(offsetof(struct ks_proc, p_fd) == 0xe0, "ks_proc.p_fd offset");
_Static_assert(offsetof(struct ks_proc, p_stats) == 0x188, "ks_proc.p_stats offset");
_Static_assert(offsetof(struct ks_proc, p_limit) == 0x190, "ks_proc.p_limit offset");
_Static_assert(offsetof(struct ks_proc, p_pgrp) == 0x198, "ks_proc.p_pgrp offset");
_Static_assert(offsetof(struct ks_proc, p_sigacts) == 0x1a0, "ks_proc.p_sigacts offset");
_Static_assert(offsetof(struct ks_proc, p_slock) == 0x450, "ks_proc.p_slock offset");
_Static_assert(offsetof(struct ks_proc, p_siglist) == 0x460, "ks_proc.p_siglist offset");
_Static_assert(offsetof(struct ks_proc, p_flag) == 0x464, "ks_proc.p_flag offset");
_Static_assert(offsetof(struct ks_proc, p_lflag) == 0x468, "ks_proc.p_lflag offset");
_Static_assert(offsetof(struct ks_proc, p_listflag) == 0x46c, "ks_proc.p_listflag offset");
_Static_assert(offsetof(struct ks_proc, p_ladvflag) == 0x470, "ks_proc.p_ladvflag offset");
_Static_assert(offsetof(struct ks_proc, p_refcount) == 0x474, "ks_proc.p_refcount offset");
_Static_assert(offsetof(struct ks_proc, p_waitref) == 0x478, "ks_proc.p_waitref offset");
_Static_assert(offsetof(struct ks_proc, p_childrencnt) == 0x47c, "ks_proc.p_childrencnt offset");
_Static_assert(offsetof(struct ks_proc, p_parentref) == 0x480, "ks_proc.p_parentref offset");
_Static_assert(offsetof(struct ks_proc, p_oppid) == 0x484, "ks_proc.p_oppid offset");
_Static_assert(offsetof(struct ks_proc, p_xstat) == 0x488, "ks_proc.p_xstat offset");
_Static_assert(offsetof(struct ks_proc, p_aio_total_count) == 0x48c, "ks_proc.p_aio_total_count offset");
_Static_assert(offsetof(struct ks_proc, p_realtimer) == 0x490, "ks_proc.p_realtimer offset");
_Static_assert(offsetof(struct ks_proc, p_rtime) == 0x4b0, "ks_proc.p_rtime offset");
_Static_assert(offsetof(struct ks_proc, p_vtimer_user) == 0x4c0, "ks_proc.p_vtimer_user offset");
_Static_assert(offsetof(struct ks_proc, p_vtimer_prof) == 0x4e0, "ks_proc.p_vtimer_prof offset");
_Static_assert(offsetof(struct ks_proc, p_rlim_cpu) == 0x500, "ks_proc.p_rlim_cpu offset");
_Static_assert(offsetof(struct ks_proc, p_debugger) == 0x510, "ks_proc.p_debugger offset");
_Static_assert(offsetof(struct ks_proc, sigwait) == 0x514, "ks_proc.sigwait offset");
_Static_assert(offsetof(struct ks_proc, sigwait_thread) == 0x518, "ks_proc.sigwait_thread offset");
_Static_assert(offsetof(struct ks_proc, exit_thread) == 0x520, "ks_proc.exit_thread offset");
_Static_assert(offsetof(struct ks_proc, si_pid) == 0x528, "ks_proc.si_pid offset");
_Static_assert(offsetof(struct ks_proc, si_status) == 0x52c, "ks_proc.si_status offset");
_Static_assert(offsetof(struct ks_proc, si_code) == 0x530, "ks_proc.si_code offset");
_Static_assert(offsetof(struct ks_proc, si_uid) == 0x534, "ks_proc.si_uid offset");
_Static_assert(offsetof(struct ks_proc, vm_shm) == 0x538, "ks_proc.vm_shm offset");
_Static_assert(offsetof(struct ks_proc, p_ractive) == 0x540, "ks_proc.p_ractive offset");
_Static_assert(offsetof(struct ks_proc, p_responsible_pid) == 0x544, "ks_proc.p_responsible_pid offset");
_Static_assert(offsetof(struct ks_proc, p_dtrace_probes) == 0x548, "ks_proc.p_dtrace_probes offset");
_Static_assert(offsetof(struct ks_proc, p_dtrace_count) == 0x54c, "ks_proc.p_dtrace_count offset");
_Static_assert(offsetof(struct ks_proc, p_dtrace_stop) == 0x550, "ks_proc.p_dtrace_stop offset");
_Static_assert(offsetof(struct ks_proc, p_dtrace_argv) == 0x558, "ks_proc.p_dtrace_argv offset");
_Static_assert(offsetof(struct ks_proc, p_dtrace_envp) == 0x560, "ks_proc.p_dtrace_envp offset");
_Static_assert(offsetof(struct ks_proc, p_dtrace_sprlock) == 0x568, "ks_proc.p_dtrace_sprlock offset");
_Static_assert(offsetof(struct ks_proc, p_dtrace_ptss_pages) == 0x578, "ks_proc.p_dtrace_ptss_pages offset");
_Static_assert(offsetof(struct ks_proc, p_dtrace_ptss_free_list) == 0x580, "ks_proc.p_dtrace_ptss_free_list offset");
_Static_assert(offsetof(struct ks_proc, p_dtrace_helpers) == 0x588, "ks_proc.p_dtrace_helpers offset");
_Static_assert(offsetof(struct ks_proc, p_dtrace_lazy_dofs) == 0x590, "ks_proc.p_dtrace_lazy_dofs offset");
_Static_assert(offsetof(struct ks_proc, p_forkcopy) == 0x598, "ks_proc.p_forkcopy offset");
_Static_assert(offsetof(struct ks_proc, p_aio_activeq) == 0x630, "ks_proc.p_aio_activeq offset");
_Static_assert(offsetof(struct ks_proc, p_aio_doneq) == 0x640, "ks_proc.p_aio_doneq offset");
_Static_assert(offsetof(struct ks_proc, p_klist) == 0x650, "ks_proc.p_klist offset");
_Static_assert(offsetof(struct ks_proc, p_ru) == 0x658, "ks_proc.p_ru offset");
_Static_assert(offsetof(struct ks_proc, p_signalholder) == 0x660, "ks_proc.p_signalholder offset");
_Static_assert(offsetof(struct ks_proc, p_transholder) == 0x668, "ks_proc.p_transholder offset");
_Static_assert(offsetof(struct ks_proc, p_sigwaitcnt) == 0x670, "ks_proc.p_sigwaitcnt offset");
_Static_assert(offsetof(struct ks_proc, p_acflag) == 0x674, "ks_proc.p_acflag offset");
_Static_assert(offsetof(struct ks_proc, p_vfs_iopolicy) == 0x676, "ks_proc.p_vfs_iopolicy offset");
_Static_assert(offsetof(struct ks_proc, p_threadstart) == 0x678, "ks_proc.p_threadstart offset");
_Static_assert(offsetof(struct ks_proc, p_wqthread) == 0x680, "ks_proc.p_wqthread offset");
_Static_assert(offsetof(struct ks_proc, p_pthsize) == 0x688, "ks_proc.p_pthsize offset");
_Static_assert(offsetof(struct ks_proc, p_pth_tsd_offset) == 0x68c, "ks_proc.p_pth_tsd_offset offset");
_Static_assert(offsetof(struct ks_proc, p_stack_addr_hint) == 0x690, "ks_proc.p_stack_addr_hint offset");
_Static_assert(offsetof(struct ks_proc, p_wqptr) == 0x698, "ks_proc.p_wqptr offset");
_Static_assert(offsetof(struct ks_proc, p_aio_wqptr) == 0x6a0, "ks_proc.p_aio_wqptr offset");
_Static_assert(offsetof(struct ks_proc, p_start) == 0x6a8, "ks_proc.p_start offset");
_Static_assert(offsetof(struct ks_proc, p_rcall) == 0x6b8, "ks_proc.p_rcall offset");
_Static_assert(offsetof(struct ks_proc, p_pthhash) == 0x6c0, "ks_proc.p_pthhash offset");
_Static_assert(offsetof(struct ks_proc, was_throttled) == 0x6c8, "ks_proc.was_throttled offset");
_Static_assert(offsetof(struct ks_proc, did_throttle) == 0x6d0, "ks_proc.did_throttle offset");
_Static_assert(offsetof(struct ks_proc, p_dispatchqueue_offset) == 0x6d8, "ks_proc.p_dispatchqueue_offset offset");
_Static_assert(offsetof(struct ks_proc, p_dispatchqueue_serialno_offset) == 0x6e0, "ks_proc.p_dispatchqueue_serialno_offset offset");
_Static_assert(offsetof(struct ks_proc, p_dispatchqueue_label_offset) == 0x6e8, "ks_proc.p_dispatchqueue_label_offset offset");
_Static_assert(offsetof(struct ks_proc, p_return_to_kernel_offset) == 0x6f0, "ks_proc.p_return_to_kernel_offset offset");
_Static_assert(offsetof(struct ks_proc, p_mach_thread_self_offset) == 0x6f8, "ks_proc.p_mach_thread_self_offset offset");
_Static_assert(offsetof(struct ks_proc, p_pthread_wq_quantum_offset) == 0x700, "ks_proc.p_pthread_wq_quantum_offset offset");
_Static_assert(offsetof(struct ks_proc, vm_pressure_last_notify_tstamp) == 0x708, "ks_proc.vm_pressure_last_notify_tstamp offset");
_Static_assert(offsetof(struct ks_proc, p_crash_behavior) == 0x718, "ks_proc.p_crash_behavior offset");
_Static_assert(offsetof(struct ks_proc, p_posix_spawn_failed) == 0x719, "ks_proc.p_posix_spawn_failed offset");
_Static_assert(offsetof(struct ks_proc, p_disallow_map_with_linking) == 0x71a, "ks_proc.p_disallow_map_with_linking offset");
_Static_assert(offsetof(struct ks_proc, p_memstat_state) == 0x71c, "ks_proc.p_memstat_state offset");
_Static_assert(offsetof(struct ks_proc, p_memstat_effectivepriority) == 0x720, "ks_proc.p_memstat_effectivepriority offset");
_Static_assert(offsetof(struct ks_proc, p_memstat_requestedpriority) == 0x724, "ks_proc.p_memstat_requestedpriority offset");
_Static_assert(offsetof(struct ks_proc, p_memstat_assertionpriority) == 0x728, "ks_proc.p_memstat_assertionpriority offset");
_Static_assert(offsetof(struct ks_proc, p_memstat_dirty) == 0x72c, "ks_proc.p_memstat_dirty offset");
_Static_assert(offsetof(struct ks_proc, p_memstat_list) == 0x730, "ks_proc.p_memstat_list offset");
_Static_assert(offsetof(struct ks_proc, p_memstat_userdata) == 0x740, "ks_proc.p_memstat_userdata offset");
_Static_assert(offsetof(struct ks_proc, p_memstat_idledeadline) == 0x748, "ks_proc.p_memstat_idledeadline offset");
_Static_assert(offsetof(struct ks_proc, p_memstat_prio_start) == 0x750, "ks_proc.p_memstat_prio_start offset");
_Static_assert(offsetof(struct ks_proc, p_memstat_idle_delta) == 0x758, "ks_proc.p_memstat_idle_delta offset");
_Static_assert(offsetof(struct ks_proc, p_memstat_memlimit) == 0x760, "ks_proc.p_memstat_memlimit offset");
_Static_assert(offsetof(struct ks_proc, p_memstat_memlimit_active) == 0x764, "ks_proc.p_memstat_memlimit_active offset");
_Static_assert(offsetof(struct ks_proc, p_memstat_memlimit_inactive) == 0x768, "ks_proc.p_memstat_memlimit_inactive offset");
_Static_assert(offsetof(struct ks_proc, p_memstat_relaunch_flags) == 0x76c, "ks_proc.p_memstat_relaunch_flags offset");
_Static_assert(offsetof(struct ks_proc, p_user_faults) == 0x770, "ks_proc.p_user_faults offset");
_Static_assert(offsetof(struct ks_proc, p_memlimit_increase) == 0x774, "ks_proc.p_memlimit_increase offset");
_Static_assert(offsetof(struct ks_proc, p_crash_behavior_deadline) == 0x778, "ks_proc.p_crash_behavior_deadline offset");
_Static_assert(offsetof(struct ks_proc, p_crash_count) == 0x780, "ks_proc.p_crash_count offset");
_Static_assert(offsetof(struct ks_proc, p_throttle_timeout) == 0x784, "ks_proc.p_throttle_timeout offset");
_Static_assert(offsetof(struct ks_proc, p_exit_reason) == 0x788, "ks_proc.p_exit_reason offset");
_Static_assert(offsetof(struct ks_proc, p_user_data) == 0x790, "ks_proc.p_user_data offset");
_Static_assert(offsetof(struct ks_proc, p_subsystem_root_path) == 0x798, "ks_proc.p_subsystem_root_path offset");
_Static_assert(offsetof(struct ks_proc, p_list) == 0x0, "ks_proc.p_list offset");
_Static_assert(offsetof(struct ks_proc, p_smr_node) == 0x0, "ks_proc.p_smr_node offset");

struct ks_proc_platform_ro_data {
    unsigned int p_platform;
    unsigned int p_min_sdk;
    unsigned int p_sdk;
};
_Static_assert(offsetof(struct ks_proc_platform_ro_data, p_platform) == 0x0, "ks_proc_platform_ro_data.p_platform offset");
_Static_assert(offsetof(struct ks_proc_platform_ro_data, p_min_sdk) == 0x4, "ks_proc_platform_ro_data.p_min_sdk offset");
_Static_assert(offsetof(struct ks_proc_platform_ro_data, p_sdk) == 0x8, "ks_proc_platform_ro_data.p_sdk offset");

struct ks_proc_ro_data_p_ucred {
    volatile struct ks_ucred *__smr_ptr;
};
_Static_assert(offsetof(struct ks_proc_ro_data_p_ucred, __smr_ptr) == 0x0, "ks_proc_ro_data_p_ucred.__smr_ptr offset");

struct ks_proc_ro_data {
    unsigned long long p_uniqueid;
    int p_idversion;
    int p_orig_ppid;
    int p_orig_ppidversion;
    unsigned int p_csflags;
    struct ks_proc_ro_data_p_ucred p_ucred;
    unsigned char *syscall_filter_mask;
    struct ks_proc_platform_ro_data p_platform_data;
};
_Static_assert(offsetof(struct ks_proc_ro_data, p_uniqueid) == 0x0, "ks_proc_ro_data.p_uniqueid offset");
_Static_assert(offsetof(struct ks_proc_ro_data, p_idversion) == 0x8, "ks_proc_ro_data.p_idversion offset");
_Static_assert(offsetof(struct ks_proc_ro_data, p_orig_ppid) == 0xc, "ks_proc_ro_data.p_orig_ppid offset");
_Static_assert(offsetof(struct ks_proc_ro_data, p_orig_ppidversion) == 0x10, "ks_proc_ro_data.p_orig_ppidversion offset");
_Static_assert(offsetof(struct ks_proc_ro_data, p_csflags) == 0x14, "ks_proc_ro_data.p_csflags offset");
_Static_assert(offsetof(struct ks_proc_ro_data, p_ucred) == 0x18, "ks_proc_ro_data.p_ucred offset");
_Static_assert(offsetof(struct ks_proc_ro_data, syscall_filter_mask) == 0x20, "ks_proc_ro_data.syscall_filter_mask offset");
_Static_assert(offsetof(struct ks_proc_ro_data, p_platform_data) == 0x28, "ks_proc_ro_data.p_platform_data offset");

struct ks_task_filter_ro_data {
    unsigned char *mach_trap_filter_mask;
    unsigned char *mach_kobj_filter_mask;
};
_Static_assert(offsetof(struct ks_task_filter_ro_data, mach_trap_filter_mask) == 0x0, "ks_task_filter_ro_data.mach_trap_filter_mask offset");
_Static_assert(offsetof(struct ks_task_filter_ro_data, mach_kobj_filter_mask) == 0x8, "ks_task_filter_ro_data.mach_kobj_filter_mask offset");

struct ks_security_token_t {
    unsigned int val[2];
};
_Static_assert(offsetof(struct ks_security_token_t, val) == 0x0, "ks_security_token_t.val offset");

struct ks_task_token_ro_data {
    struct ks_security_token_t sec_token __attribute__((aligned(4)));
    struct ks_audit_token_t audit_token __attribute__((aligned(4)));
};
_Static_assert(offsetof(struct ks_task_token_ro_data, sec_token) == 0x0, "ks_task_token_ro_data.sec_token offset");
_Static_assert(offsetof(struct ks_task_token_ro_data, audit_token) == 0x8, "ks_task_token_ro_data.audit_token offset");

struct ks_task_ro_data {
    struct ks_task_token_ro_data task_tokens;
    struct ks_task_filter_ro_data task_filters;
    unsigned int t_flags_ro;
    unsigned char task_control_port_options;
};
_Static_assert(offsetof(struct ks_task_ro_data, task_tokens) == 0x0, "ks_task_ro_data.task_tokens offset");
_Static_assert(offsetof(struct ks_task_ro_data, task_filters) == 0x28, "ks_task_ro_data.task_filters offset");
_Static_assert(offsetof(struct ks_task_ro_data, t_flags_ro) == 0x38, "ks_task_ro_data.t_flags_ro offset");
_Static_assert(offsetof(struct ks_task_ro_data, task_control_port_options) == 0x3c, "ks_task_ro_data.task_control_port_options offset");

struct ks_proc_ro {
    struct ks_proc *pr_proc;
    struct ks_task *pr_task;
    struct ks_proc_ro_data proc_data;
    struct ks_task_ro_data task_data;
};
_Static_assert(offsetof(struct ks_proc_ro, pr_proc) == 0x0, "ks_proc_ro.pr_proc offset");
_Static_assert(offsetof(struct ks_proc_ro, pr_task) == 0x8, "ks_proc_ro.pr_task offset");
_Static_assert(offsetof(struct ks_proc_ro, proc_data) == 0x10, "ks_proc_ro.proc_data offset");
_Static_assert(offsetof(struct ks_proc_ro, task_data) == 0x48, "ks_proc_ro.task_data offset");

struct ks_rusage {
    struct ks_timeval ru_utime;
    struct ks_timeval ru_stime;
    long ru_maxrss;
    long ru_ixrss;
    long ru_idrss;
    long ru_isrss;
    long ru_minflt;
    long ru_majflt;
    long ru_nswap;
    long ru_inblock;
    long ru_oublock;
    long ru_msgsnd;
    long ru_msgrcv;
    long ru_nsignals;
    long ru_nvcsw;
    long ru_nivcsw;
};
_Static_assert(offsetof(struct ks_rusage, ru_utime) == 0x0, "ks_rusage.ru_utime offset");
_Static_assert(offsetof(struct ks_rusage, ru_stime) == 0x10, "ks_rusage.ru_stime offset");
_Static_assert(offsetof(struct ks_rusage, ru_maxrss) == 0x20, "ks_rusage.ru_maxrss offset");
_Static_assert(offsetof(struct ks_rusage, ru_ixrss) == 0x28, "ks_rusage.ru_ixrss offset");
_Static_assert(offsetof(struct ks_rusage, ru_idrss) == 0x30, "ks_rusage.ru_idrss offset");
_Static_assert(offsetof(struct ks_rusage, ru_isrss) == 0x38, "ks_rusage.ru_isrss offset");
_Static_assert(offsetof(struct ks_rusage, ru_minflt) == 0x40, "ks_rusage.ru_minflt offset");
_Static_assert(offsetof(struct ks_rusage, ru_majflt) == 0x48, "ks_rusage.ru_majflt offset");
_Static_assert(offsetof(struct ks_rusage, ru_nswap) == 0x50, "ks_rusage.ru_nswap offset");
_Static_assert(offsetof(struct ks_rusage, ru_inblock) == 0x58, "ks_rusage.ru_inblock offset");
_Static_assert(offsetof(struct ks_rusage, ru_oublock) == 0x60, "ks_rusage.ru_oublock offset");
_Static_assert(offsetof(struct ks_rusage, ru_msgsnd) == 0x68, "ks_rusage.ru_msgsnd offset");
_Static_assert(offsetof(struct ks_rusage, ru_msgrcv) == 0x70, "ks_rusage.ru_msgrcv offset");
_Static_assert(offsetof(struct ks_rusage, ru_nsignals) == 0x78, "ks_rusage.ru_nsignals offset");
_Static_assert(offsetof(struct ks_rusage, ru_nvcsw) == 0x80, "ks_rusage.ru_nvcsw offset");
_Static_assert(offsetof(struct ks_rusage, ru_nivcsw) == 0x88, "ks_rusage.ru_nivcsw offset");

struct ks_rusage_info_child {
    unsigned long long ri_child_user_time;
    unsigned long long ri_child_system_time;
    unsigned long long ri_child_pkg_idle_wkups;
    unsigned long long ri_child_interrupt_wkups;
    unsigned long long ri_child_pageins;
    unsigned long long ri_child_elapsed_abstime;
};
_Static_assert(offsetof(struct ks_rusage_info_child, ri_child_user_time) == 0x0, "ks_rusage_info_child.ri_child_user_time offset");
_Static_assert(offsetof(struct ks_rusage_info_child, ri_child_system_time) == 0x8, "ks_rusage_info_child.ri_child_system_time offset");
_Static_assert(offsetof(struct ks_rusage_info_child, ri_child_pkg_idle_wkups) == 0x10, "ks_rusage_info_child.ri_child_pkg_idle_wkups offset");
_Static_assert(offsetof(struct ks_rusage_info_child, ri_child_interrupt_wkups) == 0x18, "ks_rusage_info_child.ri_child_interrupt_wkups offset");
_Static_assert(offsetof(struct ks_rusage_info_child, ri_child_pageins) == 0x20, "ks_rusage_info_child.ri_child_pageins offset");
_Static_assert(offsetof(struct ks_rusage_info_child, ri_child_elapsed_abstime) == 0x28, "ks_rusage_info_child.ri_child_elapsed_abstime offset");

struct ks_uprof {
    struct ks_uprof *pr_next;
    char *pr_base;
    unsigned int pr_size;
    unsigned int pr_off;
    unsigned int pr_scale;
    unsigned int pr_addr;
    unsigned int pr_ticks;
};
_Static_assert(offsetof(struct ks_uprof, pr_next) == 0x0, "ks_uprof.pr_next offset");
_Static_assert(offsetof(struct ks_uprof, pr_base) == 0x8, "ks_uprof.pr_base offset");
_Static_assert(offsetof(struct ks_uprof, pr_size) == 0x10, "ks_uprof.pr_size offset");
_Static_assert(offsetof(struct ks_uprof, pr_off) == 0x14, "ks_uprof.pr_off offset");
_Static_assert(offsetof(struct ks_uprof, pr_scale) == 0x18, "ks_uprof.pr_scale offset");
_Static_assert(offsetof(struct ks_uprof, pr_addr) == 0x1c, "ks_uprof.pr_addr offset");
_Static_assert(offsetof(struct ks_uprof, pr_ticks) == 0x20, "ks_uprof.pr_ticks offset");

struct ks_user_uprof {
    struct ks_user_uprof *pr_next;
    unsigned long long pr_base;
    unsigned long long pr_size;
    unsigned long long pr_off;
    unsigned long long pr_scale;
    unsigned long long pr_addr;
    unsigned long long pr_ticks;
};
_Static_assert(offsetof(struct ks_user_uprof, pr_next) == 0x0, "ks_user_uprof.pr_next offset");
_Static_assert(offsetof(struct ks_user_uprof, pr_base) == 0x8, "ks_user_uprof.pr_base offset");
_Static_assert(offsetof(struct ks_user_uprof, pr_size) == 0x10, "ks_user_uprof.pr_size offset");
_Static_assert(offsetof(struct ks_user_uprof, pr_off) == 0x18, "ks_user_uprof.pr_off offset");
_Static_assert(offsetof(struct ks_user_uprof, pr_scale) == 0x20, "ks_user_uprof.pr_scale offset");
_Static_assert(offsetof(struct ks_user_uprof, pr_addr) == 0x28, "ks_user_uprof.pr_addr offset");
_Static_assert(offsetof(struct ks_user_uprof, pr_ticks) == 0x30, "ks_user_uprof.pr_ticks offset");

struct ks_pstats {
    struct ks_rusage p_ru;
    struct ks_rusage p_cru;
    struct ks_uprof p_prof;
    unsigned long long ps_start;
    struct ks_rusage_info_child ri_child;
    struct ks_user_uprof user_p_prof;
};
_Static_assert(offsetof(struct ks_pstats, p_ru) == 0x0, "ks_pstats.p_ru offset");
_Static_assert(offsetof(struct ks_pstats, p_cru) == 0x90, "ks_pstats.p_cru offset");
_Static_assert(offsetof(struct ks_pstats, p_prof) == 0x120, "ks_pstats.p_prof offset");
_Static_assert(offsetof(struct ks_pstats, ps_start) == 0x148, "ks_pstats.ps_start offset");
_Static_assert(offsetof(struct ks_pstats, ri_child) == 0x150, "ks_pstats.ri_child offset");
_Static_assert(offsetof(struct ks_pstats, user_p_prof) == 0x180, "ks_pstats.user_p_prof offset");

struct ks_rusage_info_v6 {
    unsigned char ri_uuid[16];
    unsigned long long ri_user_time;
    unsigned long long ri_system_time;
    unsigned long long ri_pkg_idle_wkups;
    unsigned long long ri_interrupt_wkups;
    unsigned long long ri_pageins;
    unsigned long long ri_wired_size;
    unsigned long long ri_resident_size;
    unsigned long long ri_phys_footprint;
    unsigned long long ri_proc_start_abstime;
    unsigned long long ri_proc_exit_abstime;
    unsigned long long ri_child_user_time;
    unsigned long long ri_child_system_time;
    unsigned long long ri_child_pkg_idle_wkups;
    unsigned long long ri_child_interrupt_wkups;
    unsigned long long ri_child_pageins;
    unsigned long long ri_child_elapsed_abstime;
    unsigned long long ri_diskio_bytesread;
    unsigned long long ri_diskio_byteswritten;
    unsigned long long ri_cpu_time_qos_default;
    unsigned long long ri_cpu_time_qos_maintenance;
    unsigned long long ri_cpu_time_qos_background;
    unsigned long long ri_cpu_time_qos_utility;
    unsigned long long ri_cpu_time_qos_legacy;
    unsigned long long ri_cpu_time_qos_user_initiated;
    unsigned long long ri_cpu_time_qos_user_interactive;
    unsigned long long ri_billed_system_time;
    unsigned long long ri_serviced_system_time;
    unsigned long long ri_logical_writes;
    unsigned long long ri_lifetime_max_phys_footprint;
    unsigned long long ri_instructions;
    unsigned long long ri_cycles;
    unsigned long long ri_billed_energy;
    unsigned long long ri_serviced_energy;
    unsigned long long ri_interval_max_phys_footprint;
    unsigned long long ri_runnable_time;
    unsigned long long ri_flags;
    unsigned long long ri_user_ptime;
    unsigned long long ri_system_ptime;
    unsigned long long ri_pinstructions;
    unsigned long long ri_pcycles;
    unsigned long long ri_energy_nj;
    unsigned long long ri_penergy_nj;
    unsigned long long ri_secure_time_in_system;
    unsigned long long ri_secure_ptime_in_system;
    unsigned long long ri_neural_footprint;
    unsigned long long ri_lifetime_max_neural_footprint;
    unsigned long long ri_interval_max_neural_footprint;
    unsigned long long ri_reserved[9];
};
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_uuid) == 0x0, "ks_rusage_info_v6.ri_uuid offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_user_time) == 0x10, "ks_rusage_info_v6.ri_user_time offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_system_time) == 0x18, "ks_rusage_info_v6.ri_system_time offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_pkg_idle_wkups) == 0x20, "ks_rusage_info_v6.ri_pkg_idle_wkups offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_interrupt_wkups) == 0x28, "ks_rusage_info_v6.ri_interrupt_wkups offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_pageins) == 0x30, "ks_rusage_info_v6.ri_pageins offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_wired_size) == 0x38, "ks_rusage_info_v6.ri_wired_size offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_resident_size) == 0x40, "ks_rusage_info_v6.ri_resident_size offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_phys_footprint) == 0x48, "ks_rusage_info_v6.ri_phys_footprint offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_proc_start_abstime) == 0x50, "ks_rusage_info_v6.ri_proc_start_abstime offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_proc_exit_abstime) == 0x58, "ks_rusage_info_v6.ri_proc_exit_abstime offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_child_user_time) == 0x60, "ks_rusage_info_v6.ri_child_user_time offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_child_system_time) == 0x68, "ks_rusage_info_v6.ri_child_system_time offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_child_pkg_idle_wkups) == 0x70, "ks_rusage_info_v6.ri_child_pkg_idle_wkups offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_child_interrupt_wkups) == 0x78, "ks_rusage_info_v6.ri_child_interrupt_wkups offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_child_pageins) == 0x80, "ks_rusage_info_v6.ri_child_pageins offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_child_elapsed_abstime) == 0x88, "ks_rusage_info_v6.ri_child_elapsed_abstime offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_diskio_bytesread) == 0x90, "ks_rusage_info_v6.ri_diskio_bytesread offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_diskio_byteswritten) == 0x98, "ks_rusage_info_v6.ri_diskio_byteswritten offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_cpu_time_qos_default) == 0xa0, "ks_rusage_info_v6.ri_cpu_time_qos_default offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_cpu_time_qos_maintenance) == 0xa8, "ks_rusage_info_v6.ri_cpu_time_qos_maintenance offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_cpu_time_qos_background) == 0xb0, "ks_rusage_info_v6.ri_cpu_time_qos_background offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_cpu_time_qos_utility) == 0xb8, "ks_rusage_info_v6.ri_cpu_time_qos_utility offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_cpu_time_qos_legacy) == 0xc0, "ks_rusage_info_v6.ri_cpu_time_qos_legacy offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_cpu_time_qos_user_initiated) == 0xc8, "ks_rusage_info_v6.ri_cpu_time_qos_user_initiated offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_cpu_time_qos_user_interactive) == 0xd0, "ks_rusage_info_v6.ri_cpu_time_qos_user_interactive offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_billed_system_time) == 0xd8, "ks_rusage_info_v6.ri_billed_system_time offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_serviced_system_time) == 0xe0, "ks_rusage_info_v6.ri_serviced_system_time offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_logical_writes) == 0xe8, "ks_rusage_info_v6.ri_logical_writes offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_lifetime_max_phys_footprint) == 0xf0, "ks_rusage_info_v6.ri_lifetime_max_phys_footprint offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_instructions) == 0xf8, "ks_rusage_info_v6.ri_instructions offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_cycles) == 0x100, "ks_rusage_info_v6.ri_cycles offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_billed_energy) == 0x108, "ks_rusage_info_v6.ri_billed_energy offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_serviced_energy) == 0x110, "ks_rusage_info_v6.ri_serviced_energy offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_interval_max_phys_footprint) == 0x118, "ks_rusage_info_v6.ri_interval_max_phys_footprint offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_runnable_time) == 0x120, "ks_rusage_info_v6.ri_runnable_time offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_flags) == 0x128, "ks_rusage_info_v6.ri_flags offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_user_ptime) == 0x130, "ks_rusage_info_v6.ri_user_ptime offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_system_ptime) == 0x138, "ks_rusage_info_v6.ri_system_ptime offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_pinstructions) == 0x140, "ks_rusage_info_v6.ri_pinstructions offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_pcycles) == 0x148, "ks_rusage_info_v6.ri_pcycles offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_energy_nj) == 0x150, "ks_rusage_info_v6.ri_energy_nj offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_penergy_nj) == 0x158, "ks_rusage_info_v6.ri_penergy_nj offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_secure_time_in_system) == 0x160, "ks_rusage_info_v6.ri_secure_time_in_system offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_secure_ptime_in_system) == 0x168, "ks_rusage_info_v6.ri_secure_ptime_in_system offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_neural_footprint) == 0x170, "ks_rusage_info_v6.ri_neural_footprint offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_lifetime_max_neural_footprint) == 0x178, "ks_rusage_info_v6.ri_lifetime_max_neural_footprint offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_interval_max_neural_footprint) == 0x180, "ks_rusage_info_v6.ri_interval_max_neural_footprint offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_reserved) == 0x188, "ks_rusage_info_v6.ri_reserved offset");

struct ks_rusage_superset {
    struct ks_rusage ru;
    struct ks_rusage_info_v6 ri;
};
_Static_assert(offsetof(struct ks_rusage_superset, ru) == 0x0, "ks_rusage_superset.ru offset");
_Static_assert(offsetof(struct ks_rusage_superset, ri) == 0x90, "ks_rusage_superset.ri offset");

struct ks_uthread_uu_list {
    struct ks_uthread *tqe_next;
    struct ks_uthread **tqe_prev;
};
_Static_assert(offsetof(struct ks_uthread_uu_list, tqe_next) == 0x0, "ks_uthread_uu_list.tqe_next offset");
_Static_assert(offsetof(struct ks_uthread_uu_list, tqe_prev) == 0x8, "ks_uthread_uu_list.tqe_prev offset");

struct ks_uthread_uu_throttlelist {
    struct ks_uthread *tqe_next;
    struct ks_uthread **tqe_prev;
};
_Static_assert(offsetof(struct ks_uthread_uu_throttlelist, tqe_next) == 0x0, "ks_uthread_uu_throttlelist.tqe_next offset");
_Static_assert(offsetof(struct ks_uthread_uu_throttlelist, tqe_prev) == 0x8, "ks_uthread_uu_throttlelist.tqe_prev offset");

struct ks_uthread_uu_workq_entry {
    struct ks_uthread *tqe_next;
    struct ks_uthread **tqe_prev;
};
_Static_assert(offsetof(struct ks_uthread_uu_workq_entry, tqe_next) == 0x0, "ks_uthread_uu_workq_entry.tqe_next offset");
_Static_assert(offsetof(struct ks_uthread_uu_workq_entry, tqe_prev) == 0x8, "ks_uthread_uu_workq_entry.tqe_prev offset");

struct ks_uu_workq_policy {
    unsigned short qos_req : 4; /* bit offset 0 */
    unsigned short qos_max : 4; /* bit offset 4 */
    unsigned short qos_override : 4; /* bit offset 8 */
    unsigned short qos_bucket : 4; /* bit offset 12 */
};

union ks___tdu {
    struct ks___tds _tds;
    unsigned int _t_dtrace_ft;
};
_Static_assert(offsetof(union ks___tdu, _tds) == 0x0, "ks___tdu._tds offset");
_Static_assert(offsetof(union ks___tdu, _t_dtrace_ft) == 0x0, "ks___tdu._t_dtrace_ft offset");

union ks_uthread_uu_save {
    struct ks__select_data uus_select_data;
    struct ks_kevent_ctx_s uus_kevent;
    struct ks__kevent_register uus_kevent_register;
    struct ks__kauth uus_kauth;
    struct ks_ksyn_waitq_element uus_kwe;
    struct ks__waitid_data uus_waitid_data;
    struct ks__wait4_data uus_wait4_data;
    struct ks__workq_park_data uus_workq_park_data;
    struct ks__ulock_wait_data uus_ulock_wait_data;
    struct ks__bsdthread_terminate uus_bsdthread_terminate;
    struct ks__exec_data uus_exec_data;
};
_Static_assert(offsetof(union ks_uthread_uu_save, uus_select_data) == 0x0, "ks_uthread_uu_save.uus_select_data offset");
_Static_assert(offsetof(union ks_uthread_uu_save, uus_kevent) == 0x0, "ks_uthread_uu_save.uus_kevent offset");
_Static_assert(offsetof(union ks_uthread_uu_save, uus_kevent_register) == 0x0, "ks_uthread_uu_save.uus_kevent_register offset");
_Static_assert(offsetof(union ks_uthread_uu_save, uus_kauth) == 0x0, "ks_uthread_uu_save.uus_kauth offset");
_Static_assert(offsetof(union ks_uthread_uu_save, uus_kwe) == 0x0, "ks_uthread_uu_save.uus_kwe offset");
_Static_assert(offsetof(union ks_uthread_uu_save, uus_waitid_data) == 0x0, "ks_uthread_uu_save.uus_waitid_data offset");
_Static_assert(offsetof(union ks_uthread_uu_save, uus_wait4_data) == 0x0, "ks_uthread_uu_save.uus_wait4_data offset");
_Static_assert(offsetof(union ks_uthread_uu_save, uus_workq_park_data) == 0x0, "ks_uthread_uu_save.uus_workq_park_data offset");
_Static_assert(offsetof(union ks_uthread_uu_save, uus_ulock_wait_data) == 0x0, "ks_uthread_uu_save.uus_ulock_wait_data offset");
_Static_assert(offsetof(union ks_uthread_uu_save, uus_bsdthread_terminate) == 0x0, "ks_uthread_uu_save.uus_bsdthread_terminate offset");
_Static_assert(offsetof(union ks_uthread_uu_save, uus_exec_data) == 0x0, "ks_uthread_uu_save.uus_exec_data offset");

struct ks_uthread {
    unsigned long long uu_arg[8];
    int uu_rval[2];
    char uu_cursig;
    _Bool uu_workq_pthread_kill_allowed;
    unsigned short syscall_code;
    int uu_exception;
    long long uu_code;
    long long uu_subcode;
    union ks_uthread_uu_save uu_save;
    struct ks__select uu_select;
    void *uu_userstate;
    struct ks_select_set *uu_selset;
    int uu_flag;
    unsigned int uu_siglist;
    unsigned int uu_sigwait;
    unsigned int uu_sigmask;
    unsigned int uu_oldmask;
    unsigned long long uu_sigreturn_token;
    unsigned int uu_sigreturn_diversifier;
    int uu_pending_sigreturn;
    struct ks_uthread_uu_list uu_list;
    struct ks_kaudit_record *uu_ar;
    struct ks_task *uu_aio_task;
    union {
        struct ks_lck_mtx_t *uu_mtx;
        struct ks_knote_lock_ctx *uu_knlock;
    };
    struct ks_lck_spin_t uu_rethrottle_lock;
    struct ks_uthread_uu_throttlelist uu_throttlelist;
    void *uu_throttle_info;
    signed char uu_on_throttlelist;
    _Bool uu_lowpri_window;
    _Bool uu_was_rethrottled;
    _Bool uu_is_throttled;
    _Bool uu_throttle_bc;
    _Bool uu_defer_reclaims;
    unsigned short uu_pri;
    char *uu_wchan;
    int *uu_continuation;
    const char *uu_wmesg;
    struct ks_kern_sigaltstack uu_sigstk;
    struct ks_vnode *uu_vreclaims;
    struct ks_vnode *uu_cdir;
    int uu_dupfd;
    unsigned int uu_network_marks;
    struct ks_workq_threadreq_s *uu_kqr_bound;
    struct ks_uthread_uu_workq_entry uu_workq_entry;
    unsigned long uu_workq_stackaddr;
    unsigned int uu_workq_thport;
    struct ks_uu_workq_policy uu_workq_pri;
    unsigned short uu_workq_flags;
    unsigned char uu_kqueue_override;
    int uu_proc_refcount;
    unsigned int t_dtrace_errno;
    struct ks___siginfo t_dtrace_siginfo;
    unsigned long long t_dtrace_resumepid;
    unsigned char t_dtrace_stop;
    unsigned char t_dtrace_sig;
    union ks___tdu _tdu;
    unsigned long long t_dtrace_pc;
    unsigned long long t_dtrace_npc;
    unsigned long long t_dtrace_scrpc;
    unsigned long long t_dtrace_astpc;
    struct ks_dtrace_ptss_page_entry *t_dtrace_scratch;
    unsigned long long t_dtrace_regv;
    void *t_dtrace_syscall_args;
    char *pth_name;
    struct ks_doc_tombstone *t_tombstone;
    unsigned long long t_fs_private;
    struct ks_os_reason *uu_exit_reason;
};
_Static_assert(offsetof(struct ks_uthread, uu_arg) == 0x0, "ks_uthread.uu_arg offset");
_Static_assert(offsetof(struct ks_uthread, uu_rval) == 0x40, "ks_uthread.uu_rval offset");
_Static_assert(offsetof(struct ks_uthread, uu_cursig) == 0x48, "ks_uthread.uu_cursig offset");
_Static_assert(offsetof(struct ks_uthread, uu_workq_pthread_kill_allowed) == 0x49, "ks_uthread.uu_workq_pthread_kill_allowed offset");
_Static_assert(offsetof(struct ks_uthread, syscall_code) == 0x4a, "ks_uthread.syscall_code offset");
_Static_assert(offsetof(struct ks_uthread, uu_exception) == 0x4c, "ks_uthread.uu_exception offset");
_Static_assert(offsetof(struct ks_uthread, uu_code) == 0x50, "ks_uthread.uu_code offset");
_Static_assert(offsetof(struct ks_uthread, uu_subcode) == 0x58, "ks_uthread.uu_subcode offset");
_Static_assert(offsetof(struct ks_uthread, uu_save) == 0x60, "ks_uthread.uu_save offset");
_Static_assert(offsetof(struct ks_uthread, uu_select) == 0xc8, "ks_uthread.uu_select offset");
_Static_assert(offsetof(struct ks_uthread, uu_userstate) == 0xe0, "ks_uthread.uu_userstate offset");
_Static_assert(offsetof(struct ks_uthread, uu_selset) == 0xe8, "ks_uthread.uu_selset offset");
_Static_assert(offsetof(struct ks_uthread, uu_flag) == 0xf0, "ks_uthread.uu_flag offset");
_Static_assert(offsetof(struct ks_uthread, uu_siglist) == 0xf4, "ks_uthread.uu_siglist offset");
_Static_assert(offsetof(struct ks_uthread, uu_sigwait) == 0xf8, "ks_uthread.uu_sigwait offset");
_Static_assert(offsetof(struct ks_uthread, uu_sigmask) == 0xfc, "ks_uthread.uu_sigmask offset");
_Static_assert(offsetof(struct ks_uthread, uu_oldmask) == 0x100, "ks_uthread.uu_oldmask offset");
_Static_assert(offsetof(struct ks_uthread, uu_sigreturn_token) == 0x108, "ks_uthread.uu_sigreturn_token offset");
_Static_assert(offsetof(struct ks_uthread, uu_sigreturn_diversifier) == 0x110, "ks_uthread.uu_sigreturn_diversifier offset");
_Static_assert(offsetof(struct ks_uthread, uu_pending_sigreturn) == 0x114, "ks_uthread.uu_pending_sigreturn offset");
_Static_assert(offsetof(struct ks_uthread, uu_list) == 0x118, "ks_uthread.uu_list offset");
_Static_assert(offsetof(struct ks_uthread, uu_ar) == 0x128, "ks_uthread.uu_ar offset");
_Static_assert(offsetof(struct ks_uthread, uu_aio_task) == 0x130, "ks_uthread.uu_aio_task offset");
_Static_assert(offsetof(struct ks_uthread, uu_rethrottle_lock) == 0x140, "ks_uthread.uu_rethrottle_lock offset");
_Static_assert(offsetof(struct ks_uthread, uu_throttlelist) == 0x150, "ks_uthread.uu_throttlelist offset");
_Static_assert(offsetof(struct ks_uthread, uu_throttle_info) == 0x160, "ks_uthread.uu_throttle_info offset");
_Static_assert(offsetof(struct ks_uthread, uu_on_throttlelist) == 0x168, "ks_uthread.uu_on_throttlelist offset");
_Static_assert(offsetof(struct ks_uthread, uu_lowpri_window) == 0x169, "ks_uthread.uu_lowpri_window offset");
_Static_assert(offsetof(struct ks_uthread, uu_was_rethrottled) == 0x16a, "ks_uthread.uu_was_rethrottled offset");
_Static_assert(offsetof(struct ks_uthread, uu_is_throttled) == 0x16b, "ks_uthread.uu_is_throttled offset");
_Static_assert(offsetof(struct ks_uthread, uu_throttle_bc) == 0x16c, "ks_uthread.uu_throttle_bc offset");
_Static_assert(offsetof(struct ks_uthread, uu_defer_reclaims) == 0x16d, "ks_uthread.uu_defer_reclaims offset");
_Static_assert(offsetof(struct ks_uthread, uu_pri) == 0x16e, "ks_uthread.uu_pri offset");
_Static_assert(offsetof(struct ks_uthread, uu_wchan) == 0x170, "ks_uthread.uu_wchan offset");
_Static_assert(offsetof(struct ks_uthread, uu_continuation) == 0x178, "ks_uthread.uu_continuation offset");
_Static_assert(offsetof(struct ks_uthread, uu_wmesg) == 0x180, "ks_uthread.uu_wmesg offset");
_Static_assert(offsetof(struct ks_uthread, uu_sigstk) == 0x188, "ks_uthread.uu_sigstk offset");
_Static_assert(offsetof(struct ks_uthread, uu_vreclaims) == 0x1a0, "ks_uthread.uu_vreclaims offset");
_Static_assert(offsetof(struct ks_uthread, uu_cdir) == 0x1a8, "ks_uthread.uu_cdir offset");
_Static_assert(offsetof(struct ks_uthread, uu_dupfd) == 0x1b0, "ks_uthread.uu_dupfd offset");
_Static_assert(offsetof(struct ks_uthread, uu_network_marks) == 0x1b4, "ks_uthread.uu_network_marks offset");
_Static_assert(offsetof(struct ks_uthread, uu_kqr_bound) == 0x1b8, "ks_uthread.uu_kqr_bound offset");
_Static_assert(offsetof(struct ks_uthread, uu_workq_entry) == 0x1c0, "ks_uthread.uu_workq_entry offset");
_Static_assert(offsetof(struct ks_uthread, uu_workq_stackaddr) == 0x1d0, "ks_uthread.uu_workq_stackaddr offset");
_Static_assert(offsetof(struct ks_uthread, uu_workq_thport) == 0x1d8, "ks_uthread.uu_workq_thport offset");
_Static_assert(offsetof(struct ks_uthread, uu_workq_pri) == 0x1dc, "ks_uthread.uu_workq_pri offset");
_Static_assert(offsetof(struct ks_uthread, uu_workq_flags) == 0x1de, "ks_uthread.uu_workq_flags offset");
_Static_assert(offsetof(struct ks_uthread, uu_kqueue_override) == 0x1e0, "ks_uthread.uu_kqueue_override offset");
_Static_assert(offsetof(struct ks_uthread, uu_proc_refcount) == 0x1e4, "ks_uthread.uu_proc_refcount offset");
_Static_assert(offsetof(struct ks_uthread, t_dtrace_errno) == 0x1e8, "ks_uthread.t_dtrace_errno offset");
_Static_assert(offsetof(struct ks_uthread, t_dtrace_siginfo) == 0x1f0, "ks_uthread.t_dtrace_siginfo offset");
_Static_assert(offsetof(struct ks_uthread, t_dtrace_resumepid) == 0x258, "ks_uthread.t_dtrace_resumepid offset");
_Static_assert(offsetof(struct ks_uthread, t_dtrace_stop) == 0x260, "ks_uthread.t_dtrace_stop offset");
_Static_assert(offsetof(struct ks_uthread, t_dtrace_sig) == 0x261, "ks_uthread.t_dtrace_sig offset");
_Static_assert(offsetof(struct ks_uthread, _tdu) == 0x264, "ks_uthread._tdu offset");
_Static_assert(offsetof(struct ks_uthread, t_dtrace_pc) == 0x270, "ks_uthread.t_dtrace_pc offset");
_Static_assert(offsetof(struct ks_uthread, t_dtrace_npc) == 0x278, "ks_uthread.t_dtrace_npc offset");
_Static_assert(offsetof(struct ks_uthread, t_dtrace_scrpc) == 0x280, "ks_uthread.t_dtrace_scrpc offset");
_Static_assert(offsetof(struct ks_uthread, t_dtrace_astpc) == 0x288, "ks_uthread.t_dtrace_astpc offset");
_Static_assert(offsetof(struct ks_uthread, t_dtrace_scratch) == 0x290, "ks_uthread.t_dtrace_scratch offset");
_Static_assert(offsetof(struct ks_uthread, t_dtrace_regv) == 0x298, "ks_uthread.t_dtrace_regv offset");
_Static_assert(offsetof(struct ks_uthread, t_dtrace_syscall_args) == 0x2a0, "ks_uthread.t_dtrace_syscall_args offset");
_Static_assert(offsetof(struct ks_uthread, pth_name) == 0x2a8, "ks_uthread.pth_name offset");
_Static_assert(offsetof(struct ks_uthread, t_tombstone) == 0x2b0, "ks_uthread.t_tombstone offset");
_Static_assert(offsetof(struct ks_uthread, t_fs_private) == 0x2b8, "ks_uthread.t_fs_private offset");
_Static_assert(offsetof(struct ks_uthread, uu_exit_reason) == 0x2c0, "ks_uthread.uu_exit_reason offset");
_Static_assert(offsetof(struct ks_uthread, uu_mtx) == 0x138, "ks_uthread.uu_mtx offset");
_Static_assert(offsetof(struct ks_uthread, uu_knlock) == 0x138, "ks_uthread.uu_knlock offset");

struct ks_vnode_v_freelist {
    struct ks_vnode *tqe_next;
    struct ks_vnode **tqe_prev;
};
_Static_assert(offsetof(struct ks_vnode_v_freelist, tqe_next) == 0x0, "ks_vnode_v_freelist.tqe_next offset");
_Static_assert(offsetof(struct ks_vnode_v_freelist, tqe_prev) == 0x8, "ks_vnode_v_freelist.tqe_prev offset");

struct ks_vnode_v_mntvnodes {
    struct ks_vnode *tqe_next;
    struct ks_vnode **tqe_prev;
};
_Static_assert(offsetof(struct ks_vnode_v_mntvnodes, tqe_next) == 0x0, "ks_vnode_v_mntvnodes.tqe_next offset");
_Static_assert(offsetof(struct ks_vnode_v_mntvnodes, tqe_prev) == 0x8, "ks_vnode_v_mntvnodes.tqe_prev offset");

struct ks_vnode_v_ncchildren {
    struct ks_namecache *tqh_first;
    struct ks_namecache **tqh_last;
};
_Static_assert(offsetof(struct ks_vnode_v_ncchildren, tqh_first) == 0x0, "ks_vnode_v_ncchildren.tqh_first offset");
_Static_assert(offsetof(struct ks_vnode_v_ncchildren, tqh_last) == 0x8, "ks_vnode_v_ncchildren.tqh_last offset");

struct ks_vnode_v_nclinks {
    struct ks_namecache *lh_first;
};
_Static_assert(offsetof(struct ks_vnode_v_nclinks, lh_first) == 0x0, "ks_vnode_v_nclinks.lh_first offset");

union ks_vnode_v_un {
    struct ks_mount *vu_mountedhere;
    struct ks_socket *vu_socket;
    struct ks_specinfo *vu_specinfo;
    struct ks_fifoinfo *vu_fifoinfo;
    struct ks_ubc_info *vu_ubcinfo;
};
_Static_assert(offsetof(union ks_vnode_v_un, vu_mountedhere) == 0x0, "ks_vnode_v_un.vu_mountedhere offset");
_Static_assert(offsetof(union ks_vnode_v_un, vu_socket) == 0x0, "ks_vnode_v_un.vu_socket offset");
_Static_assert(offsetof(union ks_vnode_v_un, vu_specinfo) == 0x0, "ks_vnode_v_un.vu_specinfo offset");
_Static_assert(offsetof(union ks_vnode_v_un, vu_fifoinfo) == 0x0, "ks_vnode_v_un.vu_fifoinfo offset");
_Static_assert(offsetof(union ks_vnode_v_un, vu_ubcinfo) == 0x0, "ks_vnode_v_un.vu_ubcinfo offset");

struct ks_vnode {
    struct ks_lck_mtx_t v_lock;
    struct ks_vnode_v_freelist v_freelist;
    struct ks_vnode_v_mntvnodes v_mntvnodes;
    struct ks_vnode_v_ncchildren v_ncchildren;
    struct ks_vnode_v_nclinks v_nclinks;
    struct ks_vnode *v_defer_reclaimlist;
    unsigned int v_listflag;
    unsigned int v_flag;
    unsigned short v_lflag;
    unsigned char v_iterblkflags;
    unsigned char v_references;
    int v_kusecount;
    int v_usecount;
    int v_iocount;
    void *v_owner;
    unsigned char v_ext_flag;
    unsigned char v_type;
    unsigned short v_tag;
    unsigned int v_id;
    union ks_vnode_v_un v_un;
    struct ks_buflists v_cleanblkhd;
    struct ks_buflists v_dirtyblkhd;
    struct ks_klist v_knotes;
    struct ks_ucred *v_cred;
    int v_authorized_actions;
    int v_cred_timestamp;
    int v_nc_generation;
    int v_numoutput;
    int v_writecount;
    unsigned int v_holdcount;
    const char *v_name;
    struct ks_vnode *v_parent;
    struct ks_lockf *v_lockf;
    int **v_op;
    struct ks_mount *v_mount;
    void *v_data;
    struct ks_label *v_label;
    struct ks_vnode_resolve *v_resolve;
    struct ks_vnode *v_fmlink;
    struct ks_fl_head v_leases;
};
_Static_assert(offsetof(struct ks_vnode, v_lock) == 0x0, "ks_vnode.v_lock offset");
_Static_assert(offsetof(struct ks_vnode, v_freelist) == 0x10, "ks_vnode.v_freelist offset");
_Static_assert(offsetof(struct ks_vnode, v_mntvnodes) == 0x20, "ks_vnode.v_mntvnodes offset");
_Static_assert(offsetof(struct ks_vnode, v_ncchildren) == 0x30, "ks_vnode.v_ncchildren offset");
_Static_assert(offsetof(struct ks_vnode, v_nclinks) == 0x40, "ks_vnode.v_nclinks offset");
_Static_assert(offsetof(struct ks_vnode, v_defer_reclaimlist) == 0x48, "ks_vnode.v_defer_reclaimlist offset");
_Static_assert(offsetof(struct ks_vnode, v_listflag) == 0x50, "ks_vnode.v_listflag offset");
_Static_assert(offsetof(struct ks_vnode, v_flag) == 0x54, "ks_vnode.v_flag offset");
_Static_assert(offsetof(struct ks_vnode, v_lflag) == 0x58, "ks_vnode.v_lflag offset");
_Static_assert(offsetof(struct ks_vnode, v_iterblkflags) == 0x5a, "ks_vnode.v_iterblkflags offset");
_Static_assert(offsetof(struct ks_vnode, v_references) == 0x5b, "ks_vnode.v_references offset");
_Static_assert(offsetof(struct ks_vnode, v_kusecount) == 0x5c, "ks_vnode.v_kusecount offset");
_Static_assert(offsetof(struct ks_vnode, v_usecount) == 0x60, "ks_vnode.v_usecount offset");
_Static_assert(offsetof(struct ks_vnode, v_iocount) == 0x64, "ks_vnode.v_iocount offset");
_Static_assert(offsetof(struct ks_vnode, v_owner) == 0x68, "ks_vnode.v_owner offset");
_Static_assert(offsetof(struct ks_vnode, v_ext_flag) == 0x70, "ks_vnode.v_ext_flag offset");
_Static_assert(offsetof(struct ks_vnode, v_type) == 0x71, "ks_vnode.v_type offset");
_Static_assert(offsetof(struct ks_vnode, v_tag) == 0x72, "ks_vnode.v_tag offset");
_Static_assert(offsetof(struct ks_vnode, v_id) == 0x74, "ks_vnode.v_id offset");
_Static_assert(offsetof(struct ks_vnode, v_un) == 0x78, "ks_vnode.v_un offset");
_Static_assert(offsetof(struct ks_vnode, v_cleanblkhd) == 0x80, "ks_vnode.v_cleanblkhd offset");
_Static_assert(offsetof(struct ks_vnode, v_dirtyblkhd) == 0x88, "ks_vnode.v_dirtyblkhd offset");
_Static_assert(offsetof(struct ks_vnode, v_knotes) == 0x90, "ks_vnode.v_knotes offset");
_Static_assert(offsetof(struct ks_vnode, v_cred) == 0x98, "ks_vnode.v_cred offset");
_Static_assert(offsetof(struct ks_vnode, v_authorized_actions) == 0xa0, "ks_vnode.v_authorized_actions offset");
_Static_assert(offsetof(struct ks_vnode, v_cred_timestamp) == 0xa4, "ks_vnode.v_cred_timestamp offset");
_Static_assert(offsetof(struct ks_vnode, v_nc_generation) == 0xa8, "ks_vnode.v_nc_generation offset");
_Static_assert(offsetof(struct ks_vnode, v_numoutput) == 0xac, "ks_vnode.v_numoutput offset");
_Static_assert(offsetof(struct ks_vnode, v_writecount) == 0xb0, "ks_vnode.v_writecount offset");
_Static_assert(offsetof(struct ks_vnode, v_holdcount) == 0xb4, "ks_vnode.v_holdcount offset");
_Static_assert(offsetof(struct ks_vnode, v_name) == 0xb8, "ks_vnode.v_name offset");
_Static_assert(offsetof(struct ks_vnode, v_parent) == 0xc0, "ks_vnode.v_parent offset");
_Static_assert(offsetof(struct ks_vnode, v_lockf) == 0xc8, "ks_vnode.v_lockf offset");
_Static_assert(offsetof(struct ks_vnode, v_op) == 0xd0, "ks_vnode.v_op offset");
_Static_assert(offsetof(struct ks_vnode, v_mount) == 0xd8, "ks_vnode.v_mount offset");
_Static_assert(offsetof(struct ks_vnode, v_data) == 0xe0, "ks_vnode.v_data offset");
_Static_assert(offsetof(struct ks_vnode, v_label) == 0xe8, "ks_vnode.v_label offset");
_Static_assert(offsetof(struct ks_vnode, v_resolve) == 0xf0, "ks_vnode.v_resolve offset");
_Static_assert(offsetof(struct ks_vnode, v_fmlink) == 0xf8, "ks_vnode.v_fmlink offset");
_Static_assert(offsetof(struct ks_vnode, v_leases) == 0x100, "ks_vnode.v_leases offset");

struct ks_workq_aio_s_wa_aioq_entries {
    struct ks_aio_workq_entry *tqh_first;
    struct ks_aio_workq_entry **tqh_last;
};
_Static_assert(offsetof(struct ks_workq_aio_s_wa_aioq_entries, tqh_first) == 0x0, "ks_workq_aio_s_wa_aioq_entries.tqh_first offset");
_Static_assert(offsetof(struct ks_workq_aio_s_wa_aioq_entries, tqh_last) == 0x8, "ks_workq_aio_s_wa_aioq_entries.tqh_last offset");

struct ks_workq_aio_uthread_head {
    struct ks_uthread *tqh_first;
    struct ks_uthread **tqh_last;
};
_Static_assert(offsetof(struct ks_workq_aio_uthread_head, tqh_first) == 0x0, "ks_workq_aio_uthread_head.tqh_first offset");
_Static_assert(offsetof(struct ks_workq_aio_uthread_head, tqh_last) == 0x8, "ks_workq_aio_uthread_head.tqh_last offset");

struct ks_workq_aio_s {
    struct ks_thread_call *wa_death_call;
    struct ks_workq_aio_uthread_head wa_thrunlist;
    struct ks_workq_aio_uthread_head wa_thidlelist;
    struct ks_workq_aio_s_wa_aioq_entries wa_aioq_entries;
    struct ks_proc *wa_proc;
    unsigned int wa_flags;
    unsigned short wa_nthreads;
    unsigned short wa_thidlecount;
    unsigned short wa_thdying_count;
};
_Static_assert(offsetof(struct ks_workq_aio_s, wa_death_call) == 0x0, "ks_workq_aio_s.wa_death_call offset");
_Static_assert(offsetof(struct ks_workq_aio_s, wa_thrunlist) == 0x8, "ks_workq_aio_s.wa_thrunlist offset");
_Static_assert(offsetof(struct ks_workq_aio_s, wa_thidlelist) == 0x18, "ks_workq_aio_s.wa_thidlelist offset");
_Static_assert(offsetof(struct ks_workq_aio_s, wa_aioq_entries) == 0x28, "ks_workq_aio_s.wa_aioq_entries offset");
_Static_assert(offsetof(struct ks_workq_aio_s, wa_proc) == 0x38, "ks_workq_aio_s.wa_proc offset");
_Static_assert(offsetof(struct ks_workq_aio_s, wa_flags) == 0x40, "ks_workq_aio_s.wa_flags offset");
_Static_assert(offsetof(struct ks_workq_aio_s, wa_nthreads) == 0x44, "ks_workq_aio_s.wa_nthreads offset");
_Static_assert(offsetof(struct ks_workq_aio_s, wa_thidlecount) == 0x46, "ks_workq_aio_s.wa_thidlecount offset");
_Static_assert(offsetof(struct ks_workq_aio_s, wa_thdying_count) == 0x48, "ks_workq_aio_s.wa_thdying_count offset");

struct ks_workq_threadreq_tailq {
    struct ks_workq_threadreq_s *stqh_first;
    struct ks_workq_threadreq_s **stqh_last;
};
_Static_assert(offsetof(struct ks_workq_threadreq_tailq, stqh_first) == 0x0, "ks_workq_threadreq_tailq.stqh_first offset");
_Static_assert(offsetof(struct ks_workq_threadreq_tailq, stqh_last) == 0x8, "ks_workq_threadreq_tailq.stqh_last offset");

struct ks_workq_uthread_head {
    struct ks_uthread *tqh_first;
    struct ks_uthread **tqh_last;
};
_Static_assert(offsetof(struct ks_workq_uthread_head, tqh_first) == 0x0, "ks_workq_uthread_head.tqh_first offset");
_Static_assert(offsetof(struct ks_workq_uthread_head, tqh_last) == 0x8, "ks_workq_uthread_head.tqh_last offset");

struct ks_workqueue {
    struct ks_thread_call *wq_delayed_call;
    struct ks_thread_call *wq_immediate_call;
    struct ks_thread_call *wq_death_call;
    union {
        struct ks_turnstile *wq_turnstile;
        struct ks_mpsc_queue_chain wq_destroy_link;
    };
    struct ks_lck_ticket_t wq_lock;
    unsigned long long wq_thread_call_last_run;
    struct ks_os_refcnt wq_refcnt;
    unsigned int wq_flags;
    unsigned int wq_fulfilled;
    unsigned int wq_creations;
    unsigned int wq_timer_interval;
    unsigned int wq_event_manager_priority;
    unsigned int wq_reqcount;
    unsigned short wq_thdying_count;
    unsigned short wq_threads_scheduled;
    unsigned short wq_constrained_threads_scheduled;
    unsigned short wq_nthreads;
    unsigned short wq_thidlecount;
    unsigned short wq_thscheduled_count[7];
    struct ks_workq_threadreq_s *wq_event_manager_threadreq;
    unsigned __int128 wq_thactive;
    unsigned long long wq_lastblocked_ts[6];
    struct ks_proc *wq_proc;
    struct ks_uthread *wq_creator;
    void *wq_inheritor;
    struct ks_thread *wq_turnstile_updater;
    struct ks_workq_uthread_head wq_thrunlist;
    struct ks_workq_uthread_head wq_thnewlist;
    struct ks_workq_uthread_head wq_thidlelist;
    struct ks_priority_queue_sched_max wq_overcommit_queue;
    struct ks_priority_queue_sched_max wq_constrained_queue;
    struct ks_priority_queue_sched_max wq_special_queue;
    unsigned char wq_cooperative_queue_scheduled_count[6];
    unsigned short wq_cooperative_queue_best_req_qos : 3; /* bit offset 2416 */
    unsigned short wq_cooperative_queue_has_limited_max_size : 1; /* bit offset 2419 */
    unsigned short wq_exceeded_active_constrained_thread_limit : 1; /* bit offset 2420 */
    unsigned short unused : 11; /* bit offset 2421 */
    struct ks_workq_threadreq_tailq wq_cooperative_queue[6];
};
_Static_assert(offsetof(struct ks_workqueue, wq_delayed_call) == 0x0, "ks_workqueue.wq_delayed_call offset");
_Static_assert(offsetof(struct ks_workqueue, wq_immediate_call) == 0x8, "ks_workqueue.wq_immediate_call offset");
_Static_assert(offsetof(struct ks_workqueue, wq_death_call) == 0x10, "ks_workqueue.wq_death_call offset");
_Static_assert(offsetof(struct ks_workqueue, wq_lock) == 0x20, "ks_workqueue.wq_lock offset");
_Static_assert(offsetof(struct ks_workqueue, wq_thread_call_last_run) == 0x30, "ks_workqueue.wq_thread_call_last_run offset");
_Static_assert(offsetof(struct ks_workqueue, wq_refcnt) == 0x38, "ks_workqueue.wq_refcnt offset");
_Static_assert(offsetof(struct ks_workqueue, wq_flags) == 0x3c, "ks_workqueue.wq_flags offset");
_Static_assert(offsetof(struct ks_workqueue, wq_fulfilled) == 0x40, "ks_workqueue.wq_fulfilled offset");
_Static_assert(offsetof(struct ks_workqueue, wq_creations) == 0x44, "ks_workqueue.wq_creations offset");
_Static_assert(offsetof(struct ks_workqueue, wq_timer_interval) == 0x48, "ks_workqueue.wq_timer_interval offset");
_Static_assert(offsetof(struct ks_workqueue, wq_event_manager_priority) == 0x4c, "ks_workqueue.wq_event_manager_priority offset");
_Static_assert(offsetof(struct ks_workqueue, wq_reqcount) == 0x50, "ks_workqueue.wq_reqcount offset");
_Static_assert(offsetof(struct ks_workqueue, wq_thdying_count) == 0x54, "ks_workqueue.wq_thdying_count offset");
_Static_assert(offsetof(struct ks_workqueue, wq_threads_scheduled) == 0x56, "ks_workqueue.wq_threads_scheduled offset");
_Static_assert(offsetof(struct ks_workqueue, wq_constrained_threads_scheduled) == 0x58, "ks_workqueue.wq_constrained_threads_scheduled offset");
_Static_assert(offsetof(struct ks_workqueue, wq_nthreads) == 0x5a, "ks_workqueue.wq_nthreads offset");
_Static_assert(offsetof(struct ks_workqueue, wq_thidlecount) == 0x5c, "ks_workqueue.wq_thidlecount offset");
_Static_assert(offsetof(struct ks_workqueue, wq_thscheduled_count) == 0x5e, "ks_workqueue.wq_thscheduled_count offset");
_Static_assert(offsetof(struct ks_workqueue, wq_event_manager_threadreq) == 0x70, "ks_workqueue.wq_event_manager_threadreq offset");
_Static_assert(offsetof(struct ks_workqueue, wq_thactive) == 0x80, "ks_workqueue.wq_thactive offset");
_Static_assert(offsetof(struct ks_workqueue, wq_lastblocked_ts) == 0x90, "ks_workqueue.wq_lastblocked_ts offset");
_Static_assert(offsetof(struct ks_workqueue, wq_proc) == 0xc0, "ks_workqueue.wq_proc offset");
_Static_assert(offsetof(struct ks_workqueue, wq_creator) == 0xc8, "ks_workqueue.wq_creator offset");
_Static_assert(offsetof(struct ks_workqueue, wq_inheritor) == 0xd0, "ks_workqueue.wq_inheritor offset");
_Static_assert(offsetof(struct ks_workqueue, wq_turnstile_updater) == 0xd8, "ks_workqueue.wq_turnstile_updater offset");
_Static_assert(offsetof(struct ks_workqueue, wq_thrunlist) == 0xe0, "ks_workqueue.wq_thrunlist offset");
_Static_assert(offsetof(struct ks_workqueue, wq_thnewlist) == 0xf0, "ks_workqueue.wq_thnewlist offset");
_Static_assert(offsetof(struct ks_workqueue, wq_thidlelist) == 0x100, "ks_workqueue.wq_thidlelist offset");
_Static_assert(offsetof(struct ks_workqueue, wq_overcommit_queue) == 0x110, "ks_workqueue.wq_overcommit_queue offset");
_Static_assert(offsetof(struct ks_workqueue, wq_constrained_queue) == 0x118, "ks_workqueue.wq_constrained_queue offset");
_Static_assert(offsetof(struct ks_workqueue, wq_special_queue) == 0x120, "ks_workqueue.wq_special_queue offset");
_Static_assert(offsetof(struct ks_workqueue, wq_cooperative_queue_scheduled_count) == 0x128, "ks_workqueue.wq_cooperative_queue_scheduled_count offset");
_Static_assert(offsetof(struct ks_workqueue, wq_cooperative_queue) == 0x130, "ks_workqueue.wq_cooperative_queue offset");
_Static_assert(offsetof(struct ks_workqueue, wq_turnstile) == 0x18, "ks_workqueue.wq_turnstile offset");
_Static_assert(offsetof(struct ks_workqueue, wq_destroy_link) == 0x18, "ks_workqueue.wq_destroy_link offset");

typedef unsigned char ks_Byte;
typedef unsigned char ks_Bytef;
typedef unsigned int ks___darwin_gid_t;
typedef unsigned int ks___darwin_natural_t;
typedef long long ks___darwin_off_t;
typedef int ks___darwin_pid_t;
typedef unsigned int ks___darwin_sigset_t;
typedef unsigned long ks___darwin_size_t;
typedef int ks___darwin_suseconds_t;
typedef long ks___darwin_time_t;
typedef unsigned int ks___darwin_uid_t;
typedef int ks___int32_t;
typedef long long ks___int64_t;
typedef struct ks___smrq_slink_t ks___smrq_slink_t;
typedef unsigned int ks___uint32_t;
typedef unsigned long long ks___uint64_t;
typedef unsigned int ks_aio_entry_flags_t;
typedef void **ks_alloc_func;
typedef struct ks_audit_token_t ks_audit_token_t;
typedef int ks_boolean_t;
typedef char *ks_caddr_t;
typedef char ks_command_t[17];
typedef int ks_cpu_subtype_t;
typedef int ks_cpu_type_t;
typedef struct ks_dof_helper ks_dof_helper_t;
typedef struct ks_dtrace_difv ks_dtrace_difv_t;
typedef struct ks_dtrace_dstate_percpu ks_dtrace_dstate_percpu_t;
typedef unsigned int ks_dtrace_dstate_state;
typedef unsigned int ks_dtrace_dstate_state_t;
typedef struct ks_dtrace_dstate ks_dtrace_dstate_t;
typedef struct ks_dtrace_dynhash ks_dtrace_dynhash_t;
typedef struct ks_dtrace_helper_action ks_dtrace_helper_action_t;
typedef struct ks_dtrace_helper_provider ks_dtrace_helper_provider_t;
typedef struct ks_dtrace_state ks_dtrace_state_t;
typedef struct ks_dtrace_statvar ks_dtrace_statvar_t;
typedef struct ks_dtrace_vstate ks_dtrace_vstate_t;
typedef int ks_errno_t;
typedef unsigned char ks_filedesc_flags_t;
typedef void *ks_free_func;
typedef unsigned int ks_gid_t;
typedef short ks_int16_t;
typedef int ks_int32_t;
typedef long long ks_int64_t;
typedef signed char ks_int8_t;
typedef int ks_integer_t;
typedef int ks_kauth_action_t;
typedef struct ks_ucred *ks_kauth_cred_t;
typedef unsigned long long ks_kcd_cd_flag_t;
typedef unsigned long long ks_kcd_compression_type_t;
typedef unsigned char ks_kq_index_t;
typedef unsigned short ks_kq_state_t;
typedef struct ks_lck_mtx_t ks_lck_mtx_t;
typedef struct ks_lck_rw_t ks_lck_rw_t;
typedef struct ks_lck_spin_t ks_lck_spin_t;
typedef struct ks_lck_ticket_t ks_lck_ticket_t;
typedef long long ks_mach_exception_code_t;
typedef long long ks_mach_exception_data_type_t;
typedef long long ks_mach_exception_subcode_t;
typedef unsigned int ks_mach_port_name_t;
typedef unsigned long long ks_mach_vm_address_t;
typedef struct ks_mount *ks_mount_t;
typedef unsigned int ks_natural_t;
typedef long long ks_off_t;
typedef unsigned int ks_os_ref_atomic_t;
typedef unsigned int ks_os_ref_count_t;
typedef struct ks_os_refcnt ks_os_refcnt_t;
typedef int ks_persona_type_t;
typedef int ks_pid_t;
typedef char ks_proc_name_t[33];
typedef struct ks_proc_ro *ks_proc_ro_t;
typedef struct ks_proc *ks_proc_t;
typedef unsigned long long ks_rlim_t;
typedef struct ks_rusage_info_v6 ks_rusage_info_current;
typedef struct ks_security_token_t ks_security_token_t;
typedef struct ks___siginfo ks_siginfo_t;
typedef unsigned int ks_sigset_t;
typedef unsigned long ks_size_t;
typedef void *ks_smr_cb_t;
typedef unsigned char ks_task_control_port_options_t;
typedef struct ks_thread_call *ks_thread_call_t;
typedef unsigned char ks_thread_qos_t;
typedef struct ks_thread *ks_thread_t;
typedef void *ks_turnstile_inheritor_t;
typedef unsigned int ks_uInt;
typedef unsigned long ks_uLong;
typedef unsigned char ks_u_char;
typedef unsigned int ks_u_int;
typedef unsigned short ks_u_int16_t;
typedef unsigned int ks_u_int32_t;
typedef unsigned long long ks_u_int64_t;
typedef unsigned char ks_u_int8_t;
typedef unsigned long ks_u_long;
typedef unsigned short ks_u_short;
typedef unsigned int ks_uid_t;
typedef unsigned int ks_uint;
typedef unsigned short ks_uint16_t;
typedef unsigned int ks_uint32_t;
typedef unsigned long long ks_uint64_t;
typedef unsigned char ks_uint8_t;
typedef unsigned int ks_uint_t;
typedef unsigned long ks_uintptr_t;
typedef unsigned long long ks_user_addr_t;
typedef unsigned long long ks_user_size_t;
typedef long long ks_user_ssize_t;
typedef unsigned long long ks_user_ulong_t;
typedef struct ks__vm_map *ks_vm_map_t;
typedef unsigned long ks_vm_offset_t;
typedef struct ks_vnode_resolve *ks_vnode_resolve_t;
typedef struct ks_vnode *ks_vnode_t;
typedef void *ks_voidpf;
typedef unsigned int ks_workq_state_flags_t;
typedef struct ks_workq_threadreq_s ks_workq_threadreq_s;
typedef struct ks_workq_threadreq_s *ks_workq_threadreq_t;
typedef unsigned char ks_workq_tr_flags_t;
typedef unsigned char ks_workq_tr_state_t;
typedef unsigned __int128 ks_wq_thactive_t;
typedef struct ks_z_stream_s ks_z_stream;

#endif
