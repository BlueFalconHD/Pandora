#ifndef KSTRUCTS_H
#define KSTRUCTS_H

// THESE ARE FOR T8112 (m2), kernel build specific (for some types), need regen for other device types

/*
 * Generated by kstructs
 * Types emitted: 1315/217006 types in source
 * Structs: 624, Unions: 19, Enums: 78, Typedefs: 594
 */
#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>

struct ks_CEAccelerationElement;
typedef struct ks_CEAccelerationElement ks_CEAccelerationElement;
struct ks_IOSKMapper;
typedef struct ks_IOSKMapper ks_IOSKMapper;
struct ks_IOSKRegion;
typedef struct ks_IOSKRegion ks_IOSKRegion;
struct ks___nx_stats_fsw;
typedef struct ks___nx_stats_fsw ks___nx_stats_fsw;
struct ks___user_channel_schema;
typedef struct ks___user_channel_schema ks___user_channel_schema;
struct ks_affinity_set;
typedef struct ks_affinity_set ks_affinity_set;
struct ks_arm_amx_saved_state;
typedef struct ks_arm_amx_saved_state ks_arm_amx_saved_state;
struct ks_arm_context;
typedef struct ks_arm_context ks_arm_context;
struct ks_arm_debug_aggregate_state;
typedef struct ks_arm_debug_aggregate_state ks_arm_debug_aggregate_state;
struct ks_arm_neon_saved_state;
typedef struct ks_arm_neon_saved_state ks_arm_neon_saved_state;
struct ks_arm_saved_state;
typedef struct ks_arm_saved_state ks_arm_saved_state;
struct ks_arm_state_hdr;
typedef struct ks_arm_state_hdr ks_arm_state_hdr;
struct ks_ch_info;
typedef struct ks_ch_info ks_ch_info;
struct ks_cpu_data;
typedef struct ks_cpu_data ks_cpu_data;
struct ks_flow_entry;
typedef struct ks_flow_entry ks_flow_entry;
struct ks_flow_mgr;
typedef struct ks_flow_mgr ks_flow_mgr;
struct ks_fsw_ip_frag_mgr;
typedef struct ks_fsw_ip_frag_mgr ks_fsw_ip_frag_mgr;
struct ks_io_stat_info;
typedef struct ks_io_stat_info ks_io_stat_info;
struct ks_ipc_voucher;
typedef struct ks_ipc_voucher ks_ipc_voucher;
struct ks_kern_nexus_netif_llink_qset_init;
typedef struct ks_kern_nexus_netif_llink_qset_init ks_kern_nexus_netif_llink_qset_init;
struct ks_kern_pbufpool_u_bft_bkt;
typedef struct ks_kern_pbufpool_u_bft_bkt ks_kern_pbufpool_u_bft_bkt;
struct ks_kern_pbufpool_u_bkt;
typedef struct ks_kern_pbufpool_u_bkt ks_kern_pbufpool_u_bkt;
struct ks_netif_flowtable_ops;
typedef struct ks_netif_flowtable_ops ks_netif_flowtable_ops;
struct ks_netif_qset;
typedef struct ks_netif_qset ks_netif_qset;
struct ks_nxctl;
typedef struct ks_nxctl ks_nxctl;
struct ks_nxprov_params;
typedef struct ks_nxprov_params ks_nxprov_params;
struct ks_pf_ruleset;
typedef struct ks_pf_ruleset ks_pf_ruleset;
struct ks_processor;
typedef struct ks_processor ks_processor;
struct ks_radix_node_head;
typedef struct ks_radix_node_head ks_radix_node_head;
struct ks_semaphore;
typedef struct ks_semaphore ks_semaphore;
struct ks_skmem_bufctl_bkt;
typedef struct ks_skmem_bufctl_bkt ks_skmem_bufctl_bkt;
struct ks_skmem_mag;
typedef struct ks_skmem_mag ks_skmem_mag;
struct ks_skmem_magtype;
typedef struct ks_skmem_magtype ks_skmem_magtype;
struct ks_skmem_slab;
typedef struct ks_skmem_slab ks_skmem_slab;
struct ks_sksegment;
typedef struct ks_sksegment ks_sksegment;
struct ks_sksegment_bkt;
typedef struct ks_sksegment_bkt ks_sksegment_bkt;
struct ks_smr_pcpu;
typedef struct ks_smr_pcpu ks_smr_pcpu;
struct ks_task_watcher;
typedef struct ks_task_watcher ks_task_watcher;
struct ks_thread_call_thread_state;
typedef struct ks_thread_call_thread_state ks_thread_call_thread_state;
struct ks_thread_qos_override;
typedef struct ks_thread_qos_override ks_thread_qos_override;
struct ks_thread_ro;
typedef struct ks_thread_ro ks_thread_ro;
struct ks_timer_call;
typedef struct ks_timer_call ks_timer_call;

enum {
    ks_kCEContextTypeEntitlements = 0,
    ks_kCEContextTypeProvisioningProfileEntitlements = 1,
    ks_kCEContextTypeProvisioningProfile = 2,
    ks_kCEContextTypeLWCR = 3,
    ks_kCEContextTypeTotal = 4,
};

enum {
    ks_kCSRestrictedModePermNever = 0,
    ks_kCSRestrictedModePermBefore = 1,
    ks_kCSRestrictedModePermAfter = 2,
    ks_kCSRestrictedModePermBoth = 3,
};

enum {
    ks___NO_LOSS = 0,
    ks_GAP_RX = 1,
    ks_GAP_LOSS = 2,
    ks_BURST_RX = 3,
    ks_BURST_LOSS = 4,
};

enum {
    ks_kTXMCodeRegionTypeExecutable = 0,
    ks_kTXMCodeRegionTypeSharedRegion = 1,
    ks_kTXMCodeRegionTypeJIT = 2,
    ks_kTXMCodeRegionTypeDebug = 3,
};

enum {
    ks_AIO_READ = 1,
    ks_AIO_WRITE = 2,
    ks_AIO_FSYNC = 4,
    ks_AIO_DSYNC = 8,
    ks_AIO_LIO = 0x10,
    ks_AIO_LIO_WAIT = 0x20,
    ks_AIO_COMPLETED = 0x100,
    ks_AIO_CANCELLED = 0x200,
    ks_AIO_CLOSE_WAIT = 0x4000,
    ks_AIO_EXIT_WAIT = 0x8000,
};

enum {
    ks_AST_PREEMPT = 1,
    ks_AST_QUANTUM = 2,
    ks_AST_URGENT = 4,
    ks_AST_HANDOFF = 8,
    ks_AST_YIELD = 0x10,
    ks_AST_APC = 0x20,
    ks_AST_LEDGER = 0x40,
    ks_AST_BSD = 0x80,
    ks_AST_KPERF = 0x100,
    ks_AST_MACF = 0x200,
    ks_AST_RESET_PCS = 0x400,
    ks_AST_ARCADE = 0x800,
    ks_AST_MACH_EXCEPTION = 0x1000,
    ks_AST_TELEMETRY_USER = 0x2000,
    ks_AST_TELEMETRY_KERNEL = 0x4000,
    ks_AST_TELEMETRY_PMI = 0x8000,
    ks_AST_SFI = 0x10000,
    ks_AST_DTRACE = 0x20000,
    ks_AST_TELEMETRY_IO = 0x40000,
    ks_AST_KEVENT = 0x80000,
    ks_AST_REBALANCE = 0x100000,
    ks_AST_PROC_RESOURCE = 0x400000,
    ks_AST_DEBUG_ASSERT = 0x800000,
    ks_AST_TELEMETRY_MACF = 0x1000000,
    ks_AST_SYNTHESIZE_MACH = 0x2000000,
};

enum {
    ks_CC_IMPL_UNKNOWN = 0,
    ks_CC_IMPL_SHA256_LTC = 1,
    ks_CC_IMPL_SHA256_VNG_ARM = 2,
    ks_CC_IMPL_SHA256_VNG_ARM64_NEON = 3,
    ks_CC_IMPL_SHA256_VNG_INTEL_SUPPLEMENTAL_SSE3 = 4,
    ks_CC_IMPL_SHA256_VNG_INTEL_AVX1 = 5,
    ks_CC_IMPL_SHA256_VNG_INTEL_AVX2 = 6,
    ks_CC_IMPL_AES_ECB_LTC = 11,
    ks_CC_IMPL_AES_ECB_ARM = 12,
    ks_CC_IMPL_AES_ECB_INTEL_OPT = 13,
    ks_CC_IMPL_AES_ECB_INTEL_AESNI = 14,
    ks_CC_IMPL_AES_ECB_SKG = 15,
    ks_CC_IMPL_AES_ECB_TRNG = 0x10,
    ks_CC_IMPL_AES_XTS_GENERIC = 0x15,
    ks_CC_IMPL_AES_XTS_ARM = 0x16,
    ks_CC_IMPL_AES_XTS_INTEL_OPT = 0x17,
    ks_CC_IMPL_AES_XTS_INTEL_AESNI = 0x18,
    ks_CC_IMPL_SHA1_LTC = 0x1F,
    ks_CC_IMPL_SHA1_VNG_ARM = 0x20,
    ks_CC_IMPL_SHA1_VNG_INTEL_SUPPLEMENTAL_SSE3 = 0x21,
    ks_CC_IMPL_SHA1_VNG_INTEL_AVX1 = 0x22,
    ks_CC_IMPL_SHA1_VNG_INTEL_AVX2 = 0x23,
    ks_CC_IMPL_SHA384_LTC = 0x29,
    ks_CC_IMPL_SHA384_VNG_ARM = 0x2A,
    ks_CC_IMPL_SHA384_VNG_INTEL_SUPPLEMENTAL_SSE3 = 0x2B,
    ks_CC_IMPL_SHA384_VNG_INTEL_AVX1 = 0x2C,
    ks_CC_IMPL_SHA384_VNG_INTEL_AVX2 = 0x2D,
    ks_CC_IMPL_SHA512_LTC = 0x33,
    ks_CC_IMPL_SHA512_VNG_ARM = 0x34,
    ks_CC_IMPL_SHA512_VNG_INTEL_SUPPLEMENTAL_SSE3 = 0x35,
    ks_CC_IMPL_SHA512_VNG_INTEL_AVX1 = 0x36,
    ks_CC_IMPL_SHA512_VNG_INTEL_AVX2 = 0x37,
};

enum {
    ks_CH_ENDPOINT_NULL = 0,
    ks_CH_ENDPOINT_USER_PIPE_MASTER = 1,
    ks_CH_ENDPOINT_USER_PIPE_SLAVE = 2,
    ks_CH_ENDPOINT_KERNEL_PIPE = 3,
    ks_CH_ENDPOINT_NET_IF = 4,
    ks_CH_ENDPOINT_FLOW_SWITCH = 5,
};

enum {
    ks_QP_INVALID = 0,
    ks_QP_MBUF = 1,
    ks_QP_PACKET = 2,
};

enum {
    ks_QS_RUNNING = 0,
    ks_QS_SUSPENDED = 1,
};

enum {
    ks_Q_DROPHEAD = 0,
    ks_Q_DROPTAIL = 1,
    ks_Q_SFB = 2,
};

enum {
    ks_CLUSTER_TYPE_INVALID = -1,
    ks_CLUSTER_TYPE_SMP = 0,
    ks_CLUSTER_TYPE_E = 1,
    ks_CLUSTER_TYPE_P = 2,
    ks_MAX_CPU_TYPES = 3,
};

enum {
    ks_PRIO_DARWIN_GPU_UNKNOWN = 0,
    ks_PRIO_DARWIN_GPU_ALLOW = 1,
    ks_PRIO_DARWIN_GPU_DENY = 2,
    ks_PRIO_DARWIN_GPU_BACKGROUND = 3,
    ks_PRIO_DARWIN_GPU_UTILITY = 4,
    ks_PRIO_DARWIN_GPU_UI_NON_FOCAL = 5,
    ks_PRIO_DARWIN_GPU_UI = 6,
    ks_PRIO_DARWIN_GPU_UI_FOCAL = 7,
};

enum {
    ks_DTRACE_ACTIVITY_INACTIVE = 0,
    ks_DTRACE_ACTIVITY_WARMUP = 1,
    ks_DTRACE_ACTIVITY_ACTIVE = 2,
    ks_DTRACE_ACTIVITY_DRAINING = 3,
    ks_DTRACE_ACTIVITY_COOLDOWN = 4,
    ks_DTRACE_ACTIVITY_STOPPED = 5,
    ks_DTRACE_ACTIVITY_KILLED = 6,
};

enum {
    ks_DTRACE_DSTATE_CLEAN = 0,
    ks_DTRACE_DSTATE_EMPTY = 1,
    ks_DTRACE_DSTATE_DIRTY = 2,
    ks_DTRACE_DSTATE_RINSING = 3,
};

enum {
    ks_DTRACESPEC_INACTIVE = 0,
    ks_DTRACESPEC_ACTIVE = 1,
    ks_DTRACESPEC_ACTIVEONE = 2,
    ks_DTRACESPEC_ACTIVEMANY = 3,
    ks_DTRACESPEC_COMMITTING = 4,
    ks_DTRACESPEC_COMMITTINGMANY = 5,
    ks_DTRACESPEC_DISCARDING = 6,
};

enum {
    ks_DTYPE_VNODE = 1,
    ks_DTYPE_SOCKET = 2,
    ks_DTYPE_PSXSHM = 3,
    ks_DTYPE_PSXSEM = 4,
    ks_DTYPE_KQUEUE = 5,
    ks_DTYPE_PIPE = 6,
    ks_DTYPE_FSEVENTS = 7,
    ks_DTYPE_ATALK = 8,
    ks_DTYPE_NETPOLICY = 9,
    ks_DTYPE_CHANNEL = 10,
    ks_DTYPE_NEXUS = 11,
};

enum {
    ks_FD_CHROOT = 1,
    ks_FD_WORKLOOP = 2,
};

enum {
    ks_FP_NONE = 0,
    ks_FP_CLOEXEC = 1,
    ks_FP_CLOFORK = 2,
    ks_FP_INSELECT = 4,
    ks_FP_AIOISSUED = 8,
    ks_FP_SELCONFLICT = 0x10,
};

enum {
    ks_FPV_NONE = 0,
    ks_FPV_DRAIN = 1,
};

enum {
    ks_FSW_TSO_MODE_NONE = 0,
    ks_FSW_TSO_MODE_HW = 1,
    ks_FSW_TSO_MODE_SW = 2,
};

enum {
    ks_P_ALL = 0,
    ks_P_PID = 1,
    ks_P_PGID = 2,
};

enum {
    ks_IF_INTERFACE_ADVISORY_DIRECTION_TX = 1,
    ks_IF_INTERFACE_ADVISORY_DIRECTION_RX = 2,
};

enum {
    ks_IF_INTERFACE_ADVISORY_INTERFACE_TYPE_WIFI = 1,
    ks_IF_INTERFACE_ADVISORY_INTERFACE_TYPE_MIN = 1,
    ks_IF_INTERFACE_ADVISORY_INTERFACE_TYPE_CELL = 2,
    ks_IF_INTERFACE_ADVISORY_INTERFACE_TYPE_MAX = 2,
};

enum {
    ks_IF_INTERFACE_ADVISORY_NOTIFICATION_TYPE_CELLULAR_DEFAULT = 0,
    ks_IF_INTERFACE_ADVISORY_NOTIFICATION_TYPE_CELLULAR_UPLINK_CRA = 1,
    ks_IF_INTERFACE_ADVISORY_NOTIFICATION_TYPE_CELLULAR_MEASUREMENT_UPDATE = 2,
    ks_IF_INTERFACE_ADVISORY_NOTIFICATION_TYPE_CELLULAR_BANDWIDTH_LIMITATION_EVENT = 3,
    ks_IF_INTERFACE_ADVISORY_NOTIFICATION_TYPE_CELLULAR_DISCONTINUOUS_RECEPTION_EVENT = 4,
    ks_IF_INTERFACE_ADVISORY_NOTIFICATION_TYPE_CELLULAR_OUTAGE_EVENT = 5,
    ks_IF_INTERFACE_ADVISORY_NOTIFICATION_TYPE_CELLULAR_THERMAL_CRA_EVENT = 6,
};

enum {
    ks_IF_INTERFACE_ADVISORY_NOTIFICATION_TYPE_WIFI_UNDEFINED = 0,
};

enum {
    ks_IF_INTERFACE_ADVISORY_RATE_SUGGESTION_RAMP_UP = 0x7FFFFFFF,
    ks_IF_INTERFACE_ADVISORY_RATE_SUGGESTION_RAMP_DOWN = -0x80000000,
    ks_IF_INTERFACE_ADVISORY_RATE_SUGGESTION_RAMP_NEUTRAL = 0,
};

enum {
    ks_IF_INTERFACE_ADVISORY_VERSION_1 = 1,
    ks_IF_INTERFACE_ADVISORY_VERSION_MIN = 1,
    ks_IF_INTERFACE_ADVISORY_VERSION_2 = 2,
    ks_IF_INTERFACE_ADVISORY_VERSION_CURRENT = 2,
    ks_IF_INTERFACE_ADVISORY_VERSION_MAX = 2,
};

enum {
    ks_IF_INTERFACE_ADVISORY_FREQ_BAND_NOT_AVAIL = 0,
    ks_IF_INTERFACE_ADVISORY_FREQ_BAND_WIFI_24GHZ = 1,
    ks_IF_INTERFACE_ADVISORY_FREQ_BAND_WIFI_5GHZ = 2,
    ks_IF_INTERFACE_ADVISORY_FREQ_BAND_WIFI_6GHZ = 3,
};

enum {
    ks_IKM_KEEP_ALIVE_NONE = 0,
    ks_IKM_KEEP_ALIVE_OWNED = 1,
    ks_IKM_KEEP_ALIVE_IN_USE = 2,
};

enum {
    ks_IKM_TYPE_ALL_INLINED = 0,
    ks_IKM_TYPE_UDATA_OOL = 1,
    ks_IKM_TYPE_KDATA_OOL = 2,
    ks_IKM_TYPE_ALL_OOL = 3,
};

enum {
    ks_IPC_OBJECT_COPYIN_FLAGS_NONE = 0,
    ks_IPC_OBJECT_COPYIN_FLAGS_ALLOW_IMMOVABLE_SEND = 1,
    ks_IPC_OBJECT_COPYIN_FLAGS_DEADOK = 2,
    ks_IPC_OBJECT_COPYIN_FLAGS_DEST_EXTRA_COPY = 4,
    ks_IPC_OBJECT_COPYIN_FLAGS_DEST_EXTRA_MOVE = 8,
};

enum {
    ks_IO_STATE_INACTIVE = 0,
    ks_IO_STATE_IN_SPACE = 1,
    ks_IO_STATE_IN_SPACE_IMMOVABLE = 2,
    ks_IO_STATE_IN_LIMBO = 3,
    ks_IO_STATE_IN_LIMBO_PD = 4,
    ks_IO_STATE_IN_TRANSIT = 5,
    ks_IO_STATE_IN_TRANSIT_PD = 6,
};

enum {
    ks_IOT_PORT_SET = 0,
    ks_IOT_PORT = 1,
    ks_IOT_SERVICE_PORT = 2,
    ks_IOT_BOOTSTRAP_PORT = 3,
    ks_IOT_WEAK_SERVICE_PORT = 4,
    ks_IOT_CONNECTION_PORT = 5,
    ks_IOT_CONNECTION_PORT_WITH_PORT_ARRAY = 6,
    ks_IOT_EXCEPTION_PORT = 7,
    ks_IOT_TIMER_PORT = 8,
    ks_IOT_REPLY_PORT = 9,
    ks_IOT_SPECIAL_REPLY_PORT = 10,
    ks_IOT_PROVISIONAL_REPLY_PORT = 11,
    ks___IKOT_FIRST = 12,
    ks_IKOT_THREAD_CONTROL = 12,
    ks_IKOT_THREAD_READ = 13,
    ks_IKOT_THREAD_INSPECT = 14,
    ks_IKOT_TASK_CONTROL = 15,
    ks_IKOT_TASK_READ = 0x10,
    ks_IKOT_TASK_INSPECT = 0x11,
    ks_IKOT_TASK_NAME = 0x12,
    ks_IKOT_TASK_RESUME = 0x13,
    ks_IKOT_TASK_ID_TOKEN = 0x14,
    ks_IKOT_TASK_FATAL = 0x15,
    ks_IKOT_HOST = 0x16,
    ks_IKOT_HOST_PRIV = 0x17,
    ks_IKOT_CLOCK = 0x18,
    ks_IKOT_PROCESSOR = 0x19,
    ks_IKOT_PROCESSOR_SET = 0x1A,
    ks_IKOT_PROCESSOR_SET_NAME = 0x1B,
    ks_IKOT_EVENTLINK = 0x1C,
    ks_IKOT_FILEPORT = 0x1D,
    ks_IKOT_SEMAPHORE = 0x1E,
    ks_IKOT_VOUCHER = 0x1F,
    ks_IKOT_WORK_INTERVAL = 0x20,
    ks_IKOT_MEMORY_OBJECT = 0x21,
    ks_IKOT_NAMED_ENTRY = 0x22,
    ks_IKOT_MAIN_DEVICE = 0x23,
    ks_IKOT_IOKIT_IDENT = 0x24,
    ks_IKOT_IOKIT_CONNECT = 0x25,
    ks_IKOT_IOKIT_OBJECT = 0x26,
    ks_IKOT_UEXT_OBJECT = 0x27,
    ks_IKOT_EXCLAVES_RESOURCE = 0x28,
    ks_IKOT_ARCADE_REG = 0x29,
    ks_IKOT_AU_SESSIONPORT = 0x2A,
    ks_IKOT_HYPERVISOR = 0x2B,
    ks_IKOT_KCDATA = 0x2C,
    ks_IKOT_UND_REPLY = 0x2D,
    ks_IKOT_UX_HANDLER = 0x2E,
    ks_IOT_UNKNOWN = 0x2F,
    ks_IOT_ANY = 0xFF,
};

enum {
    ks_IS_HAS_BOOTSTRAP_PORT_TELEMETRY = 1,
    ks_IS_HAS_CREATE_PRP_TELEMETRY = 2,
    ks_IS_HAS_MOVE_PRP_TELEMETRY = 4,
};

enum {
    ks_KCD_CD_FLAG_IN_MARK = 1,
    ks_KCD_CD_FLAG_FINALIZE = 2,
};

enum {
    ks_KCDCT_NONE = 0,
    ks_KCDCT_ZLIB = 1,
};

enum {
    ks_KPKT_SC_UNSPEC = -1,
    ks_KPKT_SC_BK_SYS = 0x80090,
    ks_KPKT_SC_BK = 0x100080,
    ks_KPKT_SC_BE = 0,
    ks_KPKT_SC_RD = 0x180010,
    ks_KPKT_SC_OAM = 0x200020,
    ks_KPKT_SC_AV = 0x280120,
    ks_KPKT_SC_RV = 0x300110,
    ks_KPKT_SC_VI = 0x380100,
    ks_KPKT_SC_SIG = 0x380130,
    ks_KPKT_SC_VO = 0x400180,
    ks_KPKT_SC_CTL = 0x480190,
};

enum {
    ks_KN_ACTIVE = 1,
    ks_KN_QUEUED = 2,
    ks_KN_DISABLED = 4,
    ks_KN_DROPPING = 8,
    ks_KN_LOCKED = 0x10,
    ks_KN_POSTING = 0x20,
    ks_KN_DEFERDELETE = 0x80,
    ks_KN_MERGE_QOS = 0x100,
    ks_KN_REQVANISH = 0x200,
    ks_KN_VANISHED = 0x400,
    ks_KN_SUPPRESSED = 0x800,
};

enum {
    ks_KQ_SLEEP = 2,
    ks_KQ_PROCWAIT = 4,
    ks_KQ_KEV32 = 8,
    ks_KQ_KEV64 = 0x10,
    ks_KQ_KEV_QOS = 0x20,
    ks_KQ_WORKQ = 0x40,
    ks_KQ_WORKLOOP = 0x80,
    ks_KQ_PROCESSING = 0x100,
    ks_KQ_DRAIN = 0x200,
    ks_KQ_DYNAMIC = 0x800,
    ks_KQ_R2K_ARMED = 0x1000,
    ks_KQ_HAS_TURNSTILE = 0x2000,
};

enum {
    ks_MACH64_MSG_OPTION_NONE = 0,
    ks_MACH64_SEND_MSG = 1,
    ks_MACH64_RCV_MSG = 2,
    ks_MACH64_RCV_LARGE = 4,
    ks_MACH64_RCV_LARGE_IDENTITY = 8,
    ks_MACH64_SEND_TIMEOUT = 0x10,
    ks_MACH64_SEND_OVERRIDE = 0x20,
    ks_MACH64_SEND_INTERRUPT = 0x40,
    ks_MACH64_SEND_NOTIFY = 0x80,
    ks_MACH64_SEND_ALWAYS = 0x10000,
    ks_MACH64_SEND_IMPORTANCE = 0x80000,
    ks_MACH64_SEND_KERNEL = 0x400000,
    ks_MACH64_SEND_FILTER_NONFATAL = 0x10000,
    ks_MACH64_SEND_TRAILER = 0x20000,
    ks_MACH64_SEND_NOIMPORTANCE = 0x40000,
    ks_MACH64_SEND_NODENAP = 0x40000,
    ks_MACH64_SEND_SYNC_OVERRIDE = 0x100000,
    ks_MACH64_SEND_PROPAGATE_QOS = 0x200000,
    ks_MACH64_SEND_SYNC_BOOTSTRAP_CHECKIN = 0x800000,
    ks_MACH64_RCV_TIMEOUT = 0x100,
    ks_MACH64_RCV_INTERRUPT = 0x400,
    ks_MACH64_RCV_VOUCHER = 0x800,
    ks_MACH64_RCV_GUARDED_DESC = 0x1000,
    ks_MACH64_RCV_SYNC_WAIT = 0x4000,
    ks_MACH64_RCV_SYNC_PEEK = 0x8000,
    ks_MACH64_MSG_STRICT_REPLY = 0x200,
    ks_MACH64_MSG_VECTOR = 0x100000000U,
    ks_MACH64_SEND_KOBJECT_CALL = 0x200000000U,
    ks_MACH64_SEND_MQ_CALL = 0x400000000U,
    ks_MACH64_SEND_ANY = 0x800000000U,
    ks_MACH64_SEND_DK_CALL = 0x1000000000U,
    ks_MACH64_POLICY_KERNEL_EXTENSION = 0x2000000000U,
    ks_MACH64_POLICY_FILTER_NON_FATAL = 0x4000000000U,
    ks_MACH64_POLICY_FILTER_MSG = 0x8000000000U,
    ks_MACH64_POLICY_DEFAULT = 0x10000000000U,
    ks_MACH64_POLICY_ENHANCED = 0x20000000000U,
    ks_MACH64_POLICY_PLATFORM = 0x40000000000U,
    ks_MACH64_POLICY_CONTAINED = 0x80000000000U,
    ks_MACH64_POLICY_KERNEL = 0x100000000000U,
    ks_MACH64_POLICY_SIMULATED = 0x200000000000U,
    ks_MACH64_POLICY_TRANSLATED = 0x400000000000U,
    ks_MACH64_POLICY_OPTED_OUT = 0x800000000000U,
    ks_MACH64_POLICY_ENHANCED_V0 = 0x1000000000000U,
    ks_MACH64_POLICY_ENHANCED_V1 = 0x2000000000000U,
    ks_MACH64_POLICY_ENHANCED_V2 = 0x4000000000000U,
    ks_MACH64_POLICY_ENHANCED_VERSION_MASK = 0x7000000000000U,
    ks_MACH64_POLICY_MASK = 0xFF0000000000U,
    ks_MACH64_RCV_LINEAR_VECTOR = 0x1000000000000000U,
    ks_MACH64_RCV_STACK = 0x2000000000000000U,
    ks_MACH64_MACH_MSG2 = -0x8000000000000000,
};

enum {
    ks_MACH_MSG_TYPE_NONE = 0,
    ks_MACH_MSG_TYPE_MOVE_RECEIVE = 0x10,
    ks_MACH_MSG_TYPE_MOVE_SEND = 0x11,
    ks_MACH_MSG_TYPE_MOVE_SEND_ONCE = 0x12,
    ks_MACH_MSG_TYPE_COPY_SEND = 0x13,
    ks_MACH_MSG_TYPE_MAKE_SEND = 0x14,
    ks_MACH_MSG_TYPE_MAKE_SEND_ONCE = 0x15,
};

enum {
    ks_MIT_MODE_SIMPLE = 0,
    ks_MIT_MODE_ADVANCED_STATIC = 1,
    ks_MIT_MODE_ADVANCED_DYNAMIC = 2,
};

enum {
    ks_NETEM_MODEL_NULL = 0,
    ks_NETEM_MODEL_NLC = 1,
    ks_NETEM_MODEL_IOD = 2,
    ks_NETEM_MODEL_FPD = 3,
};

enum {
    ks_NA_INVALID = 0,
    ks_NA_PSEUDO = 1,
    ks_NA_USER_PIPE = 2,
    ks_NA_KERNEL_PIPE = 3,
    ks_NA_NETIF_DEV = 4,
    ks_NA_NETIF_HOST = 5,
    ks_NA_NETIF_COMPAT_DEV = 6,
    ks_NA_NETIF_COMPAT_HOST = 7,
    ks_NA_NETIF_FILTER = 8,
    ks_NA_NETIF_VP = 9,
    ks_NA_FLOWSWITCH_VP = 10,
};

enum {
    ks_NEXUS_ADVISORY_TYPE_INVALID = 0,
    ks_NEXUS_ADVISORY_TYPE_FLOWSWITCH = 1,
    ks_NEXUS_ADVISORY_TYPE_NETIF = 2,
};

enum {
    ks_NEXUS_META_SUBTYPE_INVALID = 0,
    ks_NEXUS_META_SUBTYPE_PAYLOAD = 1,
    ks_NEXUS_META_SUBTYPE_RAW = 2,
    ks_NEXUS_META_SUBTYPE_RESERVED = 3,
    ks_NEXUS_META_SUBTYPE_MAX = 3,
};

enum {
    ks_NEXUS_META_TYPE_INVALID = 0,
    ks_NEXUS_META_TYPE_QUANTUM = 1,
    ks_NEXUS_META_TYPE_PACKET = 2,
    ks_NEXUS_META_TYPE_RESERVED = 3,
    ks_NEXUS_META_TYPE_MAX = 3,
};

enum {
    ks_NEXUS_STATS_TYPE_INVALID = 0,
    ks_NEXUS_STATS_TYPE_FSW = 1,
    ks_NEXUS_STATS_TYPE_CHAN_ERRORS = 2,
};

enum {
    ks_NEXUS_TYPE_USER_PIPE = 0,
    ks_NEXUS_TYPE_KERNEL_PIPE = 1,
    ks_NEXUS_TYPE_NET_IF = 2,
    ks_NEXUS_TYPE_FLOW_SWITCH = 3,
    ks_NEXUS_TYPE_MAX = 4,
    ks_NEXUS_TYPE_UNDEFINED = -1,
};

enum {
    ks_OP_LOOKUP = 0,
    ks_OP_MOUNT = 1,
    ks_OP_UNMOUNT = 2,
    ks_OP_STATFS = 3,
    ks_OP_OPEN = 4,
    ks_OP_LINK = 5,
    ks_OP_UNLINK = 6,
    ks_OP_RENAME = 7,
    ks_OP_CHDIR = 8,
    ks_OP_CHROOT = 9,
    ks_OP_MKNOD = 10,
    ks_OP_MKFIFO = 11,
    ks_OP_SYMLINK = 12,
    ks_OP_ACCESS = 13,
    ks_OP_PATHCONF = 14,
    ks_OP_READLINK = 15,
    ks_OP_GETATTR = 0x10,
    ks_OP_SETATTR = 0x11,
    ks_OP_TRUNCATE = 0x12,
    ks_OP_COPYFILE = 0x13,
    ks_OP_MKDIR = 0x14,
    ks_OP_RMDIR = 0x15,
    ks_OP_REVOKE = 0x16,
    ks_OP_EXCHANGEDATA = 0x17,
    ks_OP_SEARCHFS = 0x18,
    ks_OP_FSCTL = 0x19,
    ks_OP_GETXATTR = 0x1A,
    ks_OP_SETXATTR = 0x1B,
    ks_OP_REMOVEXATTR = 0x1C,
    ks_OP_LISTXATTR = 0x1D,
    ks_OP_MAXOP = 0x1E,
};

enum {
    ks_PERSONA_INVALID = 0,
    ks_PERSONA_GUEST = 1,
    ks_PERSONA_MANAGED = 2,
    ks_PERSONA_PRIV = 3,
    ks_PERSONA_SYSTEM = 4,
    ks_PERSONA_DEFAULT = 5,
    ks_PERSONA_SYSTEM_PROXY = 6,
    ks_PERSONA_SYS_EXT = 7,
    ks_PERSONA_ENTERPRISE = 8,
    ks_PERSONA_TYPE_MAX = 8,
};

enum {
    ks_PSET_SMP = 0,
    ks_PSET_AMP_E = 1,
    ks_PSET_AMP_P = 2,
    ks_MAX_PSET_TYPES = 3,
};

enum {
    ks_RCT_LVL_KERNEL = 0,
    ks_RCT_LVL_USER = 1,
    ks_RCT_LVL_SECURE = 2,
    ks_RCT_LVL_COUNT = 3,
};

enum {
    ks_TH_BUCKET_FIXPRI = 0,
    ks_TH_BUCKET_SHARE_FG = 1,
    ks_TH_BUCKET_SHARE_IN = 2,
    ks_TH_BUCKET_SHARE_DF = 3,
    ks_TH_BUCKET_SHARE_UT = 4,
    ks_TH_BUCKET_SHARE_BG = 5,
    ks_TH_BUCKET_RUN = 6,
    ks_TH_BUCKET_SCHED_MAX = 6,
    ks_TH_BUCKET_MAX = 7,
};

enum {
    ks_TH_MODE_NONE = 0,
    ks_TH_MODE_REALTIME = 1,
    ks_TH_MODE_FIXED = 2,
    ks_TH_MODE_TIMESHARE = 3,
};

enum {
    ks_SKMEM_ARENA_TYPE_NEXUS = 0,
    ks_SKMEM_ARENA_TYPE_NECP = 1,
    ks_SKMEM_ARENA_TYPE_SYSTEM = 2,
};

enum {
    ks_SKMEM_REGION_GUARD_HEAD = 0,
    ks_SKMEM_REGION_SCHEMA = 1,
    ks_SKMEM_REGION_RING = 2,
    ks_SKMEM_REGION_BUF_DEF = 3,
    ks_SKMEM_REGION_BUF_LARGE = 4,
    ks_SKMEM_REGION_RXBUF_DEF = 5,
    ks_SKMEM_REGION_RXBUF_LARGE = 6,
    ks_SKMEM_REGION_TXBUF_DEF = 7,
    ks_SKMEM_REGION_TXBUF_LARGE = 8,
    ks_SKMEM_REGION_UMD = 9,
    ks_SKMEM_REGION_TXAUSD = 10,
    ks_SKMEM_REGION_RXFUSD = 11,
    ks_SKMEM_REGION_UBFT = 12,
    ks_SKMEM_REGION_USTATS = 13,
    ks_SKMEM_REGION_FLOWADV = 14,
    ks_SKMEM_REGION_NEXUSADV = 15,
    ks_SKMEM_REGION_SYSCTLS = 0x10,
    ks_SKMEM_REGION_GUARD_TAIL = 0x11,
    ks_SKMEM_REGION_KMD = 0x12,
    ks_SKMEM_REGION_RXKMD = 0x13,
    ks_SKMEM_REGION_TXKMD = 0x14,
    ks_SKMEM_REGION_KBFT = 0x15,
    ks_SKMEM_REGION_RXKBFT = 0x16,
    ks_SKMEM_REGION_TXKBFT = 0x17,
    ks_SKMEM_REGION_TXAKSD = 0x18,
    ks_SKMEM_REGION_RXFKSD = 0x19,
    ks_SKMEM_REGION_KSTATS = 0x1A,
    ks_SKMEM_REGION_INTRINSIC = 0x1B,
    ks_SKMEM_REGIONS = 0x1C,
};

enum {
    ks_TASK_CONTROL_PORT_OPTIONS_INVALID = 0,
    ks_TASK_CONTROL_PORT_OPTIONS_NONE = 1,
    ks_TASK_CONTROL_PORT_IMMOVABLE_HARD = 2,
    ks_TASK_CONTROL_PORT_IMMOVABLE_MASK = 2,
};

enum {
    ks_TASK_MEMLIMIT_IS_ACTIVE = 1,
    ks_TASK_MEMLIMIT_IS_FATAL = 2,
    ks_TASK_MEMLIMIT_ACTIVE_EXC_RESOURCE = 4,
    ks_TASK_MEMLIMIT_INACTIVE_EXC_RESOURCE = 8,
};

enum {
    ks_THREAD_CALL_ALLOC = 1,
    ks_THREAD_CALL_WAIT = 2,
    ks_THREAD_CALL_DELAYED = 4,
    ks_THREAD_CALL_RUNNING = 8,
    ks_THREAD_CALL_SIGNAL = 0x10,
    ks_THREAD_CALL_ONCE = 0x20,
    ks_THREAD_CALL_RESCHEDULE = 0x40,
    ks_THREAD_CALL_RATELIMITED = 0x80,
    ks_THREAD_CALL_FLAG_CONTINUOUS = 0x100,
    ks_THREAD_CALL_INITIALIZED = 0x200,
};

enum {
    ks_THREAD_CALL_INDEX_INVALID = 0,
    ks_THREAD_CALL_INDEX_HIGH = 1,
    ks_THREAD_CALL_INDEX_KERNEL = 2,
    ks_THREAD_CALL_INDEX_USER = 3,
    ks_THREAD_CALL_INDEX_LOW = 4,
    ks_THREAD_CALL_INDEX_KERNEL_HIGH = 5,
    ks_THREAD_CALL_INDEX_QOS_UI = 6,
    ks_THREAD_CALL_INDEX_QOS_IN = 7,
    ks_THREAD_CALL_INDEX_QOS_UT = 8,
    ks_THREAD_CALL_INDEX_MAX = 9,
};

enum {
    ks_kThreadWaitNone = 0,
    ks_kThreadWaitKernelMutex = 1,
    ks_kThreadWaitPortReceive = 2,
    ks_kThreadWaitPortSetReceive = 3,
    ks_kThreadWaitPortSend = 4,
    ks_kThreadWaitPortSendInTransit = 5,
    ks_kThreadWaitSemaphore = 6,
    ks_kThreadWaitKernelRWLockRead = 7,
    ks_kThreadWaitKernelRWLockWrite = 8,
    ks_kThreadWaitKernelRWLockUpgrade = 9,
    ks_kThreadWaitUserLock = 10,
    ks_kThreadWaitPThreadMutex = 11,
    ks_kThreadWaitPThreadRWLockRead = 12,
    ks_kThreadWaitPThreadRWLockWrite = 13,
    ks_kThreadWaitPThreadCondVar = 14,
    ks_kThreadWaitParkedWorkQueue = 15,
    ks_kThreadWaitWorkloopSyncWait = 0x10,
    ks_kThreadWaitOnProcess = 0x11,
    ks_kThreadWaitSleepWithInheritor = 0x12,
    ks_kThreadWaitEventlink = 0x13,
    ks_kThreadWaitCompressor = 0x14,
    ks_kThreadWaitParkedBoundWorkQueue = 0x15,
    ks_kThreadWaitPageBusy = 0x16,
    ks_kThreadWaitPagerInit = 0x17,
    ks_kThreadWaitPagerReady = 0x18,
    ks_kThreadWaitPagingActivity = 0x19,
    ks_kThreadWaitMappingInProgress = 0x1A,
    ks_kThreadWaitMemoryBlocked = 0x1B,
    ks_kThreadWaitPagingInProgress = 0x1C,
    ks_kThreadWaitPageInThrottle = 0x1D,
    ks_kThreadWaitExclaveCore = 0x1E,
    ks_kThreadWaitExclaveKit = 0x1F,
};

enum {
    ks_THREAD_TAG_MAINTHREAD = 1,
    ks_THREAD_TAG_CALLOUT = 2,
    ks_THREAD_TAG_IOWORKLOOP = 4,
    ks_THREAD_TAG_PTHREAD = 0x10,
    ks_THREAD_TAG_WORKQUEUE = 0x20,
    ks_THREAD_TAG_USER_JOIN = 0x40,
    ks_THREAD_TAG_AIO_WORKQUEUE = 0x80,
};

enum {
    ks_TH_WORK_INTERVAL_FLAGS_NONE = 0,
    ks_TH_WORK_INTERVAL_FLAGS_AUTO_JOIN_LEAK = 1,
    ks_TH_WORK_INTERVAL_FLAGS_HAS_WORKLOAD_ID = 2,
    ks_TH_WORK_INTERVAL_FLAGS_RT_ALLOWED = 4,
};

enum {
    ks_TURNSTILE_UPDATE_FLAGS_NONE = 0,
    ks_TURNSTILE_IMMEDIATE_UPDATE = 1,
    ks_TURNSTILE_DELAYED_UPDATE = 2,
    ks_TURNSTILE_INHERITOR_THREAD = 4,
    ks_TURNSTILE_INHERITOR_TURNSTILE = 8,
    ks_TURNSTILE_INHERITOR_NEEDS_PRI_UPDATE = 0x10,
    ks_TURNSTILE_NEEDS_PRI_UPDATE = 0x20,
    ks_TURNSTILE_INHERITOR_WORKQ = 0x40,
    ks_TURNSTILE_UPDATE_BOOST = 0x80,
};

enum {
    ks_NR_RX = 0,
    ks_NR_TX = 1,
    ks_NR_TXRX = 2,
    ks_NR_A = 2,
    ks_NR_F = 3,
    ks_NR_TXRXAF = 4,
    ks_NR_EV = 4,
    ks_NR_LBA = 5,
    ks_NR_ALL = 6,
};

enum {
    ks_UIO_USERSPACE = 0,
    ks_UIO_SYSSPACE = 2,
    ks_UIO_USERSPACE32 = 5,
    ks_UIO_USERSPACE64 = 8,
    ks_UIO_SYSSPACE32 = 11,
};

enum {
    ks_ULK_INVALID = 0,
    ks_ULK_UADDR = 1,
    ks_ULK_XPROC = 2,
};

enum {
    ks_VM_PAGE_NOT_ON_Q = 0,
    ks_VM_PAGE_IS_WIRED = 1,
    ks_VM_PAGE_USED_BY_COMPRESSOR = 2,
    ks_VM_PAGE_ON_FREE_Q = 3,
    ks_VM_PAGE_ON_FREE_LOCAL_Q = 4,
    ks_VM_PAGE_ON_THROTTLED_Q = 6,
    ks_VM_PAGE_ON_PAGEOUT_Q = 7,
    ks_VM_PAGE_ON_SPECULATIVE_Q = 8,
    ks_VM_PAGE_ON_ACTIVE_LOCAL_Q = 9,
    ks_VM_PAGE_ON_ACTIVE_Q = 10,
    ks_VM_PAGE_ON_INACTIVE_INTERNAL_Q = 11,
    ks_VM_PAGE_ON_INACTIVE_EXTERNAL_Q = 12,
    ks_VM_PAGE_ON_INACTIVE_CLEANED_Q = 13,
};

enum {
    ks_VM_PAGE_SPECIAL_Q_EMPTY = 0,
    ks_VM_PAGE_SPECIAL_Q_BG = 1,
    ks_VM_PAGE_SPECIAL_Q_DONATE = 2,
    ks_VM_PAGE_SPECIAL_Q_FG = 3,
};

enum {
    ks_VK_HASH_NONE = 0,
    ks_VK_HASH_SHA3_256 = 1,
    ks_VK_HASH_SHA3_384 = 2,
    ks_VK_HASH_SHA3_512 = 3,
};

enum {
    ks_VNON = 0,
    ks_VREG = 1,
    ks_VDIR = 2,
    ks_VBLK = 3,
    ks_VCHR = 4,
    ks_VLNK = 5,
    ks_VSOCK = 6,
    ks_VFIFO = 7,
    ks_VBAD = 8,
    ks_VSTR = 9,
    ks_VCPLX = 10,
};

enum {
    ks_WQT_INVALID = 0,
    ks_WQT_QUEUE = 1,
    ks_WQT_TURNSTILE = 2,
    ks_WQT_PORT = 3,
    ks_WQT_SELECT = 4,
    ks_WQT_PORT_SET = 5,
    ks_WQT_SELECT_SET = 6,
};

enum {
    ks_WI_CLASS_NONE = 0,
    ks_WI_CLASS_DISCRETIONARY = 1,
    ks_WI_CLASS_BEST_EFFORT = 2,
    ks_WI_CLASS_APPLICATION = 3,
    ks_WI_CLASS_SYSTEM = 4,
    ks_WI_CLASS_SYSTEM_CRITICAL = 5,
    ks_WI_CLASS_REALTIME = 6,
    ks_WI_CLASS_REALTIME_CRITICAL = 7,
    ks_WI_CLASS_APP_SUPPORT = 8,
    ks_WI_CLASS_COUNT = 9,
};

enum {
    ks_WQ_EXITING = 1,
    ks_WQ_PROC_SUSPENDED = 2,
    ks_WQ_DEATH_CALL_SCHEDULED = 4,
    ks_WQ_DELAYED_CALL_SCHEDULED = 0x10,
    ks_WQ_DELAYED_CALL_PENDED = 0x20,
    ks_WQ_IMMEDIATE_CALL_SCHEDULED = 0x40,
    ks_WQ_IMMEDIATE_CALL_PENDED = 0x80,
};

enum {
    ks_WORKQ_TR_FLAG_KEVENT = 1,
    ks_WORKQ_TR_FLAG_WORKLOOP = 2,
    ks_WORKQ_TR_FLAG_OVERCOMMIT = 4,
    ks_WORKQ_TR_FLAG_WL_PARAMS = 8,
    ks_WORKQ_TR_FLAG_WL_OUTSIDE_QOS = 0x10,
    ks_WORKQ_TR_FLAG_COOPERATIVE = 0x20,
    ks_WORKQ_TR_FLAG_PERMANENT_BIND = 0x40,
};

enum {
    ks_WORKQ_TR_STATE_IDLE = 0,
    ks_WORKQ_TR_STATE_NEW = 1,
    ks_WORKQ_TR_STATE_QUEUED = 2,
    ks_WORKQ_TR_STATE_CANCELED = 3,
    ks_WORKQ_TR_STATE_BINDING = 4,
    ks_WORKQ_TR_STATE_BOUND = 5,
};

/* refs: 1 */
struct ks_CEAccelerationContext {
    struct ks_CEAccelerationElement *index;
    unsigned long index_count;
};
_Static_assert(offsetof(struct ks_CEAccelerationContext, index) == 0x0, "ks_CEAccelerationContext.index offset");
_Static_assert(offsetof(struct ks_CEAccelerationContext, index_count) == 0x8, "ks_CEAccelerationContext.index_count offset");
_Static_assert(sizeof(struct ks_CEAccelerationContext) == 0x10, "ks_CEAccelerationContext size");

/* refs: 2 */
struct ks_ccder_read_blob {
    unsigned char *der;
    unsigned char *der_end;
};
_Static_assert(offsetof(struct ks_ccder_read_blob, der) == 0x0, "ks_ccder_read_blob.der offset");
_Static_assert(offsetof(struct ks_ccder_read_blob, der_end) == 0x8, "ks_ccder_read_blob.der_end offset");
_Static_assert(sizeof(struct ks_ccder_read_blob) == 0x10, "ks_ccder_read_blob size");

/* refs: 2 */
struct ks_der_vm_context {
    const struct ks_CERuntime *runtime;
    struct ks_CEAccelerationContext lookup;
    unsigned long dictionary_tag;
    _Bool sorted;
    _Bool valid;
    struct ks_ccder_read_blob ccstate;
};
_Static_assert(offsetof(struct ks_der_vm_context, runtime) == 0x0, "ks_der_vm_context.runtime offset");
_Static_assert(offsetof(struct ks_der_vm_context, lookup) == 0x8, "ks_der_vm_context.lookup offset");
_Static_assert(offsetof(struct ks_der_vm_context, dictionary_tag) == 0x18, "ks_der_vm_context.dictionary_tag offset");
_Static_assert(offsetof(struct ks_der_vm_context, sorted) == 0x20, "ks_der_vm_context.sorted offset");
_Static_assert(offsetof(struct ks_der_vm_context, valid) == 0x21, "ks_der_vm_context.valid offset");
_Static_assert(offsetof(struct ks_der_vm_context, ccstate) == 0x28, "ks_der_vm_context.ccstate offset");
_Static_assert(sizeof(struct ks_der_vm_context) == 0x38, "ks_der_vm_context size");

/* refs: 1 */
struct ks_CEQueryContext {
    struct ks_der_vm_context der_context;
    _Bool managed;
};
_Static_assert(offsetof(struct ks_CEQueryContext, der_context) == 0x0, "ks_CEQueryContext.der_context offset");
_Static_assert(offsetof(struct ks_CEQueryContext, managed) == 0x38, "ks_CEQueryContext.managed offset");
_Static_assert(sizeof(struct ks_CEQueryContext) == 0x40, "ks_CEQueryContext size");

/* refs: 4 */
struct ks_CERuntime {
    unsigned long long version;
    void **alloc;
    void *free;
    void *log;
    void *abort;
    _Bool *internalStatus;
    void **allocIndex;
    void *freeIndex;
};
_Static_assert(offsetof(struct ks_CERuntime, version) == 0x0, "ks_CERuntime.version offset");
_Static_assert(offsetof(struct ks_CERuntime, alloc) == 0x8, "ks_CERuntime.alloc offset");
_Static_assert(offsetof(struct ks_CERuntime, free) == 0x10, "ks_CERuntime.free offset");
_Static_assert(offsetof(struct ks_CERuntime, log) == 0x18, "ks_CERuntime.log offset");
_Static_assert(offsetof(struct ks_CERuntime, abort) == 0x20, "ks_CERuntime.abort offset");
_Static_assert(offsetof(struct ks_CERuntime, internalStatus) == 0x28, "ks_CERuntime.internalStatus offset");
_Static_assert(offsetof(struct ks_CERuntime, allocIndex) == 0x30, "ks_CERuntime.allocIndex offset");
_Static_assert(offsetof(struct ks_CERuntime, freeIndex) == 0x38, "ks_CERuntime.freeIndex offset");
_Static_assert(sizeof(struct ks_CERuntime) == 0x40, "ks_CERuntime size");

/* refs: 1 */
struct ks_IOSKArena {
};

/* refs: 2 */
struct ks_IOSKMemoryBufferSpec {
    int user_writable;
    int kernel_writable;
    int iodir_in;
    int iodir_out;
    int purgeable;
    int inhibitCache;
    int physcontig;
    int puredata;
    int threadSafe;
    int memtag;
};
_Static_assert(offsetof(struct ks_IOSKMemoryBufferSpec, user_writable) == 0x0, "ks_IOSKMemoryBufferSpec.user_writable offset");
_Static_assert(offsetof(struct ks_IOSKMemoryBufferSpec, kernel_writable) == 0x4, "ks_IOSKMemoryBufferSpec.kernel_writable offset");
_Static_assert(offsetof(struct ks_IOSKMemoryBufferSpec, iodir_in) == 0x8, "ks_IOSKMemoryBufferSpec.iodir_in offset");
_Static_assert(offsetof(struct ks_IOSKMemoryBufferSpec, iodir_out) == 0xC, "ks_IOSKMemoryBufferSpec.iodir_out offset");
_Static_assert(offsetof(struct ks_IOSKMemoryBufferSpec, purgeable) == 0x10, "ks_IOSKMemoryBufferSpec.purgeable offset");
_Static_assert(offsetof(struct ks_IOSKMemoryBufferSpec, inhibitCache) == 0x14, "ks_IOSKMemoryBufferSpec.inhibitCache offset");
_Static_assert(offsetof(struct ks_IOSKMemoryBufferSpec, physcontig) == 0x18, "ks_IOSKMemoryBufferSpec.physcontig offset");
_Static_assert(offsetof(struct ks_IOSKMemoryBufferSpec, puredata) == 0x1C, "ks_IOSKMemoryBufferSpec.puredata offset");
_Static_assert(offsetof(struct ks_IOSKMemoryBufferSpec, threadSafe) == 0x20, "ks_IOSKMemoryBufferSpec.threadSafe offset");
_Static_assert(offsetof(struct ks_IOSKMemoryBufferSpec, memtag) == 0x24, "ks_IOSKMemoryBufferSpec.memtag offset");
_Static_assert(sizeof(struct ks_IOSKMemoryBufferSpec) == 0x28, "ks_IOSKMemoryBufferSpec size");

/* refs: 2 */
struct ks_IOSKRegionSpec {
    int noRedirect;
};
_Static_assert(offsetof(struct ks_IOSKRegionSpec, noRedirect) == 0x0, "ks_IOSKRegionSpec.noRedirect offset");
_Static_assert(sizeof(struct ks_IOSKRegionSpec) == 0x4, "ks_IOSKRegionSpec size");

/* refs: 2 */
struct ks__CEContextInfo {
    unsigned char type;
    unsigned int version;
};
_Static_assert(offsetof(struct ks__CEContextInfo, type) == 0x0, "ks__CEContextInfo.type offset");
_Static_assert(offsetof(struct ks__CEContextInfo, version) == 0x4, "ks__CEContextInfo.version offset");
_Static_assert(sizeof(struct ks__CEContextInfo) == 0x8, "ks__CEContextInfo size");

/* refs: 7 */
struct ks__CEContext {
    struct ks__CEContextInfo info;
    struct ks_CEQueryContext legacyContext;
};
_Static_assert(offsetof(struct ks__CEContext, info) == 0x0, "ks__CEContext.info offset");
_Static_assert(offsetof(struct ks__CEContext, legacyContext) == 0x8, "ks__CEContext.legacyContext offset");
_Static_assert(sizeof(struct ks__CEContext) == 0x48, "ks__CEContext size");

/* refs: 2 */
struct ks__CMSValidation {
    unsigned char *cmsData;
    unsigned long cmsDataSize;
    unsigned char *cmsLeafCert;
    unsigned long cmsLeafCertSize;
    unsigned char *cmsContent;
    unsigned long cmsContentSize;
    unsigned int agilityHashType;
    unsigned char *agilityHash;
    unsigned long agilityHashSize;
    unsigned int digestType;
    unsigned long long policyFlags;
    _Bool cmsInitialized;
    _Bool cmsVerified;
    _Bool allowDebuggingRoots;
};
_Static_assert(offsetof(struct ks__CMSValidation, cmsData) == 0x0, "ks__CMSValidation.cmsData offset");
_Static_assert(offsetof(struct ks__CMSValidation, cmsDataSize) == 0x8, "ks__CMSValidation.cmsDataSize offset");
_Static_assert(offsetof(struct ks__CMSValidation, cmsLeafCert) == 0x10, "ks__CMSValidation.cmsLeafCert offset");
_Static_assert(offsetof(struct ks__CMSValidation, cmsLeafCertSize) == 0x18, "ks__CMSValidation.cmsLeafCertSize offset");
_Static_assert(offsetof(struct ks__CMSValidation, cmsContent) == 0x20, "ks__CMSValidation.cmsContent offset");
_Static_assert(offsetof(struct ks__CMSValidation, cmsContentSize) == 0x28, "ks__CMSValidation.cmsContentSize offset");
_Static_assert(offsetof(struct ks__CMSValidation, agilityHashType) == 0x30, "ks__CMSValidation.agilityHashType offset");
_Static_assert(offsetof(struct ks__CMSValidation, agilityHash) == 0x38, "ks__CMSValidation.agilityHash offset");
_Static_assert(offsetof(struct ks__CMSValidation, agilityHashSize) == 0x40, "ks__CMSValidation.agilityHashSize offset");
_Static_assert(offsetof(struct ks__CMSValidation, digestType) == 0x48, "ks__CMSValidation.digestType offset");
_Static_assert(offsetof(struct ks__CMSValidation, policyFlags) == 0x50, "ks__CMSValidation.policyFlags offset");
_Static_assert(offsetof(struct ks__CMSValidation, cmsInitialized) == 0x58, "ks__CMSValidation.cmsInitialized offset");
_Static_assert(offsetof(struct ks__CMSValidation, cmsVerified) == 0x59, "ks__CMSValidation.cmsVerified offset");
_Static_assert(offsetof(struct ks__CMSValidation, allowDebuggingRoots) == 0x5A, "ks__CMSValidation.allowDebuggingRoots offset");
_Static_assert(sizeof(struct ks__CMSValidation) == 0x60, "ks__CMSValidation size");

/* refs: 4 */
struct ks__CSBuffer {
    unsigned char *data;
    unsigned long dataSize;
};
_Static_assert(offsetof(struct ks__CSBuffer, data) == 0x0, "ks__CSBuffer.data offset");
_Static_assert(offsetof(struct ks__CSBuffer, dataSize) == 0x8, "ks__CSBuffer.dataSize offset");
_Static_assert(sizeof(struct ks__CSBuffer) == 0x10, "ks__CSBuffer size");

/* refs: 2 */
struct ks__CSCodeDirectory {
    unsigned int magic;
    unsigned int length;
    unsigned int version;
    unsigned int flags;
    unsigned int hashesOffset;
    unsigned int signingIdentifierOffset;
    unsigned int numSpecialSlots;
    unsigned int numCodeSlots;
    unsigned int codeLimit;
    unsigned char hashSize;
    unsigned char hashType;
    unsigned char platformIdentifier;
    unsigned char pageShift;
    unsigned int spare0;
};
_Static_assert(offsetof(struct ks__CSCodeDirectory, magic) == 0x0, "ks__CSCodeDirectory.magic offset");
_Static_assert(offsetof(struct ks__CSCodeDirectory, length) == 0x4, "ks__CSCodeDirectory.length offset");
_Static_assert(offsetof(struct ks__CSCodeDirectory, version) == 0x8, "ks__CSCodeDirectory.version offset");
_Static_assert(offsetof(struct ks__CSCodeDirectory, flags) == 0xC, "ks__CSCodeDirectory.flags offset");
_Static_assert(offsetof(struct ks__CSCodeDirectory, hashesOffset) == 0x10, "ks__CSCodeDirectory.hashesOffset offset");
_Static_assert(offsetof(struct ks__CSCodeDirectory, signingIdentifierOffset) == 0x14, "ks__CSCodeDirectory.signingIdentifierOffset offset");
_Static_assert(offsetof(struct ks__CSCodeDirectory, numSpecialSlots) == 0x18, "ks__CSCodeDirectory.numSpecialSlots offset");
_Static_assert(offsetof(struct ks__CSCodeDirectory, numCodeSlots) == 0x1C, "ks__CSCodeDirectory.numCodeSlots offset");
_Static_assert(offsetof(struct ks__CSCodeDirectory, codeLimit) == 0x20, "ks__CSCodeDirectory.codeLimit offset");
_Static_assert(offsetof(struct ks__CSCodeDirectory, hashSize) == 0x24, "ks__CSCodeDirectory.hashSize offset");
_Static_assert(offsetof(struct ks__CSCodeDirectory, hashType) == 0x25, "ks__CSCodeDirectory.hashType offset");
_Static_assert(offsetof(struct ks__CSCodeDirectory, platformIdentifier) == 0x26, "ks__CSCodeDirectory.platformIdentifier offset");
_Static_assert(offsetof(struct ks__CSCodeDirectory, pageShift) == 0x27, "ks__CSCodeDirectory.pageShift offset");
_Static_assert(offsetof(struct ks__CSCodeDirectory, spare0) == 0x28, "ks__CSCodeDirectory.spare0 offset");
_Static_assert(sizeof(struct ks__CSCodeDirectory) == 0x2C, "ks__CSCodeDirectory size");

/* refs: 2 */
struct ks__CSCodeDirectorySafe {
    struct ks__CSCodeDirectory *data;
    unsigned int dataSize;
};
_Static_assert(offsetof(struct ks__CSCodeDirectorySafe, data) == 0x0, "ks__CSCodeDirectorySafe.data offset");
_Static_assert(offsetof(struct ks__CSCodeDirectorySafe, dataSize) == 0x8, "ks__CSCodeDirectorySafe.dataSize offset");
_Static_assert(sizeof(struct ks__CSCodeDirectorySafe) == 0x10, "ks__CSCodeDirectorySafe size");

/* refs: 2 */
struct ks__CSConfigCallerSignature {
    struct ks__SignatureValidation **acquireSig;
    void *releaseSig;
};
_Static_assert(offsetof(struct ks__CSConfigCallerSignature, acquireSig) == 0x0, "ks__CSConfigCallerSignature.acquireSig offset");
_Static_assert(offsetof(struct ks__CSConfigCallerSignature, releaseSig) == 0x8, "ks__CSConfigCallerSignature.releaseSig offset");
_Static_assert(sizeof(struct ks__CSConfigCallerSignature) == 0x10, "ks__CSConfigCallerSignature size");

/* refs: 2 */
struct ks__CSConfigCompilationService {
    _Bool *matchCDHash;
};
_Static_assert(offsetof(struct ks__CSConfigCompilationService, matchCDHash) == 0x0, "ks__CSConfigCompilationService.matchCDHash offset");
_Static_assert(sizeof(struct ks__CSConfigCompilationService) == 0x8, "ks__CSConfigCompilationService size");

/* refs: 2 */
struct ks__CSConfigEnvironmentState {
    _Bool *developerMode;
    _Bool *demoMode;
    _Bool *lockdownMode;
    _Bool *researchMode;
    _Bool *extendedResearchMode;
};
_Static_assert(offsetof(struct ks__CSConfigEnvironmentState, developerMode) == 0x0, "ks__CSConfigEnvironmentState.developerMode offset");
_Static_assert(offsetof(struct ks__CSConfigEnvironmentState, demoMode) == 0x8, "ks__CSConfigEnvironmentState.demoMode offset");
_Static_assert(offsetof(struct ks__CSConfigEnvironmentState, lockdownMode) == 0x10, "ks__CSConfigEnvironmentState.lockdownMode offset");
_Static_assert(offsetof(struct ks__CSConfigEnvironmentState, researchMode) == 0x18, "ks__CSConfigEnvironmentState.researchMode offset");
_Static_assert(offsetof(struct ks__CSConfigEnvironmentState, extendedResearchMode) == 0x20, "ks__CSConfigEnvironmentState.extendedResearchMode offset");
_Static_assert(sizeof(struct ks__CSConfigEnvironmentState) == 0x28, "ks__CSConfigEnvironmentState size");

/* refs: 2 */
struct ks__CSConfigLocalSigning {
    struct ks__CSBuffer *getPublicKey;
    _Bool *matchAuthentication;
    struct ks__CEContext *allowedEntitlementsSet;
};
_Static_assert(offsetof(struct ks__CSConfigLocalSigning, getPublicKey) == 0x0, "ks__CSConfigLocalSigning.getPublicKey offset");
_Static_assert(offsetof(struct ks__CSConfigLocalSigning, matchAuthentication) == 0x8, "ks__CSConfigLocalSigning.matchAuthentication offset");
_Static_assert(offsetof(struct ks__CSConfigLocalSigning, allowedEntitlementsSet) == 0x10, "ks__CSConfigLocalSigning.allowedEntitlementsSet offset");
_Static_assert(sizeof(struct ks__CSConfigLocalSigning) == 0x18, "ks__CSConfigLocalSigning size");

/* refs: 2 */
struct ks__CSConfigProvisioningProfiles {
    char deviceUDID[0x30];
    _Bool *auxiliaryValidate;
};
_Static_assert(offsetof(struct ks__CSConfigProvisioningProfiles, deviceUDID) == 0x0, "ks__CSConfigProvisioningProfiles.deviceUDID offset");
_Static_assert(offsetof(struct ks__CSConfigProvisioningProfiles, auxiliaryValidate) == 0x30, "ks__CSConfigProvisioningProfiles.auxiliaryValidate offset");
_Static_assert(sizeof(struct ks__CSConfigProvisioningProfiles) == 0x38, "ks__CSConfigProvisioningProfiles size");

/* refs: 2 */
struct ks__CSConfigTrustCaches {
    struct ks__TCReturn *queryCDHash;
    struct ks__TCReturn *queryCDHashForREM;
    _Bool queryTokenSupported;
};
_Static_assert(offsetof(struct ks__CSConfigTrustCaches, queryCDHash) == 0x0, "ks__CSConfigTrustCaches.queryCDHash offset");
_Static_assert(offsetof(struct ks__CSConfigTrustCaches, queryCDHashForREM) == 0x8, "ks__CSConfigTrustCaches.queryCDHashForREM offset");
_Static_assert(offsetof(struct ks__CSConfigTrustCaches, queryTokenSupported) == 0x10, "ks__CSConfigTrustCaches.queryTokenSupported offset");
_Static_assert(sizeof(struct ks__CSConfigTrustCaches) == 0x18, "ks__CSConfigTrustCaches size");

/* refs: 3 */
struct ks__CSConfig {
    struct ks__CSConfigOSPolicy *systemPolicy;
    _Bool *platformCodeOnly;
    struct ks_CERuntime *entitlementsRuntime;
    struct ks__CSConfigTrustCaches trustCaches;
    struct ks__CSConfigProvisioningProfiles provisioningProfiles;
    struct ks__CSConfigLocalSigning localSigning;
    struct ks__CSConfigCompilationService compilationService;
    struct ks__CSConfigCallerSignature callerSignature;
    struct ks__CSConfigEnvironmentState environmentState;
    struct ks__CSMutableBuffer *getMutableBuffer;
    struct {
        _Bool skipTrustEvaluation;
        _Bool allowAnySignature;
        _Bool allowUnrestrictedLocalSigning;
        _Bool allowInternalCAs;
        _Bool enforceCoreTrust;
        _Bool relaxRestrictedModePerms;
        _Bool relaxProfileTrust;
    } exemptions;
};
_Static_assert(offsetof(struct ks__CSConfig, systemPolicy) == 0x0, "ks__CSConfig.systemPolicy offset");
_Static_assert(offsetof(struct ks__CSConfig, platformCodeOnly) == 0x8, "ks__CSConfig.platformCodeOnly offset");
_Static_assert(offsetof(struct ks__CSConfig, entitlementsRuntime) == 0x10, "ks__CSConfig.entitlementsRuntime offset");
_Static_assert(offsetof(struct ks__CSConfig, trustCaches) == 0x18, "ks__CSConfig.trustCaches offset");
_Static_assert(offsetof(struct ks__CSConfig, provisioningProfiles) == 0x30, "ks__CSConfig.provisioningProfiles offset");
_Static_assert(offsetof(struct ks__CSConfig, localSigning) == 0x68, "ks__CSConfig.localSigning offset");
_Static_assert(offsetof(struct ks__CSConfig, compilationService) == 0x80, "ks__CSConfig.compilationService offset");
_Static_assert(offsetof(struct ks__CSConfig, callerSignature) == 0x88, "ks__CSConfig.callerSignature offset");
_Static_assert(offsetof(struct ks__CSConfig, environmentState) == 0x98, "ks__CSConfig.environmentState offset");
_Static_assert(offsetof(struct ks__CSConfig, getMutableBuffer) == 0xC0, "ks__CSConfig.getMutableBuffer offset");
_Static_assert(offsetof(struct ks__CSConfig, exemptions) == 0xC8, "ks__CSConfig.exemptions offset");
_Static_assert(sizeof(struct ks__CSConfig) == 0xD0, "ks__CSConfig size");

/* refs: 2 */
struct ks__CSConfigFeatureSet {
    _Bool restrictedExecutionMode;
    _Bool OOPJit;
    _Bool localSigning;
    _Bool compilationService;
    _Bool appleInternalProfiles;
    _Bool developerMode;
    _Bool demoMode;
    _Bool JIT;
    _Bool executableCommPage;
};
_Static_assert(offsetof(struct ks__CSConfigFeatureSet, restrictedExecutionMode) == 0x0, "ks__CSConfigFeatureSet.restrictedExecutionMode offset");
_Static_assert(offsetof(struct ks__CSConfigFeatureSet, OOPJit) == 0x1, "ks__CSConfigFeatureSet.OOPJit offset");
_Static_assert(offsetof(struct ks__CSConfigFeatureSet, localSigning) == 0x2, "ks__CSConfigFeatureSet.localSigning offset");
_Static_assert(offsetof(struct ks__CSConfigFeatureSet, compilationService) == 0x3, "ks__CSConfigFeatureSet.compilationService offset");
_Static_assert(offsetof(struct ks__CSConfigFeatureSet, appleInternalProfiles) == 0x4, "ks__CSConfigFeatureSet.appleInternalProfiles offset");
_Static_assert(offsetof(struct ks__CSConfigFeatureSet, developerMode) == 0x5, "ks__CSConfigFeatureSet.developerMode offset");
_Static_assert(offsetof(struct ks__CSConfigFeatureSet, demoMode) == 0x6, "ks__CSConfigFeatureSet.demoMode offset");
_Static_assert(offsetof(struct ks__CSConfigFeatureSet, JIT) == 0x7, "ks__CSConfigFeatureSet.JIT offset");
_Static_assert(offsetof(struct ks__CSConfigFeatureSet, executableCommPage) == 0x8, "ks__CSConfigFeatureSet.executableCommPage offset");
_Static_assert(sizeof(struct ks__CSConfigFeatureSet) == 0x9, "ks__CSConfigFeatureSet size");

/* refs: 2 */
struct ks__CSConfigOSPolicy {
    unsigned int minimumCodeDirectoryVersion;
    unsigned char minimumHashTypeForPlatformCode;
    _Bool trustCacheCodeOnly;
    _Bool platformCodeOnly;
    unsigned long long platformCTFlags;
    unsigned long long appStoreCTFlags;
    unsigned long long profileValidatedCTFlags;
    unsigned long long appStoreQACTFlags;
    unsigned long long profileValidatedQACTFlags;
    unsigned long long platformQACTFlags;
    unsigned long long profileCTFlags;
    const char **developerLimit;
    struct ks__CSConfigFeatureSet featureSet;
    struct {
        const char *appContainerPath;
    } specialPaths;
};
_Static_assert(offsetof(struct ks__CSConfigOSPolicy, minimumCodeDirectoryVersion) == 0x0, "ks__CSConfigOSPolicy.minimumCodeDirectoryVersion offset");
_Static_assert(offsetof(struct ks__CSConfigOSPolicy, minimumHashTypeForPlatformCode) == 0x4, "ks__CSConfigOSPolicy.minimumHashTypeForPlatformCode offset");
_Static_assert(offsetof(struct ks__CSConfigOSPolicy, trustCacheCodeOnly) == 0x5, "ks__CSConfigOSPolicy.trustCacheCodeOnly offset");
_Static_assert(offsetof(struct ks__CSConfigOSPolicy, platformCodeOnly) == 0x6, "ks__CSConfigOSPolicy.platformCodeOnly offset");
_Static_assert(offsetof(struct ks__CSConfigOSPolicy, platformCTFlags) == 0x8, "ks__CSConfigOSPolicy.platformCTFlags offset");
_Static_assert(offsetof(struct ks__CSConfigOSPolicy, appStoreCTFlags) == 0x10, "ks__CSConfigOSPolicy.appStoreCTFlags offset");
_Static_assert(offsetof(struct ks__CSConfigOSPolicy, profileValidatedCTFlags) == 0x18, "ks__CSConfigOSPolicy.profileValidatedCTFlags offset");
_Static_assert(offsetof(struct ks__CSConfigOSPolicy, appStoreQACTFlags) == 0x20, "ks__CSConfigOSPolicy.appStoreQACTFlags offset");
_Static_assert(offsetof(struct ks__CSConfigOSPolicy, profileValidatedQACTFlags) == 0x28, "ks__CSConfigOSPolicy.profileValidatedQACTFlags offset");
_Static_assert(offsetof(struct ks__CSConfigOSPolicy, platformQACTFlags) == 0x30, "ks__CSConfigOSPolicy.platformQACTFlags offset");
_Static_assert(offsetof(struct ks__CSConfigOSPolicy, profileCTFlags) == 0x38, "ks__CSConfigOSPolicy.profileCTFlags offset");
_Static_assert(offsetof(struct ks__CSConfigOSPolicy, developerLimit) == 0x40, "ks__CSConfigOSPolicy.developerLimit offset");
_Static_assert(offsetof(struct ks__CSConfigOSPolicy, featureSet) == 0x48, "ks__CSConfigOSPolicy.featureSet offset");
_Static_assert(offsetof(struct ks__CSConfigOSPolicy, specialPaths) == 0x58, "ks__CSConfigOSPolicy.specialPaths offset");
_Static_assert(sizeof(struct ks__CSConfigOSPolicy) == 0x60, "ks__CSConfigOSPolicy size");

/* refs: 2 */
struct ks__CSMutableBuffer {
    unsigned char *data;
    unsigned long dataSize;
};
_Static_assert(offsetof(struct ks__CSMutableBuffer, data) == 0x0, "ks__CSMutableBuffer.data offset");
_Static_assert(offsetof(struct ks__CSMutableBuffer, dataSize) == 0x8, "ks__CSMutableBuffer.dataSize offset");
_Static_assert(sizeof(struct ks__CSMutableBuffer) == 0x10, "ks__CSMutableBuffer size");

/* refs: 2 */
struct ks__CSProfileProperties {
    unsigned int developer : 1; /* bit offset 0 */
    unsigned int testFlight : 1; /* bit offset 1 */
    unsigned int universal : 1; /* bit offset 2 */
    unsigned int appleInternal : 1; /* bit offset 3 */
    unsigned int demoMode : 1; /* bit offset 4 */
    unsigned int appShack : 1; /* bit offset 5 */
    unsigned int internalBuild : 1; /* bit offset 6 */
    unsigned int noExecute : 1; /* bit offset 7 */
    unsigned int reserved : 23; /* bit offset 8 */
};
_Static_assert(sizeof(struct ks__CSProfileProperties) == 0x4, "ks__CSProfileProperties size");

/* refs: 2 */
struct ks__CSSuperBlobIndex {
    unsigned int type;
    unsigned int offset;
};
_Static_assert(offsetof(struct ks__CSSuperBlobIndex, type) == 0x0, "ks__CSSuperBlobIndex.type offset");
_Static_assert(offsetof(struct ks__CSSuperBlobIndex, offset) == 0x4, "ks__CSSuperBlobIndex.offset offset");
_Static_assert(sizeof(struct ks__CSSuperBlobIndex) == 0x8, "ks__CSSuperBlobIndex size");

/* refs: 2 */
struct ks__CSSuperBlob {
    unsigned int magic;
    unsigned int length;
    unsigned int count;
    struct ks__CSSuperBlobIndex index[0];
};
_Static_assert(offsetof(struct ks__CSSuperBlob, magic) == 0x0, "ks__CSSuperBlob.magic offset");
_Static_assert(offsetof(struct ks__CSSuperBlob, length) == 0x4, "ks__CSSuperBlob.length offset");
_Static_assert(offsetof(struct ks__CSSuperBlob, count) == 0x8, "ks__CSSuperBlob.count offset");
_Static_assert(offsetof(struct ks__CSSuperBlob, index) == 0xC, "ks__CSSuperBlob.index offset");
_Static_assert(sizeof(struct ks__CSSuperBlob) == 0xC, "ks__CSSuperBlob size");

/* refs: 2 */
struct ks__CSSuperBlobSafe {
    struct ks__CSSuperBlob *data;
    unsigned int dataSize;
};
_Static_assert(offsetof(struct ks__CSSuperBlobSafe, data) == 0x0, "ks__CSSuperBlobSafe.data offset");
_Static_assert(offsetof(struct ks__CSSuperBlobSafe, dataSize) == 0x8, "ks__CSSuperBlobSafe.dataSize offset");
_Static_assert(sizeof(struct ks__CSSuperBlobSafe) == 0x10, "ks__CSSuperBlobSafe size");

/* refs: 2 */
struct ks__ProfileValidation {
    struct ks__CSConfig *config;
    struct ks__CMSValidation profileCMS;
    struct ks__CEContext profileCtx;
    struct ks__CEContext entCtx;
    _Bool entInit;
    struct ks__CSProfileProperties properties __attribute__((aligned(4)));
    _Bool profileInitialized;
    _Bool profileVerified;
    _Bool profileTrusted;
};
_Static_assert(offsetof(struct ks__ProfileValidation, config) == 0x0, "ks__ProfileValidation.config offset");
_Static_assert(offsetof(struct ks__ProfileValidation, profileCMS) == 0x8, "ks__ProfileValidation.profileCMS offset");
_Static_assert(offsetof(struct ks__ProfileValidation, profileCtx) == 0x68, "ks__ProfileValidation.profileCtx offset");
_Static_assert(offsetof(struct ks__ProfileValidation, entCtx) == 0xB0, "ks__ProfileValidation.entCtx offset");
_Static_assert(offsetof(struct ks__ProfileValidation, entInit) == 0xF8, "ks__ProfileValidation.entInit offset");
_Static_assert(offsetof(struct ks__ProfileValidation, properties) == 0xFC, "ks__ProfileValidation.properties offset");
_Static_assert(offsetof(struct ks__ProfileValidation, profileInitialized) == 0x100, "ks__ProfileValidation.profileInitialized offset");
_Static_assert(offsetof(struct ks__ProfileValidation, profileVerified) == 0x101, "ks__ProfileValidation.profileVerified offset");
_Static_assert(offsetof(struct ks__ProfileValidation, profileTrusted) == 0x102, "ks__ProfileValidation.profileTrusted offset");
_Static_assert(sizeof(struct ks__ProfileValidation) == 0x108, "ks__ProfileValidation size");

/* refs: 3 */
struct ks__SignatureValidation {
    struct ks__CSConfig *config;
    struct ks__CSBuffer signatureBlob;
    struct ks__CSSuperBlobSafe superBlob;
    _Bool unusedBufferAllocated;
    _Bool signatureParsed;
    _Bool appContainerPath;
    struct ks__CSCodeDirectorySafe codeDirectory;
    unsigned char CDHash[0x14];
    struct ks__CEContext entCtx;
    _Bool entInit;
    unsigned char trustLevelInterim;
    unsigned char trustLevel;
    struct ks__ProfileValidation *profile;
    struct ks__CSBuffer leafCert;
};
_Static_assert(offsetof(struct ks__SignatureValidation, config) == 0x0, "ks__SignatureValidation.config offset");
_Static_assert(offsetof(struct ks__SignatureValidation, signatureBlob) == 0x8, "ks__SignatureValidation.signatureBlob offset");
_Static_assert(offsetof(struct ks__SignatureValidation, superBlob) == 0x18, "ks__SignatureValidation.superBlob offset");
_Static_assert(offsetof(struct ks__SignatureValidation, unusedBufferAllocated) == 0x28, "ks__SignatureValidation.unusedBufferAllocated offset");
_Static_assert(offsetof(struct ks__SignatureValidation, signatureParsed) == 0x29, "ks__SignatureValidation.signatureParsed offset");
_Static_assert(offsetof(struct ks__SignatureValidation, appContainerPath) == 0x2A, "ks__SignatureValidation.appContainerPath offset");
_Static_assert(offsetof(struct ks__SignatureValidation, codeDirectory) == 0x30, "ks__SignatureValidation.codeDirectory offset");
_Static_assert(offsetof(struct ks__SignatureValidation, CDHash) == 0x40, "ks__SignatureValidation.CDHash offset");
_Static_assert(offsetof(struct ks__SignatureValidation, entCtx) == 0x58, "ks__SignatureValidation.entCtx offset");
_Static_assert(offsetof(struct ks__SignatureValidation, entInit) == 0xA0, "ks__SignatureValidation.entInit offset");
_Static_assert(offsetof(struct ks__SignatureValidation, trustLevelInterim) == 0xA1, "ks__SignatureValidation.trustLevelInterim offset");
_Static_assert(offsetof(struct ks__SignatureValidation, trustLevel) == 0xA2, "ks__SignatureValidation.trustLevel offset");
_Static_assert(offsetof(struct ks__SignatureValidation, profile) == 0xA8, "ks__SignatureValidation.profile offset");
_Static_assert(offsetof(struct ks__SignatureValidation, leafCert) == 0xB0, "ks__SignatureValidation.leafCert offset");
_Static_assert(sizeof(struct ks__SignatureValidation) == 0xC0, "ks__SignatureValidation size");

/* refs: 3 */
struct ks__TCReturn {
    union {
        unsigned int rawValue;
        struct {
            unsigned char component;
            unsigned char error;
            unsigned short uniqueError;
        };
    };
};
_Static_assert(sizeof(struct ks__TCReturn) == 0x4, "ks__TCReturn size");

/* refs: 2 */
struct ks__TXMAddressSpaceID {
    unsigned short identifier;
    unsigned short type;
};
_Static_assert(offsetof(struct ks__TXMAddressSpaceID, identifier) == 0x0, "ks__TXMAddressSpaceID.identifier offset");
_Static_assert(offsetof(struct ks__TXMAddressSpaceID, type) == 0x2, "ks__TXMAddressSpaceID.type offset");
_Static_assert(sizeof(struct ks__TXMAddressSpaceID) == 0x4, "ks__TXMAddressSpaceID size");

/* refs: 2 */
struct ks__TXMCodeRegionRBTree {
    struct ks__TXMCodeRegion *rbh_root;
};
_Static_assert(offsetof(struct ks__TXMCodeRegionRBTree, rbh_root) == 0x0, "ks__TXMCodeRegionRBTree.rbh_root offset");
_Static_assert(sizeof(struct ks__TXMCodeRegionRBTree) == 0x8, "ks__TXMCodeRegionRBTree size");

/* refs: 2 */
struct ks__TXMTaggedPointer {
    union {
        unsigned __int128 raw;
        struct {
            unsigned long tag;
            unsigned long addr;
        };
    };
};
_Static_assert(sizeof(struct ks__TXMTaggedPointer) == 0x10, "ks__TXMTaggedPointer size");

/* refs: 4 */
struct ks__TXMSlabObject {
    struct ks__TXMTaggedPointer objectLink;
    unsigned char objectLock;
    _Bool objectActive;
} __attribute__((packed));
_Static_assert(offsetof(struct ks__TXMSlabObject, objectLink) == 0x0, "ks__TXMSlabObject.objectLink offset");
_Static_assert(offsetof(struct ks__TXMSlabObject, objectLock) == 0x10, "ks__TXMSlabObject.objectLock offset");
_Static_assert(offsetof(struct ks__TXMSlabObject, objectActive) == 0x11, "ks__TXMSlabObject.objectActive offset");
_Static_assert(sizeof(struct ks__TXMSlabObject) == 0x12, "ks__TXMSlabObject size");

/* refs: 3 */
struct ks__TXMAddressSpace {
    struct ks__TXMSlabObject slabObject;
    unsigned long long addrSpaceFlags;
    unsigned char remPerms;
    struct ks__TXMAddressSpaceID addrSpaceID;
    struct ks__TXMCodeRegionRBTree codeRegions;
    struct {
        _Atomic _Bool allowsInvalidCode;
        struct ks__TXMCodeRegion *sharedCacheRegionAllocation;
        struct ks__TXMCodeRegion *mainRegion;
        struct ks__TXMCodeRegion *sharedCacheRegion;
        struct ks__TXMCodeRegion *jitRegion;
    };
    struct {
        unsigned long baseAddr;
        unsigned long baseAddrEnd;
        unsigned int referenceCount;
    };
};
_Static_assert(offsetof(struct ks__TXMAddressSpace, slabObject) == 0x0, "ks__TXMAddressSpace.slabObject offset");
_Static_assert(offsetof(struct ks__TXMAddressSpace, addrSpaceFlags) == 0x18, "ks__TXMAddressSpace.addrSpaceFlags offset");
_Static_assert(offsetof(struct ks__TXMAddressSpace, remPerms) == 0x20, "ks__TXMAddressSpace.remPerms offset");
_Static_assert(offsetof(struct ks__TXMAddressSpace, addrSpaceID) == 0x22, "ks__TXMAddressSpace.addrSpaceID offset");
_Static_assert(offsetof(struct ks__TXMAddressSpace, codeRegions) == 0x28, "ks__TXMAddressSpace.codeRegions offset");
_Static_assert(sizeof(struct ks__TXMAddressSpace) == 0x70, "ks__TXMAddressSpace size");

/* refs: 9 */
struct ks__TXMCodeRegion {
    struct ks__TXMSlabObject slabObject;
    struct {
        unsigned char type : 7; /* bit offset 0 */
        unsigned char debugged : 1; /* bit offset 7 */
    } properties;
    union {
        struct {
            unsigned long offsetInFile;
            struct ks__TXMCodeSignature *codeSignature;
        } executable;
        struct {
            struct ks__TXMAddressSpace *nestedSpace;
        } sharedCache;
    };
    unsigned long addr;
    unsigned long addrEnd;
    struct {
        struct ks__TXMCodeRegion *rbe_left;
        struct ks__TXMCodeRegion *rbe_right;
        struct ks__TXMCodeRegion *rbe_parent;
    } RBLink;
};
_Static_assert(offsetof(struct ks__TXMCodeRegion, slabObject) == 0x0, "ks__TXMCodeRegion.slabObject offset");
_Static_assert(offsetof(struct ks__TXMCodeRegion, properties) == 0x12, "ks__TXMCodeRegion.properties offset");
_Static_assert(offsetof(struct ks__TXMCodeRegion, addr) == 0x28, "ks__TXMCodeRegion.addr offset");
_Static_assert(offsetof(struct ks__TXMCodeRegion, addrEnd) == 0x30, "ks__TXMCodeRegion.addrEnd offset");
_Static_assert(offsetof(struct ks__TXMCodeRegion, RBLink) == 0x38, "ks__TXMCodeRegion.RBLink offset");
_Static_assert(sizeof(struct ks__TXMCodeRegion) == 0x50, "ks__TXMCodeRegion size");

/* refs: 2 */
struct ks__TXMCodeSignature {
    struct ks__TXMSlabObject slabObject;
    unsigned char sptmType;
    unsigned int referenceCount;
    _Bool reconstituted;
    const void *kernelEntitlements;
    struct ks__SignatureValidation sig;
};
_Static_assert(offsetof(struct ks__TXMCodeSignature, slabObject) == 0x0, "ks__TXMCodeSignature.slabObject offset");
_Static_assert(offsetof(struct ks__TXMCodeSignature, sptmType) == 0x12, "ks__TXMCodeSignature.sptmType offset");
_Static_assert(offsetof(struct ks__TXMCodeSignature, referenceCount) == 0x14, "ks__TXMCodeSignature.referenceCount offset");
_Static_assert(offsetof(struct ks__TXMCodeSignature, reconstituted) == 0x18, "ks__TXMCodeSignature.reconstituted offset");
_Static_assert(offsetof(struct ks__TXMCodeSignature, kernelEntitlements) == 0x20, "ks__TXMCodeSignature.kernelEntitlements offset");
_Static_assert(offsetof(struct ks__TXMCodeSignature, sig) == 0x28, "ks__TXMCodeSignature.sig offset");
_Static_assert(sizeof(struct ks__TXMCodeSignature) == 0xE8, "ks__TXMCodeSignature size");

/* refs: 2 */
struct ks___CodeDirectory {
    unsigned int magic;
    unsigned int length;
    unsigned int version;
    unsigned int flags;
    unsigned int hashOffset;
    unsigned int identOffset;
    unsigned int nSpecialSlots;
    unsigned int nCodeSlots;
    unsigned int codeLimit;
    unsigned char hashSize;
    unsigned char hashType;
    unsigned char platform;
    unsigned char pageSize;
    unsigned int spare2;
    char end_earliest[0];
    unsigned int scatterOffset;
    char end_withScatter[0];
    unsigned int teamOffset;
    char end_withTeam[0];
    unsigned int spare3;
    unsigned long long codeLimit64;
    char end_withCodeLimit64[0];
    unsigned long long execSegBase;
    unsigned long long execSegLimit;
    unsigned long long execSegFlags;
    char end_withExecSeg[0];
    unsigned int runtime;
    unsigned int preEncryptOffset;
    char end_withPreEncryptOffset[0];
    unsigned char linkageHashType;
    unsigned char linkageApplicationType;
    unsigned short linkageApplicationSubType;
    unsigned int linkageOffset;
    unsigned int linkageSize;
    char end_withLinkage[0];
};
_Static_assert(offsetof(struct ks___CodeDirectory, magic) == 0x0, "ks___CodeDirectory.magic offset");
_Static_assert(offsetof(struct ks___CodeDirectory, length) == 0x4, "ks___CodeDirectory.length offset");
_Static_assert(offsetof(struct ks___CodeDirectory, version) == 0x8, "ks___CodeDirectory.version offset");
_Static_assert(offsetof(struct ks___CodeDirectory, flags) == 0xC, "ks___CodeDirectory.flags offset");
_Static_assert(offsetof(struct ks___CodeDirectory, hashOffset) == 0x10, "ks___CodeDirectory.hashOffset offset");
_Static_assert(offsetof(struct ks___CodeDirectory, identOffset) == 0x14, "ks___CodeDirectory.identOffset offset");
_Static_assert(offsetof(struct ks___CodeDirectory, nSpecialSlots) == 0x18, "ks___CodeDirectory.nSpecialSlots offset");
_Static_assert(offsetof(struct ks___CodeDirectory, nCodeSlots) == 0x1C, "ks___CodeDirectory.nCodeSlots offset");
_Static_assert(offsetof(struct ks___CodeDirectory, codeLimit) == 0x20, "ks___CodeDirectory.codeLimit offset");
_Static_assert(offsetof(struct ks___CodeDirectory, hashSize) == 0x24, "ks___CodeDirectory.hashSize offset");
_Static_assert(offsetof(struct ks___CodeDirectory, hashType) == 0x25, "ks___CodeDirectory.hashType offset");
_Static_assert(offsetof(struct ks___CodeDirectory, platform) == 0x26, "ks___CodeDirectory.platform offset");
_Static_assert(offsetof(struct ks___CodeDirectory, pageSize) == 0x27, "ks___CodeDirectory.pageSize offset");
_Static_assert(offsetof(struct ks___CodeDirectory, spare2) == 0x28, "ks___CodeDirectory.spare2 offset");
_Static_assert(offsetof(struct ks___CodeDirectory, end_earliest) == 0x2C, "ks___CodeDirectory.end_earliest offset");
_Static_assert(offsetof(struct ks___CodeDirectory, scatterOffset) == 0x2C, "ks___CodeDirectory.scatterOffset offset");
_Static_assert(offsetof(struct ks___CodeDirectory, end_withScatter) == 0x30, "ks___CodeDirectory.end_withScatter offset");
_Static_assert(offsetof(struct ks___CodeDirectory, teamOffset) == 0x30, "ks___CodeDirectory.teamOffset offset");
_Static_assert(offsetof(struct ks___CodeDirectory, end_withTeam) == 0x34, "ks___CodeDirectory.end_withTeam offset");
_Static_assert(offsetof(struct ks___CodeDirectory, spare3) == 0x34, "ks___CodeDirectory.spare3 offset");
_Static_assert(offsetof(struct ks___CodeDirectory, codeLimit64) == 0x38, "ks___CodeDirectory.codeLimit64 offset");
_Static_assert(offsetof(struct ks___CodeDirectory, end_withCodeLimit64) == 0x40, "ks___CodeDirectory.end_withCodeLimit64 offset");
_Static_assert(offsetof(struct ks___CodeDirectory, execSegBase) == 0x40, "ks___CodeDirectory.execSegBase offset");
_Static_assert(offsetof(struct ks___CodeDirectory, execSegLimit) == 0x48, "ks___CodeDirectory.execSegLimit offset");
_Static_assert(offsetof(struct ks___CodeDirectory, execSegFlags) == 0x50, "ks___CodeDirectory.execSegFlags offset");
_Static_assert(offsetof(struct ks___CodeDirectory, end_withExecSeg) == 0x58, "ks___CodeDirectory.end_withExecSeg offset");
_Static_assert(offsetof(struct ks___CodeDirectory, runtime) == 0x58, "ks___CodeDirectory.runtime offset");
_Static_assert(offsetof(struct ks___CodeDirectory, preEncryptOffset) == 0x5C, "ks___CodeDirectory.preEncryptOffset offset");
_Static_assert(offsetof(struct ks___CodeDirectory, end_withPreEncryptOffset) == 0x60, "ks___CodeDirectory.end_withPreEncryptOffset offset");
_Static_assert(offsetof(struct ks___CodeDirectory, linkageHashType) == 0x60, "ks___CodeDirectory.linkageHashType offset");
_Static_assert(offsetof(struct ks___CodeDirectory, linkageApplicationType) == 0x61, "ks___CodeDirectory.linkageApplicationType offset");
_Static_assert(offsetof(struct ks___CodeDirectory, linkageApplicationSubType) == 0x62, "ks___CodeDirectory.linkageApplicationSubType offset");
_Static_assert(offsetof(struct ks___CodeDirectory, linkageOffset) == 0x64, "ks___CodeDirectory.linkageOffset offset");
_Static_assert(offsetof(struct ks___CodeDirectory, linkageSize) == 0x68, "ks___CodeDirectory.linkageSize offset");
_Static_assert(offsetof(struct ks___CodeDirectory, end_withLinkage) == 0x6C, "ks___CodeDirectory.end_withLinkage offset");
_Static_assert(sizeof(struct ks___CodeDirectory) == 0x70, "ks___CodeDirectory size");

/* refs: 3 */
struct ks___SC_GenericBlob {
    unsigned int magic;
    unsigned int length;
    char data[];
};
_Static_assert(offsetof(struct ks___SC_GenericBlob, magic) == 0x0, "ks___SC_GenericBlob.magic offset");
_Static_assert(offsetof(struct ks___SC_GenericBlob, length) == 0x4, "ks___SC_GenericBlob.length offset");
_Static_assert(offsetof(struct ks___SC_GenericBlob, data) == 0x8, "ks___SC_GenericBlob.data offset");
_Static_assert(sizeof(struct ks___SC_GenericBlob) == 0x8, "ks___SC_GenericBlob size");

/* refs: 6 */
struct ks___bounds_safety__wide_ptr_bidi_indexable_4 {
    char *ptr;
    char *ub;
    char *lb;
} __attribute__((aligned(8)));
_Static_assert(offsetof(struct ks___bounds_safety__wide_ptr_bidi_indexable_4, ptr) == 0x0, "ks___bounds_safety__wide_ptr_bidi_indexable_4.ptr offset");
_Static_assert(offsetof(struct ks___bounds_safety__wide_ptr_bidi_indexable_4, ub) == 0x8, "ks___bounds_safety__wide_ptr_bidi_indexable_4.ub offset");
_Static_assert(offsetof(struct ks___bounds_safety__wide_ptr_bidi_indexable_4, lb) == 0x10, "ks___bounds_safety__wide_ptr_bidi_indexable_4.lb offset");
_Static_assert(sizeof(struct ks___bounds_safety__wide_ptr_bidi_indexable_4) == 0x18, "ks___bounds_safety__wide_ptr_bidi_indexable_4 size");

/* refs: 2 */
struct ks___buflet {
    unsigned long long __buflet_next;
    unsigned long long __baddr;
    unsigned int __bft_idx;
    unsigned int __bidx;
    unsigned int __nbft_idx;
    unsigned int __dlim;
    unsigned int __doff;
    unsigned int __dlen;
    unsigned short __flag;
} __attribute__((packed));
_Static_assert(offsetof(struct ks___buflet, __buflet_next) == 0x0, "ks___buflet.__buflet_next offset");
_Static_assert(offsetof(struct ks___buflet, __baddr) == 0x8, "ks___buflet.__baddr offset");
_Static_assert(offsetof(struct ks___buflet, __bft_idx) == 0x10, "ks___buflet.__bft_idx offset");
_Static_assert(offsetof(struct ks___buflet, __bidx) == 0x14, "ks___buflet.__bidx offset");
_Static_assert(offsetof(struct ks___buflet, __nbft_idx) == 0x18, "ks___buflet.__nbft_idx offset");
_Static_assert(offsetof(struct ks___buflet, __dlim) == 0x1C, "ks___buflet.__dlim offset");
_Static_assert(offsetof(struct ks___buflet, __doff) == 0x20, "ks___buflet.__doff offset");
_Static_assert(offsetof(struct ks___buflet, __dlen) == 0x24, "ks___buflet.__dlen offset");
_Static_assert(offsetof(struct ks___buflet, __flag) == 0x28, "ks___buflet.__flag offset");
_Static_assert(sizeof(struct ks___buflet) == 0x2A, "ks___buflet size");

/* refs: 1 */
struct ks___flow_classq {
    unsigned int _fcq_hash;
    unsigned int _fcq_flags;
};
_Static_assert(offsetof(struct ks___flow_classq, _fcq_hash) == 0x0, "ks___flow_classq._fcq_hash offset");
_Static_assert(offsetof(struct ks___flow_classq, _fcq_flags) == 0x4, "ks___flow_classq._fcq_flags offset");
_Static_assert(sizeof(struct ks___flow_classq) == 0x8, "ks___flow_classq size");

/* refs: 7 */
struct ks_in_addr {
    unsigned int s_addr;
};
_Static_assert(offsetof(struct ks_in_addr, s_addr) == 0x0, "ks_in_addr.s_addr offset");
_Static_assert(sizeof(struct ks_in_addr) == 0x4, "ks_in_addr size");

/* refs: 1 */
struct ks___flow_l3_ipv4_addrs {
    struct ks_in_addr _src;
    struct ks_in_addr _dst;
};
_Static_assert(offsetof(struct ks___flow_l3_ipv4_addrs, _src) == 0x0, "ks___flow_l3_ipv4_addrs._src offset");
_Static_assert(offsetof(struct ks___flow_l3_ipv4_addrs, _dst) == 0x4, "ks___flow_l3_ipv4_addrs._dst offset");
_Static_assert(sizeof(struct ks___flow_l3_ipv4_addrs) == 0x8, "ks___flow_l3_ipv4_addrs size");

/* refs: 12 */
struct ks_in6_addr {
    union {
        unsigned char __u6_addr8[0x10];
        unsigned short __u6_addr16[8];
        unsigned int __u6_addr32[4];
    } __u6_addr;
};
_Static_assert(offsetof(struct ks_in6_addr, __u6_addr) == 0x0, "ks_in6_addr.__u6_addr offset");
_Static_assert(sizeof(struct ks_in6_addr) == 0x10, "ks_in6_addr size");

/* refs: 1 */
struct ks___flow_l3_ipv6_addrs {
    struct ks_in6_addr _src;
    struct ks_in6_addr _dst;
};
_Static_assert(offsetof(struct ks___flow_l3_ipv6_addrs, _src) == 0x0, "ks___flow_l3_ipv6_addrs._src offset");
_Static_assert(offsetof(struct ks___flow_l3_ipv6_addrs, _dst) == 0x10, "ks___flow_l3_ipv6_addrs._dst offset");
_Static_assert(sizeof(struct ks___flow_l3_ipv6_addrs) == 0x20, "ks___flow_l3_ipv6_addrs size");

/* refs: 1 */
struct ks___flow_l3 {
    union {
        struct ks___flow_l3_ipv4_addrs _l3_ipv4;
        struct ks___flow_l3_ipv6_addrs _l3_ipv6;
    };
    unsigned char _l3_ip_ver;
    unsigned char _l3_proto;
    unsigned char _l3_hlen;
    unsigned int _l3_is_frag : 1; /* bit offset 280 */
    unsigned int _l3_is_first_frag : 1; /* bit offset 281 */
    unsigned int _l3_reserved_flags : 6; /* bit offset 282 */
    unsigned int _l3_frag_id;
    unsigned long long _l3_ptr;
};
_Static_assert(offsetof(struct ks___flow_l3, _l3_ip_ver) == 0x20, "ks___flow_l3._l3_ip_ver offset");
_Static_assert(offsetof(struct ks___flow_l3, _l3_proto) == 0x21, "ks___flow_l3._l3_proto offset");
_Static_assert(offsetof(struct ks___flow_l3, _l3_hlen) == 0x22, "ks___flow_l3._l3_hlen offset");
_Static_assert(offsetof(struct ks___flow_l3, _l3_frag_id) == 0x24, "ks___flow_l3._l3_frag_id offset");
_Static_assert(offsetof(struct ks___flow_l3, _l3_ptr) == 0x28, "ks___flow_l3._l3_ptr offset");
_Static_assert(sizeof(struct ks___flow_l3) == 0x30, "ks___flow_l3 size");

/* refs: 1 */
struct ks___flow_policy {
    unsigned int _fpc_id;
    unsigned int _fpc_skip_id;
    union {
        unsigned long long _fpc_euuid_64[2];
        unsigned int _fpc_euuid_32[4];
        unsigned char _fpc_euuid[0x10];
    } __attribute__((aligned(8)));
};
_Static_assert(offsetof(struct ks___flow_policy, _fpc_id) == 0x0, "ks___flow_policy._fpc_id offset");
_Static_assert(offsetof(struct ks___flow_policy, _fpc_skip_id) == 0x4, "ks___flow_policy._fpc_skip_id offset");
_Static_assert(sizeof(struct ks___flow_policy) == 0x18, "ks___flow_policy size");

/* refs: 1 */
struct ks___flow_source {
    union {
        unsigned long long _fsrc_id_64[2];
        unsigned int _fsrc_id_32[4];
        unsigned char _fsrc_id[0x10];
    } __attribute__((aligned(8)));
    unsigned int _fsrc_fidx;
    unsigned char _fsrc_type;
    unsigned char _fsrc_pad[3];
};
_Static_assert(offsetof(struct ks___flow_source, _fsrc_fidx) == 0x10, "ks___flow_source._fsrc_fidx offset");
_Static_assert(offsetof(struct ks___flow_source, _fsrc_type) == 0x14, "ks___flow_source._fsrc_type offset");
_Static_assert(offsetof(struct ks___flow_source, _fsrc_pad) == 0x15, "ks___flow_source._fsrc_pad offset");
_Static_assert(sizeof(struct ks___flow_source) == 0x18, "ks___flow_source size");

/* refs: 1 */
struct ks___flow_init {
    struct ks___flow_l3 __l3;
    struct ks___flow_classq __classq;
    unsigned int __ulen;
    unsigned char __ulp_encap;
    unsigned char __pad[3];
    unsigned long long __pad64[2];
    struct ks___flow_source __source;
    struct ks___flow_policy __policy;
};
_Static_assert(offsetof(struct ks___flow_init, __l3) == 0x0, "ks___flow_init.__l3 offset");
_Static_assert(offsetof(struct ks___flow_init, __classq) == 0x30, "ks___flow_init.__classq offset");
_Static_assert(offsetof(struct ks___flow_init, __ulen) == 0x38, "ks___flow_init.__ulen offset");
_Static_assert(offsetof(struct ks___flow_init, __ulp_encap) == 0x3C, "ks___flow_init.__ulp_encap offset");
_Static_assert(offsetof(struct ks___flow_init, __pad) == 0x3D, "ks___flow_init.__pad offset");
_Static_assert(offsetof(struct ks___flow_init, __pad64) == 0x40, "ks___flow_init.__pad64 offset");
_Static_assert(offsetof(struct ks___flow_init, __source) == 0x50, "ks___flow_init.__source offset");
_Static_assert(offsetof(struct ks___flow_init, __policy) == 0x68, "ks___flow_init.__policy offset");
_Static_assert(sizeof(struct ks___flow_init) == 0x80, "ks___flow_init size");

/* refs: 1 */
struct ks___flow_l4_esp {
    unsigned int _spi;
};
_Static_assert(offsetof(struct ks___flow_l4_esp, _spi) == 0x0, "ks___flow_l4_esp._spi offset");
_Static_assert(sizeof(struct ks___flow_l4_esp) == 0x4, "ks___flow_l4_esp size");

/* refs: 1 */
struct ks___flow_l4_tcp {
    unsigned short _src;
    unsigned short _dst;
    unsigned int _seq;
    unsigned int _ack;
    union {
        struct {
            unsigned char _tcp_res : 4; /* bit offset 0 */
            unsigned char _off : 4; /* bit offset 4 */
            unsigned char _flags;
            unsigned short _win;
        };
        unsigned int _ofw;
    };
};
_Static_assert(offsetof(struct ks___flow_l4_tcp, _src) == 0x0, "ks___flow_l4_tcp._src offset");
_Static_assert(offsetof(struct ks___flow_l4_tcp, _dst) == 0x2, "ks___flow_l4_tcp._dst offset");
_Static_assert(offsetof(struct ks___flow_l4_tcp, _seq) == 0x4, "ks___flow_l4_tcp._seq offset");
_Static_assert(offsetof(struct ks___flow_l4_tcp, _ack) == 0x8, "ks___flow_l4_tcp._ack offset");
_Static_assert(sizeof(struct ks___flow_l4_tcp) == 0x10, "ks___flow_l4_tcp size");

/* refs: 1 */
struct ks___flow_l4_udp {
    unsigned short _src;
    unsigned short _dst;
    unsigned int _ls;
};
_Static_assert(offsetof(struct ks___flow_l4_udp, _src) == 0x0, "ks___flow_l4_udp._src offset");
_Static_assert(offsetof(struct ks___flow_l4_udp, _dst) == 0x2, "ks___flow_l4_udp._dst offset");
_Static_assert(offsetof(struct ks___flow_l4_udp, _ls) == 0x4, "ks___flow_l4_udp._ls offset");
_Static_assert(sizeof(struct ks___flow_l4_udp) == 0x8, "ks___flow_l4_udp size");

/* refs: 1 */
struct ks___flow_l4 {
    union {
        struct ks___flow_l4_tcp _l4_tcp;
        struct ks___flow_l4_udp _l4_udp;
        struct ks___flow_l4_esp _l4_esp;
    };
    unsigned char _l4_hlen;
    unsigned char _l4_agg_fast;
    unsigned char _l4_pad[6];
    unsigned long long _l4_ptr;
};
_Static_assert(offsetof(struct ks___flow_l4, _l4_hlen) == 0x10, "ks___flow_l4._l4_hlen offset");
_Static_assert(offsetof(struct ks___flow_l4, _l4_agg_fast) == 0x11, "ks___flow_l4._l4_agg_fast offset");
_Static_assert(offsetof(struct ks___flow_l4, _l4_pad) == 0x12, "ks___flow_l4._l4_pad offset");
_Static_assert(offsetof(struct ks___flow_l4, _l4_ptr) == 0x18, "ks___flow_l4._l4_ptr offset");
_Static_assert(sizeof(struct ks___flow_l4) == 0x20, "ks___flow_l4 size");

/* refs: 1 */
struct ks___flow {
    union {
        struct ks___flow_init flow_init;
        unsigned long long flow_init_data[0x10];
    } __attribute__((aligned(16)));
    union {
        struct ks___flow_l4 flow_l4;
        unsigned long long flow_l4_data[4];
    } __attribute__((aligned(8)));
} __attribute__((aligned(16)));
_Static_assert(sizeof(struct ks___flow) == 0xA0, "ks___flow size");

/* refs: 2 */
struct ks___kern_buflet {
    struct ks___buflet buf_com;
    const struct ks_skmem_bufctl *buf_ctl;
} __attribute__((packed));
_Static_assert(offsetof(struct ks___kern_buflet, buf_com) == 0x0, "ks___kern_buflet.buf_com offset");
_Static_assert(offsetof(struct ks___kern_buflet, buf_ctl) == 0x2A, "ks___kern_buflet.buf_ctl offset");
_Static_assert(sizeof(struct ks___kern_buflet) == 0x32, "ks___kern_buflet size");

/* refs: 2 */
union ks_lck_mtx_state {
    struct {
        unsigned int owner : 28; /* bit offset 0 */
        unsigned int ilocked : 1; /* bit offset 28 */
        unsigned int spin_mode : 1; /* bit offset 29 */
        unsigned int needs_wakeup : 1; /* bit offset 30 */
        unsigned int profile : 1; /* bit offset 31 */
        unsigned short ilk_tail;
        unsigned short as_tail;
    };
    unsigned int data;
    unsigned long long val;
};
_Static_assert(offsetof(union ks_lck_mtx_state, data) == 0x0, "ks_lck_mtx_state.data offset");
_Static_assert(offsetof(union ks_lck_mtx_state, val) == 0x0, "ks_lck_mtx_state.val offset");

/* refs: 80 */
struct ks_lck_mtx_s {
    unsigned int lck_mtx_tsid : 24; /* bit offset 0 */
    unsigned char lck_mtx_type : 8; /* bit offset 24 */
    unsigned int lck_mtx_grp;
    union ks_lck_mtx_state lck_mtx;
};
_Static_assert(offsetof(struct ks_lck_mtx_s, lck_mtx_grp) == 0x4, "ks_lck_mtx_s.lck_mtx_grp offset");
_Static_assert(offsetof(struct ks_lck_mtx_s, lck_mtx) == 0x8, "ks_lck_mtx_s.lck_mtx offset");
_Static_assert(sizeof(struct ks_lck_mtx_s) == 0x10, "ks_lck_mtx_s size");

/* refs: 8 */
struct ks_klist {
    struct ks_knote *slh_first;
};
_Static_assert(offsetof(struct ks_klist, slh_first) == 0x0, "ks_klist.slh_first offset");
_Static_assert(sizeof(struct ks_klist) == 0x8, "ks_klist size");

/* refs: 12 */
struct ks_circle_queue_head {
    struct ks_queue_entry *head;
};
_Static_assert(offsetof(struct ks_circle_queue_head, head) == 0x0, "ks_circle_queue_head.head offset");
_Static_assert(sizeof(struct ks_circle_queue_head) == 0x8, "ks_circle_queue_head size");

/* refs: 7 */
struct ks_mpsc_queue_chain {
    struct ks_mpsc_queue_chain * _Atomic mpqc_next;
};
_Static_assert(offsetof(struct ks_mpsc_queue_chain, mpqc_next) == 0x0, "ks_mpsc_queue_chain.mpqc_next offset");
_Static_assert(sizeof(struct ks_mpsc_queue_chain) == 0x8, "ks_mpsc_queue_chain size");

/* refs: 11 */
struct ks_priority_queue_sched_max {
    struct ks_priority_queue_entry_sched *pq_root;
};
_Static_assert(offsetof(struct ks_priority_queue_sched_max, pq_root) == 0x0, "ks_priority_queue_sched_max.pq_root offset");
_Static_assert(sizeof(struct ks_priority_queue_sched_max) == 0x8, "ks_priority_queue_sched_max size");

/* refs: 4 */
struct ks_waitq_link_list_entry {
    struct ks_waitq_link_list_entry *next;
};
_Static_assert(offsetof(struct ks_waitq_link_list_entry, next) == 0x0, "ks_waitq_link_list_entry.next offset");
_Static_assert(sizeof(struct ks_waitq_link_list_entry) == 0x8, "ks_waitq_link_list_entry size");

/* refs: 8 */
union ks_hw_lck_ticket_s {
    struct {
        unsigned char lck_type;
        unsigned char lck_valid : 1; /* bit offset 8 */
        unsigned char lck_is_pv : 1; /* bit offset 9 */
        unsigned char lck_unused : 6; /* bit offset 10 */
        union {
            struct {
                unsigned char cticket;
                unsigned char nticket;
            };
            unsigned short tcurnext;
        };
    };
    unsigned int lck_value;
};
_Static_assert(offsetof(union ks_hw_lck_ticket_s, lck_value) == 0x0, "ks_hw_lck_ticket_s.lck_value offset");

/* refs: 4 */
struct ks_waitq {
    struct {
        unsigned int waitq_type : 3; /* bit offset 0 */
        unsigned int waitq_fifo : 1; /* bit offset 3 */
        unsigned int waitq_preposted : 1; /* bit offset 4 */
        unsigned int waitq_eventmask : 27; /* bit offset 5 */
    };
    union ks_hw_lck_ticket_s waitq_interlock;
    unsigned char waitq_padding[0];
    union {
        struct ks_circle_queue_head waitq_queue;
        struct ks_priority_queue_sched_max waitq_prio_queue;
        struct ks_turnstile *waitq_ts;
    };
    union {
        struct ks_circle_queue_head waitq_links;
        struct ks_waitq_link_list_entry waitq_sellinks;
        void *waitq_inheritor;
        struct ks_mpsc_queue_chain waitq_defer;
    };
} __attribute__((aligned(8)));
_Static_assert(offsetof(struct ks_waitq, waitq_interlock) == 0x4, "ks_waitq.waitq_interlock offset");
_Static_assert(offsetof(struct ks_waitq, waitq_padding) == 0x8, "ks_waitq.waitq_padding offset");
_Static_assert(sizeof(struct ks_waitq) == 0x18, "ks_waitq size");

/* refs: 5 */
struct ks_selinfo {
    union {
        struct ks_waitq si_waitq __attribute__((aligned(8)));
        unsigned char si_waitq_storage[0x28];
    };
    struct ks_klist si_note;
    unsigned int si_flags;
};
_Static_assert(offsetof(struct ks_selinfo, si_note) == 0x28, "ks_selinfo.si_note offset");
_Static_assert(offsetof(struct ks_selinfo, si_flags) == 0x30, "ks_selinfo.si_flags offset");
_Static_assert(sizeof(struct ks_selinfo) == 0x38, "ks_selinfo size");

/* refs: 3 */
struct ks_ch_selinfo {
    struct ks_lck_mtx_s csi_lock;
    struct ks_selinfo csi_si;
    unsigned int csi_flags;
    unsigned int csi_pending;
    unsigned long long csi_eff_interval;
    unsigned long long csi_interval;
    struct ks_thread_call *csi_tcall;
};
_Static_assert(offsetof(struct ks_ch_selinfo, csi_lock) == 0x0, "ks_ch_selinfo.csi_lock offset");
_Static_assert(offsetof(struct ks_ch_selinfo, csi_si) == 0x10, "ks_ch_selinfo.csi_si offset");
_Static_assert(offsetof(struct ks_ch_selinfo, csi_flags) == 0x48, "ks_ch_selinfo.csi_flags offset");
_Static_assert(offsetof(struct ks_ch_selinfo, csi_pending) == 0x4C, "ks_ch_selinfo.csi_pending offset");
_Static_assert(offsetof(struct ks_ch_selinfo, csi_eff_interval) == 0x50, "ks_ch_selinfo.csi_eff_interval offset");
_Static_assert(offsetof(struct ks_ch_selinfo, csi_interval) == 0x58, "ks_ch_selinfo.csi_interval offset");
_Static_assert(offsetof(struct ks_ch_selinfo, csi_tcall) == 0x60, "ks_ch_selinfo.csi_tcall offset");
_Static_assert(sizeof(struct ks_ch_selinfo) == 0x68, "ks_ch_selinfo size");

/* refs: 2 */
struct ks_channel_ring_error_stats {
    unsigned int cres_pkt_alloc_failures;
    unsigned int __cres_reserved[1];
};
_Static_assert(offsetof(struct ks_channel_ring_error_stats, cres_pkt_alloc_failures) == 0x0, "ks_channel_ring_error_stats.cres_pkt_alloc_failures offset");
_Static_assert(offsetof(struct ks_channel_ring_error_stats, __cres_reserved) == 0x4, "ks_channel_ring_error_stats.__cres_reserved offset");
_Static_assert(sizeof(struct ks_channel_ring_error_stats) == 0x8, "ks_channel_ring_error_stats size");

/* refs: 2 */
struct ks_channel_ring_stats {
    unsigned long long crs_total_slots_transferred;
    unsigned long long crs_total_bytes_transferred;
    unsigned long long crs_number_of_transfers;
    unsigned long long crs_last_update_net_uptime;
    unsigned long long crs_slots_per_second;
    unsigned long long crs_slots_per_second_ma;
    unsigned long long crs_bytes_per_second;
    unsigned long long crs_bytes_per_second_ma;
    unsigned int crs_min_slots_transferred;
    unsigned int crs_max_slots_transferred;
};
_Static_assert(offsetof(struct ks_channel_ring_stats, crs_total_slots_transferred) == 0x0, "ks_channel_ring_stats.crs_total_slots_transferred offset");
_Static_assert(offsetof(struct ks_channel_ring_stats, crs_total_bytes_transferred) == 0x8, "ks_channel_ring_stats.crs_total_bytes_transferred offset");
_Static_assert(offsetof(struct ks_channel_ring_stats, crs_number_of_transfers) == 0x10, "ks_channel_ring_stats.crs_number_of_transfers offset");
_Static_assert(offsetof(struct ks_channel_ring_stats, crs_last_update_net_uptime) == 0x18, "ks_channel_ring_stats.crs_last_update_net_uptime offset");
_Static_assert(offsetof(struct ks_channel_ring_stats, crs_slots_per_second) == 0x20, "ks_channel_ring_stats.crs_slots_per_second offset");
_Static_assert(offsetof(struct ks_channel_ring_stats, crs_slots_per_second_ma) == 0x28, "ks_channel_ring_stats.crs_slots_per_second_ma offset");
_Static_assert(offsetof(struct ks_channel_ring_stats, crs_bytes_per_second) == 0x30, "ks_channel_ring_stats.crs_bytes_per_second offset");
_Static_assert(offsetof(struct ks_channel_ring_stats, crs_bytes_per_second_ma) == 0x38, "ks_channel_ring_stats.crs_bytes_per_second_ma offset");
_Static_assert(offsetof(struct ks_channel_ring_stats, crs_min_slots_transferred) == 0x40, "ks_channel_ring_stats.crs_min_slots_transferred offset");
_Static_assert(offsetof(struct ks_channel_ring_stats, crs_max_slots_transferred) == 0x44, "ks_channel_ring_stats.crs_max_slots_transferred offset");
_Static_assert(sizeof(struct ks_channel_ring_stats) == 0x48, "ks_channel_ring_stats size");

/* refs: 2 */
struct ks_channel_ring_user_stats {
    unsigned long long crsu_total_slots_transferred;
    unsigned long long crsu_total_bytes_transferred;
    unsigned long long crsu_number_of_syncs;
    unsigned long long crsu_bytes_per_sync;
    unsigned long long crsu_bytes_per_sync_ma;
    unsigned int crsu_min_slots_transferred;
    unsigned int crsu_max_slots_transferred;
    unsigned int crsu_slots_per_sync;
    unsigned int crsu_slots_per_sync_ma;
};
_Static_assert(offsetof(struct ks_channel_ring_user_stats, crsu_total_slots_transferred) == 0x0, "ks_channel_ring_user_stats.crsu_total_slots_transferred offset");
_Static_assert(offsetof(struct ks_channel_ring_user_stats, crsu_total_bytes_transferred) == 0x8, "ks_channel_ring_user_stats.crsu_total_bytes_transferred offset");
_Static_assert(offsetof(struct ks_channel_ring_user_stats, crsu_number_of_syncs) == 0x10, "ks_channel_ring_user_stats.crsu_number_of_syncs offset");
_Static_assert(offsetof(struct ks_channel_ring_user_stats, crsu_bytes_per_sync) == 0x18, "ks_channel_ring_user_stats.crsu_bytes_per_sync offset");
_Static_assert(offsetof(struct ks_channel_ring_user_stats, crsu_bytes_per_sync_ma) == 0x20, "ks_channel_ring_user_stats.crsu_bytes_per_sync_ma offset");
_Static_assert(offsetof(struct ks_channel_ring_user_stats, crsu_min_slots_transferred) == 0x28, "ks_channel_ring_user_stats.crsu_min_slots_transferred offset");
_Static_assert(offsetof(struct ks_channel_ring_user_stats, crsu_max_slots_transferred) == 0x2C, "ks_channel_ring_user_stats.crsu_max_slots_transferred offset");
_Static_assert(offsetof(struct ks_channel_ring_user_stats, crsu_slots_per_sync) == 0x30, "ks_channel_ring_user_stats.crsu_slots_per_sync offset");
_Static_assert(offsetof(struct ks_channel_ring_user_stats, crsu_slots_per_sync_ma) == 0x34, "ks_channel_ring_user_stats.crsu_slots_per_sync_ma offset");
_Static_assert(sizeof(struct ks_channel_ring_user_stats) == 0x38, "ks_channel_ring_user_stats size");

/* refs: 1 */
struct ks_hslock {
    unsigned long lock_data;
};
_Static_assert(offsetof(struct ks_hslock, lock_data) == 0x0, "ks_hslock.lock_data offset");
_Static_assert(sizeof(struct ks_hslock) == 0x8, "ks_hslock size");

/* refs: 15 */
struct ks_lck_spin_s {
    struct ks_hslock hwlock;
    unsigned long type;
};
_Static_assert(offsetof(struct ks_lck_spin_s, hwlock) == 0x0, "ks_lck_spin_s.hwlock offset");
_Static_assert(offsetof(struct ks_lck_spin_s, type) == 0x8, "ks_lck_spin_s.type offset");
_Static_assert(sizeof(struct ks_lck_spin_s) == 0x10, "ks_lck_spin_s size");

/* refs: 1 */
struct ks_kq_head {
    struct ks___kern_packet *kq_first;
    struct ks___kern_packet **kq_last;
    unsigned int kq_len;
};
_Static_assert(offsetof(struct ks_kq_head, kq_first) == 0x0, "ks_kq_head.kq_first offset");
_Static_assert(offsetof(struct ks_kq_head, kq_last) == 0x8, "ks_kq_head.kq_last offset");
_Static_assert(offsetof(struct ks_kq_head, kq_len) == 0x10, "ks_kq_head.kq_len offset");
_Static_assert(sizeof(struct ks_kq_head) == 0x18, "ks_kq_head size");

/* refs: 1 */
struct ks_mq_head {
    struct ks_mbuf *mq_first;
    struct ks_mbuf **mq_last;
};
_Static_assert(offsetof(struct ks_mq_head, mq_first) == 0x0, "ks_mq_head.mq_first offset");
_Static_assert(offsetof(struct ks_mq_head, mq_last) == 0x8, "ks_mq_head.mq_last offset");
_Static_assert(sizeof(struct ks_mq_head) == 0x10, "ks_mq_head size");

/* refs: 4 */
struct ks__class_queue_ {
    union {
        struct ks_mq_head __mbufq;
        struct ks_kq_head __kpktq;
    } __pktq_u;
    unsigned int qlen;
    unsigned int qlim;
    unsigned long long qsize;
    unsigned int qtype;
    unsigned int qstate;
    unsigned int qptype;
};
_Static_assert(offsetof(struct ks__class_queue_, __pktq_u) == 0x0, "ks__class_queue_.__pktq_u offset");
_Static_assert(offsetof(struct ks__class_queue_, qlen) == 0x18, "ks__class_queue_.qlen offset");
_Static_assert(offsetof(struct ks__class_queue_, qlim) == 0x1C, "ks__class_queue_.qlim offset");
_Static_assert(offsetof(struct ks__class_queue_, qsize) == 0x20, "ks__class_queue_.qsize offset");
_Static_assert(offsetof(struct ks__class_queue_, qtype) == 0x28, "ks__class_queue_.qtype offset");
_Static_assert(offsetof(struct ks__class_queue_, qstate) == 0x2C, "ks__class_queue_.qstate offset");
_Static_assert(offsetof(struct ks__class_queue_, qptype) == 0x30, "ks__class_queue_.qptype offset");
_Static_assert(sizeof(struct ks__class_queue_) == 0x38, "ks__class_queue_ size");

/* refs: 2 */
struct ks_nx_mbq {
    struct ks_lck_mtx_s nx_mbq_lock;
    struct ks__class_queue_ nx_mbq_q;
    struct ks__lck_grp_ *nx_mbq_grp;
    struct ks___kern_channel_ring *nx_mbq_kring;
};
_Static_assert(offsetof(struct ks_nx_mbq, nx_mbq_lock) == 0x0, "ks_nx_mbq.nx_mbq_lock offset");
_Static_assert(offsetof(struct ks_nx_mbq, nx_mbq_q) == 0x10, "ks_nx_mbq.nx_mbq_q offset");
_Static_assert(offsetof(struct ks_nx_mbq, nx_mbq_grp) == 0x48, "ks_nx_mbq.nx_mbq_grp offset");
_Static_assert(offsetof(struct ks_nx_mbq, nx_mbq_kring) == 0x50, "ks_nx_mbq.nx_mbq_kring offset");
_Static_assert(sizeof(struct ks_nx_mbq) == 0x58, "ks_nx_mbq size");

/* refs: 18 */
struct ks___kern_channel_ring {
    struct ks___user_channel_ring *ckr_ring;
    unsigned int ckr_flags;
    unsigned int ckr_num_slots;
    unsigned int ckr_max_pkt_len;
    unsigned int ckr_largest;
    unsigned int ckr_lim;
    unsigned int ckr_tx;
    unsigned int ckr_khead;
    unsigned int ckr_ktail;
    unsigned int ckr_khead_pre;
    unsigned int ckr_rhead;
    unsigned int ckr_rtail;
    unsigned int ckr_transfer_decay;
    unsigned long long ckr_ready_bytes;
    unsigned long long ckr_ready_slots;
    struct ks_lck_spin_s ckr_slock;
    struct ks_thread *ckr_owner;
    unsigned int ckr_busy;
    unsigned int ckr_want;
    unsigned int ckr_state;
    unsigned int ckr_alloc_ws;
    struct ks_nexus_adapter *ckr_na;
    struct ks_kern_pbufpool *ckr_pp;
    struct ks___slot_desc *ckr_usds;
    unsigned int ckr_usds_cnt;
    struct ks___slot_desc *ckr_ksds;
    unsigned int ckr_ksds_cnt;
    struct ks___slot_desc *ckr_ksds_last;
    struct ks_skmem_cache *ckr_ksds_cache;
    unsigned int ckr_ring_id;
    int ckr_rate_limited;
    unsigned long long *ckr_scratch;
    unsigned int ckr_scratch_cnt;
    int *ckr_na_sync;
    volatile int *ckr_na_notify;
    int *ckr_prologue;
    void *ckr_finalize;
    unsigned long long ckr_sync_time;
    int *ckr_save_notify;
    int ckr_svc;
    unsigned int ckr_slot_ctxs_set;
    struct ks_slot_ctx *ckr_slot_ctxs;
    unsigned int ckr_slot_ctxs_cnt;
    void *ckr_ctx;
    struct ks_ch_selinfo ckr_si;
    int *ckr_netif_notify;
    void *ckr_netif_mit_stats;
    struct ks_nx_netif_mit *ckr_mit;
    unsigned int ckr_pending_intr;
    unsigned int ckr_pending_doorbell;
    struct ks_mbuf **ckr_tx_pool;
    unsigned int ckr_tx_pool_count;
    struct ks_nx_mbq ckr_rx_queue;
    struct ks___kern_channel_ring *ckr_pipe;
    struct ks___user_channel_ring *ckr_save_ring;
    struct ks_lck_mtx_s ckr_qlock;
    unsigned int ckr_users;
    long long ckr_tbr_token;
    long long ckr_tbr_depth;
    unsigned long long ckr_tbr_last;
    struct ks_channel_ring_error_stats ckr_err_stats __attribute__((aligned(64)));
    struct ks_channel_ring_stats ckr_stats __attribute__((aligned(64)));
    unsigned long long ckr_accumulated_bytes;
    unsigned long long ckr_accumulated_slots;
    unsigned long long ckr_accumulate_start;
    struct ks_channel_ring_user_stats ckr_usr_stats __attribute__((aligned(64)));
    unsigned long long ckr_user_accumulated_bytes;
    unsigned long long ckr_user_accumulated_slots;
    unsigned long long ckr_user_accumulated_syncs;
    unsigned long long ckr_user_accumulate_start;
    struct ks__lck_grp_ *ckr_qlock_group;
    struct ks__lck_grp_ *ckr_slock_group;
    char ckr_name[0x40];
    unsigned long long ckr_rx_dequeue_ts;
    unsigned long long ckr_rx_enqueue_ts;
} __attribute__((aligned(128)));
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_ring) == 0x0, "ks___kern_channel_ring.ckr_ring offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_flags) == 0x8, "ks___kern_channel_ring.ckr_flags offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_num_slots) == 0xC, "ks___kern_channel_ring.ckr_num_slots offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_max_pkt_len) == 0x10, "ks___kern_channel_ring.ckr_max_pkt_len offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_largest) == 0x14, "ks___kern_channel_ring.ckr_largest offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_lim) == 0x18, "ks___kern_channel_ring.ckr_lim offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_tx) == 0x1C, "ks___kern_channel_ring.ckr_tx offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_khead) == 0x20, "ks___kern_channel_ring.ckr_khead offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_ktail) == 0x24, "ks___kern_channel_ring.ckr_ktail offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_khead_pre) == 0x28, "ks___kern_channel_ring.ckr_khead_pre offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_rhead) == 0x2C, "ks___kern_channel_ring.ckr_rhead offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_rtail) == 0x30, "ks___kern_channel_ring.ckr_rtail offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_transfer_decay) == 0x34, "ks___kern_channel_ring.ckr_transfer_decay offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_ready_bytes) == 0x38, "ks___kern_channel_ring.ckr_ready_bytes offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_ready_slots) == 0x40, "ks___kern_channel_ring.ckr_ready_slots offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_slock) == 0x48, "ks___kern_channel_ring.ckr_slock offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_owner) == 0x58, "ks___kern_channel_ring.ckr_owner offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_busy) == 0x60, "ks___kern_channel_ring.ckr_busy offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_want) == 0x64, "ks___kern_channel_ring.ckr_want offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_state) == 0x68, "ks___kern_channel_ring.ckr_state offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_alloc_ws) == 0x6C, "ks___kern_channel_ring.ckr_alloc_ws offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_na) == 0x70, "ks___kern_channel_ring.ckr_na offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_pp) == 0x78, "ks___kern_channel_ring.ckr_pp offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_usds) == 0x80, "ks___kern_channel_ring.ckr_usds offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_usds_cnt) == 0x88, "ks___kern_channel_ring.ckr_usds_cnt offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_ksds) == 0x90, "ks___kern_channel_ring.ckr_ksds offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_ksds_cnt) == 0x98, "ks___kern_channel_ring.ckr_ksds_cnt offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_ksds_last) == 0xA0, "ks___kern_channel_ring.ckr_ksds_last offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_ksds_cache) == 0xA8, "ks___kern_channel_ring.ckr_ksds_cache offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_ring_id) == 0xB0, "ks___kern_channel_ring.ckr_ring_id offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_rate_limited) == 0xB4, "ks___kern_channel_ring.ckr_rate_limited offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_scratch) == 0xB8, "ks___kern_channel_ring.ckr_scratch offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_scratch_cnt) == 0xC0, "ks___kern_channel_ring.ckr_scratch_cnt offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_na_sync) == 0xC8, "ks___kern_channel_ring.ckr_na_sync offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_na_notify) == 0xD0, "ks___kern_channel_ring.ckr_na_notify offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_prologue) == 0xD8, "ks___kern_channel_ring.ckr_prologue offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_finalize) == 0xE0, "ks___kern_channel_ring.ckr_finalize offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_sync_time) == 0xE8, "ks___kern_channel_ring.ckr_sync_time offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_save_notify) == 0xF0, "ks___kern_channel_ring.ckr_save_notify offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_svc) == 0xF8, "ks___kern_channel_ring.ckr_svc offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_slot_ctxs_set) == 0xFC, "ks___kern_channel_ring.ckr_slot_ctxs_set offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_slot_ctxs) == 0x100, "ks___kern_channel_ring.ckr_slot_ctxs offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_slot_ctxs_cnt) == 0x108, "ks___kern_channel_ring.ckr_slot_ctxs_cnt offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_ctx) == 0x110, "ks___kern_channel_ring.ckr_ctx offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_si) == 0x118, "ks___kern_channel_ring.ckr_si offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_netif_notify) == 0x180, "ks___kern_channel_ring.ckr_netif_notify offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_netif_mit_stats) == 0x188, "ks___kern_channel_ring.ckr_netif_mit_stats offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_mit) == 0x190, "ks___kern_channel_ring.ckr_mit offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_pending_intr) == 0x198, "ks___kern_channel_ring.ckr_pending_intr offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_pending_doorbell) == 0x19C, "ks___kern_channel_ring.ckr_pending_doorbell offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_tx_pool) == 0x1A0, "ks___kern_channel_ring.ckr_tx_pool offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_tx_pool_count) == 0x1A8, "ks___kern_channel_ring.ckr_tx_pool_count offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_rx_queue) == 0x1B0, "ks___kern_channel_ring.ckr_rx_queue offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_pipe) == 0x208, "ks___kern_channel_ring.ckr_pipe offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_save_ring) == 0x210, "ks___kern_channel_ring.ckr_save_ring offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_qlock) == 0x218, "ks___kern_channel_ring.ckr_qlock offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_users) == 0x228, "ks___kern_channel_ring.ckr_users offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_tbr_token) == 0x230, "ks___kern_channel_ring.ckr_tbr_token offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_tbr_depth) == 0x238, "ks___kern_channel_ring.ckr_tbr_depth offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_tbr_last) == 0x240, "ks___kern_channel_ring.ckr_tbr_last offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_err_stats) == 0x280, "ks___kern_channel_ring.ckr_err_stats offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_stats) == 0x2C0, "ks___kern_channel_ring.ckr_stats offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_accumulated_bytes) == 0x308, "ks___kern_channel_ring.ckr_accumulated_bytes offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_accumulated_slots) == 0x310, "ks___kern_channel_ring.ckr_accumulated_slots offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_accumulate_start) == 0x318, "ks___kern_channel_ring.ckr_accumulate_start offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_usr_stats) == 0x340, "ks___kern_channel_ring.ckr_usr_stats offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_user_accumulated_bytes) == 0x378, "ks___kern_channel_ring.ckr_user_accumulated_bytes offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_user_accumulated_slots) == 0x380, "ks___kern_channel_ring.ckr_user_accumulated_slots offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_user_accumulated_syncs) == 0x388, "ks___kern_channel_ring.ckr_user_accumulated_syncs offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_user_accumulate_start) == 0x390, "ks___kern_channel_ring.ckr_user_accumulate_start offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_qlock_group) == 0x398, "ks___kern_channel_ring.ckr_qlock_group offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_slock_group) == 0x3A0, "ks___kern_channel_ring.ckr_slock_group offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_name) == 0x3A8, "ks___kern_channel_ring.ckr_name offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_rx_dequeue_ts) == 0x3E8, "ks___kern_channel_ring.ckr_rx_dequeue_ts offset");
_Static_assert(offsetof(struct ks___kern_channel_ring, ckr_rx_enqueue_ts) == 0x3F0, "ks___kern_channel_ring.ckr_rx_enqueue_ts offset");
_Static_assert(sizeof(struct ks___kern_channel_ring) == 0x400, "ks___kern_channel_ring size");

/* refs: 1 */
struct ks_ifnet_interface_advisory_capacity {
    int rate_trend_suggestion;
    unsigned long long timestamp;
    unsigned long long max_bandwidth;
    unsigned long long total_byte_count;
    unsigned long long average_throughput;
    unsigned int flushable_queue_size;
    unsigned int non_flushable_queue_size;
    unsigned int average_delay;
} __attribute__((packed));
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_capacity, rate_trend_suggestion) == 0x0, "ks_ifnet_interface_advisory_capacity.rate_trend_suggestion offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_capacity, timestamp) == 0x4, "ks_ifnet_interface_advisory_capacity.timestamp offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_capacity, max_bandwidth) == 0xC, "ks_ifnet_interface_advisory_capacity.max_bandwidth offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_capacity, total_byte_count) == 0x14, "ks_ifnet_interface_advisory_capacity.total_byte_count offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_capacity, average_throughput) == 0x1C, "ks_ifnet_interface_advisory_capacity.average_throughput offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_capacity, flushable_queue_size) == 0x24, "ks_ifnet_interface_advisory_capacity.flushable_queue_size offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_capacity, non_flushable_queue_size) == 0x28, "ks_ifnet_interface_advisory_capacity.non_flushable_queue_size offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_capacity, average_delay) == 0x2C, "ks_ifnet_interface_advisory_capacity.average_delay offset");
_Static_assert(sizeof(struct ks_ifnet_interface_advisory_capacity) == 0x30, "ks_ifnet_interface_advisory_capacity size");

/* refs: 1 */
struct ks_ifnet_interface_advisory_cell_context {
    unsigned char radio_access_technology;
    short reference_signal_level;
    short signal_level;
    signed char signal_quality;
    unsigned char uplink_bler;
    unsigned char downlink_bler;
    unsigned char bandwidth_limitation_indication;
    unsigned char cdrx_state;
    unsigned short cdrx_cycle;
    unsigned short estimated_outage_period;
    unsigned char outage_state;
    unsigned char __pad;
} __attribute__((packed));
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_cell_context, radio_access_technology) == 0x0, "ks_ifnet_interface_advisory_cell_context.radio_access_technology offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_cell_context, reference_signal_level) == 0x1, "ks_ifnet_interface_advisory_cell_context.reference_signal_level offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_cell_context, signal_level) == 0x3, "ks_ifnet_interface_advisory_cell_context.signal_level offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_cell_context, signal_quality) == 0x5, "ks_ifnet_interface_advisory_cell_context.signal_quality offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_cell_context, uplink_bler) == 0x6, "ks_ifnet_interface_advisory_cell_context.uplink_bler offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_cell_context, downlink_bler) == 0x7, "ks_ifnet_interface_advisory_cell_context.downlink_bler offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_cell_context, bandwidth_limitation_indication) == 0x8, "ks_ifnet_interface_advisory_cell_context.bandwidth_limitation_indication offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_cell_context, cdrx_state) == 0x9, "ks_ifnet_interface_advisory_cell_context.cdrx_state offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_cell_context, cdrx_cycle) == 0xA, "ks_ifnet_interface_advisory_cell_context.cdrx_cycle offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_cell_context, estimated_outage_period) == 0xC, "ks_ifnet_interface_advisory_cell_context.estimated_outage_period offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_cell_context, outage_state) == 0xE, "ks_ifnet_interface_advisory_cell_context.outage_state offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_cell_context, __pad) == 0xF, "ks_ifnet_interface_advisory_cell_context.__pad offset");
_Static_assert(sizeof(struct ks_ifnet_interface_advisory_cell_context) == 0x10, "ks_ifnet_interface_advisory_cell_context size");

/* refs: 2 */
union ks_ifnet_interface_advisory_notification_type_t {
    unsigned char cell;
    unsigned char wifi;
};
_Static_assert(offsetof(union ks_ifnet_interface_advisory_notification_type_t, cell) == 0x0, "ks_ifnet_interface_advisory_notification_type_t.cell offset");
_Static_assert(offsetof(union ks_ifnet_interface_advisory_notification_type_t, wifi) == 0x0, "ks_ifnet_interface_advisory_notification_type_t.wifi offset");

/* refs: 1 */
struct ks_ifnet_interface_advisory_header {
    unsigned char version;
    unsigned char direction;
    unsigned char interface_type;
    union ks_ifnet_interface_advisory_notification_type_t notification_type;
};
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_header, version) == 0x0, "ks_ifnet_interface_advisory_header.version offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_header, direction) == 0x1, "ks_ifnet_interface_advisory_header.direction offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_header, interface_type) == 0x2, "ks_ifnet_interface_advisory_header.interface_type offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_header, notification_type) == 0x3, "ks_ifnet_interface_advisory_header.notification_type offset");
_Static_assert(sizeof(struct ks_ifnet_interface_advisory_header) == 0x4, "ks_ifnet_interface_advisory_header size");

/* refs: 1 */
struct ks_ifnet_interface_advisory_wifi_context {
    unsigned char frequency_band;
    unsigned char intermittent_state;
    unsigned short estimated_intermittent_period;
    unsigned short single_outage_period;
    unsigned char bt_coex;
    unsigned char quality_score_delay;
    unsigned char quality_score_loss;
    unsigned char quality_score_channel;
    unsigned char radio_coex;
    unsigned short wlan_duty_cycle;
    unsigned int wifi_observed_tx_bitrate[6];
} __attribute__((packed));
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_wifi_context, frequency_band) == 0x0, "ks_ifnet_interface_advisory_wifi_context.frequency_band offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_wifi_context, intermittent_state) == 0x1, "ks_ifnet_interface_advisory_wifi_context.intermittent_state offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_wifi_context, estimated_intermittent_period) == 0x2, "ks_ifnet_interface_advisory_wifi_context.estimated_intermittent_period offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_wifi_context, single_outage_period) == 0x4, "ks_ifnet_interface_advisory_wifi_context.single_outage_period offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_wifi_context, bt_coex) == 0x6, "ks_ifnet_interface_advisory_wifi_context.bt_coex offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_wifi_context, quality_score_delay) == 0x7, "ks_ifnet_interface_advisory_wifi_context.quality_score_delay offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_wifi_context, quality_score_loss) == 0x8, "ks_ifnet_interface_advisory_wifi_context.quality_score_loss offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_wifi_context, quality_score_channel) == 0x9, "ks_ifnet_interface_advisory_wifi_context.quality_score_channel offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_wifi_context, radio_coex) == 0xA, "ks_ifnet_interface_advisory_wifi_context.radio_coex offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_wifi_context, wlan_duty_cycle) == 0xB, "ks_ifnet_interface_advisory_wifi_context.wlan_duty_cycle offset");
_Static_assert(offsetof(struct ks_ifnet_interface_advisory_wifi_context, wifi_observed_tx_bitrate) == 0xD, "ks_ifnet_interface_advisory_wifi_context.wifi_observed_tx_bitrate offset");
_Static_assert(sizeof(struct ks_ifnet_interface_advisory_wifi_context) == 0x25, "ks_ifnet_interface_advisory_wifi_context size");

/* refs: 1 */
struct ks_ifnet_interface_advisory {
    union {
        struct {
            unsigned char version;
            unsigned char direction;
            unsigned short _reserved;
            int rate_trend_suggestion;
            unsigned long long timestamp;
            unsigned long long max_bandwidth;
            unsigned long long total_byte_count;
            unsigned long long average_throughput;
            unsigned int flushable_queue_size;
            unsigned int non_flushable_queue_size;
            unsigned int average_delay;
            unsigned char frequency_band;
            unsigned char intermittent_state;
            unsigned short estimated_intermittent_period;
            unsigned short single_outage_period;
            unsigned char bt_coex;
            unsigned char quality_score_delay;
            unsigned char quality_score_loss;
            unsigned char quality_score_channel;
        };
        struct {
            struct ks_ifnet_interface_advisory_header header;
            struct ks_ifnet_interface_advisory_capacity capacity;
            union {
                struct ks_ifnet_interface_advisory_wifi_context wifi_context;
                struct ks_ifnet_interface_advisory_cell_context cell_context;
            };
        };
    };
} __attribute__((aligned(8)));
_Static_assert(sizeof(struct ks_ifnet_interface_advisory) == 0x60, "ks_ifnet_interface_advisory size");

/* refs: 2 */
struct ks___kern_netif_intf_advisory {
    unsigned int cksum;
    unsigned int _reserved;
    struct ks_ifnet_interface_advisory adv __attribute__((aligned(8)));
} __attribute__((aligned(8)));
_Static_assert(offsetof(struct ks___kern_netif_intf_advisory, cksum) == 0x0, "ks___kern_netif_intf_advisory.cksum offset");
_Static_assert(offsetof(struct ks___kern_netif_intf_advisory, _reserved) == 0x4, "ks___kern_netif_intf_advisory._reserved offset");
_Static_assert(offsetof(struct ks___kern_netif_intf_advisory, adv) == 0x8, "ks___kern_netif_intf_advisory.adv offset");
_Static_assert(sizeof(struct ks___kern_netif_intf_advisory) == 0x68, "ks___kern_netif_intf_advisory size");

/* refs: 2 */
struct ks___quantum {
    union {
        unsigned char __uuid[0x10];
        unsigned char __val8[0x10];
        unsigned short __val16[8];
        unsigned int __val32[4];
        unsigned long long __val64[2];
    } __flow_id_u;
    unsigned int __q_len;
    unsigned int __q_svc_class;
    unsigned short __q_flags;
    unsigned short __q_pad[3];
} __attribute__((aligned(8)));
_Static_assert(offsetof(struct ks___quantum, __flow_id_u) == 0x0, "ks___quantum.__flow_id_u offset");
_Static_assert(offsetof(struct ks___quantum, __q_len) == 0x10, "ks___quantum.__q_len offset");
_Static_assert(offsetof(struct ks___quantum, __q_svc_class) == 0x14, "ks___quantum.__q_svc_class offset");
_Static_assert(offsetof(struct ks___quantum, __q_flags) == 0x18, "ks___quantum.__q_flags offset");
_Static_assert(offsetof(struct ks___quantum, __q_pad) == 0x1A, "ks___quantum.__q_pad offset");
_Static_assert(sizeof(struct ks___quantum) == 0x20, "ks___quantum size");

/* refs: 3 */
struct ks___kern_quantum {
    struct ks___quantum qum_com __attribute__((aligned(8)));
    struct {
        struct ks___kern_quantum *sle_next;
    } qum_upp_link;
    const struct ks_kern_pbufpool *qum_pp;
    const struct ks___user_quantum *qum_user;
    const struct ks___kern_slot_desc *qum_ksd;
    struct ks___kern_buflet qum_buf[1];
    int qum_pid;
} __attribute__((aligned(8)));
_Static_assert(offsetof(struct ks___kern_quantum, qum_com) == 0x0, "ks___kern_quantum.qum_com offset");
_Static_assert(offsetof(struct ks___kern_quantum, qum_upp_link) == 0x20, "ks___kern_quantum.qum_upp_link offset");
_Static_assert(offsetof(struct ks___kern_quantum, qum_pp) == 0x28, "ks___kern_quantum.qum_pp offset");
_Static_assert(offsetof(struct ks___kern_quantum, qum_user) == 0x30, "ks___kern_quantum.qum_user offset");
_Static_assert(offsetof(struct ks___kern_quantum, qum_ksd) == 0x38, "ks___kern_quantum.qum_ksd offset");
_Static_assert(offsetof(struct ks___kern_quantum, qum_buf) == 0x40, "ks___kern_quantum.qum_buf offset");
_Static_assert(offsetof(struct ks___kern_quantum, qum_pid) == 0x74, "ks___kern_quantum.qum_pid offset");
_Static_assert(sizeof(struct ks___kern_quantum) == 0x78, "ks___kern_quantum size");

/* refs: 1 */
struct ks___packet_com {
    unsigned short __link_flags;
    unsigned char __headroom;
    unsigned char __l2_len;
    unsigned int __csum_flags;
    union {
        struct {
            unsigned short __csum_start_off;
            unsigned short __csum_value;
        } __csum_rx;
        struct {
            unsigned short __csum_start_off;
            unsigned short __csum_stuff_off;
        } __csum_tx;
        unsigned int __csum_data;
    };
    unsigned int __comp_gencnt;
    unsigned int __trace_id;
    unsigned char __aggr_type;
    unsigned char __seg_cnt;
    unsigned short __proto_seg_sz;
    union {
        unsigned int __flags32[2];
        unsigned long long __flags;
    };
} __attribute__((aligned(8)));
_Static_assert(offsetof(struct ks___packet_com, __link_flags) == 0x0, "ks___packet_com.__link_flags offset");
_Static_assert(offsetof(struct ks___packet_com, __headroom) == 0x2, "ks___packet_com.__headroom offset");
_Static_assert(offsetof(struct ks___packet_com, __l2_len) == 0x3, "ks___packet_com.__l2_len offset");
_Static_assert(offsetof(struct ks___packet_com, __csum_flags) == 0x4, "ks___packet_com.__csum_flags offset");
_Static_assert(offsetof(struct ks___packet_com, __comp_gencnt) == 0xC, "ks___packet_com.__comp_gencnt offset");
_Static_assert(offsetof(struct ks___packet_com, __trace_id) == 0x10, "ks___packet_com.__trace_id offset");
_Static_assert(offsetof(struct ks___packet_com, __aggr_type) == 0x14, "ks___packet_com.__aggr_type offset");
_Static_assert(offsetof(struct ks___packet_com, __seg_cnt) == 0x15, "ks___packet_com.__seg_cnt offset");
_Static_assert(offsetof(struct ks___packet_com, __proto_seg_sz) == 0x16, "ks___packet_com.__proto_seg_sz offset");
_Static_assert(sizeof(struct ks___packet_com) == 0x20, "ks___packet_com size");

/* refs: 1 */
struct ks___packet {
    union {
        unsigned long long __pkt_data[4];
        struct ks___packet_com __pkt_com __attribute__((aligned(8)));
    };
};
_Static_assert(sizeof(struct ks___packet) == 0x20, "ks___packet size");

/* refs: 5 */
struct ks___kern_packet {
    struct ks___kern_quantum pkt_qum __attribute__((aligned(8)));
    struct ks___packet pkt_com;
    struct ks___packet_opt *pkt_com_opt;
    unsigned long long pkt_timestamp;
    struct ks___kern_packet *pkt_nextpkt;
    union {
        struct ks_mbuf *pkt_mbuf;
        struct ks___kern_packet *pkt_pkt;
    };
    struct ks___flow *pkt_flow;
    struct ks___packet_compl *pkt_tx_compl;
    void *pkt_priv;
    unsigned int pkt_fpd_seqnum;
    unsigned short pkt_fpd_metadata;
    unsigned short pkt_bufs_max;
    unsigned short pkt_bufs_cnt;
    unsigned int pkt_chain_count;
    unsigned int pkt_chain_bytes;
    unsigned short pkt_nx_port;
    unsigned short pkt_vpna_gencnt;
    unsigned short pkt_trace_tag;
    unsigned char pkt_qset_idx;
    unsigned char _pad[1];
} __attribute__((aligned(8)));
_Static_assert(offsetof(struct ks___kern_packet, pkt_qum) == 0x0, "ks___kern_packet.pkt_qum offset");
_Static_assert(offsetof(struct ks___kern_packet, pkt_com) == 0x78, "ks___kern_packet.pkt_com offset");
_Static_assert(offsetof(struct ks___kern_packet, pkt_com_opt) == 0x98, "ks___kern_packet.pkt_com_opt offset");
_Static_assert(offsetof(struct ks___kern_packet, pkt_timestamp) == 0xA0, "ks___kern_packet.pkt_timestamp offset");
_Static_assert(offsetof(struct ks___kern_packet, pkt_nextpkt) == 0xA8, "ks___kern_packet.pkt_nextpkt offset");
_Static_assert(offsetof(struct ks___kern_packet, pkt_flow) == 0xB8, "ks___kern_packet.pkt_flow offset");
_Static_assert(offsetof(struct ks___kern_packet, pkt_tx_compl) == 0xC0, "ks___kern_packet.pkt_tx_compl offset");
_Static_assert(offsetof(struct ks___kern_packet, pkt_priv) == 0xC8, "ks___kern_packet.pkt_priv offset");
_Static_assert(offsetof(struct ks___kern_packet, pkt_fpd_seqnum) == 0xD0, "ks___kern_packet.pkt_fpd_seqnum offset");
_Static_assert(offsetof(struct ks___kern_packet, pkt_fpd_metadata) == 0xD4, "ks___kern_packet.pkt_fpd_metadata offset");
_Static_assert(offsetof(struct ks___kern_packet, pkt_bufs_max) == 0xD6, "ks___kern_packet.pkt_bufs_max offset");
_Static_assert(offsetof(struct ks___kern_packet, pkt_bufs_cnt) == 0xD8, "ks___kern_packet.pkt_bufs_cnt offset");
_Static_assert(offsetof(struct ks___kern_packet, pkt_chain_count) == 0xDC, "ks___kern_packet.pkt_chain_count offset");
_Static_assert(offsetof(struct ks___kern_packet, pkt_chain_bytes) == 0xE0, "ks___kern_packet.pkt_chain_bytes offset");
_Static_assert(offsetof(struct ks___kern_packet, pkt_nx_port) == 0xE4, "ks___kern_packet.pkt_nx_port offset");
_Static_assert(offsetof(struct ks___kern_packet, pkt_vpna_gencnt) == 0xE6, "ks___kern_packet.pkt_vpna_gencnt offset");
_Static_assert(offsetof(struct ks___kern_packet, pkt_trace_tag) == 0xE8, "ks___kern_packet.pkt_trace_tag offset");
_Static_assert(offsetof(struct ks___kern_packet, pkt_qset_idx) == 0xEA, "ks___kern_packet.pkt_qset_idx offset");
_Static_assert(offsetof(struct ks___kern_packet, _pad) == 0xEB, "ks___kern_packet._pad offset");
_Static_assert(sizeof(struct ks___kern_packet) == 0xF0, "ks___kern_packet size");

/* refs: 1 */
struct ks___kern_slot_desc {
    union {
        struct ks___kern_quantum *sd_qum;
        struct ks___kern_packet *sd_pkt;
        struct ks___kern_buflet *sd_buf;
        void *sd_md;
    };
};
_Static_assert(sizeof(struct ks___kern_slot_desc) == 0x8, "ks___kern_slot_desc size");

/* refs: 1 */
struct ks___packet_compl {
    union {
        unsigned long long compl_data64[3];
        struct {
            unsigned long _cb_arg;
            unsigned long _cb_data;
            unsigned int _tx_status;
            unsigned int _pad;
        } compl_data;
    };
    unsigned char compl_callbacks;
    unsigned int compl_context;
};
_Static_assert(offsetof(struct ks___packet_compl, compl_callbacks) == 0x18, "ks___packet_compl.compl_callbacks offset");
_Static_assert(offsetof(struct ks___packet_compl, compl_context) == 0x1C, "ks___packet_compl.compl_context offset");
_Static_assert(sizeof(struct ks___packet_compl) == 0x20, "ks___packet_compl size");

/* refs: 1 */
struct ks___packet_opt_com {
    union {
        unsigned long long __token_data[2];
        unsigned char __token[0x10];
    };
    unsigned long long __expire_ts;
    unsigned long long __pkt_tx_time;
    unsigned short __vlan_tag;
    unsigned short __token_len;
    unsigned char __token_type;
    unsigned char __expiry_action;
    unsigned char __app_type;
    unsigned char __app_metadata;
} __attribute__((aligned(8)));
_Static_assert(offsetof(struct ks___packet_opt_com, __expire_ts) == 0x10, "ks___packet_opt_com.__expire_ts offset");
_Static_assert(offsetof(struct ks___packet_opt_com, __pkt_tx_time) == 0x18, "ks___packet_opt_com.__pkt_tx_time offset");
_Static_assert(offsetof(struct ks___packet_opt_com, __vlan_tag) == 0x20, "ks___packet_opt_com.__vlan_tag offset");
_Static_assert(offsetof(struct ks___packet_opt_com, __token_len) == 0x22, "ks___packet_opt_com.__token_len offset");
_Static_assert(offsetof(struct ks___packet_opt_com, __token_type) == 0x24, "ks___packet_opt_com.__token_type offset");
_Static_assert(offsetof(struct ks___packet_opt_com, __expiry_action) == 0x25, "ks___packet_opt_com.__expiry_action offset");
_Static_assert(offsetof(struct ks___packet_opt_com, __app_type) == 0x26, "ks___packet_opt_com.__app_type offset");
_Static_assert(offsetof(struct ks___packet_opt_com, __app_metadata) == 0x27, "ks___packet_opt_com.__app_metadata offset");
_Static_assert(sizeof(struct ks___packet_opt_com) == 0x28, "ks___packet_opt_com size");

/* refs: 1 */
struct ks___packet_opt {
    union {
        unsigned long long __pkt_opt_data[5];
        struct ks___packet_opt_com __pkt_opt_com __attribute__((aligned(8)));
    };
};
_Static_assert(sizeof(struct ks___packet_opt) == 0x28, "ks___packet_opt size");

/* refs: 1 */
union ks_sigval {
    int sival_int;
    void *sival_ptr;
};
_Static_assert(offsetof(union ks_sigval, sival_int) == 0x0, "ks_sigval.sival_int offset");
_Static_assert(offsetof(union ks_sigval, sival_ptr) == 0x0, "ks_sigval.sival_ptr offset");

/* refs: 2 */
struct ks___siginfo {
    int si_signo;
    int si_errno;
    int si_code;
    int si_pid;
    unsigned int si_uid;
    int si_status;
    void *si_addr;
    union ks_sigval si_value;
    long si_band;
    unsigned long __pad[7];
};
_Static_assert(offsetof(struct ks___siginfo, si_signo) == 0x0, "ks___siginfo.si_signo offset");
_Static_assert(offsetof(struct ks___siginfo, si_errno) == 0x4, "ks___siginfo.si_errno offset");
_Static_assert(offsetof(struct ks___siginfo, si_code) == 0x8, "ks___siginfo.si_code offset");
_Static_assert(offsetof(struct ks___siginfo, si_pid) == 0xC, "ks___siginfo.si_pid offset");
_Static_assert(offsetof(struct ks___siginfo, si_uid) == 0x10, "ks___siginfo.si_uid offset");
_Static_assert(offsetof(struct ks___siginfo, si_status) == 0x14, "ks___siginfo.si_status offset");
_Static_assert(offsetof(struct ks___siginfo, si_addr) == 0x18, "ks___siginfo.si_addr offset");
_Static_assert(offsetof(struct ks___siginfo, si_value) == 0x20, "ks___siginfo.si_value offset");
_Static_assert(offsetof(struct ks___siginfo, si_band) == 0x28, "ks___siginfo.si_band offset");
_Static_assert(offsetof(struct ks___siginfo, __pad) == 0x30, "ks___siginfo.__pad offset");
_Static_assert(sizeof(struct ks___siginfo) == 0x68, "ks___siginfo size");

/* refs: 1 */
struct ks___user_slot_desc {
    unsigned int sd_md_idx;
    unsigned short sd_flags;
    unsigned short sd_len;
};
_Static_assert(offsetof(struct ks___user_slot_desc, sd_md_idx) == 0x0, "ks___user_slot_desc.sd_md_idx offset");
_Static_assert(offsetof(struct ks___user_slot_desc, sd_flags) == 0x4, "ks___user_slot_desc.sd_flags offset");
_Static_assert(offsetof(struct ks___user_slot_desc, sd_len) == 0x6, "ks___user_slot_desc.sd_len offset");
_Static_assert(sizeof(struct ks___user_slot_desc) == 0x8, "ks___user_slot_desc size");

/* refs: 5 */
struct ks___slot_desc {
    union {
        struct ks___user_slot_desc _sd_user;
        unsigned long long _sd_private[1];
    };
};
_Static_assert(sizeof(struct ks___slot_desc) == 0x8, "ks___slot_desc size");

/* refs: 3 */
struct ks___smrq_link_t {
    volatile struct ks_smrq_link *__smr_ptr;
};
_Static_assert(offsetof(struct ks___smrq_link_t, __smr_ptr) == 0x0, "ks___smrq_link_t.__smr_ptr offset");
_Static_assert(sizeof(struct ks___smrq_link_t) == 0x8, "ks___smrq_link_t size");

/* refs: 3 */
struct ks___smrq_slink_t {
    volatile struct ks_smrq_slink *__smr_ptr;
};
_Static_assert(offsetof(struct ks___smrq_slink_t, __smr_ptr) == 0x0, "ks___smrq_slink_t.__smr_ptr offset");
_Static_assert(sizeof(struct ks___smrq_slink_t) == 0x8, "ks___smrq_slink_t size");

/* refs: 1 */
struct ks___sockaddr_header {
    unsigned char sa_len;
    unsigned char sa_family;
};
_Static_assert(offsetof(struct ks___sockaddr_header, sa_len) == 0x0, "ks___sockaddr_header.sa_len offset");
_Static_assert(offsetof(struct ks___sockaddr_header, sa_family) == 0x1, "ks___sockaddr_header.sa_family offset");
_Static_assert(sizeof(struct ks___sockaddr_header) == 0x2, "ks___sockaddr_header size");

/* refs: 1 */
struct ks___tds {
    unsigned char _t_dtrace_on;
    unsigned char _t_dtrace_step;
    unsigned char _t_dtrace_ret;
    unsigned char _t_dtrace_ast;
    unsigned char _t_dtrace_reg;
};
_Static_assert(offsetof(struct ks___tds, _t_dtrace_on) == 0x0, "ks___tds._t_dtrace_on offset");
_Static_assert(offsetof(struct ks___tds, _t_dtrace_step) == 0x1, "ks___tds._t_dtrace_step offset");
_Static_assert(offsetof(struct ks___tds, _t_dtrace_ret) == 0x2, "ks___tds._t_dtrace_ret offset");
_Static_assert(offsetof(struct ks___tds, _t_dtrace_ast) == 0x3, "ks___tds._t_dtrace_ast offset");
_Static_assert(offsetof(struct ks___tds, _t_dtrace_reg) == 0x4, "ks___tds._t_dtrace_reg offset");
_Static_assert(sizeof(struct ks___tds) == 0x5, "ks___tds size");

/* refs: 1 */
struct ks___user_buflet {
    struct ks___buflet buf_com;
};
_Static_assert(offsetof(struct ks___user_buflet, buf_com) == 0x0, "ks___user_buflet.buf_com offset");
_Static_assert(sizeof(struct ks___user_buflet) == 0x2A, "ks___user_buflet size");

/* refs: 2 */
struct ks___user_channel_ring {
    unsigned int ring_head;
    unsigned int ring_tail;
    unsigned int ring_khead;
    unsigned int ring_num_slots;
    unsigned int ring_def_buf_size;
    unsigned int ring_large_buf_size;
    unsigned short ring_md_size;
    unsigned short ring_bft_size;
    unsigned short ring_id;
    unsigned short ring_kind;
    unsigned long long ring_def_buf_base __attribute__((aligned(8)));
    unsigned long long ring_large_buf_base __attribute__((aligned(8)));
    unsigned long long ring_md_base __attribute__((aligned(8)));
    unsigned long long ring_sd_base __attribute__((aligned(8)));
    unsigned long long ring_bft_base __attribute__((aligned(8)));
    unsigned long long ring_sync_time __attribute__((aligned(8)));
    unsigned long long ring_notify_time __attribute__((aligned(8)));
    unsigned int ring_alloc_ws;
    unsigned int ring_alloc_buf_ws;
};
_Static_assert(offsetof(struct ks___user_channel_ring, ring_head) == 0x0, "ks___user_channel_ring.ring_head offset");
_Static_assert(offsetof(struct ks___user_channel_ring, ring_tail) == 0x4, "ks___user_channel_ring.ring_tail offset");
_Static_assert(offsetof(struct ks___user_channel_ring, ring_khead) == 0x8, "ks___user_channel_ring.ring_khead offset");
_Static_assert(offsetof(struct ks___user_channel_ring, ring_num_slots) == 0xC, "ks___user_channel_ring.ring_num_slots offset");
_Static_assert(offsetof(struct ks___user_channel_ring, ring_def_buf_size) == 0x10, "ks___user_channel_ring.ring_def_buf_size offset");
_Static_assert(offsetof(struct ks___user_channel_ring, ring_large_buf_size) == 0x14, "ks___user_channel_ring.ring_large_buf_size offset");
_Static_assert(offsetof(struct ks___user_channel_ring, ring_md_size) == 0x18, "ks___user_channel_ring.ring_md_size offset");
_Static_assert(offsetof(struct ks___user_channel_ring, ring_bft_size) == 0x1A, "ks___user_channel_ring.ring_bft_size offset");
_Static_assert(offsetof(struct ks___user_channel_ring, ring_id) == 0x1C, "ks___user_channel_ring.ring_id offset");
_Static_assert(offsetof(struct ks___user_channel_ring, ring_kind) == 0x1E, "ks___user_channel_ring.ring_kind offset");
_Static_assert(offsetof(struct ks___user_channel_ring, ring_def_buf_base) == 0x20, "ks___user_channel_ring.ring_def_buf_base offset");
_Static_assert(offsetof(struct ks___user_channel_ring, ring_large_buf_base) == 0x28, "ks___user_channel_ring.ring_large_buf_base offset");
_Static_assert(offsetof(struct ks___user_channel_ring, ring_md_base) == 0x30, "ks___user_channel_ring.ring_md_base offset");
_Static_assert(offsetof(struct ks___user_channel_ring, ring_sd_base) == 0x38, "ks___user_channel_ring.ring_sd_base offset");
_Static_assert(offsetof(struct ks___user_channel_ring, ring_bft_base) == 0x40, "ks___user_channel_ring.ring_bft_base offset");
_Static_assert(offsetof(struct ks___user_channel_ring, ring_sync_time) == 0x48, "ks___user_channel_ring.ring_sync_time offset");
_Static_assert(offsetof(struct ks___user_channel_ring, ring_notify_time) == 0x50, "ks___user_channel_ring.ring_notify_time offset");
_Static_assert(offsetof(struct ks___user_channel_ring, ring_alloc_ws) == 0x58, "ks___user_channel_ring.ring_alloc_ws offset");
_Static_assert(offsetof(struct ks___user_channel_ring, ring_alloc_buf_ws) == 0x5C, "ks___user_channel_ring.ring_alloc_buf_ws offset");
_Static_assert(sizeof(struct ks___user_channel_ring) == 0x60, "ks___user_channel_ring size");

/* refs: 1 */
struct ks___user_quantum {
    struct ks___quantum qum_com __attribute__((aligned(8)));
    struct ks___user_buflet qum_buf[1];
    unsigned short qum_usecnt;
} __attribute__((aligned(8)));
_Static_assert(offsetof(struct ks___user_quantum, qum_com) == 0x0, "ks___user_quantum.qum_com offset");
_Static_assert(offsetof(struct ks___user_quantum, qum_buf) == 0x20, "ks___user_quantum.qum_buf offset");
_Static_assert(offsetof(struct ks___user_quantum, qum_usecnt) == 0x4A, "ks___user_quantum.qum_usecnt offset");
_Static_assert(sizeof(struct ks___user_quantum) == 0x50, "ks___user_quantum size");

/* refs: 1 */
struct ks__bsdthread_terminate {
    unsigned long long ulock_addr;
    unsigned int kport;
};
_Static_assert(offsetof(struct ks__bsdthread_terminate, ulock_addr) == 0x0, "ks__bsdthread_terminate.ulock_addr offset");
_Static_assert(offsetof(struct ks__bsdthread_terminate, kport) == 0x8, "ks__bsdthread_terminate.kport offset");
_Static_assert(sizeof(struct ks__bsdthread_terminate) == 0x10, "ks__bsdthread_terminate size");

/* refs: 2 */
struct ks__cpu_time_qos_stats {
    unsigned long long cpu_time_qos_default;
    unsigned long long cpu_time_qos_maintenance;
    unsigned long long cpu_time_qos_background;
    unsigned long long cpu_time_qos_utility;
    unsigned long long cpu_time_qos_legacy;
    unsigned long long cpu_time_qos_user_initiated;
    unsigned long long cpu_time_qos_user_interactive;
};
_Static_assert(offsetof(struct ks__cpu_time_qos_stats, cpu_time_qos_default) == 0x0, "ks__cpu_time_qos_stats.cpu_time_qos_default offset");
_Static_assert(offsetof(struct ks__cpu_time_qos_stats, cpu_time_qos_maintenance) == 0x8, "ks__cpu_time_qos_stats.cpu_time_qos_maintenance offset");
_Static_assert(offsetof(struct ks__cpu_time_qos_stats, cpu_time_qos_background) == 0x10, "ks__cpu_time_qos_stats.cpu_time_qos_background offset");
_Static_assert(offsetof(struct ks__cpu_time_qos_stats, cpu_time_qos_utility) == 0x18, "ks__cpu_time_qos_stats.cpu_time_qos_utility offset");
_Static_assert(offsetof(struct ks__cpu_time_qos_stats, cpu_time_qos_legacy) == 0x20, "ks__cpu_time_qos_stats.cpu_time_qos_legacy offset");
_Static_assert(offsetof(struct ks__cpu_time_qos_stats, cpu_time_qos_user_initiated) == 0x28, "ks__cpu_time_qos_stats.cpu_time_qos_user_initiated offset");
_Static_assert(offsetof(struct ks__cpu_time_qos_stats, cpu_time_qos_user_interactive) == 0x30, "ks__cpu_time_qos_stats.cpu_time_qos_user_interactive offset");
_Static_assert(sizeof(struct ks__cpu_time_qos_stats) == 0x38, "ks__cpu_time_qos_stats size");

/* refs: 1 */
struct ks__exec_data {
    struct ks_image_params *imgp;
};
_Static_assert(offsetof(struct ks__exec_data, imgp) == 0x0, "ks__exec_data.imgp offset");
_Static_assert(sizeof(struct ks__exec_data) == 0x8, "ks__exec_data size");

/* refs: 1 */
struct ks__kauth {
    unsigned long long message;
};
_Static_assert(offsetof(struct ks__kauth, message) == 0x0, "ks__kauth.message offset");
_Static_assert(sizeof(struct ks__kauth) == 0x8, "ks__kauth size");

/* refs: 1 */
struct ks_kevent_qos_s {
    unsigned long long ident;
    short filter;
    unsigned short flags;
    int qos;
    unsigned long long udata;
    unsigned int fflags;
    unsigned int xflags;
    long long data;
    unsigned long long ext[4];
};
_Static_assert(offsetof(struct ks_kevent_qos_s, ident) == 0x0, "ks_kevent_qos_s.ident offset");
_Static_assert(offsetof(struct ks_kevent_qos_s, filter) == 0x8, "ks_kevent_qos_s.filter offset");
_Static_assert(offsetof(struct ks_kevent_qos_s, flags) == 0xA, "ks_kevent_qos_s.flags offset");
_Static_assert(offsetof(struct ks_kevent_qos_s, qos) == 0xC, "ks_kevent_qos_s.qos offset");
_Static_assert(offsetof(struct ks_kevent_qos_s, udata) == 0x10, "ks_kevent_qos_s.udata offset");
_Static_assert(offsetof(struct ks_kevent_qos_s, fflags) == 0x18, "ks_kevent_qos_s.fflags offset");
_Static_assert(offsetof(struct ks_kevent_qos_s, xflags) == 0x1C, "ks_kevent_qos_s.xflags offset");
_Static_assert(offsetof(struct ks_kevent_qos_s, data) == 0x20, "ks_kevent_qos_s.data offset");
_Static_assert(offsetof(struct ks_kevent_qos_s, ext) == 0x28, "ks_kevent_qos_s.ext offset");
_Static_assert(sizeof(struct ks_kevent_qos_s) == 0x48, "ks_kevent_qos_s size");

/* refs: 1 */
struct ks__kevent_register {
    struct ks_kevent_qos_s kev;
    struct ks_thread *handoff_thread;
    struct ks_kqworkloop *kqwl;
    int eventout;
    unsigned long long ueventlist;
};
_Static_assert(offsetof(struct ks__kevent_register, kev) == 0x0, "ks__kevent_register.kev offset");
_Static_assert(offsetof(struct ks__kevent_register, handoff_thread) == 0x48, "ks__kevent_register.handoff_thread offset");
_Static_assert(offsetof(struct ks__kevent_register, kqwl) == 0x50, "ks__kevent_register.kqwl offset");
_Static_assert(offsetof(struct ks__kevent_register, eventout) == 0x58, "ks__kevent_register.eventout offset");
_Static_assert(offsetof(struct ks__kevent_register, ueventlist) == 0x60, "ks__kevent_register.ueventlist offset");
_Static_assert(sizeof(struct ks__kevent_register) == 0x68, "ks__kevent_register size");

/* refs: 11 */
struct ks__lck_grp_stat_ {
    unsigned long long lgs_count;
    unsigned int lgs_enablings;
    unsigned int lgs_probeid;
    unsigned long long lgs_limit;
};
_Static_assert(offsetof(struct ks__lck_grp_stat_, lgs_count) == 0x0, "ks__lck_grp_stat_.lgs_count offset");
_Static_assert(offsetof(struct ks__lck_grp_stat_, lgs_enablings) == 0x8, "ks__lck_grp_stat_.lgs_enablings offset");
_Static_assert(offsetof(struct ks__lck_grp_stat_, lgs_probeid) == 0xC, "ks__lck_grp_stat_.lgs_probeid offset");
_Static_assert(offsetof(struct ks__lck_grp_stat_, lgs_limit) == 0x10, "ks__lck_grp_stat_.lgs_limit offset");
_Static_assert(sizeof(struct ks__lck_grp_stat_) == 0x18, "ks__lck_grp_stat_ size");

/* refs: 2 */
struct ks__lck_grp_stats_ {
    struct ks__lck_grp_stat_ lgss_spin_held;
    struct ks__lck_grp_stat_ lgss_spin_miss;
    struct ks__lck_grp_stat_ lgss_spin_spin;
    struct ks__lck_grp_stat_ lgss_ticket_held;
    struct ks__lck_grp_stat_ lgss_ticket_miss;
    struct ks__lck_grp_stat_ lgss_ticket_spin;
    struct ks__lck_grp_stat_ lgss_mtx_held;
    struct ks__lck_grp_stat_ lgss_mtx_direct_wait;
    struct ks__lck_grp_stat_ lgss_mtx_miss;
    struct ks__lck_grp_stat_ lgss_mtx_wait;
};
_Static_assert(offsetof(struct ks__lck_grp_stats_, lgss_spin_held) == 0x0, "ks__lck_grp_stats_.lgss_spin_held offset");
_Static_assert(offsetof(struct ks__lck_grp_stats_, lgss_spin_miss) == 0x18, "ks__lck_grp_stats_.lgss_spin_miss offset");
_Static_assert(offsetof(struct ks__lck_grp_stats_, lgss_spin_spin) == 0x30, "ks__lck_grp_stats_.lgss_spin_spin offset");
_Static_assert(offsetof(struct ks__lck_grp_stats_, lgss_ticket_held) == 0x48, "ks__lck_grp_stats_.lgss_ticket_held offset");
_Static_assert(offsetof(struct ks__lck_grp_stats_, lgss_ticket_miss) == 0x60, "ks__lck_grp_stats_.lgss_ticket_miss offset");
_Static_assert(offsetof(struct ks__lck_grp_stats_, lgss_ticket_spin) == 0x78, "ks__lck_grp_stats_.lgss_ticket_spin offset");
_Static_assert(offsetof(struct ks__lck_grp_stats_, lgss_mtx_held) == 0x90, "ks__lck_grp_stats_.lgss_mtx_held offset");
_Static_assert(offsetof(struct ks__lck_grp_stats_, lgss_mtx_direct_wait) == 0xA8, "ks__lck_grp_stats_.lgss_mtx_direct_wait offset");
_Static_assert(offsetof(struct ks__lck_grp_stats_, lgss_mtx_miss) == 0xC0, "ks__lck_grp_stats_.lgss_mtx_miss offset");
_Static_assert(offsetof(struct ks__lck_grp_stats_, lgss_mtx_wait) == 0xD8, "ks__lck_grp_stats_.lgss_mtx_wait offset");
_Static_assert(sizeof(struct ks__lck_grp_stats_) == 0xF0, "ks__lck_grp_stats_ size");

/* refs: 6 */
struct ks__lck_grp_ {
    unsigned int lck_grp_refcnt;
    unsigned int lck_grp_attr_id;
    unsigned int lck_grp_spincnt;
    unsigned int lck_grp_ticketcnt;
    unsigned int lck_grp_mtxcnt;
    unsigned int lck_grp_rwcnt;
    char lck_grp_name[0x40];
    struct ks__lck_grp_stats_ lck_grp_stats;
};
_Static_assert(offsetof(struct ks__lck_grp_, lck_grp_refcnt) == 0x0, "ks__lck_grp_.lck_grp_refcnt offset");
_Static_assert(offsetof(struct ks__lck_grp_, lck_grp_attr_id) == 0x4, "ks__lck_grp_.lck_grp_attr_id offset");
_Static_assert(offsetof(struct ks__lck_grp_, lck_grp_spincnt) == 0x8, "ks__lck_grp_.lck_grp_spincnt offset");
_Static_assert(offsetof(struct ks__lck_grp_, lck_grp_ticketcnt) == 0xC, "ks__lck_grp_.lck_grp_ticketcnt offset");
_Static_assert(offsetof(struct ks__lck_grp_, lck_grp_mtxcnt) == 0x10, "ks__lck_grp_.lck_grp_mtxcnt offset");
_Static_assert(offsetof(struct ks__lck_grp_, lck_grp_rwcnt) == 0x14, "ks__lck_grp_.lck_grp_rwcnt offset");
_Static_assert(offsetof(struct ks__lck_grp_, lck_grp_name) == 0x18, "ks__lck_grp_.lck_grp_name offset");
_Static_assert(offsetof(struct ks__lck_grp_, lck_grp_stats) == 0x58, "ks__lck_grp_.lck_grp_stats offset");
_Static_assert(sizeof(struct ks__lck_grp_) == 0x148, "ks__lck_grp_ size");

/* refs: 3 */
struct ks_classq_pkt {
    union {
        struct ks_mbuf *cp_mbuf;
        struct ks___kern_packet *cp_kpkt;
    };
    unsigned int cp_ptype;
};
_Static_assert(offsetof(struct ks_classq_pkt, cp_ptype) == 0x8, "ks_classq_pkt.cp_ptype offset");
_Static_assert(sizeof(struct ks_classq_pkt) == 0x10, "ks_classq_pkt size");

/* refs: 2 */
struct ks__pktsched_pkt_ {
    struct ks_classq_pkt __pkt;
    struct ks_classq_pkt __tail;
    unsigned int __plen;
    unsigned int __pcnt;
};
_Static_assert(offsetof(struct ks__pktsched_pkt_, __pkt) == 0x0, "ks__pktsched_pkt_.__pkt offset");
_Static_assert(offsetof(struct ks__pktsched_pkt_, __tail) == 0x10, "ks__pktsched_pkt_.__tail offset");
_Static_assert(offsetof(struct ks__pktsched_pkt_, __plen) == 0x20, "ks__pktsched_pkt_.__plen offset");
_Static_assert(offsetof(struct ks__pktsched_pkt_, __pcnt) == 0x24, "ks__pktsched_pkt_.__pcnt offset");
_Static_assert(sizeof(struct ks__pktsched_pkt_) == 0x28, "ks__pktsched_pkt_ size");

/* refs: 1 */
struct ks__select {
    unsigned int *ibits;
    unsigned int *obits;
    unsigned int nbytes;
};
_Static_assert(offsetof(struct ks__select, ibits) == 0x0, "ks__select.ibits offset");
_Static_assert(offsetof(struct ks__select, obits) == 0x8, "ks__select.obits offset");
_Static_assert(offsetof(struct ks__select, nbytes) == 0x10, "ks__select.nbytes offset");
_Static_assert(sizeof(struct ks__select) == 0x18, "ks__select size");

/* refs: 1 */
struct ks__select_data {
    unsigned long long abstime;
    int count;
    struct ks_select_nocancel_args *args;
    int *retval;
};
_Static_assert(offsetof(struct ks__select_data, abstime) == 0x0, "ks__select_data.abstime offset");
_Static_assert(offsetof(struct ks__select_data, count) == 0x8, "ks__select_data.count offset");
_Static_assert(offsetof(struct ks__select_data, args) == 0x10, "ks__select_data.args offset");
_Static_assert(offsetof(struct ks__select_data, retval) == 0x18, "ks__select_data.retval offset");
_Static_assert(sizeof(struct ks__select_data) == 0x20, "ks__select_data size");

/* refs: 1 */
struct ks__ulock_wait_data {
    struct ks_ull *ull;
    struct ks_thread *owner_thread;
    struct ks_thread *old_owner;
    int *retval;
    unsigned int flags;
};
_Static_assert(offsetof(struct ks__ulock_wait_data, ull) == 0x0, "ks__ulock_wait_data.ull offset");
_Static_assert(offsetof(struct ks__ulock_wait_data, owner_thread) == 0x8, "ks__ulock_wait_data.owner_thread offset");
_Static_assert(offsetof(struct ks__ulock_wait_data, old_owner) == 0x10, "ks__ulock_wait_data.old_owner offset");
_Static_assert(offsetof(struct ks__ulock_wait_data, retval) == 0x18, "ks__ulock_wait_data.retval offset");
_Static_assert(offsetof(struct ks__ulock_wait_data, flags) == 0x20, "ks__ulock_wait_data.flags offset");
_Static_assert(sizeof(struct ks__ulock_wait_data) == 0x28, "ks__ulock_wait_data size");

/* refs: 2 */
union ks_lck_rw_word_t {
    struct {
        unsigned short shared_count;
        unsigned short interlock : 1; /* bit offset 16 */
        unsigned short priv_excl : 1; /* bit offset 17 */
        unsigned short want_upgrade : 1; /* bit offset 18 */
        unsigned short want_excl : 1; /* bit offset 19 */
        unsigned short r_waiting : 1; /* bit offset 20 */
        unsigned short w_waiting : 1; /* bit offset 21 */
        unsigned short can_sleep : 1; /* bit offset 22 */
        unsigned short _pad2 : 8; /* bit offset 23 */
        unsigned short tag_valid : 1; /* bit offset 31 */
    };
    unsigned int data;
};
_Static_assert(offsetof(union ks_lck_rw_word_t, data) == 0x0, "ks_lck_rw_word_t.data offset");

/* refs: 17 */
struct ks_lck_rw_s {
    unsigned int lck_rw_unused : 24; /* bit offset 0 */
    unsigned int lck_rw_type : 8; /* bit offset 24 */
    unsigned int lck_rw_padding;
    union ks_lck_rw_word_t lck_rw;
    unsigned int lck_rw_owner;
};
_Static_assert(offsetof(struct ks_lck_rw_s, lck_rw_padding) == 0x4, "ks_lck_rw_s.lck_rw_padding offset");
_Static_assert(offsetof(struct ks_lck_rw_s, lck_rw) == 0x8, "ks_lck_rw_s.lck_rw offset");
_Static_assert(offsetof(struct ks_lck_rw_s, lck_rw_owner) == 0xC, "ks_lck_rw_s.lck_rw_owner offset");
_Static_assert(sizeof(struct ks_lck_rw_s) == 0x10, "ks_lck_rw_s size");

/* refs: 1 */
struct ks_rb_head {
    struct ks_vm_map_store *rbh_root;
};
_Static_assert(offsetof(struct ks_rb_head, rbh_root) == 0x0, "ks_rb_head.rbh_root offset");
_Static_assert(sizeof(struct ks_rb_head) == 0x8, "ks_rb_head size");

/* refs: 4 */
struct ks_vm_map_links {
    unsigned long prev : 48; /* bit offset 0 */
    unsigned char vme_zero_wire_count_waiters : 1; /* bit offset 48 */
    struct ks_vm_map_entry *next;
    unsigned long long start;
    unsigned long long end;
};
_Static_assert(offsetof(struct ks_vm_map_links, next) == 0x8, "ks_vm_map_links.next offset");
_Static_assert(offsetof(struct ks_vm_map_links, start) == 0x10, "ks_vm_map_links.start offset");
_Static_assert(offsetof(struct ks_vm_map_links, end) == 0x18, "ks_vm_map_links.end offset");
_Static_assert(sizeof(struct ks_vm_map_links) == 0x20, "ks_vm_map_links size");

/* refs: 1 */
struct ks_vm_map_header {
    struct ks_vm_map_links links;
    int nentries;
    unsigned short page_shift;
    unsigned short entries_pageable : 1; /* bit offset 304 */
    unsigned short __padding : 15; /* bit offset 305 */
    struct ks_rb_head rb_head_store;
};
_Static_assert(offsetof(struct ks_vm_map_header, links) == 0x0, "ks_vm_map_header.links offset");
_Static_assert(offsetof(struct ks_vm_map_header, nentries) == 0x20, "ks_vm_map_header.nentries offset");
_Static_assert(offsetof(struct ks_vm_map_header, page_shift) == 0x24, "ks_vm_map_header.page_shift offset");
_Static_assert(offsetof(struct ks_vm_map_header, rb_head_store) == 0x28, "ks_vm_map_header.rb_head_store offset");
_Static_assert(sizeof(struct ks_vm_map_header) == 0x30, "ks_vm_map_header size");

/* refs: 7 */
struct ks__vm_map {
    struct ks_lck_rw_s lock;
    struct ks_vm_map_header hdr;
    struct ks_pmap *pmap;
    unsigned long long size;
    unsigned long long size_limit;
    unsigned long long data_limit;
    unsigned long long user_wire_limit;
    unsigned long long user_wire_size;
    unsigned int map_refcnt;
    unsigned long long vmu1;
    struct ks_vm_map_entry *hint;
    union {
        struct ks_vm_map_links *vmmap_hole_hint;
        struct ks_vm_map_corpse_footprint_header *vmmap_corpse_footprint;
    } vmmap_u_1;
    union {
        struct ks_vm_map_entry *_first_free;
        struct ks_vm_map_links *_holes;
    } f_s;
    unsigned int wait_for_space : 1; /* bit offset 1216 */
    unsigned int wiring_required : 1; /* bit offset 1217 */
    unsigned int no_zero_fill : 1; /* bit offset 1218 */
    unsigned int mapped_in_other_pmaps : 1; /* bit offset 1219 */
    unsigned int switch_protect : 1; /* bit offset 1220 */
    unsigned int disable_vmentry_reuse : 1; /* bit offset 1221 */
    unsigned int map_disallow_data_exec : 1; /* bit offset 1222 */
    unsigned int holelistenabled : 1; /* bit offset 1223 */
    unsigned int is_nested_map : 1; /* bit offset 1224 */
    unsigned int map_disallow_new_exec : 1; /* bit offset 1225 */
    unsigned int jit_entry_exists : 1; /* bit offset 1226 */
    unsigned int has_corpse_footprint : 1; /* bit offset 1227 */
    unsigned int terminated : 1; /* bit offset 1228 */
    unsigned int is_alien : 1; /* bit offset 1229 */
    unsigned int cs_enforcement : 1; /* bit offset 1230 */
    unsigned int cs_debugged : 1; /* bit offset 1231 */
    unsigned int reserved_regions : 1; /* bit offset 1232 */
    unsigned int single_jit : 1; /* bit offset 1233 */
    unsigned int never_faults : 1; /* bit offset 1234 */
    unsigned int uses_user_ranges : 1; /* bit offset 1235 */
    unsigned int tpro_enforcement : 1; /* bit offset 1236 */
    unsigned int corpse_source : 1; /* bit offset 1237 */
    unsigned int cs_platform_binary : 1; /* bit offset 1238 */
    unsigned int vmmap_sealed : 2; /* bit offset 1239 */
    unsigned int res0 : 1; /* bit offset 1241 */
    unsigned int pad : 6; /* bit offset 1242 */
    unsigned long long timestamp;
    struct ks_task *owning_task;
    const void *serial_id;
};
_Static_assert(offsetof(struct ks__vm_map, lock) == 0x0, "ks__vm_map.lock offset");
_Static_assert(offsetof(struct ks__vm_map, hdr) == 0x10, "ks__vm_map.hdr offset");
_Static_assert(offsetof(struct ks__vm_map, pmap) == 0x40, "ks__vm_map.pmap offset");
_Static_assert(offsetof(struct ks__vm_map, size) == 0x48, "ks__vm_map.size offset");
_Static_assert(offsetof(struct ks__vm_map, size_limit) == 0x50, "ks__vm_map.size_limit offset");
_Static_assert(offsetof(struct ks__vm_map, data_limit) == 0x58, "ks__vm_map.data_limit offset");
_Static_assert(offsetof(struct ks__vm_map, user_wire_limit) == 0x60, "ks__vm_map.user_wire_limit offset");
_Static_assert(offsetof(struct ks__vm_map, user_wire_size) == 0x68, "ks__vm_map.user_wire_size offset");
_Static_assert(offsetof(struct ks__vm_map, map_refcnt) == 0x70, "ks__vm_map.map_refcnt offset");
_Static_assert(offsetof(struct ks__vm_map, vmu1) == 0x78, "ks__vm_map.vmu1 offset");
_Static_assert(offsetof(struct ks__vm_map, hint) == 0x80, "ks__vm_map.hint offset");
_Static_assert(offsetof(struct ks__vm_map, vmmap_u_1) == 0x88, "ks__vm_map.vmmap_u_1 offset");
_Static_assert(offsetof(struct ks__vm_map, f_s) == 0x90, "ks__vm_map.f_s offset");
_Static_assert(offsetof(struct ks__vm_map, timestamp) == 0xA0, "ks__vm_map.timestamp offset");
_Static_assert(offsetof(struct ks__vm_map, owning_task) == 0xA8, "ks__vm_map.owning_task offset");
_Static_assert(offsetof(struct ks__vm_map, serial_id) == 0xB0, "ks__vm_map.serial_id offset");
_Static_assert(sizeof(struct ks__vm_map) == 0xB8, "ks__vm_map size");

/* refs: 2 */
struct ks__vm_object_query_data_ {
    unsigned long long object_id;
    unsigned long long virtual_size;
    unsigned long long resident_size;
    unsigned long long wired_size;
    unsigned long long reusable_size;
    unsigned long long compressed_size;
    struct {
        unsigned long long vo_no_footprint : 1; /* bit offset 0 */
        unsigned long long vo_ledger_tag : 3; /* bit offset 1 */
        unsigned long long purgable : 2; /* bit offset 4 */
    };
};
_Static_assert(offsetof(struct ks__vm_object_query_data_, object_id) == 0x0, "ks__vm_object_query_data_.object_id offset");
_Static_assert(offsetof(struct ks__vm_object_query_data_, virtual_size) == 0x8, "ks__vm_object_query_data_.virtual_size offset");
_Static_assert(offsetof(struct ks__vm_object_query_data_, resident_size) == 0x10, "ks__vm_object_query_data_.resident_size offset");
_Static_assert(offsetof(struct ks__vm_object_query_data_, wired_size) == 0x18, "ks__vm_object_query_data_.wired_size offset");
_Static_assert(offsetof(struct ks__vm_object_query_data_, reusable_size) == 0x20, "ks__vm_object_query_data_.reusable_size offset");
_Static_assert(offsetof(struct ks__vm_object_query_data_, compressed_size) == 0x28, "ks__vm_object_query_data_.compressed_size offset");
_Static_assert(sizeof(struct ks__vm_object_query_data_) == 0x38, "ks__vm_object_query_data_ size");

/* refs: 2 */
struct ks__vmobject_list_output_ {
    unsigned long long entries;
    struct ks__vm_object_query_data_ data[0];
};
_Static_assert(offsetof(struct ks__vmobject_list_output_, entries) == 0x0, "ks__vmobject_list_output_.entries offset");
_Static_assert(offsetof(struct ks__vmobject_list_output_, data) == 0x8, "ks__vmobject_list_output_.data offset");
_Static_assert(sizeof(struct ks__vmobject_list_output_) == 0x8, "ks__vmobject_list_output_ size");

/* refs: 1 */
struct ks__wait4_data {
    struct ks_wait4_nocancel_args *args;
    int *retval;
};
_Static_assert(offsetof(struct ks__wait4_data, args) == 0x0, "ks__wait4_data.args offset");
_Static_assert(offsetof(struct ks__wait4_data, retval) == 0x8, "ks__wait4_data.retval offset");
_Static_assert(sizeof(struct ks__wait4_data) == 0x10, "ks__wait4_data size");

/* refs: 1 */
struct ks__waitid_data {
    struct ks_waitid_nocancel_args *args;
    int *retval;
};
_Static_assert(offsetof(struct ks__waitid_data, args) == 0x0, "ks__waitid_data.args offset");
_Static_assert(offsetof(struct ks__waitid_data, retval) == 0x8, "ks__waitid_data.retval offset");
_Static_assert(sizeof(struct ks__waitid_data) == 0x10, "ks__waitid_data size");

/* refs: 1 */
struct ks__workq_park_data {
    unsigned long long idle_stamp;
    unsigned long long workloop_params;
    unsigned int fulfilled_snapshot;
    unsigned int yields;
    void *thread_request;
    unsigned int upcall_flags;
    _Bool has_stack;
    unsigned char qos;
};
_Static_assert(offsetof(struct ks__workq_park_data, idle_stamp) == 0x0, "ks__workq_park_data.idle_stamp offset");
_Static_assert(offsetof(struct ks__workq_park_data, workloop_params) == 0x8, "ks__workq_park_data.workloop_params offset");
_Static_assert(offsetof(struct ks__workq_park_data, fulfilled_snapshot) == 0x10, "ks__workq_park_data.fulfilled_snapshot offset");
_Static_assert(offsetof(struct ks__workq_park_data, yields) == 0x14, "ks__workq_park_data.yields offset");
_Static_assert(offsetof(struct ks__workq_park_data, thread_request) == 0x18, "ks__workq_park_data.thread_request offset");
_Static_assert(offsetof(struct ks__workq_park_data, upcall_flags) == 0x20, "ks__workq_park_data.upcall_flags offset");
_Static_assert(offsetof(struct ks__workq_park_data, has_stack) == 0x24, "ks__workq_park_data.has_stack offset");
_Static_assert(offsetof(struct ks__workq_park_data, qos) == 0x25, "ks__workq_park_data.qos offset");
_Static_assert(sizeof(struct ks__workq_park_data) == 0x28, "ks__workq_park_data size");

/* refs: 2 */
struct ks_cccbc_ctx {
    unsigned char b[0x10];
} __attribute__((aligned(16)));
_Static_assert(offsetof(struct ks_cccbc_ctx, b) == 0x0, "ks_cccbc_ctx.b offset");
_Static_assert(sizeof(struct ks_cccbc_ctx) == 0x10, "ks_cccbc_ctx size");

/* refs: 2 */
struct ks_aes_encrypt_ctx {
    struct ks_cccbc_ctx ctx[0x12] __attribute__((aligned(16)));
};
_Static_assert(offsetof(struct ks_aes_encrypt_ctx, ctx) == 0x0, "ks_aes_encrypt_ctx.ctx offset");
_Static_assert(sizeof(struct ks_aes_encrypt_ctx) == 0x120, "ks_aes_encrypt_ctx size");

/* refs: 49 */
struct ks_queue_entry {
    struct ks_queue_entry *next;
    struct ks_queue_entry *prev;
};
_Static_assert(offsetof(struct ks_queue_entry, next) == 0x0, "ks_queue_entry.next offset");
_Static_assert(offsetof(struct ks_queue_entry, prev) == 0x8, "ks_queue_entry.prev offset");
_Static_assert(sizeof(struct ks_queue_entry) == 0x10, "ks_queue_entry size");

/* refs: 1 */
struct ks_affinity_space {
    struct ks_lck_mtx_s aspc_lock;
    unsigned int aspc_task_count;
    struct ks_queue_entry aspc_affinities;
};
_Static_assert(offsetof(struct ks_affinity_space, aspc_lock) == 0x0, "ks_affinity_space.aspc_lock offset");
_Static_assert(offsetof(struct ks_affinity_space, aspc_task_count) == 0x10, "ks_affinity_space.aspc_task_count offset");
_Static_assert(offsetof(struct ks_affinity_space, aspc_affinities) == 0x18, "ks_affinity_space.aspc_affinities offset");
_Static_assert(sizeof(struct ks_affinity_space) == 0x28, "ks_affinity_space size");

/* refs: 24 */
struct ks_os_refcnt {
    unsigned int ref_count;
};
_Static_assert(offsetof(struct ks_os_refcnt, ref_count) == 0x0, "ks_os_refcnt.ref_count offset");
_Static_assert(sizeof(struct ks_os_refcnt) == 0x4, "ks_os_refcnt size");

/* refs: 1 */
union ks_user_sigval {
    struct {
        unsigned int pad;
        int sival_int;
    } size_equivalent;
    unsigned long long sival_ptr;
};
_Static_assert(offsetof(union ks_user_sigval, size_equivalent) == 0x0, "ks_user_sigval.size_equivalent offset");
_Static_assert(offsetof(union ks_user_sigval, sival_ptr) == 0x0, "ks_user_sigval.sival_ptr offset");

/* refs: 1 */
struct ks_user_sigevent {
    int sigev_notify;
    int sigev_signo;
    union ks_user_sigval sigev_value;
    unsigned long long sigev_notify_function;
    unsigned long long sigev_notify_attributes;
};
_Static_assert(offsetof(struct ks_user_sigevent, sigev_notify) == 0x0, "ks_user_sigevent.sigev_notify offset");
_Static_assert(offsetof(struct ks_user_sigevent, sigev_signo) == 0x4, "ks_user_sigevent.sigev_signo offset");
_Static_assert(offsetof(struct ks_user_sigevent, sigev_value) == 0x8, "ks_user_sigevent.sigev_value offset");
_Static_assert(offsetof(struct ks_user_sigevent, sigev_notify_function) == 0x10, "ks_user_sigevent.sigev_notify_function offset");
_Static_assert(offsetof(struct ks_user_sigevent, sigev_notify_attributes) == 0x18, "ks_user_sigevent.sigev_notify_attributes offset");
_Static_assert(sizeof(struct ks_user_sigevent) == 0x20, "ks_user_sigevent size");

/* refs: 1 */
struct ks_user_aiocb {
    int aio_fildes;
    long long aio_offset;
    unsigned long long aio_buf;
    unsigned long long aio_nbytes;
    int aio_reqprio;
    struct ks_user_sigevent aio_sigevent;
    int aio_lio_opcode;
};
_Static_assert(offsetof(struct ks_user_aiocb, aio_fildes) == 0x0, "ks_user_aiocb.aio_fildes offset");
_Static_assert(offsetof(struct ks_user_aiocb, aio_offset) == 0x8, "ks_user_aiocb.aio_offset offset");
_Static_assert(offsetof(struct ks_user_aiocb, aio_buf) == 0x10, "ks_user_aiocb.aio_buf offset");
_Static_assert(offsetof(struct ks_user_aiocb, aio_nbytes) == 0x18, "ks_user_aiocb.aio_nbytes offset");
_Static_assert(offsetof(struct ks_user_aiocb, aio_reqprio) == 0x20, "ks_user_aiocb.aio_reqprio offset");
_Static_assert(offsetof(struct ks_user_aiocb, aio_sigevent) == 0x28, "ks_user_aiocb.aio_sigevent offset");
_Static_assert(offsetof(struct ks_user_aiocb, aio_lio_opcode) == 0x48, "ks_user_aiocb.aio_lio_opcode offset");
_Static_assert(sizeof(struct ks_user_aiocb) == 0x50, "ks_user_aiocb size");

/* refs: 4 */
struct ks_vfs_context {
    struct ks_thread *vc_thread;
    struct ks_ucred *vc_ucred;
};
_Static_assert(offsetof(struct ks_vfs_context, vc_thread) == 0x0, "ks_vfs_context.vc_thread offset");
_Static_assert(offsetof(struct ks_vfs_context, vc_ucred) == 0x8, "ks_vfs_context.vc_ucred offset");
_Static_assert(sizeof(struct ks_vfs_context) == 0x10, "ks_vfs_context size");

/* refs: 10 */
struct ks_aio_workq_entry {
    struct {
        struct ks_aio_workq_entry *tqe_next;
        struct ks_aio_workq_entry **tqe_prev;
    } aio_workq_link;
    struct {
        struct ks_aio_workq_entry *tqe_next;
        struct ks_aio_workq_entry **tqe_prev;
    } aio_proc_link;
    long long returnval;
    int errorval;
    struct ks_os_refcnt aio_refcount;
    unsigned int flags;
    int lio_pending;
    struct ks_aio_workq_entry *lio_leader;
    struct ks_proc *procp;
    unsigned long long uaiocbp;
    struct ks_user_aiocb aiocb;
    struct ks_vfs_context context;
    struct ks__vm_map *aio_map;
};
_Static_assert(offsetof(struct ks_aio_workq_entry, aio_workq_link) == 0x0, "ks_aio_workq_entry.aio_workq_link offset");
_Static_assert(offsetof(struct ks_aio_workq_entry, aio_proc_link) == 0x10, "ks_aio_workq_entry.aio_proc_link offset");
_Static_assert(offsetof(struct ks_aio_workq_entry, returnval) == 0x20, "ks_aio_workq_entry.returnval offset");
_Static_assert(offsetof(struct ks_aio_workq_entry, errorval) == 0x28, "ks_aio_workq_entry.errorval offset");
_Static_assert(offsetof(struct ks_aio_workq_entry, aio_refcount) == 0x2C, "ks_aio_workq_entry.aio_refcount offset");
_Static_assert(offsetof(struct ks_aio_workq_entry, flags) == 0x30, "ks_aio_workq_entry.flags offset");
_Static_assert(offsetof(struct ks_aio_workq_entry, lio_pending) == 0x34, "ks_aio_workq_entry.lio_pending offset");
_Static_assert(offsetof(struct ks_aio_workq_entry, lio_leader) == 0x38, "ks_aio_workq_entry.lio_leader offset");
_Static_assert(offsetof(struct ks_aio_workq_entry, procp) == 0x40, "ks_aio_workq_entry.procp offset");
_Static_assert(offsetof(struct ks_aio_workq_entry, uaiocbp) == 0x48, "ks_aio_workq_entry.uaiocbp offset");
_Static_assert(offsetof(struct ks_aio_workq_entry, aiocb) == 0x50, "ks_aio_workq_entry.aiocb offset");
_Static_assert(offsetof(struct ks_aio_workq_entry, context) == 0xA0, "ks_aio_workq_entry.context offset");
_Static_assert(offsetof(struct ks_aio_workq_entry, aio_map) == 0xB0, "ks_aio_workq_entry.aio_map offset");
_Static_assert(sizeof(struct ks_aio_workq_entry) == 0xB8, "ks_aio_workq_entry size");

/* refs: 2 */
struct ks_arm64_uexc_region_t {
    unsigned long long start;
    unsigned long long end;
    unsigned long long handler;
    unsigned long long refcon;
};
_Static_assert(offsetof(struct ks_arm64_uexc_region_t, start) == 0x0, "ks_arm64_uexc_region_t.start offset");
_Static_assert(offsetof(struct ks_arm64_uexc_region_t, end) == 0x8, "ks_arm64_uexc_region_t.end offset");
_Static_assert(offsetof(struct ks_arm64_uexc_region_t, handler) == 0x10, "ks_arm64_uexc_region_t.handler offset");
_Static_assert(offsetof(struct ks_arm64_uexc_region_t, refcon) == 0x18, "ks_arm64_uexc_region_t.refcon offset");
_Static_assert(sizeof(struct ks_arm64_uexc_region_t) == 0x20, "ks_arm64_uexc_region_t size");

/* refs: 2 */
struct ks_au_evclass_map {
    unsigned short ec_number;
    unsigned int ec_class;
};
_Static_assert(offsetof(struct ks_au_evclass_map, ec_number) == 0x0, "ks_au_evclass_map.ec_number offset");
_Static_assert(offsetof(struct ks_au_evclass_map, ec_class) == 0x4, "ks_au_evclass_map.ec_class offset");
_Static_assert(sizeof(struct ks_au_evclass_map) == 0x8, "ks_au_evclass_map size");

/* refs: 2 */
struct ks_au_expire_after {
    long age;
    unsigned long size;
    unsigned char op_type;
};
_Static_assert(offsetof(struct ks_au_expire_after, age) == 0x0, "ks_au_expire_after.age offset");
_Static_assert(offsetof(struct ks_au_expire_after, size) == 0x8, "ks_au_expire_after.size offset");
_Static_assert(offsetof(struct ks_au_expire_after, op_type) == 0x10, "ks_au_expire_after.op_type offset");
_Static_assert(sizeof(struct ks_au_expire_after) == 0x18, "ks_au_expire_after size");

/* refs: 1 */
struct ks_au_identity_info {
    unsigned int signer_type;
    char *signing_id;
    unsigned char signing_id_trunc;
    char *team_id;
    unsigned char team_id_trunc;
    unsigned char *cdhash;
    unsigned short cdhash_len;
};
_Static_assert(offsetof(struct ks_au_identity_info, signer_type) == 0x0, "ks_au_identity_info.signer_type offset");
_Static_assert(offsetof(struct ks_au_identity_info, signing_id) == 0x8, "ks_au_identity_info.signing_id offset");
_Static_assert(offsetof(struct ks_au_identity_info, signing_id_trunc) == 0x10, "ks_au_identity_info.signing_id_trunc offset");
_Static_assert(offsetof(struct ks_au_identity_info, team_id) == 0x18, "ks_au_identity_info.team_id offset");
_Static_assert(offsetof(struct ks_au_identity_info, team_id_trunc) == 0x20, "ks_au_identity_info.team_id_trunc offset");
_Static_assert(offsetof(struct ks_au_identity_info, cdhash) == 0x28, "ks_au_identity_info.cdhash offset");
_Static_assert(offsetof(struct ks_au_identity_info, cdhash_len) == 0x30, "ks_au_identity_info.cdhash_len offset");
_Static_assert(sizeof(struct ks_au_identity_info) == 0x38, "ks_au_identity_info size");

/* refs: 9 */
struct ks_au_mask {
    unsigned int am_success;
    unsigned int am_failure;
};
_Static_assert(offsetof(struct ks_au_mask, am_success) == 0x0, "ks_au_mask.am_success offset");
_Static_assert(offsetof(struct ks_au_mask, am_failure) == 0x4, "ks_au_mask.am_failure offset");
_Static_assert(sizeof(struct ks_au_mask) == 0x8, "ks_au_mask size");

/* refs: 2 */
struct ks_au_qctrl {
    int aq_hiwater;
    int aq_lowater;
    int aq_bufsz;
    int aq_delay;
    int aq_minfree;
};
_Static_assert(offsetof(struct ks_au_qctrl, aq_hiwater) == 0x0, "ks_au_qctrl.aq_hiwater offset");
_Static_assert(offsetof(struct ks_au_qctrl, aq_lowater) == 0x4, "ks_au_qctrl.aq_lowater offset");
_Static_assert(offsetof(struct ks_au_qctrl, aq_bufsz) == 0x8, "ks_au_qctrl.aq_bufsz offset");
_Static_assert(offsetof(struct ks_au_qctrl, aq_delay) == 0xC, "ks_au_qctrl.aq_delay offset");
_Static_assert(offsetof(struct ks_au_qctrl, aq_minfree) == 0x10, "ks_au_qctrl.aq_minfree offset");
_Static_assert(sizeof(struct ks_au_qctrl) == 0x14, "ks_au_qctrl size");

/* refs: 2 */
struct ks_au_qctrl64 {
    unsigned long long aq64_hiwater;
    unsigned long long aq64_lowater;
    unsigned long long aq64_bufsz;
    unsigned long long aq64_delay;
    long long aq64_minfree;
};
_Static_assert(offsetof(struct ks_au_qctrl64, aq64_hiwater) == 0x0, "ks_au_qctrl64.aq64_hiwater offset");
_Static_assert(offsetof(struct ks_au_qctrl64, aq64_lowater) == 0x8, "ks_au_qctrl64.aq64_lowater offset");
_Static_assert(offsetof(struct ks_au_qctrl64, aq64_bufsz) == 0x10, "ks_au_qctrl64.aq64_bufsz offset");
_Static_assert(offsetof(struct ks_au_qctrl64, aq64_delay) == 0x18, "ks_au_qctrl64.aq64_delay offset");
_Static_assert(offsetof(struct ks_au_qctrl64, aq64_minfree) == 0x20, "ks_au_qctrl64.aq64_minfree offset");
_Static_assert(sizeof(struct ks_au_qctrl64) == 0x28, "ks_au_qctrl64 size");

/* refs: 1 */
struct ks_au_session {
    struct ks_auditinfo_addr *as_aia_p;
    struct ks_au_mask as_mask;
};
_Static_assert(offsetof(struct ks_au_session, as_aia_p) == 0x0, "ks_au_session.as_aia_p offset");
_Static_assert(offsetof(struct ks_au_session, as_mask) == 0x8, "ks_au_session.as_mask offset");
_Static_assert(sizeof(struct ks_au_session) == 0x10, "ks_au_session size");

/* refs: 5 */
struct ks_au_tid {
    int port;
    unsigned int machine;
};
_Static_assert(offsetof(struct ks_au_tid, port) == 0x0, "ks_au_tid.port offset");
_Static_assert(offsetof(struct ks_au_tid, machine) == 0x4, "ks_au_tid.machine offset");
_Static_assert(sizeof(struct ks_au_tid) == 0x8, "ks_au_tid size");

/* refs: 5 */
struct ks_au_tid_addr {
    int at_port;
    unsigned int at_type;
    unsigned int at_addr[4];
};
_Static_assert(offsetof(struct ks_au_tid_addr, at_port) == 0x0, "ks_au_tid_addr.at_port offset");
_Static_assert(offsetof(struct ks_au_tid_addr, at_type) == 0x4, "ks_au_tid_addr.at_type offset");
_Static_assert(offsetof(struct ks_au_tid_addr, at_addr) == 0x8, "ks_au_tid_addr.at_addr offset");
_Static_assert(sizeof(struct ks_au_tid_addr) == 0x18, "ks_au_tid_addr size");

/* refs: 2 */
struct ks_audit_fstat {
    unsigned long long af_filesz;
    unsigned long long af_currsz;
};
_Static_assert(offsetof(struct ks_audit_fstat, af_filesz) == 0x0, "ks_audit_fstat.af_filesz offset");
_Static_assert(offsetof(struct ks_audit_fstat, af_currsz) == 0x8, "ks_audit_fstat.af_currsz offset");
_Static_assert(sizeof(struct ks_audit_fstat) == 0x10, "ks_audit_fstat size");

/* refs: 1 */
struct ks_groupset {
    unsigned int gidset[0x10];
    unsigned int gidset_size;
};
_Static_assert(offsetof(struct ks_groupset, gidset) == 0x0, "ks_groupset.gidset offset");
_Static_assert(offsetof(struct ks_groupset, gidset_size) == 0x40, "ks_groupset.gidset_size offset");
_Static_assert(sizeof(struct ks_groupset) == 0x44, "ks_groupset size");

/* refs: 1 */
struct ks_ipc_perm {
    unsigned int uid;
    unsigned int gid;
    unsigned int cuid;
    unsigned int cgid;
    unsigned short mode;
    unsigned short _seq;
    int _key;
} __attribute__((aligned(4)));
_Static_assert(offsetof(struct ks_ipc_perm, uid) == 0x0, "ks_ipc_perm.uid offset");
_Static_assert(offsetof(struct ks_ipc_perm, gid) == 0x4, "ks_ipc_perm.gid offset");
_Static_assert(offsetof(struct ks_ipc_perm, cuid) == 0x8, "ks_ipc_perm.cuid offset");
_Static_assert(offsetof(struct ks_ipc_perm, cgid) == 0xC, "ks_ipc_perm.cgid offset");
_Static_assert(offsetof(struct ks_ipc_perm, mode) == 0x10, "ks_ipc_perm.mode offset");
_Static_assert(offsetof(struct ks_ipc_perm, _seq) == 0x12, "ks_ipc_perm._seq offset");
_Static_assert(offsetof(struct ks_ipc_perm, _key) == 0x14, "ks_ipc_perm._key offset");
_Static_assert(sizeof(struct ks_ipc_perm) == 0x18, "ks_ipc_perm size");

/* refs: 1 */
struct ks_posix_ipc_perm {
    unsigned int pipc_uid;
    unsigned int pipc_gid;
    unsigned short pipc_mode;
};
_Static_assert(offsetof(struct ks_posix_ipc_perm, pipc_uid) == 0x0, "ks_posix_ipc_perm.pipc_uid offset");
_Static_assert(offsetof(struct ks_posix_ipc_perm, pipc_gid) == 0x4, "ks_posix_ipc_perm.pipc_gid offset");
_Static_assert(offsetof(struct ks_posix_ipc_perm, pipc_mode) == 0x8, "ks_posix_ipc_perm.pipc_mode offset");
_Static_assert(sizeof(struct ks_posix_ipc_perm) == 0xC, "ks_posix_ipc_perm size");

/* refs: 3 */
struct ks_sockaddr_storage {
    unsigned char ss_len;
    unsigned char ss_family;
    char __ss_pad1[6];
    long long __ss_align;
    char __ss_pad2[0x70];
};
_Static_assert(offsetof(struct ks_sockaddr_storage, ss_len) == 0x0, "ks_sockaddr_storage.ss_len offset");
_Static_assert(offsetof(struct ks_sockaddr_storage, ss_family) == 0x1, "ks_sockaddr_storage.ss_family offset");
_Static_assert(offsetof(struct ks_sockaddr_storage, __ss_pad1) == 0x2, "ks_sockaddr_storage.__ss_pad1 offset");
_Static_assert(offsetof(struct ks_sockaddr_storage, __ss_align) == 0x8, "ks_sockaddr_storage.__ss_align offset");
_Static_assert(offsetof(struct ks_sockaddr_storage, __ss_pad2) == 0x10, "ks_sockaddr_storage.__ss_pad2 offset");
_Static_assert(sizeof(struct ks_sockaddr_storage) == 0x80, "ks_sockaddr_storage size");

/* refs: 1 */
struct ks_socket_au_info {
    int sai_domain;
    int sai_type;
    int sai_protocol;
    struct ks_sockaddr_storage sai_faddr;
    struct ks_sockaddr_storage sai_laddr;
};
_Static_assert(offsetof(struct ks_socket_au_info, sai_domain) == 0x0, "ks_socket_au_info.sai_domain offset");
_Static_assert(offsetof(struct ks_socket_au_info, sai_type) == 0x4, "ks_socket_au_info.sai_type offset");
_Static_assert(offsetof(struct ks_socket_au_info, sai_protocol) == 0x8, "ks_socket_au_info.sai_protocol offset");
_Static_assert(offsetof(struct ks_socket_au_info, sai_faddr) == 0x10, "ks_socket_au_info.sai_faddr offset");
_Static_assert(offsetof(struct ks_socket_au_info, sai_laddr) == 0x90, "ks_socket_au_info.sai_laddr offset");
_Static_assert(sizeof(struct ks_socket_au_info) == 0x110, "ks_socket_au_info size");

/* refs: 21 */
struct ks_timespec {
    long tv_sec;
    long tv_nsec;
};
_Static_assert(offsetof(struct ks_timespec, tv_sec) == 0x0, "ks_timespec.tv_sec offset");
_Static_assert(offsetof(struct ks_timespec, tv_nsec) == 0x8, "ks_timespec.tv_nsec offset");
_Static_assert(sizeof(struct ks_timespec) == 0x10, "ks_timespec size");

/* refs: 2 */
struct ks_vnode_au_info {
    unsigned short vn_mode;
    unsigned int vn_uid;
    unsigned int vn_gid;
    int vn_dev;
    long vn_fsid;
    long vn_fileid;
    long vn_gen;
};
_Static_assert(offsetof(struct ks_vnode_au_info, vn_mode) == 0x0, "ks_vnode_au_info.vn_mode offset");
_Static_assert(offsetof(struct ks_vnode_au_info, vn_uid) == 0x4, "ks_vnode_au_info.vn_uid offset");
_Static_assert(offsetof(struct ks_vnode_au_info, vn_gid) == 0x8, "ks_vnode_au_info.vn_gid offset");
_Static_assert(offsetof(struct ks_vnode_au_info, vn_dev) == 0xC, "ks_vnode_au_info.vn_dev offset");
_Static_assert(offsetof(struct ks_vnode_au_info, vn_fsid) == 0x10, "ks_vnode_au_info.vn_fsid offset");
_Static_assert(offsetof(struct ks_vnode_au_info, vn_fileid) == 0x18, "ks_vnode_au_info.vn_fileid offset");
_Static_assert(offsetof(struct ks_vnode_au_info, vn_gen) == 0x20, "ks_vnode_au_info.vn_gen offset");
_Static_assert(sizeof(struct ks_vnode_au_info) == 0x28, "ks_vnode_au_info size");

/* refs: 1 */
struct ks_xucred {
    unsigned int cr_version;
    unsigned int cr_uid;
    short cr_ngroups;
    unsigned int cr_groups[0x10];
};
_Static_assert(offsetof(struct ks_xucred, cr_version) == 0x0, "ks_xucred.cr_version offset");
_Static_assert(offsetof(struct ks_xucred, cr_uid) == 0x4, "ks_xucred.cr_uid offset");
_Static_assert(offsetof(struct ks_xucred, cr_ngroups) == 0x8, "ks_xucred.cr_ngroups offset");
_Static_assert(offsetof(struct ks_xucred, cr_groups) == 0xC, "ks_xucred.cr_groups offset");
_Static_assert(sizeof(struct ks_xucred) == 0x4C, "ks_xucred size");

/* refs: 2 */
struct ks_audit_stat {
    unsigned int as_version;
    unsigned int as_numevent;
    int as_generated;
    int as_nonattrib;
    int as_kernel;
    int as_audit;
    int as_auditctl;
    int as_enqueue;
    int as_written;
    int as_wblocked;
    int as_rblocked;
    int as_dropped;
    int as_totalsize;
    unsigned int as_memused;
};
_Static_assert(offsetof(struct ks_audit_stat, as_version) == 0x0, "ks_audit_stat.as_version offset");
_Static_assert(offsetof(struct ks_audit_stat, as_numevent) == 0x4, "ks_audit_stat.as_numevent offset");
_Static_assert(offsetof(struct ks_audit_stat, as_generated) == 0x8, "ks_audit_stat.as_generated offset");
_Static_assert(offsetof(struct ks_audit_stat, as_nonattrib) == 0xC, "ks_audit_stat.as_nonattrib offset");
_Static_assert(offsetof(struct ks_audit_stat, as_kernel) == 0x10, "ks_audit_stat.as_kernel offset");
_Static_assert(offsetof(struct ks_audit_stat, as_audit) == 0x14, "ks_audit_stat.as_audit offset");
_Static_assert(offsetof(struct ks_audit_stat, as_auditctl) == 0x18, "ks_audit_stat.as_auditctl offset");
_Static_assert(offsetof(struct ks_audit_stat, as_enqueue) == 0x1C, "ks_audit_stat.as_enqueue offset");
_Static_assert(offsetof(struct ks_audit_stat, as_written) == 0x20, "ks_audit_stat.as_written offset");
_Static_assert(offsetof(struct ks_audit_stat, as_wblocked) == 0x24, "ks_audit_stat.as_wblocked offset");
_Static_assert(offsetof(struct ks_audit_stat, as_rblocked) == 0x28, "ks_audit_stat.as_rblocked offset");
_Static_assert(offsetof(struct ks_audit_stat, as_dropped) == 0x2C, "ks_audit_stat.as_dropped offset");
_Static_assert(offsetof(struct ks_audit_stat, as_totalsize) == 0x30, "ks_audit_stat.as_totalsize offset");
_Static_assert(offsetof(struct ks_audit_stat, as_memused) == 0x34, "ks_audit_stat.as_memused offset");
_Static_assert(sizeof(struct ks_audit_stat) == 0x38, "ks_audit_stat size");

/* refs: 2 */
struct ks_auditinfo {
    unsigned int ai_auid;
    struct ks_au_mask ai_mask;
    struct ks_au_tid ai_termid;
    int ai_asid;
};
_Static_assert(offsetof(struct ks_auditinfo, ai_auid) == 0x0, "ks_auditinfo.ai_auid offset");
_Static_assert(offsetof(struct ks_auditinfo, ai_mask) == 0x4, "ks_auditinfo.ai_mask offset");
_Static_assert(offsetof(struct ks_auditinfo, ai_termid) == 0xC, "ks_auditinfo.ai_termid offset");
_Static_assert(offsetof(struct ks_auditinfo, ai_asid) == 0x14, "ks_auditinfo.ai_asid offset");
_Static_assert(sizeof(struct ks_auditinfo) == 0x18, "ks_auditinfo size");

/* refs: 3 */
struct ks_auditinfo_addr {
    unsigned int ai_auid;
    struct ks_au_mask ai_mask;
    struct ks_au_tid_addr ai_termid;
    int ai_asid;
    unsigned long long ai_flags __attribute__((aligned(8)));
};
_Static_assert(offsetof(struct ks_auditinfo_addr, ai_auid) == 0x0, "ks_auditinfo_addr.ai_auid offset");
_Static_assert(offsetof(struct ks_auditinfo_addr, ai_mask) == 0x4, "ks_auditinfo_addr.ai_mask offset");
_Static_assert(offsetof(struct ks_auditinfo_addr, ai_termid) == 0xC, "ks_auditinfo_addr.ai_termid offset");
_Static_assert(offsetof(struct ks_auditinfo_addr, ai_asid) == 0x24, "ks_auditinfo_addr.ai_asid offset");
_Static_assert(offsetof(struct ks_auditinfo_addr, ai_flags) == 0x28, "ks_auditinfo_addr.ai_flags offset");
_Static_assert(sizeof(struct ks_auditinfo_addr) == 0x30, "ks_auditinfo_addr size");

/* refs: 2 */
struct ks_auditpinfo {
    int ap_pid;
    unsigned int ap_auid;
    struct ks_au_mask ap_mask;
    struct ks_au_tid ap_termid;
    int ap_asid;
};
_Static_assert(offsetof(struct ks_auditpinfo, ap_pid) == 0x0, "ks_auditpinfo.ap_pid offset");
_Static_assert(offsetof(struct ks_auditpinfo, ap_auid) == 0x4, "ks_auditpinfo.ap_auid offset");
_Static_assert(offsetof(struct ks_auditpinfo, ap_mask) == 0x8, "ks_auditpinfo.ap_mask offset");
_Static_assert(offsetof(struct ks_auditpinfo, ap_termid) == 0x10, "ks_auditpinfo.ap_termid offset");
_Static_assert(offsetof(struct ks_auditpinfo, ap_asid) == 0x18, "ks_auditpinfo.ap_asid offset");
_Static_assert(sizeof(struct ks_auditpinfo) == 0x1C, "ks_auditpinfo size");

/* refs: 2 */
struct ks_auditpinfo_addr {
    int ap_pid;
    unsigned int ap_auid;
    struct ks_au_mask ap_mask;
    struct ks_au_tid_addr ap_termid;
    int ap_asid;
    unsigned long long ap_flags __attribute__((aligned(8)));
};
_Static_assert(offsetof(struct ks_auditpinfo_addr, ap_pid) == 0x0, "ks_auditpinfo_addr.ap_pid offset");
_Static_assert(offsetof(struct ks_auditpinfo_addr, ap_auid) == 0x4, "ks_auditpinfo_addr.ap_auid offset");
_Static_assert(offsetof(struct ks_auditpinfo_addr, ap_mask) == 0x8, "ks_auditpinfo_addr.ap_mask offset");
_Static_assert(offsetof(struct ks_auditpinfo_addr, ap_termid) == 0x10, "ks_auditpinfo_addr.ap_termid offset");
_Static_assert(offsetof(struct ks_auditpinfo_addr, ap_asid) == 0x28, "ks_auditpinfo_addr.ap_asid offset");
_Static_assert(offsetof(struct ks_auditpinfo_addr, ap_flags) == 0x30, "ks_auditpinfo_addr.ap_flags offset");
_Static_assert(sizeof(struct ks_auditpinfo_addr) == 0x38, "ks_auditpinfo_addr size");

/* refs: 1 */
union ks_auditon_udata {
    char *au_path;
    int au_cond;
    int au_policy;
    long long au_cond64;
    long long au_policy64;
    int au_trigger;
    struct ks_au_evclass_map au_evclass;
    struct ks_au_mask au_mask;
    unsigned long long au_flags __attribute__((aligned(8)));
    struct ks_auditinfo au_auinfo;
    struct ks_auditpinfo au_aupinfo;
    struct ks_auditpinfo_addr au_aupinfo_addr;
    struct ks_au_qctrl au_qctrl;
    struct ks_au_qctrl64 au_qctrl64;
    struct ks_audit_stat au_stat;
    struct ks_audit_fstat au_fstat;
    struct ks_auditinfo_addr au_kau_info;
    unsigned char au_ctl_mode;
    struct ks_au_expire_after au_expire_after;
};
_Static_assert(offsetof(union ks_auditon_udata, au_path) == 0x0, "ks_auditon_udata.au_path offset");
_Static_assert(offsetof(union ks_auditon_udata, au_cond) == 0x0, "ks_auditon_udata.au_cond offset");
_Static_assert(offsetof(union ks_auditon_udata, au_policy) == 0x0, "ks_auditon_udata.au_policy offset");
_Static_assert(offsetof(union ks_auditon_udata, au_cond64) == 0x0, "ks_auditon_udata.au_cond64 offset");
_Static_assert(offsetof(union ks_auditon_udata, au_policy64) == 0x0, "ks_auditon_udata.au_policy64 offset");
_Static_assert(offsetof(union ks_auditon_udata, au_trigger) == 0x0, "ks_auditon_udata.au_trigger offset");
_Static_assert(offsetof(union ks_auditon_udata, au_evclass) == 0x0, "ks_auditon_udata.au_evclass offset");
_Static_assert(offsetof(union ks_auditon_udata, au_mask) == 0x0, "ks_auditon_udata.au_mask offset");
_Static_assert(offsetof(union ks_auditon_udata, au_flags) == 0x0, "ks_auditon_udata.au_flags offset");
_Static_assert(offsetof(union ks_auditon_udata, au_auinfo) == 0x0, "ks_auditon_udata.au_auinfo offset");
_Static_assert(offsetof(union ks_auditon_udata, au_aupinfo) == 0x0, "ks_auditon_udata.au_aupinfo offset");
_Static_assert(offsetof(union ks_auditon_udata, au_aupinfo_addr) == 0x0, "ks_auditon_udata.au_aupinfo_addr offset");
_Static_assert(offsetof(union ks_auditon_udata, au_qctrl) == 0x0, "ks_auditon_udata.au_qctrl offset");
_Static_assert(offsetof(union ks_auditon_udata, au_qctrl64) == 0x0, "ks_auditon_udata.au_qctrl64 offset");
_Static_assert(offsetof(union ks_auditon_udata, au_stat) == 0x0, "ks_auditon_udata.au_stat offset");
_Static_assert(offsetof(union ks_auditon_udata, au_fstat) == 0x0, "ks_auditon_udata.au_fstat offset");
_Static_assert(offsetof(union ks_auditon_udata, au_kau_info) == 0x0, "ks_auditon_udata.au_kau_info offset");
_Static_assert(offsetof(union ks_auditon_udata, au_ctl_mode) == 0x0, "ks_auditon_udata.au_ctl_mode offset");
_Static_assert(offsetof(union ks_auditon_udata, au_expire_after) == 0x0, "ks_auditon_udata.au_expire_after offset");

/* refs: 1 */
struct ks_audit_record {
    unsigned int ar_magic;
    int ar_event;
    int ar_retval;
    int ar_errno;
    struct ks_timespec ar_starttime;
    struct ks_timespec ar_endtime;
    unsigned long long ar_valid_arg;
    struct ks_xucred ar_subj_cred;
    unsigned int ar_subj_ruid;
    unsigned int ar_subj_rgid;
    unsigned int ar_subj_egid;
    unsigned int ar_subj_auid;
    int ar_subj_asid;
    int ar_subj_pid;
    struct ks_au_tid ar_subj_term;
    struct ks_au_tid_addr ar_subj_term_addr;
    struct ks_au_mask ar_subj_amask;
    unsigned int ar_arg_euid;
    unsigned int ar_arg_ruid;
    unsigned int ar_arg_suid;
    unsigned int ar_arg_egid;
    unsigned int ar_arg_rgid;
    unsigned int ar_arg_sgid;
    int ar_arg_pid;
    int ar_arg_asid;
    struct ks_au_tid ar_arg_termid;
    struct ks_au_tid_addr ar_arg_termid_addr;
    unsigned int ar_arg_uid;
    unsigned int ar_arg_auid;
    unsigned int ar_arg_gid;
    struct ks_groupset ar_arg_groups;
    int ar_arg_fd;
    int ar_arg_fflags;
    unsigned short ar_arg_mode;
    unsigned int ar_arg_value32;
    unsigned long long ar_arg_value64;
    unsigned long long ar_arg_addr;
    unsigned long long ar_arg_len;
    int ar_arg_mask;
    unsigned int ar_arg_signum;
    char ar_arg_login[0xFF];
    int ar_arg_ctlname[12];
    struct ks_socket_au_info ar_arg_sockinfo;
    char *ar_arg_upath1;
    char *ar_arg_upath2;
    char *ar_arg_kpath1;
    char *ar_arg_kpath2;
    char *ar_vnode1_mac_labels;
    char *ar_vnode2_mac_labels;
    char *ar_cred_mac_labels;
    char *ar_arg_mac_string;
    char *ar_arg_text;
    void *ar_arg_opaque;
    void *ar_arg_data;
    unsigned short ar_arg_opq_size;
    unsigned char ar_arg_data_type;
    unsigned char ar_arg_data_count;
    struct ks_au_mask ar_arg_amask;
    struct ks_vnode_au_info ar_arg_vnode1;
    struct ks_vnode_au_info ar_arg_vnode2;
    int ar_arg_cmd;
    int ar_arg_svipc_cmd;
    struct ks_ipc_perm ar_arg_svipc_perm __attribute__((aligned(4)));
    int ar_arg_svipc_id;
    unsigned long long ar_arg_svipc_addr;
    struct ks_posix_ipc_perm ar_arg_pipc_perm;
    unsigned int ar_arg_mach_port1;
    unsigned int ar_arg_mach_port2;
    union ks_auditon_udata ar_arg_auditon;
    char *ar_arg_argv;
    int ar_arg_argc;
    char *ar_arg_envv;
    int ar_arg_envc;
    int ar_arg_exitstatus;
    int ar_arg_exitretval;
    struct ks_sockaddr_storage ar_arg_sockaddr;
    int ar_arg_fd2;
    struct ks_mac_audit_record_list_t *ar_mac_records;
    int ar_forced_by_mac;
    struct ks_au_identity_info ar_arg_identity;
};
_Static_assert(offsetof(struct ks_audit_record, ar_magic) == 0x0, "ks_audit_record.ar_magic offset");
_Static_assert(offsetof(struct ks_audit_record, ar_event) == 0x4, "ks_audit_record.ar_event offset");
_Static_assert(offsetof(struct ks_audit_record, ar_retval) == 0x8, "ks_audit_record.ar_retval offset");
_Static_assert(offsetof(struct ks_audit_record, ar_errno) == 0xC, "ks_audit_record.ar_errno offset");
_Static_assert(offsetof(struct ks_audit_record, ar_starttime) == 0x10, "ks_audit_record.ar_starttime offset");
_Static_assert(offsetof(struct ks_audit_record, ar_endtime) == 0x20, "ks_audit_record.ar_endtime offset");
_Static_assert(offsetof(struct ks_audit_record, ar_valid_arg) == 0x30, "ks_audit_record.ar_valid_arg offset");
_Static_assert(offsetof(struct ks_audit_record, ar_subj_cred) == 0x38, "ks_audit_record.ar_subj_cred offset");
_Static_assert(offsetof(struct ks_audit_record, ar_subj_ruid) == 0x84, "ks_audit_record.ar_subj_ruid offset");
_Static_assert(offsetof(struct ks_audit_record, ar_subj_rgid) == 0x88, "ks_audit_record.ar_subj_rgid offset");
_Static_assert(offsetof(struct ks_audit_record, ar_subj_egid) == 0x8C, "ks_audit_record.ar_subj_egid offset");
_Static_assert(offsetof(struct ks_audit_record, ar_subj_auid) == 0x90, "ks_audit_record.ar_subj_auid offset");
_Static_assert(offsetof(struct ks_audit_record, ar_subj_asid) == 0x94, "ks_audit_record.ar_subj_asid offset");
_Static_assert(offsetof(struct ks_audit_record, ar_subj_pid) == 0x98, "ks_audit_record.ar_subj_pid offset");
_Static_assert(offsetof(struct ks_audit_record, ar_subj_term) == 0x9C, "ks_audit_record.ar_subj_term offset");
_Static_assert(offsetof(struct ks_audit_record, ar_subj_term_addr) == 0xA4, "ks_audit_record.ar_subj_term_addr offset");
_Static_assert(offsetof(struct ks_audit_record, ar_subj_amask) == 0xBC, "ks_audit_record.ar_subj_amask offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_euid) == 0xC4, "ks_audit_record.ar_arg_euid offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_ruid) == 0xC8, "ks_audit_record.ar_arg_ruid offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_suid) == 0xCC, "ks_audit_record.ar_arg_suid offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_egid) == 0xD0, "ks_audit_record.ar_arg_egid offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_rgid) == 0xD4, "ks_audit_record.ar_arg_rgid offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_sgid) == 0xD8, "ks_audit_record.ar_arg_sgid offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_pid) == 0xDC, "ks_audit_record.ar_arg_pid offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_asid) == 0xE0, "ks_audit_record.ar_arg_asid offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_termid) == 0xE4, "ks_audit_record.ar_arg_termid offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_termid_addr) == 0xEC, "ks_audit_record.ar_arg_termid_addr offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_uid) == 0x104, "ks_audit_record.ar_arg_uid offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_auid) == 0x108, "ks_audit_record.ar_arg_auid offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_gid) == 0x10C, "ks_audit_record.ar_arg_gid offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_groups) == 0x110, "ks_audit_record.ar_arg_groups offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_fd) == 0x154, "ks_audit_record.ar_arg_fd offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_fflags) == 0x158, "ks_audit_record.ar_arg_fflags offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_mode) == 0x15C, "ks_audit_record.ar_arg_mode offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_value32) == 0x160, "ks_audit_record.ar_arg_value32 offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_value64) == 0x168, "ks_audit_record.ar_arg_value64 offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_addr) == 0x170, "ks_audit_record.ar_arg_addr offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_len) == 0x178, "ks_audit_record.ar_arg_len offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_mask) == 0x180, "ks_audit_record.ar_arg_mask offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_signum) == 0x184, "ks_audit_record.ar_arg_signum offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_login) == 0x188, "ks_audit_record.ar_arg_login offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_ctlname) == 0x288, "ks_audit_record.ar_arg_ctlname offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_sockinfo) == 0x2B8, "ks_audit_record.ar_arg_sockinfo offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_upath1) == 0x3C8, "ks_audit_record.ar_arg_upath1 offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_upath2) == 0x3D0, "ks_audit_record.ar_arg_upath2 offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_kpath1) == 0x3D8, "ks_audit_record.ar_arg_kpath1 offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_kpath2) == 0x3E0, "ks_audit_record.ar_arg_kpath2 offset");
_Static_assert(offsetof(struct ks_audit_record, ar_vnode1_mac_labels) == 0x3E8, "ks_audit_record.ar_vnode1_mac_labels offset");
_Static_assert(offsetof(struct ks_audit_record, ar_vnode2_mac_labels) == 0x3F0, "ks_audit_record.ar_vnode2_mac_labels offset");
_Static_assert(offsetof(struct ks_audit_record, ar_cred_mac_labels) == 0x3F8, "ks_audit_record.ar_cred_mac_labels offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_mac_string) == 0x400, "ks_audit_record.ar_arg_mac_string offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_text) == 0x408, "ks_audit_record.ar_arg_text offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_opaque) == 0x410, "ks_audit_record.ar_arg_opaque offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_data) == 0x418, "ks_audit_record.ar_arg_data offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_opq_size) == 0x420, "ks_audit_record.ar_arg_opq_size offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_data_type) == 0x422, "ks_audit_record.ar_arg_data_type offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_data_count) == 0x423, "ks_audit_record.ar_arg_data_count offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_amask) == 0x424, "ks_audit_record.ar_arg_amask offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_vnode1) == 0x430, "ks_audit_record.ar_arg_vnode1 offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_vnode2) == 0x458, "ks_audit_record.ar_arg_vnode2 offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_cmd) == 0x480, "ks_audit_record.ar_arg_cmd offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_svipc_cmd) == 0x484, "ks_audit_record.ar_arg_svipc_cmd offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_svipc_perm) == 0x488, "ks_audit_record.ar_arg_svipc_perm offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_svipc_id) == 0x4A0, "ks_audit_record.ar_arg_svipc_id offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_svipc_addr) == 0x4A8, "ks_audit_record.ar_arg_svipc_addr offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_pipc_perm) == 0x4B0, "ks_audit_record.ar_arg_pipc_perm offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_mach_port1) == 0x4BC, "ks_audit_record.ar_arg_mach_port1 offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_mach_port2) == 0x4C0, "ks_audit_record.ar_arg_mach_port2 offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_auditon) == 0x4C8, "ks_audit_record.ar_arg_auditon offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_argv) == 0x500, "ks_audit_record.ar_arg_argv offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_argc) == 0x508, "ks_audit_record.ar_arg_argc offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_envv) == 0x510, "ks_audit_record.ar_arg_envv offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_envc) == 0x518, "ks_audit_record.ar_arg_envc offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_exitstatus) == 0x51C, "ks_audit_record.ar_arg_exitstatus offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_exitretval) == 0x520, "ks_audit_record.ar_arg_exitretval offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_sockaddr) == 0x528, "ks_audit_record.ar_arg_sockaddr offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_fd2) == 0x5A8, "ks_audit_record.ar_arg_fd2 offset");
_Static_assert(offsetof(struct ks_audit_record, ar_mac_records) == 0x5B0, "ks_audit_record.ar_mac_records offset");
_Static_assert(offsetof(struct ks_audit_record, ar_forced_by_mac) == 0x5B8, "ks_audit_record.ar_forced_by_mac offset");
_Static_assert(offsetof(struct ks_audit_record, ar_arg_identity) == 0x5C0, "ks_audit_record.ar_arg_identity offset");
_Static_assert(sizeof(struct ks_audit_record) == 0x5F8, "ks_audit_record size");

/* refs: 2 */
struct ks_audit_token_t {
    unsigned int val[8];
} __attribute__((aligned(4)));
_Static_assert(offsetof(struct ks_audit_token_t, val) == 0x0, "ks_audit_token_t.val offset");
_Static_assert(sizeof(struct ks_audit_token_t) == 0x20, "ks_audit_token_t size");

/* refs: 1 */
struct ks_bandwidth {
    unsigned long long rate;
    unsigned long long prev_time_to_send;
};
_Static_assert(offsetof(struct ks_bandwidth, rate) == 0x0, "ks_bandwidth.rate offset");
_Static_assert(offsetof(struct ks_bandwidth, prev_time_to_send) == 0x8, "ks_bandwidth.prev_time_to_send offset");
_Static_assert(sizeof(struct ks_bandwidth) == 0x10, "ks_bandwidth size");

/* refs: 1 */
struct ks_bank_element {
    unsigned int be_type : 31; /* bit offset 0 */
    unsigned int be_voucher_ref : 1; /* bit offset 31 */
    unsigned int be_refs;
    unsigned int be_made;
};
_Static_assert(offsetof(struct ks_bank_element, be_refs) == 0x4, "ks_bank_element.be_refs offset");
_Static_assert(offsetof(struct ks_bank_element, be_made) == 0x8, "ks_bank_element.be_made offset");
_Static_assert(sizeof(struct ks_bank_element) == 0xC, "ks_bank_element size");

/* refs: 1 */
struct ks_proc_persona_info {
    unsigned long long unique_pid;
    int pid;
    unsigned int flags;
    unsigned int pidversion;
    unsigned int persona_id;
    unsigned int uid;
    unsigned int gid;
    unsigned char macho_uuid[0x10];
};
_Static_assert(offsetof(struct ks_proc_persona_info, unique_pid) == 0x0, "ks_proc_persona_info.unique_pid offset");
_Static_assert(offsetof(struct ks_proc_persona_info, pid) == 0x8, "ks_proc_persona_info.pid offset");
_Static_assert(offsetof(struct ks_proc_persona_info, flags) == 0xC, "ks_proc_persona_info.flags offset");
_Static_assert(offsetof(struct ks_proc_persona_info, pidversion) == 0x10, "ks_proc_persona_info.pidversion offset");
_Static_assert(offsetof(struct ks_proc_persona_info, persona_id) == 0x14, "ks_proc_persona_info.persona_id offset");
_Static_assert(offsetof(struct ks_proc_persona_info, uid) == 0x18, "ks_proc_persona_info.uid offset");
_Static_assert(offsetof(struct ks_proc_persona_info, gid) == 0x1C, "ks_proc_persona_info.gid offset");
_Static_assert(offsetof(struct ks_proc_persona_info, macho_uuid) == 0x20, "ks_proc_persona_info.macho_uuid offset");
_Static_assert(sizeof(struct ks_proc_persona_info) == 0x30, "ks_proc_persona_info size");

/* refs: 1 */
struct ks_bank_task {
    struct ks_bank_element bt_elem;
    struct ks_proc_persona_info bt_proc_persona;
    struct ks_ledger *bt_ledger;
    struct ks_queue_entry bt_accounts_to_pay;
    struct ks_queue_entry bt_accounts_to_charge;
    struct ks_lck_mtx_s bt_acc_to_pay_lock;
    struct ks_lck_mtx_s bt_acc_to_charge_lock;
    unsigned int bt_persona_uid;
    unsigned int bt_hasentitlement : 1; /* bit offset 1120 */
    unsigned long long bt_rsrc_coal_id;
    struct ks_thread_group *bt_thread_group;
};
_Static_assert(offsetof(struct ks_bank_task, bt_elem) == 0x0, "ks_bank_task.bt_elem offset");
_Static_assert(offsetof(struct ks_bank_task, bt_proc_persona) == 0x10, "ks_bank_task.bt_proc_persona offset");
_Static_assert(offsetof(struct ks_bank_task, bt_ledger) == 0x40, "ks_bank_task.bt_ledger offset");
_Static_assert(offsetof(struct ks_bank_task, bt_accounts_to_pay) == 0x48, "ks_bank_task.bt_accounts_to_pay offset");
_Static_assert(offsetof(struct ks_bank_task, bt_accounts_to_charge) == 0x58, "ks_bank_task.bt_accounts_to_charge offset");
_Static_assert(offsetof(struct ks_bank_task, bt_acc_to_pay_lock) == 0x68, "ks_bank_task.bt_acc_to_pay_lock offset");
_Static_assert(offsetof(struct ks_bank_task, bt_acc_to_charge_lock) == 0x78, "ks_bank_task.bt_acc_to_charge_lock offset");
_Static_assert(offsetof(struct ks_bank_task, bt_persona_uid) == 0x88, "ks_bank_task.bt_persona_uid offset");
_Static_assert(offsetof(struct ks_bank_task, bt_rsrc_coal_id) == 0x90, "ks_bank_task.bt_rsrc_coal_id offset");
_Static_assert(offsetof(struct ks_bank_task, bt_thread_group) == 0x98, "ks_bank_task.bt_thread_group offset");
_Static_assert(sizeof(struct ks_bank_task) == 0xA0, "ks_bank_task size");

/* refs: 1 */
struct ks_bool_gen {
    unsigned int seed[4];
    unsigned int state;
    struct ks_lck_spin_s lock;
};
_Static_assert(offsetof(struct ks_bool_gen, seed) == 0x0, "ks_bool_gen.seed offset");
_Static_assert(offsetof(struct ks_bool_gen, state) == 0x10, "ks_bool_gen.state offset");
_Static_assert(offsetof(struct ks_bool_gen, lock) == 0x18, "ks_bool_gen.lock offset");
_Static_assert(sizeof(struct ks_bool_gen) == 0x28, "ks_bool_gen size");

/* refs: 1 */
struct ks_bpf_comp_stats {
    unsigned long long bcs_total_read;
    unsigned long long bcs_total_size;
    unsigned long long bcs_total_hdr_size;
    unsigned long long bcs_count_no_common_prefix;
    unsigned long long bcs_count_compressed_prefix;
    unsigned long long bcs_total_compressed_prefix_size;
    unsigned long long bcs_max_compressed_prefix_size;
};
_Static_assert(offsetof(struct ks_bpf_comp_stats, bcs_total_read) == 0x0, "ks_bpf_comp_stats.bcs_total_read offset");
_Static_assert(offsetof(struct ks_bpf_comp_stats, bcs_total_size) == 0x8, "ks_bpf_comp_stats.bcs_total_size offset");
_Static_assert(offsetof(struct ks_bpf_comp_stats, bcs_total_hdr_size) == 0x10, "ks_bpf_comp_stats.bcs_total_hdr_size offset");
_Static_assert(offsetof(struct ks_bpf_comp_stats, bcs_count_no_common_prefix) == 0x18, "ks_bpf_comp_stats.bcs_count_no_common_prefix offset");
_Static_assert(offsetof(struct ks_bpf_comp_stats, bcs_count_compressed_prefix) == 0x20, "ks_bpf_comp_stats.bcs_count_compressed_prefix offset");
_Static_assert(offsetof(struct ks_bpf_comp_stats, bcs_total_compressed_prefix_size) == 0x28, "ks_bpf_comp_stats.bcs_total_compressed_prefix_size offset");
_Static_assert(offsetof(struct ks_bpf_comp_stats, bcs_max_compressed_prefix_size) == 0x30, "ks_bpf_comp_stats.bcs_max_compressed_prefix_size offset");
_Static_assert(sizeof(struct ks_bpf_comp_stats) == 0x38, "ks_bpf_comp_stats size");

/* refs: 1 */
struct ks_bpf_d {
    struct ks_bpf_d *bd_next;
    struct ks___bounds_safety__wide_ptr_bidi_indexable_4 bd_sbuf;
    struct ks___bounds_safety__wide_ptr_bidi_indexable_4 bd_hbuf;
    struct ks___bounds_safety__wide_ptr_bidi_indexable_4 bd_fbuf;
    unsigned int bd_slen;
    unsigned int bd_hlen;
    unsigned int bd_scnt;
    unsigned int bd_hcnt;
    unsigned int bd_bufsize;
    _Bool bd_hbuf_read;
    _Bool bd_hbuf_write;
    _Bool bd_headdrop;
    unsigned int bd_write_size_max;
    unsigned int bd_rtout;
    struct ks_bpf_if *bd_bif;
    struct ks_bpf_insn *bd_filter;
    unsigned int bd_filter_len;
    unsigned long long bd_rcount;
    unsigned long long bd_dcount;
    unsigned long long bd_fcount;
    unsigned long long bd_wcount;
    unsigned long long bd_wdcount;
    unsigned char bd_promisc;
    unsigned char bd_state;
    unsigned char bd_immediate;
    unsigned int bd_dev_minor;
    int bd_async;
    int bd_sig;
    int bd_sigio;
    struct ks_selinfo bd_sel;
    int bd_hdrcmplt;
    unsigned int bd_direction;
    int bd_oflags;
    struct ks_thread_call *bd_thread_call;
    int bd_traffic_class;
    int bd_flags;
    int bd_tstamp;
    int bd_refcnt;
    void *bd_ref_lr[4];
    void *bd_unref_lr[4];
    int bd_next_ref_lr;
    int bd_next_unref_lr;
    struct ks_proc *bd_opened_by;
    unsigned char bd_uuid[0x10];
    int bd_pid;
    unsigned char bd_prev_slen;
    struct ks___bounds_safety__wide_ptr_bidi_indexable_4 bd_prev_sbuf;
    struct ks___bounds_safety__wide_ptr_bidi_indexable_4 bd_prev_fbuf;
    struct ks_bpf_comp_stats bd_bcs;
};
_Static_assert(offsetof(struct ks_bpf_d, bd_next) == 0x0, "ks_bpf_d.bd_next offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_sbuf) == 0x8, "ks_bpf_d.bd_sbuf offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_hbuf) == 0x20, "ks_bpf_d.bd_hbuf offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_fbuf) == 0x38, "ks_bpf_d.bd_fbuf offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_slen) == 0x50, "ks_bpf_d.bd_slen offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_hlen) == 0x54, "ks_bpf_d.bd_hlen offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_scnt) == 0x58, "ks_bpf_d.bd_scnt offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_hcnt) == 0x5C, "ks_bpf_d.bd_hcnt offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_bufsize) == 0x60, "ks_bpf_d.bd_bufsize offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_hbuf_read) == 0x64, "ks_bpf_d.bd_hbuf_read offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_hbuf_write) == 0x65, "ks_bpf_d.bd_hbuf_write offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_headdrop) == 0x66, "ks_bpf_d.bd_headdrop offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_write_size_max) == 0x68, "ks_bpf_d.bd_write_size_max offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_rtout) == 0x6C, "ks_bpf_d.bd_rtout offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_bif) == 0x70, "ks_bpf_d.bd_bif offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_filter) == 0x78, "ks_bpf_d.bd_filter offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_filter_len) == 0x80, "ks_bpf_d.bd_filter_len offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_rcount) == 0x88, "ks_bpf_d.bd_rcount offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_dcount) == 0x90, "ks_bpf_d.bd_dcount offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_fcount) == 0x98, "ks_bpf_d.bd_fcount offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_wcount) == 0xA0, "ks_bpf_d.bd_wcount offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_wdcount) == 0xA8, "ks_bpf_d.bd_wdcount offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_promisc) == 0xB0, "ks_bpf_d.bd_promisc offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_state) == 0xB1, "ks_bpf_d.bd_state offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_immediate) == 0xB2, "ks_bpf_d.bd_immediate offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_dev_minor) == 0xB4, "ks_bpf_d.bd_dev_minor offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_async) == 0xB8, "ks_bpf_d.bd_async offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_sig) == 0xBC, "ks_bpf_d.bd_sig offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_sigio) == 0xC0, "ks_bpf_d.bd_sigio offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_sel) == 0xC8, "ks_bpf_d.bd_sel offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_hdrcmplt) == 0x100, "ks_bpf_d.bd_hdrcmplt offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_direction) == 0x104, "ks_bpf_d.bd_direction offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_oflags) == 0x108, "ks_bpf_d.bd_oflags offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_thread_call) == 0x110, "ks_bpf_d.bd_thread_call offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_traffic_class) == 0x118, "ks_bpf_d.bd_traffic_class offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_flags) == 0x11C, "ks_bpf_d.bd_flags offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_tstamp) == 0x120, "ks_bpf_d.bd_tstamp offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_refcnt) == 0x124, "ks_bpf_d.bd_refcnt offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_ref_lr) == 0x128, "ks_bpf_d.bd_ref_lr offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_unref_lr) == 0x148, "ks_bpf_d.bd_unref_lr offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_next_ref_lr) == 0x168, "ks_bpf_d.bd_next_ref_lr offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_next_unref_lr) == 0x16C, "ks_bpf_d.bd_next_unref_lr offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_opened_by) == 0x170, "ks_bpf_d.bd_opened_by offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_uuid) == 0x178, "ks_bpf_d.bd_uuid offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_pid) == 0x188, "ks_bpf_d.bd_pid offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_prev_slen) == 0x18C, "ks_bpf_d.bd_prev_slen offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_prev_sbuf) == 0x190, "ks_bpf_d.bd_prev_sbuf offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_prev_fbuf) == 0x1A8, "ks_bpf_d.bd_prev_fbuf offset");
_Static_assert(offsetof(struct ks_bpf_d, bd_bcs) == 0x1C0, "ks_bpf_d.bd_bcs offset");
_Static_assert(sizeof(struct ks_bpf_d) == 0x1F8, "ks_bpf_d size");

/* refs: 2 */
struct ks_bpf_if {
    struct ks_bpf_if *bif_next;
    struct ks_bpf_d *bif_dlist;
    unsigned int bif_dlt;
    unsigned int bif_hdrlen;
    unsigned int bif_exthdrlen;
    unsigned int bif_comphdrlen;
    struct ks_ifnet *bif_ifp;
    int *bif_send;
    int *bif_tap;
};
_Static_assert(offsetof(struct ks_bpf_if, bif_next) == 0x0, "ks_bpf_if.bif_next offset");
_Static_assert(offsetof(struct ks_bpf_if, bif_dlist) == 0x8, "ks_bpf_if.bif_dlist offset");
_Static_assert(offsetof(struct ks_bpf_if, bif_dlt) == 0x10, "ks_bpf_if.bif_dlt offset");
_Static_assert(offsetof(struct ks_bpf_if, bif_hdrlen) == 0x14, "ks_bpf_if.bif_hdrlen offset");
_Static_assert(offsetof(struct ks_bpf_if, bif_exthdrlen) == 0x18, "ks_bpf_if.bif_exthdrlen offset");
_Static_assert(offsetof(struct ks_bpf_if, bif_comphdrlen) == 0x1C, "ks_bpf_if.bif_comphdrlen offset");
_Static_assert(offsetof(struct ks_bpf_if, bif_ifp) == 0x20, "ks_bpf_if.bif_ifp offset");
_Static_assert(offsetof(struct ks_bpf_if, bif_send) == 0x28, "ks_bpf_if.bif_send offset");
_Static_assert(offsetof(struct ks_bpf_if, bif_tap) == 0x30, "ks_bpf_if.bif_tap offset");
_Static_assert(sizeof(struct ks_bpf_if) == 0x38, "ks_bpf_if size");

/* refs: 2 */
struct ks_bpf_insn {
    unsigned short code;
    unsigned char jt;
    unsigned char jf;
    unsigned int k;
};
_Static_assert(offsetof(struct ks_bpf_insn, code) == 0x0, "ks_bpf_insn.code offset");
_Static_assert(offsetof(struct ks_bpf_insn, jt) == 0x2, "ks_bpf_insn.jt offset");
_Static_assert(offsetof(struct ks_bpf_insn, jf) == 0x3, "ks_bpf_insn.jf offset");
_Static_assert(offsetof(struct ks_bpf_insn, k) == 0x4, "ks_bpf_insn.k offset");
_Static_assert(sizeof(struct ks_bpf_insn) == 0x8, "ks_bpf_insn size");

/* refs: 1 */
struct ks_bufattr {
    struct ks_cpx *ba_cpx;
    unsigned long long ba_cp_file_off;
    unsigned long long ba_flags;
    void *ba_un;
    unsigned int ba_verify_type;
};
_Static_assert(offsetof(struct ks_bufattr, ba_cpx) == 0x0, "ks_bufattr.ba_cpx offset");
_Static_assert(offsetof(struct ks_bufattr, ba_cp_file_off) == 0x8, "ks_bufattr.ba_cp_file_off offset");
_Static_assert(offsetof(struct ks_bufattr, ba_flags) == 0x10, "ks_bufattr.ba_flags offset");
_Static_assert(offsetof(struct ks_bufattr, ba_un) == 0x18, "ks_bufattr.ba_un offset");
_Static_assert(offsetof(struct ks_bufattr, ba_verify_type) == 0x20, "ks_bufattr.ba_verify_type offset");
_Static_assert(sizeof(struct ks_bufattr) == 0x28, "ks_bufattr size");

/* refs: 21 */
struct ks_timeval {
    long tv_sec;
    int tv_usec;
};
_Static_assert(offsetof(struct ks_timeval, tv_sec) == 0x0, "ks_timeval.tv_sec offset");
_Static_assert(offsetof(struct ks_timeval, tv_usec) == 0x8, "ks_timeval.tv_usec offset");
_Static_assert(sizeof(struct ks_timeval) == 0x10, "ks_timeval size");

/* refs: 10 */
struct ks_buf {
    struct {
        struct ks_buf *le_next;
        struct ks_buf **le_prev;
    } b_hash;
    struct {
        struct ks_buf *le_next;
        struct ks_buf **le_prev;
    } b_vnbufs;
    struct {
        struct ks_buf *tqe_next;
        struct ks_buf **tqe_prev;
    } b_freelist;
    int b_timestamp;
    struct ks_timeval b_timestamp_tv;
    int b_whichq;
    unsigned int b_flags;
    unsigned int b_lflags;
    int b_error;
    int b_bufsize;
    int b_bcount;
    int b_resid;
    int b_dev;
    unsigned long b_datap;
    long long b_lblkno;
    long long b_blkno;
    void *b_iodone;
    struct ks_vnode *b_vp;
    struct ks_ucred *b_rcred;
    struct ks_ucred *b_wcred;
    void *b_upl;
    struct ks_buf *b_real_bp;
    struct {
        struct ks_buf *tqe_next;
        struct ks_buf **tqe_prev;
    } b_act;
    void *b_drvdata;
    void *b_fsprivate;
    void *b_transaction;
    int b_dirtyoff;
    int b_dirtyend;
    int b_validoff;
    int b_validend;
    unsigned int b_redundancy_flags;
    struct ks_proc *b_proc;
    struct ks_bufattr b_attr;
    long long b_lblksize;
    struct ks_vnode *b_vnop_vp;
};
_Static_assert(offsetof(struct ks_buf, b_hash) == 0x0, "ks_buf.b_hash offset");
_Static_assert(offsetof(struct ks_buf, b_vnbufs) == 0x10, "ks_buf.b_vnbufs offset");
_Static_assert(offsetof(struct ks_buf, b_freelist) == 0x20, "ks_buf.b_freelist offset");
_Static_assert(offsetof(struct ks_buf, b_timestamp) == 0x30, "ks_buf.b_timestamp offset");
_Static_assert(offsetof(struct ks_buf, b_timestamp_tv) == 0x38, "ks_buf.b_timestamp_tv offset");
_Static_assert(offsetof(struct ks_buf, b_whichq) == 0x48, "ks_buf.b_whichq offset");
_Static_assert(offsetof(struct ks_buf, b_flags) == 0x4C, "ks_buf.b_flags offset");
_Static_assert(offsetof(struct ks_buf, b_lflags) == 0x50, "ks_buf.b_lflags offset");
_Static_assert(offsetof(struct ks_buf, b_error) == 0x54, "ks_buf.b_error offset");
_Static_assert(offsetof(struct ks_buf, b_bufsize) == 0x58, "ks_buf.b_bufsize offset");
_Static_assert(offsetof(struct ks_buf, b_bcount) == 0x5C, "ks_buf.b_bcount offset");
_Static_assert(offsetof(struct ks_buf, b_resid) == 0x60, "ks_buf.b_resid offset");
_Static_assert(offsetof(struct ks_buf, b_dev) == 0x64, "ks_buf.b_dev offset");
_Static_assert(offsetof(struct ks_buf, b_datap) == 0x68, "ks_buf.b_datap offset");
_Static_assert(offsetof(struct ks_buf, b_lblkno) == 0x70, "ks_buf.b_lblkno offset");
_Static_assert(offsetof(struct ks_buf, b_blkno) == 0x78, "ks_buf.b_blkno offset");
_Static_assert(offsetof(struct ks_buf, b_iodone) == 0x80, "ks_buf.b_iodone offset");
_Static_assert(offsetof(struct ks_buf, b_vp) == 0x88, "ks_buf.b_vp offset");
_Static_assert(offsetof(struct ks_buf, b_rcred) == 0x90, "ks_buf.b_rcred offset");
_Static_assert(offsetof(struct ks_buf, b_wcred) == 0x98, "ks_buf.b_wcred offset");
_Static_assert(offsetof(struct ks_buf, b_upl) == 0xA0, "ks_buf.b_upl offset");
_Static_assert(offsetof(struct ks_buf, b_real_bp) == 0xA8, "ks_buf.b_real_bp offset");
_Static_assert(offsetof(struct ks_buf, b_act) == 0xB0, "ks_buf.b_act offset");
_Static_assert(offsetof(struct ks_buf, b_drvdata) == 0xC0, "ks_buf.b_drvdata offset");
_Static_assert(offsetof(struct ks_buf, b_fsprivate) == 0xC8, "ks_buf.b_fsprivate offset");
_Static_assert(offsetof(struct ks_buf, b_transaction) == 0xD0, "ks_buf.b_transaction offset");
_Static_assert(offsetof(struct ks_buf, b_dirtyoff) == 0xD8, "ks_buf.b_dirtyoff offset");
_Static_assert(offsetof(struct ks_buf, b_dirtyend) == 0xDC, "ks_buf.b_dirtyend offset");
_Static_assert(offsetof(struct ks_buf, b_validoff) == 0xE0, "ks_buf.b_validoff offset");
_Static_assert(offsetof(struct ks_buf, b_validend) == 0xE4, "ks_buf.b_validend offset");
_Static_assert(offsetof(struct ks_buf, b_redundancy_flags) == 0xE8, "ks_buf.b_redundancy_flags offset");
_Static_assert(offsetof(struct ks_buf, b_proc) == 0xF0, "ks_buf.b_proc offset");
_Static_assert(offsetof(struct ks_buf, b_attr) == 0xF8, "ks_buf.b_attr offset");
_Static_assert(offsetof(struct ks_buf, b_lblksize) == 0x120, "ks_buf.b_lblksize offset");
_Static_assert(offsetof(struct ks_buf, b_vnop_vp) == 0x128, "ks_buf.b_vnop_vp offset");
_Static_assert(sizeof(struct ks_buf) == 0x130, "ks_buf size");

/* refs: 2 */
struct ks_buflists {
    struct ks_buf *lh_first;
};
_Static_assert(offsetof(struct ks_buflists, lh_first) == 0x0, "ks_buflists.lh_first offset");
_Static_assert(sizeof(struct ks_buflists) == 0x8, "ks_buflists size");

/* refs: 1 */
struct ks_necp_mtag_ {
    unsigned int necp_policy_id;
    unsigned int necp_skip_policy_id;
    unsigned int necp_route_rule_id;
    unsigned short necp_last_interface_index;
    unsigned short necp_app_id;
};
_Static_assert(offsetof(struct ks_necp_mtag_, necp_policy_id) == 0x0, "ks_necp_mtag_.necp_policy_id offset");
_Static_assert(offsetof(struct ks_necp_mtag_, necp_skip_policy_id) == 0x4, "ks_necp_mtag_.necp_skip_policy_id offset");
_Static_assert(offsetof(struct ks_necp_mtag_, necp_route_rule_id) == 0x8, "ks_necp_mtag_.necp_route_rule_id offset");
_Static_assert(offsetof(struct ks_necp_mtag_, necp_last_interface_index) == 0xC, "ks_necp_mtag_.necp_last_interface_index offset");
_Static_assert(offsetof(struct ks_necp_mtag_, necp_app_id) == 0xE, "ks_necp_mtag_.necp_app_id offset");
_Static_assert(sizeof(struct ks_necp_mtag_) == 0x10, "ks_necp_mtag_ size");

/* refs: 1 */
struct ks_pf_mtag {
    unsigned short pftag_flags;
    unsigned short pftag_rtableid;
    unsigned short pftag_tag;
    unsigned short pftag_routed;
};
_Static_assert(offsetof(struct ks_pf_mtag, pftag_flags) == 0x0, "ks_pf_mtag.pftag_flags offset");
_Static_assert(offsetof(struct ks_pf_mtag, pftag_rtableid) == 0x2, "ks_pf_mtag.pftag_rtableid offset");
_Static_assert(offsetof(struct ks_pf_mtag, pftag_tag) == 0x4, "ks_pf_mtag.pftag_tag offset");
_Static_assert(offsetof(struct ks_pf_mtag, pftag_routed) == 0x6, "ks_pf_mtag.pftag_routed offset");
_Static_assert(sizeof(struct ks_pf_mtag) == 0x8, "ks_pf_mtag size");

/* refs: 1 */
struct ks_rawip_mtag {
    int _pid;
    int _e_pid;
};
_Static_assert(offsetof(struct ks_rawip_mtag, _pid) == 0x0, "ks_rawip_mtag._pid offset");
_Static_assert(offsetof(struct ks_rawip_mtag, _e_pid) == 0x4, "ks_rawip_mtag._e_pid offset");
_Static_assert(sizeof(struct ks_rawip_mtag) == 0x8, "ks_rawip_mtag size");

/* refs: 1 */
struct ks_mptcp_pktinfo {
    unsigned long long mtpi_dsn;
    unsigned int mtpi_rel_seq;
    unsigned short mtpi_length;
    unsigned short mtpi_csum;
};
_Static_assert(offsetof(struct ks_mptcp_pktinfo, mtpi_dsn) == 0x0, "ks_mptcp_pktinfo.mtpi_dsn offset");
_Static_assert(offsetof(struct ks_mptcp_pktinfo, mtpi_rel_seq) == 0x8, "ks_mptcp_pktinfo.mtpi_rel_seq offset");
_Static_assert(offsetof(struct ks_mptcp_pktinfo, mtpi_length) == 0xC, "ks_mptcp_pktinfo.mtpi_length offset");
_Static_assert(offsetof(struct ks_mptcp_pktinfo, mtpi_csum) == 0xE, "ks_mptcp_pktinfo.mtpi_csum offset");
_Static_assert(sizeof(struct ks_mptcp_pktinfo) == 0x10, "ks_mptcp_pktinfo size");

/* refs: 1 */
struct ks_tcp_pktinfo {
    union {
        struct {
            unsigned short seg_size;
            unsigned short hdr_len;
            unsigned int start_seq;
            int pid;
            int e_pid;
        } __tx;
        struct {
            unsigned char seg_cnt;
        } __rx;
    } __offload;
};
_Static_assert(offsetof(struct ks_tcp_pktinfo, __offload) == 0x0, "ks_tcp_pktinfo.__offload offset");
_Static_assert(sizeof(struct ks_tcp_pktinfo) == 0x10, "ks_tcp_pktinfo size");

/* refs: 1 */
struct ks_tcp_mtag {
    union {
        struct ks_tcp_pktinfo tm_tcp;
        struct ks_mptcp_pktinfo tm_mptcp;
    };
};
_Static_assert(sizeof(struct ks_tcp_mtag) == 0x10, "ks_tcp_mtag size");

/* refs: 1 */
struct ks_udp_mtag {
    int _pid;
    int _e_pid;
};
_Static_assert(offsetof(struct ks_udp_mtag, _pid) == 0x0, "ks_udp_mtag._pid offset");
_Static_assert(offsetof(struct ks_udp_mtag, _e_pid) == 0x4, "ks_udp_mtag._e_pid offset");
_Static_assert(sizeof(struct ks_udp_mtag) == 0x8, "ks_udp_mtag size");

/* refs: 1 */
struct ks_proto_mtag_ {
    union {
        struct ks_tcp_mtag tcp;
        struct ks_udp_mtag udp;
        struct ks_rawip_mtag rawip;
    } __pr_u;
};
_Static_assert(offsetof(struct ks_proto_mtag_, __pr_u) == 0x0, "ks_proto_mtag_.__pr_u offset");
_Static_assert(sizeof(struct ks_proto_mtag_) == 0x10, "ks_proto_mtag_ size");

/* refs: 1 */
struct ks_ccdigest_info {
    unsigned long output_size;
    unsigned long state_size;
    unsigned long block_size;
    unsigned long oid_size;
    const unsigned char *oid;
    const void *initial_state;
    void *compress;
    void *final;
    unsigned int impl;
    void *compress_parallel;
};
_Static_assert(offsetof(struct ks_ccdigest_info, output_size) == 0x0, "ks_ccdigest_info.output_size offset");
_Static_assert(offsetof(struct ks_ccdigest_info, state_size) == 0x8, "ks_ccdigest_info.state_size offset");
_Static_assert(offsetof(struct ks_ccdigest_info, block_size) == 0x10, "ks_ccdigest_info.block_size offset");
_Static_assert(offsetof(struct ks_ccdigest_info, oid_size) == 0x18, "ks_ccdigest_info.oid_size offset");
_Static_assert(offsetof(struct ks_ccdigest_info, oid) == 0x20, "ks_ccdigest_info.oid offset");
_Static_assert(offsetof(struct ks_ccdigest_info, initial_state) == 0x28, "ks_ccdigest_info.initial_state offset");
_Static_assert(offsetof(struct ks_ccdigest_info, compress) == 0x30, "ks_ccdigest_info.compress offset");
_Static_assert(offsetof(struct ks_ccdigest_info, final) == 0x38, "ks_ccdigest_info.final offset");
_Static_assert(offsetof(struct ks_ccdigest_info, impl) == 0x40, "ks_ccdigest_info.impl offset");
_Static_assert(offsetof(struct ks_ccdigest_info, compress_parallel) == 0x48, "ks_ccdigest_info.compress_parallel offset");
_Static_assert(sizeof(struct ks_ccdigest_info) == 0x50, "ks_ccdigest_info size");

/* refs: 1 */
struct ks_cfil_mqhead {
    struct ks_mbuf *mq_first;
    struct ks_mbuf **mq_last;
};
_Static_assert(offsetof(struct ks_cfil_mqhead, mq_first) == 0x0, "ks_cfil_mqhead.mq_first offset");
_Static_assert(offsetof(struct ks_cfil_mqhead, mq_last) == 0x8, "ks_cfil_mqhead.mq_last offset");
_Static_assert(sizeof(struct ks_cfil_mqhead) == 0x10, "ks_cfil_mqhead size");

/* refs: 3 */
struct ks_cfil_queue {
    unsigned long long q_start;
    unsigned long long q_end;
    struct ks_cfil_mqhead q_mq;
};
_Static_assert(offsetof(struct ks_cfil_queue, q_start) == 0x0, "ks_cfil_queue.q_start offset");
_Static_assert(offsetof(struct ks_cfil_queue, q_end) == 0x8, "ks_cfil_queue.q_end offset");
_Static_assert(offsetof(struct ks_cfil_queue, q_mq) == 0x10, "ks_cfil_queue.q_mq offset");
_Static_assert(sizeof(struct ks_cfil_queue) == 0x20, "ks_cfil_queue size");

/* refs: 2 */
struct ks_cfe_buf {
    struct ks_cfil_queue cfe_pending_q;
    struct ks_cfil_queue cfe_ctl_q;
    unsigned long long cfe_pass_offset;
    unsigned long long cfe_peek_offset;
    unsigned long long cfe_peeked;
};
_Static_assert(offsetof(struct ks_cfe_buf, cfe_pending_q) == 0x0, "ks_cfe_buf.cfe_pending_q offset");
_Static_assert(offsetof(struct ks_cfe_buf, cfe_ctl_q) == 0x20, "ks_cfe_buf.cfe_ctl_q offset");
_Static_assert(offsetof(struct ks_cfe_buf, cfe_pass_offset) == 0x40, "ks_cfe_buf.cfe_pass_offset offset");
_Static_assert(offsetof(struct ks_cfe_buf, cfe_peek_offset) == 0x48, "ks_cfe_buf.cfe_peek_offset offset");
_Static_assert(offsetof(struct ks_cfe_buf, cfe_peeked) == 0x50, "ks_cfe_buf.cfe_peeked offset");
_Static_assert(sizeof(struct ks_cfe_buf) == 0x58, "ks_cfe_buf size");

/* refs: 2 */
struct ks_cfi_buf {
    unsigned long long cfi_pending_first;
    unsigned long long cfi_pending_last;
    unsigned int cfi_pending_mbcnt;
    unsigned int cfi_pending_mbnum;
    unsigned int cfi_tail_drop_cnt;
    unsigned long long cfi_pass_offset;
    struct ks_cfil_queue cfi_inject_q;
};
_Static_assert(offsetof(struct ks_cfi_buf, cfi_pending_first) == 0x0, "ks_cfi_buf.cfi_pending_first offset");
_Static_assert(offsetof(struct ks_cfi_buf, cfi_pending_last) == 0x8, "ks_cfi_buf.cfi_pending_last offset");
_Static_assert(offsetof(struct ks_cfi_buf, cfi_pending_mbcnt) == 0x10, "ks_cfi_buf.cfi_pending_mbcnt offset");
_Static_assert(offsetof(struct ks_cfi_buf, cfi_pending_mbnum) == 0x14, "ks_cfi_buf.cfi_pending_mbnum offset");
_Static_assert(offsetof(struct ks_cfi_buf, cfi_tail_drop_cnt) == 0x18, "ks_cfi_buf.cfi_tail_drop_cnt offset");
_Static_assert(offsetof(struct ks_cfi_buf, cfi_pass_offset) == 0x20, "ks_cfi_buf.cfi_pass_offset offset");
_Static_assert(offsetof(struct ks_cfi_buf, cfi_inject_q) == 0x28, "ks_cfi_buf.cfi_inject_q offset");
_Static_assert(sizeof(struct ks_cfi_buf) == 0x48, "ks_cfi_buf size");

/* refs: 1 */
struct ks_cfil_crypto_state {
    const struct ks_ccdigest_info *digest_info;
    unsigned char key[0x20];
};
_Static_assert(offsetof(struct ks_cfil_crypto_state, digest_info) == 0x0, "ks_cfil_crypto_state.digest_info offset");
_Static_assert(offsetof(struct ks_cfil_crypto_state, key) == 0x8, "ks_cfil_crypto_state.key offset");
_Static_assert(sizeof(struct ks_cfil_crypto_state) == 0x28, "ks_cfil_crypto_state size");

/* refs: 7 */
struct ks_cfil_entry {
    struct {
        struct ks_cfil_entry *tqe_next;
        struct ks_cfil_entry **tqe_prev;
    } cfe_link;
    struct {
        struct ks_cfil_entry *sle_next;
    } cfe_order_link;
    struct ks_content_filter *cfe_filter;
    struct ks_cfil_info *cfe_cfil_info;
    unsigned int cfe_flags;
    unsigned int cfe_necp_control_unit;
    struct ks_timeval cfe_last_event;
    struct ks_timeval cfe_last_action;
    unsigned long long cfe_byte_inbound_count_reported;
    unsigned long long cfe_byte_outbound_count_reported;
    struct ks_timeval cfe_stats_report_ts;
    unsigned int cfe_stats_report_frequency;
    int cfe_laddr_sent;
    struct ks_cfe_buf cfe_snd;
    struct ks_cfe_buf cfe_rcv;
};
_Static_assert(offsetof(struct ks_cfil_entry, cfe_link) == 0x0, "ks_cfil_entry.cfe_link offset");
_Static_assert(offsetof(struct ks_cfil_entry, cfe_order_link) == 0x10, "ks_cfil_entry.cfe_order_link offset");
_Static_assert(offsetof(struct ks_cfil_entry, cfe_filter) == 0x18, "ks_cfil_entry.cfe_filter offset");
_Static_assert(offsetof(struct ks_cfil_entry, cfe_cfil_info) == 0x20, "ks_cfil_entry.cfe_cfil_info offset");
_Static_assert(offsetof(struct ks_cfil_entry, cfe_flags) == 0x28, "ks_cfil_entry.cfe_flags offset");
_Static_assert(offsetof(struct ks_cfil_entry, cfe_necp_control_unit) == 0x2C, "ks_cfil_entry.cfe_necp_control_unit offset");
_Static_assert(offsetof(struct ks_cfil_entry, cfe_last_event) == 0x30, "ks_cfil_entry.cfe_last_event offset");
_Static_assert(offsetof(struct ks_cfil_entry, cfe_last_action) == 0x40, "ks_cfil_entry.cfe_last_action offset");
_Static_assert(offsetof(struct ks_cfil_entry, cfe_byte_inbound_count_reported) == 0x50, "ks_cfil_entry.cfe_byte_inbound_count_reported offset");
_Static_assert(offsetof(struct ks_cfil_entry, cfe_byte_outbound_count_reported) == 0x58, "ks_cfil_entry.cfe_byte_outbound_count_reported offset");
_Static_assert(offsetof(struct ks_cfil_entry, cfe_stats_report_ts) == 0x60, "ks_cfil_entry.cfe_stats_report_ts offset");
_Static_assert(offsetof(struct ks_cfil_entry, cfe_stats_report_frequency) == 0x70, "ks_cfil_entry.cfe_stats_report_frequency offset");
_Static_assert(offsetof(struct ks_cfil_entry, cfe_laddr_sent) == 0x74, "ks_cfil_entry.cfe_laddr_sent offset");
_Static_assert(offsetof(struct ks_cfil_entry, cfe_snd) == 0x78, "ks_cfil_entry.cfe_snd offset");
_Static_assert(offsetof(struct ks_cfil_entry, cfe_rcv) == 0xD0, "ks_cfil_entry.cfe_rcv offset");
_Static_assert(sizeof(struct ks_cfil_entry) == 0x128, "ks_cfil_entry size");

/* refs: 1 */
struct ks_timeval64 {
    long long tv_sec;
    long long tv_usec;
};
_Static_assert(offsetof(struct ks_timeval64, tv_sec) == 0x0, "ks_timeval64.tv_sec offset");
_Static_assert(offsetof(struct ks_timeval64, tv_usec) == 0x8, "ks_timeval64.tv_usec offset");
_Static_assert(sizeof(struct ks_timeval64) == 0x10, "ks_timeval64 size");

/* refs: 9 */
struct ks_sockaddr {
    unsigned char sa_len;
    unsigned char sa_family;
    char sa_data[14];
};
_Static_assert(offsetof(struct ks_sockaddr, sa_len) == 0x0, "ks_sockaddr.sa_len offset");
_Static_assert(offsetof(struct ks_sockaddr, sa_family) == 0x1, "ks_sockaddr.sa_family offset");
_Static_assert(offsetof(struct ks_sockaddr, sa_data) == 0x2, "ks_sockaddr.sa_data offset");
_Static_assert(sizeof(struct ks_sockaddr) == 0x10, "ks_sockaddr size");

/* refs: 1 */
struct ks_sockaddr_in {
    unsigned char sin_len;
    unsigned char sin_family;
    unsigned short sin_port;
    struct ks_in_addr sin_addr;
    char sin_zero[8];
};
_Static_assert(offsetof(struct ks_sockaddr_in, sin_len) == 0x0, "ks_sockaddr_in.sin_len offset");
_Static_assert(offsetof(struct ks_sockaddr_in, sin_family) == 0x1, "ks_sockaddr_in.sin_family offset");
_Static_assert(offsetof(struct ks_sockaddr_in, sin_port) == 0x2, "ks_sockaddr_in.sin_port offset");
_Static_assert(offsetof(struct ks_sockaddr_in, sin_addr) == 0x4, "ks_sockaddr_in.sin_addr offset");
_Static_assert(offsetof(struct ks_sockaddr_in, sin_zero) == 0x8, "ks_sockaddr_in.sin_zero offset");
_Static_assert(sizeof(struct ks_sockaddr_in) == 0x10, "ks_sockaddr_in size");

/* refs: 2 */
struct ks_sockaddr_in6 {
    unsigned char sin6_len;
    unsigned char sin6_family;
    unsigned short sin6_port;
    unsigned int sin6_flowinfo;
    struct ks_in6_addr sin6_addr;
    unsigned int sin6_scope_id;
};
_Static_assert(offsetof(struct ks_sockaddr_in6, sin6_len) == 0x0, "ks_sockaddr_in6.sin6_len offset");
_Static_assert(offsetof(struct ks_sockaddr_in6, sin6_family) == 0x1, "ks_sockaddr_in6.sin6_family offset");
_Static_assert(offsetof(struct ks_sockaddr_in6, sin6_port) == 0x2, "ks_sockaddr_in6.sin6_port offset");
_Static_assert(offsetof(struct ks_sockaddr_in6, sin6_flowinfo) == 0x4, "ks_sockaddr_in6.sin6_flowinfo offset");
_Static_assert(offsetof(struct ks_sockaddr_in6, sin6_addr) == 0x8, "ks_sockaddr_in6.sin6_addr offset");
_Static_assert(offsetof(struct ks_sockaddr_in6, sin6_scope_id) == 0x18, "ks_sockaddr_in6.sin6_scope_id offset");
_Static_assert(sizeof(struct ks_sockaddr_in6) == 0x1C, "ks_sockaddr_in6 size");

/* refs: 7 */
union ks_sockaddr_in_4_6 {
    struct ks_sockaddr sa;
    struct ks___sockaddr_header sah;
    struct ks_sockaddr_in sin;
    struct ks_sockaddr_in6 sin6;
};
_Static_assert(offsetof(union ks_sockaddr_in_4_6, sa) == 0x0, "ks_sockaddr_in_4_6.sa offset");
_Static_assert(offsetof(union ks_sockaddr_in_4_6, sah) == 0x0, "ks_sockaddr_in_4_6.sah offset");
_Static_assert(offsetof(union ks_sockaddr_in_4_6, sin) == 0x0, "ks_sockaddr_in_4_6.sin offset");
_Static_assert(offsetof(union ks_sockaddr_in_4_6, sin6) == 0x0, "ks_sockaddr_in_4_6.sin6 offset");

/* refs: 6 */
struct ks_cfil_info {
    struct {
        struct ks_cfil_info *tqe_next;
        struct ks_cfil_info **tqe_prev;
    } cfi_link;
    struct {
        struct ks_cfil_info *tqe_next;
        struct ks_cfil_info **tqe_prev;
    } cfi_link_stats;
    struct ks_socket *cfi_so;
    unsigned long long cfi_flags;
    unsigned long long cfi_sock_id;
    struct ks_timeval64 cfi_first_event;
    unsigned int cfi_op_list_ctr;
    unsigned int cfi_op_time[6];
    unsigned char cfi_op_list[6];
    union ks_sockaddr_in_4_6 cfi_so_attach_faddr;
    union ks_sockaddr_in_4_6 cfi_so_attach_laddr;
    int cfi_dir;
    unsigned long long cfi_byte_inbound_count;
    unsigned long long cfi_byte_outbound_count;
    struct ks_timeval cfi_timestamp;
    int cfi_isSignatureLatest;
    unsigned int cfi_filter_control_unit;
    unsigned int cfi_filter_policy_gencount;
    unsigned int cfi_debug;
    struct ks_cfi_buf cfi_snd;
    struct ks_cfi_buf cfi_rcv;
    struct ks_cfil_entry cfi_entries[8];
    struct ks_soflow_hash_entry *cfi_hash_entry;
    struct {
        struct ks_cfil_entry *slh_first;
    } cfi_ordered_entries;
    struct ks_os_refcnt cfi_ref_count;
} __attribute__((aligned(8)));
_Static_assert(offsetof(struct ks_cfil_info, cfi_link) == 0x0, "ks_cfil_info.cfi_link offset");
_Static_assert(offsetof(struct ks_cfil_info, cfi_link_stats) == 0x10, "ks_cfil_info.cfi_link_stats offset");
_Static_assert(offsetof(struct ks_cfil_info, cfi_so) == 0x20, "ks_cfil_info.cfi_so offset");
_Static_assert(offsetof(struct ks_cfil_info, cfi_flags) == 0x28, "ks_cfil_info.cfi_flags offset");
_Static_assert(offsetof(struct ks_cfil_info, cfi_sock_id) == 0x30, "ks_cfil_info.cfi_sock_id offset");
_Static_assert(offsetof(struct ks_cfil_info, cfi_first_event) == 0x38, "ks_cfil_info.cfi_first_event offset");
_Static_assert(offsetof(struct ks_cfil_info, cfi_op_list_ctr) == 0x48, "ks_cfil_info.cfi_op_list_ctr offset");
_Static_assert(offsetof(struct ks_cfil_info, cfi_op_time) == 0x4C, "ks_cfil_info.cfi_op_time offset");
_Static_assert(offsetof(struct ks_cfil_info, cfi_op_list) == 0x64, "ks_cfil_info.cfi_op_list offset");
_Static_assert(offsetof(struct ks_cfil_info, cfi_so_attach_faddr) == 0x6C, "ks_cfil_info.cfi_so_attach_faddr offset");
_Static_assert(offsetof(struct ks_cfil_info, cfi_so_attach_laddr) == 0x88, "ks_cfil_info.cfi_so_attach_laddr offset");
_Static_assert(offsetof(struct ks_cfil_info, cfi_dir) == 0xA4, "ks_cfil_info.cfi_dir offset");
_Static_assert(offsetof(struct ks_cfil_info, cfi_byte_inbound_count) == 0xA8, "ks_cfil_info.cfi_byte_inbound_count offset");
_Static_assert(offsetof(struct ks_cfil_info, cfi_byte_outbound_count) == 0xB0, "ks_cfil_info.cfi_byte_outbound_count offset");
_Static_assert(offsetof(struct ks_cfil_info, cfi_timestamp) == 0xB8, "ks_cfil_info.cfi_timestamp offset");
_Static_assert(offsetof(struct ks_cfil_info, cfi_isSignatureLatest) == 0xC8, "ks_cfil_info.cfi_isSignatureLatest offset");
_Static_assert(offsetof(struct ks_cfil_info, cfi_filter_control_unit) == 0xCC, "ks_cfil_info.cfi_filter_control_unit offset");
_Static_assert(offsetof(struct ks_cfil_info, cfi_filter_policy_gencount) == 0xD0, "ks_cfil_info.cfi_filter_policy_gencount offset");
_Static_assert(offsetof(struct ks_cfil_info, cfi_debug) == 0xD4, "ks_cfil_info.cfi_debug offset");
_Static_assert(offsetof(struct ks_cfil_info, cfi_snd) == 0xD8, "ks_cfil_info.cfi_snd offset");
_Static_assert(offsetof(struct ks_cfil_info, cfi_rcv) == 0x120, "ks_cfil_info.cfi_rcv offset");
_Static_assert(offsetof(struct ks_cfil_info, cfi_entries) == 0x168, "ks_cfil_info.cfi_entries offset");
_Static_assert(offsetof(struct ks_cfil_info, cfi_hash_entry) == 0xAA8, "ks_cfil_info.cfi_hash_entry offset");
_Static_assert(offsetof(struct ks_cfil_info, cfi_ordered_entries) == 0xAB0, "ks_cfil_info.cfi_ordered_entries offset");
_Static_assert(offsetof(struct ks_cfil_info, cfi_ref_count) == 0xAB8, "ks_cfil_info.cfi_ref_count offset");
_Static_assert(sizeof(struct ks_cfil_info) == 0xAC0, "ks_cfil_info size");

/* refs: 1 */
struct ks_cl_readahead {
    struct ks_lck_mtx_s cl_lockr;
    long long cl_lastr;
    long long cl_maxra;
    int cl_ralen;
};
_Static_assert(offsetof(struct ks_cl_readahead, cl_lockr) == 0x0, "ks_cl_readahead.cl_lockr offset");
_Static_assert(offsetof(struct ks_cl_readahead, cl_lastr) == 0x10, "ks_cl_readahead.cl_lastr offset");
_Static_assert(offsetof(struct ks_cl_readahead, cl_maxra) == 0x18, "ks_cl_readahead.cl_maxra offset");
_Static_assert(offsetof(struct ks_cl_readahead, cl_ralen) == 0x20, "ks_cl_readahead.cl_ralen offset");
_Static_assert(sizeof(struct ks_cl_readahead) == 0x28, "ks_cl_readahead size");

/* refs: 1 */
struct ks_cl_wextent {
    long long b_addr;
    long long e_addr;
    int io_flags;
};
_Static_assert(offsetof(struct ks_cl_wextent, b_addr) == 0x0, "ks_cl_wextent.b_addr offset");
_Static_assert(offsetof(struct ks_cl_wextent, e_addr) == 0x8, "ks_cl_wextent.e_addr offset");
_Static_assert(offsetof(struct ks_cl_wextent, io_flags) == 0x10, "ks_cl_wextent.io_flags offset");
_Static_assert(sizeof(struct ks_cl_wextent) == 0x18, "ks_cl_wextent size");

/* refs: 1 */
struct ks_cl_writebehind {
    struct ks_lck_mtx_s cl_lockw;
    void *cl_scmap;
    long long cl_last_write;
    long long cl_seq_written;
    int cl_sparse_pushes;
    int cl_sparse_wait;
    int cl_number;
    struct ks_cl_wextent cl_clusters[8];
};
_Static_assert(offsetof(struct ks_cl_writebehind, cl_lockw) == 0x0, "ks_cl_writebehind.cl_lockw offset");
_Static_assert(offsetof(struct ks_cl_writebehind, cl_scmap) == 0x10, "ks_cl_writebehind.cl_scmap offset");
_Static_assert(offsetof(struct ks_cl_writebehind, cl_last_write) == 0x18, "ks_cl_writebehind.cl_last_write offset");
_Static_assert(offsetof(struct ks_cl_writebehind, cl_seq_written) == 0x20, "ks_cl_writebehind.cl_seq_written offset");
_Static_assert(offsetof(struct ks_cl_writebehind, cl_sparse_pushes) == 0x28, "ks_cl_writebehind.cl_sparse_pushes offset");
_Static_assert(offsetof(struct ks_cl_writebehind, cl_sparse_wait) == 0x2C, "ks_cl_writebehind.cl_sparse_wait offset");
_Static_assert(offsetof(struct ks_cl_writebehind, cl_number) == 0x30, "ks_cl_writebehind.cl_number offset");
_Static_assert(offsetof(struct ks_cl_writebehind, cl_clusters) == 0x38, "ks_cl_writebehind.cl_clusters offset");
_Static_assert(sizeof(struct ks_cl_writebehind) == 0xF8, "ks_cl_writebehind size");

/* refs: 3 */
struct ks_clist {
    int c_cc;
    int c_cn;
    unsigned char *c_cf;
    unsigned char *c_cl;
    unsigned char *c_cs;
    unsigned char *c_ce;
    unsigned char *c_cq;
};
_Static_assert(offsetof(struct ks_clist, c_cc) == 0x0, "ks_clist.c_cc offset");
_Static_assert(offsetof(struct ks_clist, c_cn) == 0x4, "ks_clist.c_cn offset");
_Static_assert(offsetof(struct ks_clist, c_cf) == 0x8, "ks_clist.c_cf offset");
_Static_assert(offsetof(struct ks_clist, c_cl) == 0x10, "ks_clist.c_cl offset");
_Static_assert(offsetof(struct ks_clist, c_cs) == 0x18, "ks_clist.c_cs offset");
_Static_assert(offsetof(struct ks_clist, c_ce) == 0x20, "ks_clist.c_ce offset");
_Static_assert(offsetof(struct ks_clist, c_cq) == 0x28, "ks_clist.c_cq offset");
_Static_assert(sizeof(struct ks_clist) == 0x30, "ks_clist size");

/* refs: 1 */
struct ks_coalition_effective_policy {
    unsigned long long cep_darwinbg : 1; /* bit offset 0 */
    unsigned long long cep_reserved : 63; /* bit offset 1 */
};
_Static_assert(sizeof(struct ks_coalition_effective_policy) == 0x8, "ks_coalition_effective_policy size");

/* refs: 1 */
struct ks_coalition_requested_policy {
    unsigned long long crp_darwinbg : 1; /* bit offset 0 */
    unsigned long long crp_reserved : 63; /* bit offset 1 */
};
_Static_assert(sizeof(struct ks_coalition_requested_policy) == 0x8, "ks_coalition_requested_policy size");

/* refs: 1 */
struct ks_i_jetsam_coalition {
    struct ks_task *leader;
    struct ks_queue_entry extensions;
    struct ks_queue_entry services;
    struct ks_queue_entry other;
    struct ks_thread_group *thread_group;
    _Bool swap_enabled;
    struct ks_coalition_requested_policy c_requested_policy __attribute__((aligned(8)));
    struct ks_coalition_effective_policy c_effective_policy;
};
_Static_assert(offsetof(struct ks_i_jetsam_coalition, leader) == 0x0, "ks_i_jetsam_coalition.leader offset");
_Static_assert(offsetof(struct ks_i_jetsam_coalition, extensions) == 0x8, "ks_i_jetsam_coalition.extensions offset");
_Static_assert(offsetof(struct ks_i_jetsam_coalition, services) == 0x18, "ks_i_jetsam_coalition.services offset");
_Static_assert(offsetof(struct ks_i_jetsam_coalition, other) == 0x28, "ks_i_jetsam_coalition.other offset");
_Static_assert(offsetof(struct ks_i_jetsam_coalition, thread_group) == 0x38, "ks_i_jetsam_coalition.thread_group offset");
_Static_assert(offsetof(struct ks_i_jetsam_coalition, swap_enabled) == 0x40, "ks_i_jetsam_coalition.swap_enabled offset");
_Static_assert(offsetof(struct ks_i_jetsam_coalition, c_requested_policy) == 0x48, "ks_i_jetsam_coalition.c_requested_policy offset");
_Static_assert(offsetof(struct ks_i_jetsam_coalition, c_effective_policy) == 0x50, "ks_i_jetsam_coalition.c_effective_policy offset");
_Static_assert(sizeof(struct ks_i_jetsam_coalition) == 0x58, "ks_i_jetsam_coalition size");

/* refs: 1 */
struct ks_recount_coalition {
    struct ks_recount_usage *rco_exited;
};
_Static_assert(offsetof(struct ks_recount_coalition, rco_exited) == 0x0, "ks_recount_coalition.rco_exited offset");
_Static_assert(sizeof(struct ks_recount_coalition) == 0x8, "ks_recount_coalition size");

/* refs: 1 */
struct ks_i_resource_coalition {
    struct ks_ledger *ledger;
    unsigned long long bytesread;
    unsigned long long byteswritten;
    unsigned long long energy;
    unsigned long long gpu_time;
    unsigned long long logical_immediate_writes;
    unsigned long long logical_deferred_writes;
    unsigned long long logical_invalidated_writes;
    unsigned long long logical_metadata_writes;
    unsigned long long logical_immediate_writes_to_external;
    unsigned long long logical_deferred_writes_to_external;
    unsigned long long logical_invalidated_writes_to_external;
    unsigned long long logical_metadata_writes_to_external;
    unsigned long long cpu_time_eqos[7];
    unsigned long long cpu_time_rqos[7];
    unsigned long long cpu_instructions;
    unsigned long long cpu_cycles;
    unsigned long long ane_mach_time;
    unsigned long long ane_energy_nj;
    unsigned long long gpu_energy_nj;
    unsigned long long gpu_energy_nj_billed_to_me;
    unsigned long long gpu_energy_nj_billed_to_others;
    struct ks_recount_coalition co_recount;
    unsigned long long task_count;
    unsigned long long dead_task_count;
    unsigned long long last_became_nonempty_time;
    unsigned long long time_nonempty;
    struct ks_queue_entry tasks;
    struct ks_ledger *resource_monitor_ledger;
    unsigned long long fs_metadata_writes;
};
_Static_assert(offsetof(struct ks_i_resource_coalition, ledger) == 0x0, "ks_i_resource_coalition.ledger offset");
_Static_assert(offsetof(struct ks_i_resource_coalition, bytesread) == 0x8, "ks_i_resource_coalition.bytesread offset");
_Static_assert(offsetof(struct ks_i_resource_coalition, byteswritten) == 0x10, "ks_i_resource_coalition.byteswritten offset");
_Static_assert(offsetof(struct ks_i_resource_coalition, energy) == 0x18, "ks_i_resource_coalition.energy offset");
_Static_assert(offsetof(struct ks_i_resource_coalition, gpu_time) == 0x20, "ks_i_resource_coalition.gpu_time offset");
_Static_assert(offsetof(struct ks_i_resource_coalition, logical_immediate_writes) == 0x28, "ks_i_resource_coalition.logical_immediate_writes offset");
_Static_assert(offsetof(struct ks_i_resource_coalition, logical_deferred_writes) == 0x30, "ks_i_resource_coalition.logical_deferred_writes offset");
_Static_assert(offsetof(struct ks_i_resource_coalition, logical_invalidated_writes) == 0x38, "ks_i_resource_coalition.logical_invalidated_writes offset");
_Static_assert(offsetof(struct ks_i_resource_coalition, logical_metadata_writes) == 0x40, "ks_i_resource_coalition.logical_metadata_writes offset");
_Static_assert(offsetof(struct ks_i_resource_coalition, logical_immediate_writes_to_external) == 0x48, "ks_i_resource_coalition.logical_immediate_writes_to_external offset");
_Static_assert(offsetof(struct ks_i_resource_coalition, logical_deferred_writes_to_external) == 0x50, "ks_i_resource_coalition.logical_deferred_writes_to_external offset");
_Static_assert(offsetof(struct ks_i_resource_coalition, logical_invalidated_writes_to_external) == 0x58, "ks_i_resource_coalition.logical_invalidated_writes_to_external offset");
_Static_assert(offsetof(struct ks_i_resource_coalition, logical_metadata_writes_to_external) == 0x60, "ks_i_resource_coalition.logical_metadata_writes_to_external offset");
_Static_assert(offsetof(struct ks_i_resource_coalition, cpu_time_eqos) == 0x68, "ks_i_resource_coalition.cpu_time_eqos offset");
_Static_assert(offsetof(struct ks_i_resource_coalition, cpu_time_rqos) == 0xA0, "ks_i_resource_coalition.cpu_time_rqos offset");
_Static_assert(offsetof(struct ks_i_resource_coalition, cpu_instructions) == 0xD8, "ks_i_resource_coalition.cpu_instructions offset");
_Static_assert(offsetof(struct ks_i_resource_coalition, cpu_cycles) == 0xE0, "ks_i_resource_coalition.cpu_cycles offset");
_Static_assert(offsetof(struct ks_i_resource_coalition, ane_mach_time) == 0xE8, "ks_i_resource_coalition.ane_mach_time offset");
_Static_assert(offsetof(struct ks_i_resource_coalition, ane_energy_nj) == 0xF0, "ks_i_resource_coalition.ane_energy_nj offset");
_Static_assert(offsetof(struct ks_i_resource_coalition, gpu_energy_nj) == 0xF8, "ks_i_resource_coalition.gpu_energy_nj offset");
_Static_assert(offsetof(struct ks_i_resource_coalition, gpu_energy_nj_billed_to_me) == 0x100, "ks_i_resource_coalition.gpu_energy_nj_billed_to_me offset");
_Static_assert(offsetof(struct ks_i_resource_coalition, gpu_energy_nj_billed_to_others) == 0x108, "ks_i_resource_coalition.gpu_energy_nj_billed_to_others offset");
_Static_assert(offsetof(struct ks_i_resource_coalition, co_recount) == 0x110, "ks_i_resource_coalition.co_recount offset");
_Static_assert(offsetof(struct ks_i_resource_coalition, task_count) == 0x118, "ks_i_resource_coalition.task_count offset");
_Static_assert(offsetof(struct ks_i_resource_coalition, dead_task_count) == 0x120, "ks_i_resource_coalition.dead_task_count offset");
_Static_assert(offsetof(struct ks_i_resource_coalition, last_became_nonempty_time) == 0x128, "ks_i_resource_coalition.last_became_nonempty_time offset");
_Static_assert(offsetof(struct ks_i_resource_coalition, time_nonempty) == 0x130, "ks_i_resource_coalition.time_nonempty offset");
_Static_assert(offsetof(struct ks_i_resource_coalition, tasks) == 0x138, "ks_i_resource_coalition.tasks offset");
_Static_assert(offsetof(struct ks_i_resource_coalition, resource_monitor_ledger) == 0x148, "ks_i_resource_coalition.resource_monitor_ledger offset");
_Static_assert(offsetof(struct ks_i_resource_coalition, fs_metadata_writes) == 0x150, "ks_i_resource_coalition.fs_metadata_writes offset");
_Static_assert(sizeof(struct ks_i_resource_coalition) == 0x158, "ks_i_resource_coalition size");

/* refs: 5 */
struct ks_smr_node {
    struct ks_smr_node *smrn_next;
    void *smrn_cb;
};
_Static_assert(offsetof(struct ks_smr_node, smrn_next) == 0x0, "ks_smr_node.smrn_next offset");
_Static_assert(offsetof(struct ks_smr_node, smrn_cb) == 0x8, "ks_smr_node.smrn_cb offset");
_Static_assert(sizeof(struct ks_smr_node) == 0x10, "ks_smr_node size");

/* refs: 5 */
struct ks_smrq_slink {
    struct ks___smrq_slink_t next;
};
_Static_assert(offsetof(struct ks_smrq_slink, next) == 0x0, "ks_smrq_slink.next offset");
_Static_assert(sizeof(struct ks_smrq_slink) == 0x8, "ks_smrq_slink size");

/* refs: 2 */
struct ks_coalition {
    unsigned long long id;
    unsigned int type;
    unsigned int role;
    unsigned int ref_count;
    unsigned int active_count;
    unsigned int focal_task_count;
    unsigned int nonfocal_task_count;
    unsigned int game_task_count;
    unsigned int carplay_task_count;
    unsigned int privileged : 1; /* bit offset 320 */
    unsigned int termrequested : 1; /* bit offset 321 */
    unsigned int terminated : 1; /* bit offset 322 */
    unsigned int reaped : 1; /* bit offset 323 */
    unsigned int notified : 1; /* bit offset 324 */
    unsigned int efficient : 1; /* bit offset 325 */
    struct ks_smrq_slink link;
    union {
        struct ks_lck_mtx_s lock;
        struct ks_smr_node smr_node;
    };
    union {
        struct ks_i_resource_coalition r;
        struct ks_i_jetsam_coalition j;
    };
};
_Static_assert(offsetof(struct ks_coalition, id) == 0x0, "ks_coalition.id offset");
_Static_assert(offsetof(struct ks_coalition, type) == 0x8, "ks_coalition.type offset");
_Static_assert(offsetof(struct ks_coalition, role) == 0xC, "ks_coalition.role offset");
_Static_assert(offsetof(struct ks_coalition, ref_count) == 0x10, "ks_coalition.ref_count offset");
_Static_assert(offsetof(struct ks_coalition, active_count) == 0x14, "ks_coalition.active_count offset");
_Static_assert(offsetof(struct ks_coalition, focal_task_count) == 0x18, "ks_coalition.focal_task_count offset");
_Static_assert(offsetof(struct ks_coalition, nonfocal_task_count) == 0x1C, "ks_coalition.nonfocal_task_count offset");
_Static_assert(offsetof(struct ks_coalition, game_task_count) == 0x20, "ks_coalition.game_task_count offset");
_Static_assert(offsetof(struct ks_coalition, carplay_task_count) == 0x24, "ks_coalition.carplay_task_count offset");
_Static_assert(offsetof(struct ks_coalition, link) == 0x30, "ks_coalition.link offset");
_Static_assert(sizeof(struct ks_coalition) == 0x1A0, "ks_coalition size");

/* refs: 1 */
struct ks_componentname {
    unsigned int cn_nameiop;
    unsigned int cn_flags;
    struct ks_vfs_context *cn_context;
    struct ks_nameidata *cn_ndp;
    char *cn_pnbuf;
    int cn_pnlen;
    char *cn_nameptr;
    int cn_namelen;
    unsigned int cn_hash;
    unsigned int cn_consume;
};
_Static_assert(offsetof(struct ks_componentname, cn_nameiop) == 0x0, "ks_componentname.cn_nameiop offset");
_Static_assert(offsetof(struct ks_componentname, cn_flags) == 0x4, "ks_componentname.cn_flags offset");
_Static_assert(offsetof(struct ks_componentname, cn_context) == 0x8, "ks_componentname.cn_context offset");
_Static_assert(offsetof(struct ks_componentname, cn_ndp) == 0x10, "ks_componentname.cn_ndp offset");
_Static_assert(offsetof(struct ks_componentname, cn_pnbuf) == 0x18, "ks_componentname.cn_pnbuf offset");
_Static_assert(offsetof(struct ks_componentname, cn_pnlen) == 0x20, "ks_componentname.cn_pnlen offset");
_Static_assert(offsetof(struct ks_componentname, cn_nameptr) == 0x28, "ks_componentname.cn_nameptr offset");
_Static_assert(offsetof(struct ks_componentname, cn_namelen) == 0x30, "ks_componentname.cn_namelen offset");
_Static_assert(offsetof(struct ks_componentname, cn_hash) == 0x34, "ks_componentname.cn_hash offset");
_Static_assert(offsetof(struct ks_componentname, cn_consume) == 0x38, "ks_componentname.cn_consume offset");
_Static_assert(sizeof(struct ks_componentname) == 0x40, "ks_componentname size");

/* refs: 1 */
struct ks_content_filter {
    void *cf_kcref;
    unsigned int cf_kcunit;
    unsigned int cf_flags;
    unsigned int cf_necp_control_unit;
    unsigned int cf_sock_count;
    struct {
        struct ks_cfil_entry *tqh_first;
        struct ks_cfil_entry **tqh_last;
    } cf_sock_entries;
    struct ks_cfil_crypto_state *cf_crypto_state;
};
_Static_assert(offsetof(struct ks_content_filter, cf_kcref) == 0x0, "ks_content_filter.cf_kcref offset");
_Static_assert(offsetof(struct ks_content_filter, cf_kcunit) == 0x8, "ks_content_filter.cf_kcunit offset");
_Static_assert(offsetof(struct ks_content_filter, cf_flags) == 0xC, "ks_content_filter.cf_flags offset");
_Static_assert(offsetof(struct ks_content_filter, cf_necp_control_unit) == 0x10, "ks_content_filter.cf_necp_control_unit offset");
_Static_assert(offsetof(struct ks_content_filter, cf_sock_count) == 0x14, "ks_content_filter.cf_sock_count offset");
_Static_assert(offsetof(struct ks_content_filter, cf_sock_entries) == 0x18, "ks_content_filter.cf_sock_entries offset");
_Static_assert(offsetof(struct ks_content_filter, cf_crypto_state) == 0x28, "ks_content_filter.cf_crypto_state offset");
_Static_assert(sizeof(struct ks_content_filter) == 0x30, "ks_content_filter size");

/* refs: 1 */
struct ks_corruption {
    unsigned int corruption_p;
};
_Static_assert(offsetof(struct ks_corruption, corruption_p) == 0x0, "ks_corruption.corruption_p offset");
_Static_assert(sizeof(struct ks_corruption) == 0x4, "ks_corruption size");

/* refs: 1 */
struct ks_cpx {
    struct ks_aes_encrypt_ctx *cpx_iv_aes_ctx_ptr;
    unsigned int cpx_flags;
    unsigned short cpx_max_key_len;
    unsigned short cpx_key_len;
    unsigned char cpx_cached_key[];
};
_Static_assert(offsetof(struct ks_cpx, cpx_iv_aes_ctx_ptr) == 0x0, "ks_cpx.cpx_iv_aes_ctx_ptr offset");
_Static_assert(offsetof(struct ks_cpx, cpx_flags) == 0x8, "ks_cpx.cpx_flags offset");
_Static_assert(offsetof(struct ks_cpx, cpx_max_key_len) == 0xC, "ks_cpx.cpx_max_key_len offset");
_Static_assert(offsetof(struct ks_cpx, cpx_key_len) == 0xE, "ks_cpx.cpx_key_len offset");
_Static_assert(offsetof(struct ks_cpx, cpx_cached_key) == 0x10, "ks_cpx.cpx_cached_key offset");
_Static_assert(sizeof(struct ks_cpx) == 0x10, "ks_cpx size");

/* refs: 1 */
struct ks_cs_blob_platform_flags {
    unsigned int csb_platform_binary : 1; /* bit offset 0 */
    unsigned int csb_platform_path : 1; /* bit offset 1 */
};
_Static_assert(sizeof(struct ks_cs_blob_platform_flags) == 0x4, "ks_cs_blob_platform_flags size");

/* refs: 1 */
struct ks_cs_cpu_info {
    int csb_cpu_type;
    int csb_cpu_subtype;
};
_Static_assert(offsetof(struct ks_cs_cpu_info, csb_cpu_type) == 0x0, "ks_cs_cpu_info.csb_cpu_type offset");
_Static_assert(offsetof(struct ks_cs_cpu_info, csb_cpu_subtype) == 0x4, "ks_cs_cpu_info.csb_cpu_subtype offset");
_Static_assert(sizeof(struct ks_cs_cpu_info) == 0x8, "ks_cs_cpu_info size");

/* refs: 1 */
struct ks_cs_signer_info {
    unsigned int csb_flags;
    unsigned int csb_signer_type;
};
_Static_assert(offsetof(struct ks_cs_signer_info, csb_flags) == 0x0, "ks_cs_signer_info.csb_flags offset");
_Static_assert(offsetof(struct ks_cs_signer_info, csb_signer_type) == 0x4, "ks_cs_signer_info.csb_signer_type offset");
_Static_assert(sizeof(struct ks_cs_signer_info) == 0x8, "ks_cs_signer_info size");

/* refs: 2 */
struct ks_cs_blob {
    struct ks_cs_blob *csb_next;
    struct ks_vnode *csb_vnode;
    void *csb_ro_addr;
    struct ks_cs_cpu_info csb_cpu_info;
    struct ks_cs_signer_info csb_signer_info;
    long long csb_base_offset;
    long long csb_start_offset;
    long long csb_end_offset;
    unsigned long csb_mem_size;
    unsigned long csb_mem_offset;
    void *csb_mem_kaddr;
    unsigned char csb_cdhash[0x14];
    const struct ks_cs_hash *csb_hashtype;
    unsigned char csb_linkage[0x14];
    const struct ks_cs_hash *csb_linkage_hashtype;
    int csb_hash_pageshift;
    int csb_hash_firstlevel_pageshift;
    struct ks___CodeDirectory *csb_cd;
    const char *csb_teamid;
    char *csb_supplement_teamid;
    struct ks___SC_GenericBlob *csb_entitlements_blob;
    struct ks___SC_GenericBlob *csb_der_entitlements_blob;
    void *csb_entitlements;
    unsigned int csb_reconstituted;
    struct ks_cs_blob_platform_flags csb_platform_flags;
    unsigned int csb_validation_category;
    unsigned long long csb_auxiliary_info;
    void *csb_csm_obj;
    _Bool csb_csm_managed;
    unsigned int csb_csm_trust_level;
};
_Static_assert(offsetof(struct ks_cs_blob, csb_next) == 0x0, "ks_cs_blob.csb_next offset");
_Static_assert(offsetof(struct ks_cs_blob, csb_vnode) == 0x8, "ks_cs_blob.csb_vnode offset");
_Static_assert(offsetof(struct ks_cs_blob, csb_ro_addr) == 0x10, "ks_cs_blob.csb_ro_addr offset");
_Static_assert(offsetof(struct ks_cs_blob, csb_cpu_info) == 0x18, "ks_cs_blob.csb_cpu_info offset");
_Static_assert(offsetof(struct ks_cs_blob, csb_signer_info) == 0x20, "ks_cs_blob.csb_signer_info offset");
_Static_assert(offsetof(struct ks_cs_blob, csb_base_offset) == 0x28, "ks_cs_blob.csb_base_offset offset");
_Static_assert(offsetof(struct ks_cs_blob, csb_start_offset) == 0x30, "ks_cs_blob.csb_start_offset offset");
_Static_assert(offsetof(struct ks_cs_blob, csb_end_offset) == 0x38, "ks_cs_blob.csb_end_offset offset");
_Static_assert(offsetof(struct ks_cs_blob, csb_mem_size) == 0x40, "ks_cs_blob.csb_mem_size offset");
_Static_assert(offsetof(struct ks_cs_blob, csb_mem_offset) == 0x48, "ks_cs_blob.csb_mem_offset offset");
_Static_assert(offsetof(struct ks_cs_blob, csb_mem_kaddr) == 0x50, "ks_cs_blob.csb_mem_kaddr offset");
_Static_assert(offsetof(struct ks_cs_blob, csb_cdhash) == 0x58, "ks_cs_blob.csb_cdhash offset");
_Static_assert(offsetof(struct ks_cs_blob, csb_hashtype) == 0x70, "ks_cs_blob.csb_hashtype offset");
_Static_assert(offsetof(struct ks_cs_blob, csb_linkage) == 0x78, "ks_cs_blob.csb_linkage offset");
_Static_assert(offsetof(struct ks_cs_blob, csb_linkage_hashtype) == 0x90, "ks_cs_blob.csb_linkage_hashtype offset");
_Static_assert(offsetof(struct ks_cs_blob, csb_hash_pageshift) == 0x98, "ks_cs_blob.csb_hash_pageshift offset");
_Static_assert(offsetof(struct ks_cs_blob, csb_hash_firstlevel_pageshift) == 0x9C, "ks_cs_blob.csb_hash_firstlevel_pageshift offset");
_Static_assert(offsetof(struct ks_cs_blob, csb_cd) == 0xA0, "ks_cs_blob.csb_cd offset");
_Static_assert(offsetof(struct ks_cs_blob, csb_teamid) == 0xA8, "ks_cs_blob.csb_teamid offset");
_Static_assert(offsetof(struct ks_cs_blob, csb_supplement_teamid) == 0xB0, "ks_cs_blob.csb_supplement_teamid offset");
_Static_assert(offsetof(struct ks_cs_blob, csb_entitlements_blob) == 0xB8, "ks_cs_blob.csb_entitlements_blob offset");
_Static_assert(offsetof(struct ks_cs_blob, csb_der_entitlements_blob) == 0xC0, "ks_cs_blob.csb_der_entitlements_blob offset");
_Static_assert(offsetof(struct ks_cs_blob, csb_entitlements) == 0xC8, "ks_cs_blob.csb_entitlements offset");
_Static_assert(offsetof(struct ks_cs_blob, csb_reconstituted) == 0xD0, "ks_cs_blob.csb_reconstituted offset");
_Static_assert(offsetof(struct ks_cs_blob, csb_platform_flags) == 0xD4, "ks_cs_blob.csb_platform_flags offset");
_Static_assert(offsetof(struct ks_cs_blob, csb_validation_category) == 0xD8, "ks_cs_blob.csb_validation_category offset");
_Static_assert(offsetof(struct ks_cs_blob, csb_auxiliary_info) == 0xE0, "ks_cs_blob.csb_auxiliary_info offset");
_Static_assert(offsetof(struct ks_cs_blob, csb_csm_obj) == 0xE8, "ks_cs_blob.csb_csm_obj offset");
_Static_assert(offsetof(struct ks_cs_blob, csb_csm_managed) == 0xF0, "ks_cs_blob.csb_csm_managed offset");
_Static_assert(offsetof(struct ks_cs_blob, csb_csm_trust_level) == 0xF4, "ks_cs_blob.csb_csm_trust_level offset");
_Static_assert(sizeof(struct ks_cs_blob) == 0xF8, "ks_cs_blob size");

/* refs: 2 */
struct ks_cs_hash {
    unsigned char cs_type;
    unsigned long cs_size;
    unsigned long cs_digest_size;
    void *cs_init;
    void *cs_update;
    void *cs_final;
};
_Static_assert(offsetof(struct ks_cs_hash, cs_type) == 0x0, "ks_cs_hash.cs_type offset");
_Static_assert(offsetof(struct ks_cs_hash, cs_size) == 0x8, "ks_cs_hash.cs_size offset");
_Static_assert(offsetof(struct ks_cs_hash, cs_digest_size) == 0x10, "ks_cs_hash.cs_digest_size offset");
_Static_assert(offsetof(struct ks_cs_hash, cs_init) == 0x18, "ks_cs_hash.cs_init offset");
_Static_assert(offsetof(struct ks_cs_hash, cs_update) == 0x20, "ks_cs_hash.cs_update offset");
_Static_assert(offsetof(struct ks_cs_hash, cs_final) == 0x28, "ks_cs_hash.cs_final offset");
_Static_assert(sizeof(struct ks_cs_hash) == 0x30, "ks_cs_hash size");

/* refs: 1 */
struct ks_data_stats {
    unsigned long long rxpackets;
    unsigned long long rxbytes;
    unsigned long long txpackets;
    unsigned long long txbytes;
};
_Static_assert(offsetof(struct ks_data_stats, rxpackets) == 0x0, "ks_data_stats.rxpackets offset");
_Static_assert(offsetof(struct ks_data_stats, rxbytes) == 0x8, "ks_data_stats.rxbytes offset");
_Static_assert(offsetof(struct ks_data_stats, txpackets) == 0x10, "ks_data_stats.txpackets offset");
_Static_assert(offsetof(struct ks_data_stats, txbytes) == 0x18, "ks_data_stats.txbytes offset");
_Static_assert(sizeof(struct ks_data_stats) == 0x20, "ks_data_stats size");

/* refs: 1 */
struct ks_ifnet_stat_increment_param {
    unsigned int packets_in;
    unsigned int bytes_in;
    unsigned int errors_in;
    unsigned int packets_out;
    unsigned int bytes_out;
    unsigned int errors_out;
    unsigned int collisions;
    unsigned int dropped;
};
_Static_assert(offsetof(struct ks_ifnet_stat_increment_param, packets_in) == 0x0, "ks_ifnet_stat_increment_param.packets_in offset");
_Static_assert(offsetof(struct ks_ifnet_stat_increment_param, bytes_in) == 0x4, "ks_ifnet_stat_increment_param.bytes_in offset");
_Static_assert(offsetof(struct ks_ifnet_stat_increment_param, errors_in) == 0x8, "ks_ifnet_stat_increment_param.errors_in offset");
_Static_assert(offsetof(struct ks_ifnet_stat_increment_param, packets_out) == 0xC, "ks_ifnet_stat_increment_param.packets_out offset");
_Static_assert(offsetof(struct ks_ifnet_stat_increment_param, bytes_out) == 0x10, "ks_ifnet_stat_increment_param.bytes_out offset");
_Static_assert(offsetof(struct ks_ifnet_stat_increment_param, errors_out) == 0x14, "ks_ifnet_stat_increment_param.errors_out offset");
_Static_assert(offsetof(struct ks_ifnet_stat_increment_param, collisions) == 0x18, "ks_ifnet_stat_increment_param.collisions offset");
_Static_assert(offsetof(struct ks_ifnet_stat_increment_param, dropped) == 0x1C, "ks_ifnet_stat_increment_param.dropped offset");
_Static_assert(sizeof(struct ks_ifnet_stat_increment_param) == 0x20, "ks_ifnet_stat_increment_param size");

/* refs: 1 */
struct ks_dlil_threading_info {
    struct ks_lck_mtx_s dlth_lock;
    struct ks__class_queue_ dlth_pkts;
    struct ks_ifnet *dlth_ifp;
    struct ks_ifnet_stat_increment_param dlth_stats;
    unsigned int dlth_flags;
    unsigned int dlth_wtot;
    int *dlth_strategy;
    int dlth_affinity;
    unsigned int dlth_affinity_tag;
    struct ks_thread *dlth_thread;
    struct ks_thread *dlth_driver_thread;
    struct ks_thread *dlth_poller_thread;
    struct ks__lck_grp_ *dlth_lock_grp;
    char dlth_name_storage[0x20];
    const char *dlth_name;
    unsigned int dlth_trim_cnt;
    unsigned int dlth_trim_pkts_dropped;
    unsigned long long dlth_pkts_cnt;
};
_Static_assert(offsetof(struct ks_dlil_threading_info, dlth_lock) == 0x0, "ks_dlil_threading_info.dlth_lock offset");
_Static_assert(offsetof(struct ks_dlil_threading_info, dlth_pkts) == 0x10, "ks_dlil_threading_info.dlth_pkts offset");
_Static_assert(offsetof(struct ks_dlil_threading_info, dlth_ifp) == 0x48, "ks_dlil_threading_info.dlth_ifp offset");
_Static_assert(offsetof(struct ks_dlil_threading_info, dlth_stats) == 0x50, "ks_dlil_threading_info.dlth_stats offset");
_Static_assert(offsetof(struct ks_dlil_threading_info, dlth_flags) == 0x70, "ks_dlil_threading_info.dlth_flags offset");
_Static_assert(offsetof(struct ks_dlil_threading_info, dlth_wtot) == 0x74, "ks_dlil_threading_info.dlth_wtot offset");
_Static_assert(offsetof(struct ks_dlil_threading_info, dlth_strategy) == 0x78, "ks_dlil_threading_info.dlth_strategy offset");
_Static_assert(offsetof(struct ks_dlil_threading_info, dlth_affinity) == 0x80, "ks_dlil_threading_info.dlth_affinity offset");
_Static_assert(offsetof(struct ks_dlil_threading_info, dlth_affinity_tag) == 0x84, "ks_dlil_threading_info.dlth_affinity_tag offset");
_Static_assert(offsetof(struct ks_dlil_threading_info, dlth_thread) == 0x88, "ks_dlil_threading_info.dlth_thread offset");
_Static_assert(offsetof(struct ks_dlil_threading_info, dlth_driver_thread) == 0x90, "ks_dlil_threading_info.dlth_driver_thread offset");
_Static_assert(offsetof(struct ks_dlil_threading_info, dlth_poller_thread) == 0x98, "ks_dlil_threading_info.dlth_poller_thread offset");
_Static_assert(offsetof(struct ks_dlil_threading_info, dlth_lock_grp) == 0xA0, "ks_dlil_threading_info.dlth_lock_grp offset");
_Static_assert(offsetof(struct ks_dlil_threading_info, dlth_name_storage) == 0xA8, "ks_dlil_threading_info.dlth_name_storage offset");
_Static_assert(offsetof(struct ks_dlil_threading_info, dlth_name) == 0xC8, "ks_dlil_threading_info.dlth_name offset");
_Static_assert(offsetof(struct ks_dlil_threading_info, dlth_trim_cnt) == 0xD0, "ks_dlil_threading_info.dlth_trim_cnt offset");
_Static_assert(offsetof(struct ks_dlil_threading_info, dlth_trim_pkts_dropped) == 0xD4, "ks_dlil_threading_info.dlth_trim_pkts_dropped offset");
_Static_assert(offsetof(struct ks_dlil_threading_info, dlth_pkts_cnt) == 0xD8, "ks_dlil_threading_info.dlth_pkts_cnt offset");
_Static_assert(sizeof(struct ks_dlil_threading_info) == 0xE0, "ks_dlil_threading_info size");

/* refs: 1 */
struct ks_doc_tombstone {
    struct ks_vnode *t_lastop_parent;
    struct ks_vnode *t_lastop_item;
    unsigned int t_lastop_parent_vid;
    unsigned int t_lastop_item_vid;
    unsigned long long t_lastop_fileid;
    unsigned long long t_lastop_document_id;
    unsigned char t_lastop_filename[0x100];
};
_Static_assert(offsetof(struct ks_doc_tombstone, t_lastop_parent) == 0x0, "ks_doc_tombstone.t_lastop_parent offset");
_Static_assert(offsetof(struct ks_doc_tombstone, t_lastop_item) == 0x8, "ks_doc_tombstone.t_lastop_item offset");
_Static_assert(offsetof(struct ks_doc_tombstone, t_lastop_parent_vid) == 0x10, "ks_doc_tombstone.t_lastop_parent_vid offset");
_Static_assert(offsetof(struct ks_doc_tombstone, t_lastop_item_vid) == 0x14, "ks_doc_tombstone.t_lastop_item_vid offset");
_Static_assert(offsetof(struct ks_doc_tombstone, t_lastop_fileid) == 0x18, "ks_doc_tombstone.t_lastop_fileid offset");
_Static_assert(offsetof(struct ks_doc_tombstone, t_lastop_document_id) == 0x20, "ks_doc_tombstone.t_lastop_document_id offset");
_Static_assert(offsetof(struct ks_doc_tombstone, t_lastop_filename) == 0x28, "ks_doc_tombstone.t_lastop_filename offset");
_Static_assert(sizeof(struct ks_doc_tombstone) == 0x128, "ks_doc_tombstone size");

/* refs: 3 */
struct ks_dof_helper {
    char dofhp_mod[0x40];
    unsigned long long dofhp_addr;
    unsigned long long dofhp_dof;
};
_Static_assert(offsetof(struct ks_dof_helper, dofhp_mod) == 0x0, "ks_dof_helper.dofhp_mod offset");
_Static_assert(offsetof(struct ks_dof_helper, dofhp_addr) == 0x40, "ks_dof_helper.dofhp_addr offset");
_Static_assert(offsetof(struct ks_dof_helper, dofhp_dof) == 0x48, "ks_dof_helper.dofhp_dof offset");
_Static_assert(sizeof(struct ks_dof_helper) == 0x50, "ks_dof_helper size");

/* refs: 1 */
struct ks_dof_ioctl_data {
    unsigned long long dofiod_count;
    struct ks_dof_helper dofiod_helpers[1];
};
_Static_assert(offsetof(struct ks_dof_ioctl_data, dofiod_count) == 0x0, "ks_dof_ioctl_data.dofiod_count offset");
_Static_assert(offsetof(struct ks_dof_ioctl_data, dofiod_helpers) == 0x8, "ks_dof_ioctl_data.dofiod_helpers offset");
_Static_assert(sizeof(struct ks_dof_ioctl_data) == 0x58, "ks_dof_ioctl_data size");

/* refs: 4 */
struct ks_domain {
    int dom_family;
    unsigned int dom_flags;
    unsigned int dom_refs;
    struct ks_lck_mtx_s *dom_mtx;
    struct ks_lck_mtx_s dom_mtx_s;
    struct {
        struct ks_domain *tqe_next;
        struct ks_domain **tqe_prev;
    } dom_entry;
    struct {
        struct ks_protosw *tqh_first;
        struct ks_protosw **tqh_last;
    } dom_protosw;
    void *dom_init;
    int *dom_externalize;
    void *dom_dispose;
    int *dom_rtattach;
    int dom_rtoffset;
    int dom_maxrtkey;
    int dom_protohdrlen;
    const char *dom_name;
    struct ks_domain_old *dom_old;
};
_Static_assert(offsetof(struct ks_domain, dom_family) == 0x0, "ks_domain.dom_family offset");
_Static_assert(offsetof(struct ks_domain, dom_flags) == 0x4, "ks_domain.dom_flags offset");
_Static_assert(offsetof(struct ks_domain, dom_refs) == 0x8, "ks_domain.dom_refs offset");
_Static_assert(offsetof(struct ks_domain, dom_mtx) == 0x10, "ks_domain.dom_mtx offset");
_Static_assert(offsetof(struct ks_domain, dom_mtx_s) == 0x18, "ks_domain.dom_mtx_s offset");
_Static_assert(offsetof(struct ks_domain, dom_entry) == 0x28, "ks_domain.dom_entry offset");
_Static_assert(offsetof(struct ks_domain, dom_protosw) == 0x38, "ks_domain.dom_protosw offset");
_Static_assert(offsetof(struct ks_domain, dom_init) == 0x48, "ks_domain.dom_init offset");
_Static_assert(offsetof(struct ks_domain, dom_externalize) == 0x50, "ks_domain.dom_externalize offset");
_Static_assert(offsetof(struct ks_domain, dom_dispose) == 0x58, "ks_domain.dom_dispose offset");
_Static_assert(offsetof(struct ks_domain, dom_rtattach) == 0x60, "ks_domain.dom_rtattach offset");
_Static_assert(offsetof(struct ks_domain, dom_rtoffset) == 0x68, "ks_domain.dom_rtoffset offset");
_Static_assert(offsetof(struct ks_domain, dom_maxrtkey) == 0x6C, "ks_domain.dom_maxrtkey offset");
_Static_assert(offsetof(struct ks_domain, dom_protohdrlen) == 0x70, "ks_domain.dom_protohdrlen offset");
_Static_assert(offsetof(struct ks_domain, dom_name) == 0x78, "ks_domain.dom_name offset");
_Static_assert(offsetof(struct ks_domain, dom_old) == 0x80, "ks_domain.dom_old offset");
_Static_assert(sizeof(struct ks_domain) == 0x88, "ks_domain size");

/* refs: 1 */
#pragma pack(push, 4)
struct ks_domain_old {
    int dom_family;
    const char *dom_name;
    void *dom_init;
    int *dom_externalize;
    void *dom_dispose;
    struct ks_protosw_old *dom_protosw;
    struct ks_domain_old *dom_next;
    int *dom_rtattach;
    int dom_rtoffset;
    int dom_maxrtkey;
    int dom_protohdrlen;
    int dom_refs;
    struct ks_lck_mtx_s *dom_mtx;
    unsigned int dom_flags;
    unsigned int reserved[2];
};
#pragma pack(pop)
_Static_assert(offsetof(struct ks_domain_old, dom_family) == 0x0, "ks_domain_old.dom_family offset");
_Static_assert(offsetof(struct ks_domain_old, dom_name) == 0x4, "ks_domain_old.dom_name offset");
_Static_assert(offsetof(struct ks_domain_old, dom_init) == 0xC, "ks_domain_old.dom_init offset");
_Static_assert(offsetof(struct ks_domain_old, dom_externalize) == 0x14, "ks_domain_old.dom_externalize offset");
_Static_assert(offsetof(struct ks_domain_old, dom_dispose) == 0x1C, "ks_domain_old.dom_dispose offset");
_Static_assert(offsetof(struct ks_domain_old, dom_protosw) == 0x24, "ks_domain_old.dom_protosw offset");
_Static_assert(offsetof(struct ks_domain_old, dom_next) == 0x2C, "ks_domain_old.dom_next offset");
_Static_assert(offsetof(struct ks_domain_old, dom_rtattach) == 0x34, "ks_domain_old.dom_rtattach offset");
_Static_assert(offsetof(struct ks_domain_old, dom_rtoffset) == 0x3C, "ks_domain_old.dom_rtoffset offset");
_Static_assert(offsetof(struct ks_domain_old, dom_maxrtkey) == 0x40, "ks_domain_old.dom_maxrtkey offset");
_Static_assert(offsetof(struct ks_domain_old, dom_protohdrlen) == 0x44, "ks_domain_old.dom_protohdrlen offset");
_Static_assert(offsetof(struct ks_domain_old, dom_refs) == 0x48, "ks_domain_old.dom_refs offset");
_Static_assert(offsetof(struct ks_domain_old, dom_mtx) == 0x4C, "ks_domain_old.dom_mtx offset");
_Static_assert(offsetof(struct ks_domain_old, dom_flags) == 0x54, "ks_domain_old.dom_flags offset");
_Static_assert(offsetof(struct ks_domain_old, reserved) == 0x58, "ks_domain_old.reserved offset");
_Static_assert(sizeof(struct ks_domain_old) == 0x60, "ks_domain_old size");

/* refs: 1 */
struct ks_driver_mtag_ {
    unsigned long _drv_tx_compl_arg;
    unsigned long _drv_tx_compl_data;
    int _drv_tx_status;
    unsigned short _drv_flowid;
};
_Static_assert(offsetof(struct ks_driver_mtag_, _drv_tx_compl_arg) == 0x0, "ks_driver_mtag_._drv_tx_compl_arg offset");
_Static_assert(offsetof(struct ks_driver_mtag_, _drv_tx_compl_data) == 0x8, "ks_driver_mtag_._drv_tx_compl_data offset");
_Static_assert(offsetof(struct ks_driver_mtag_, _drv_tx_status) == 0x10, "ks_driver_mtag_._drv_tx_status offset");
_Static_assert(offsetof(struct ks_driver_mtag_, _drv_flowid) == 0x14, "ks_driver_mtag_._drv_flowid offset");
_Static_assert(sizeof(struct ks_driver_mtag_) == 0x18, "ks_driver_mtag_ size");

/* refs: 2 */
struct ks_dtrace_recdesc {
    unsigned short dtrd_action;
    unsigned int dtrd_size;
    unsigned int dtrd_offset;
    unsigned short dtrd_alignment;
    unsigned short dtrd_format;
    unsigned long long dtrd_arg;
    unsigned long long dtrd_uarg;
};
_Static_assert(offsetof(struct ks_dtrace_recdesc, dtrd_action) == 0x0, "ks_dtrace_recdesc.dtrd_action offset");
_Static_assert(offsetof(struct ks_dtrace_recdesc, dtrd_size) == 0x4, "ks_dtrace_recdesc.dtrd_size offset");
_Static_assert(offsetof(struct ks_dtrace_recdesc, dtrd_offset) == 0x8, "ks_dtrace_recdesc.dtrd_offset offset");
_Static_assert(offsetof(struct ks_dtrace_recdesc, dtrd_alignment) == 0xC, "ks_dtrace_recdesc.dtrd_alignment offset");
_Static_assert(offsetof(struct ks_dtrace_recdesc, dtrd_format) == 0xE, "ks_dtrace_recdesc.dtrd_format offset");
_Static_assert(offsetof(struct ks_dtrace_recdesc, dtrd_arg) == 0x10, "ks_dtrace_recdesc.dtrd_arg offset");
_Static_assert(offsetof(struct ks_dtrace_recdesc, dtrd_uarg) == 0x18, "ks_dtrace_recdesc.dtrd_uarg offset");
_Static_assert(sizeof(struct ks_dtrace_recdesc) == 0x20, "ks_dtrace_recdesc size");

/* refs: 5 */
struct ks_dtrace_action {
    unsigned short dta_kind;
    unsigned short dta_intuple;
    unsigned int dta_refcnt;
    struct ks_dtrace_difo *dta_difo;
    struct ks_dtrace_recdesc dta_rec;
    struct ks_dtrace_action *dta_prev;
    struct ks_dtrace_action *dta_next;
};
_Static_assert(offsetof(struct ks_dtrace_action, dta_kind) == 0x0, "ks_dtrace_action.dta_kind offset");
_Static_assert(offsetof(struct ks_dtrace_action, dta_intuple) == 0x2, "ks_dtrace_action.dta_intuple offset");
_Static_assert(offsetof(struct ks_dtrace_action, dta_refcnt) == 0x4, "ks_dtrace_action.dta_refcnt offset");
_Static_assert(offsetof(struct ks_dtrace_action, dta_difo) == 0x8, "ks_dtrace_action.dta_difo offset");
_Static_assert(offsetof(struct ks_dtrace_action, dta_rec) == 0x10, "ks_dtrace_action.dta_rec offset");
_Static_assert(offsetof(struct ks_dtrace_action, dta_prev) == 0x30, "ks_dtrace_action.dta_prev offset");
_Static_assert(offsetof(struct ks_dtrace_action, dta_next) == 0x38, "ks_dtrace_action.dta_next offset");
_Static_assert(sizeof(struct ks_dtrace_action) == 0x40, "ks_dtrace_action size");

/* refs: 2 */
struct ks_dtrace_aggregation {
    struct ks_dtrace_action dtag_action;
    unsigned int dtag_id;
    struct ks_dtrace_ecb *dtag_ecb;
    struct ks_dtrace_action *dtag_first;
    unsigned int dtag_base;
    unsigned char dtag_hasarg;
    unsigned long long dtag_initial;
    void *dtag_aggregate;
};
_Static_assert(offsetof(struct ks_dtrace_aggregation, dtag_action) == 0x0, "ks_dtrace_aggregation.dtag_action offset");
_Static_assert(offsetof(struct ks_dtrace_aggregation, dtag_id) == 0x40, "ks_dtrace_aggregation.dtag_id offset");
_Static_assert(offsetof(struct ks_dtrace_aggregation, dtag_ecb) == 0x48, "ks_dtrace_aggregation.dtag_ecb offset");
_Static_assert(offsetof(struct ks_dtrace_aggregation, dtag_first) == 0x50, "ks_dtrace_aggregation.dtag_first offset");
_Static_assert(offsetof(struct ks_dtrace_aggregation, dtag_base) == 0x58, "ks_dtrace_aggregation.dtag_base offset");
_Static_assert(offsetof(struct ks_dtrace_aggregation, dtag_hasarg) == 0x5C, "ks_dtrace_aggregation.dtag_hasarg offset");
_Static_assert(offsetof(struct ks_dtrace_aggregation, dtag_initial) == 0x60, "ks_dtrace_aggregation.dtag_initial offset");
_Static_assert(offsetof(struct ks_dtrace_aggregation, dtag_aggregate) == 0x68, "ks_dtrace_aggregation.dtag_aggregate offset");
_Static_assert(sizeof(struct ks_dtrace_aggregation) == 0x70, "ks_dtrace_aggregation size");

/* refs: 6 */
struct ks_dtrace_attribute {
    unsigned char dtat_name;
    unsigned char dtat_data;
    unsigned char dtat_class;
};
_Static_assert(offsetof(struct ks_dtrace_attribute, dtat_name) == 0x0, "ks_dtrace_attribute.dtat_name offset");
_Static_assert(offsetof(struct ks_dtrace_attribute, dtat_data) == 0x1, "ks_dtrace_attribute.dtat_data offset");
_Static_assert(offsetof(struct ks_dtrace_attribute, dtat_class) == 0x2, "ks_dtrace_attribute.dtat_class offset");
_Static_assert(sizeof(struct ks_dtrace_attribute) == 0x3, "ks_dtrace_attribute size");

/* refs: 4 */
struct ks_dtrace_buffer {
    unsigned long long dtb_offset;
    unsigned long long dtb_cur_limit;
    unsigned long long dtb_limit;
    unsigned long long dtb_size;
    unsigned int dtb_flags;
    unsigned int dtb_drops;
    char *dtb_tomax;
    char *dtb_xamot;
    unsigned int dtb_xamot_flags;
    unsigned int dtb_xamot_drops;
    unsigned long long dtb_xamot_offset;
    unsigned int dtb_errors;
    unsigned int dtb_xamot_errors;
    unsigned long long dtb_switched;
    unsigned long long dtb_interval;
    unsigned long long dtb_pad2[4];
};
_Static_assert(offsetof(struct ks_dtrace_buffer, dtb_offset) == 0x0, "ks_dtrace_buffer.dtb_offset offset");
_Static_assert(offsetof(struct ks_dtrace_buffer, dtb_cur_limit) == 0x8, "ks_dtrace_buffer.dtb_cur_limit offset");
_Static_assert(offsetof(struct ks_dtrace_buffer, dtb_limit) == 0x10, "ks_dtrace_buffer.dtb_limit offset");
_Static_assert(offsetof(struct ks_dtrace_buffer, dtb_size) == 0x18, "ks_dtrace_buffer.dtb_size offset");
_Static_assert(offsetof(struct ks_dtrace_buffer, dtb_flags) == 0x20, "ks_dtrace_buffer.dtb_flags offset");
_Static_assert(offsetof(struct ks_dtrace_buffer, dtb_drops) == 0x24, "ks_dtrace_buffer.dtb_drops offset");
_Static_assert(offsetof(struct ks_dtrace_buffer, dtb_tomax) == 0x28, "ks_dtrace_buffer.dtb_tomax offset");
_Static_assert(offsetof(struct ks_dtrace_buffer, dtb_xamot) == 0x30, "ks_dtrace_buffer.dtb_xamot offset");
_Static_assert(offsetof(struct ks_dtrace_buffer, dtb_xamot_flags) == 0x38, "ks_dtrace_buffer.dtb_xamot_flags offset");
_Static_assert(offsetof(struct ks_dtrace_buffer, dtb_xamot_drops) == 0x3C, "ks_dtrace_buffer.dtb_xamot_drops offset");
_Static_assert(offsetof(struct ks_dtrace_buffer, dtb_xamot_offset) == 0x40, "ks_dtrace_buffer.dtb_xamot_offset offset");
_Static_assert(offsetof(struct ks_dtrace_buffer, dtb_errors) == 0x48, "ks_dtrace_buffer.dtb_errors offset");
_Static_assert(offsetof(struct ks_dtrace_buffer, dtb_xamot_errors) == 0x4C, "ks_dtrace_buffer.dtb_xamot_errors offset");
_Static_assert(offsetof(struct ks_dtrace_buffer, dtb_switched) == 0x50, "ks_dtrace_buffer.dtb_switched offset");
_Static_assert(offsetof(struct ks_dtrace_buffer, dtb_interval) == 0x58, "ks_dtrace_buffer.dtb_interval offset");
_Static_assert(offsetof(struct ks_dtrace_buffer, dtb_pad2) == 0x60, "ks_dtrace_buffer.dtb_pad2 offset");
_Static_assert(sizeof(struct ks_dtrace_buffer) == 0x80, "ks_dtrace_buffer size");

/* refs: 2 */
struct ks_dtrace_cred {
    struct ks_ucred *dcr_cred;
    unsigned char dcr_destructive;
    unsigned char dcr_visible;
    unsigned short dcr_action;
};
_Static_assert(offsetof(struct ks_dtrace_cred, dcr_cred) == 0x0, "ks_dtrace_cred.dcr_cred offset");
_Static_assert(offsetof(struct ks_dtrace_cred, dcr_destructive) == 0x8, "ks_dtrace_cred.dcr_destructive offset");
_Static_assert(offsetof(struct ks_dtrace_cred, dcr_visible) == 0x9, "ks_dtrace_cred.dcr_visible offset");
_Static_assert(offsetof(struct ks_dtrace_cred, dcr_action) == 0xA, "ks_dtrace_cred.dcr_action offset");
_Static_assert(sizeof(struct ks_dtrace_cred) == 0x10, "ks_dtrace_cred size");

/* refs: 3 */
struct ks_dtrace_diftype {
    unsigned char dtdt_kind;
    unsigned char dtdt_ckind;
    unsigned char dtdt_flags;
    unsigned char dtdt_pad;
    unsigned int dtdt_size;
};
_Static_assert(offsetof(struct ks_dtrace_diftype, dtdt_kind) == 0x0, "ks_dtrace_diftype.dtdt_kind offset");
_Static_assert(offsetof(struct ks_dtrace_diftype, dtdt_ckind) == 0x1, "ks_dtrace_diftype.dtdt_ckind offset");
_Static_assert(offsetof(struct ks_dtrace_diftype, dtdt_flags) == 0x2, "ks_dtrace_diftype.dtdt_flags offset");
_Static_assert(offsetof(struct ks_dtrace_diftype, dtdt_pad) == 0x3, "ks_dtrace_diftype.dtdt_pad offset");
_Static_assert(offsetof(struct ks_dtrace_diftype, dtdt_size) == 0x4, "ks_dtrace_diftype.dtdt_size offset");
_Static_assert(sizeof(struct ks_dtrace_diftype) == 0x8, "ks_dtrace_diftype size");

/* refs: 5 */
struct ks_dtrace_difo {
    unsigned int *dtdo_buf;
    unsigned long long *dtdo_inttab;
    char *dtdo_strtab;
    struct ks_dtrace_difv *dtdo_vartab;
    unsigned int dtdo_len;
    unsigned int dtdo_intlen;
    unsigned int dtdo_strlen;
    unsigned int dtdo_varlen;
    struct ks_dtrace_diftype dtdo_rtype;
    unsigned int dtdo_refcnt;
    unsigned int dtdo_destructive;
};
_Static_assert(offsetof(struct ks_dtrace_difo, dtdo_buf) == 0x0, "ks_dtrace_difo.dtdo_buf offset");
_Static_assert(offsetof(struct ks_dtrace_difo, dtdo_inttab) == 0x8, "ks_dtrace_difo.dtdo_inttab offset");
_Static_assert(offsetof(struct ks_dtrace_difo, dtdo_strtab) == 0x10, "ks_dtrace_difo.dtdo_strtab offset");
_Static_assert(offsetof(struct ks_dtrace_difo, dtdo_vartab) == 0x18, "ks_dtrace_difo.dtdo_vartab offset");
_Static_assert(offsetof(struct ks_dtrace_difo, dtdo_len) == 0x20, "ks_dtrace_difo.dtdo_len offset");
_Static_assert(offsetof(struct ks_dtrace_difo, dtdo_intlen) == 0x24, "ks_dtrace_difo.dtdo_intlen offset");
_Static_assert(offsetof(struct ks_dtrace_difo, dtdo_strlen) == 0x28, "ks_dtrace_difo.dtdo_strlen offset");
_Static_assert(offsetof(struct ks_dtrace_difo, dtdo_varlen) == 0x2C, "ks_dtrace_difo.dtdo_varlen offset");
_Static_assert(offsetof(struct ks_dtrace_difo, dtdo_rtype) == 0x30, "ks_dtrace_difo.dtdo_rtype offset");
_Static_assert(offsetof(struct ks_dtrace_difo, dtdo_refcnt) == 0x38, "ks_dtrace_difo.dtdo_refcnt offset");
_Static_assert(offsetof(struct ks_dtrace_difo, dtdo_destructive) == 0x3C, "ks_dtrace_difo.dtdo_destructive offset");
_Static_assert(sizeof(struct ks_dtrace_difo) == 0x40, "ks_dtrace_difo size");

/* refs: 4 */
struct ks_dtrace_difv {
    unsigned int dtdv_name;
    unsigned int dtdv_id;
    unsigned char dtdv_kind;
    unsigned char dtdv_scope;
    unsigned short dtdv_flags;
    struct ks_dtrace_diftype dtdv_type;
};
_Static_assert(offsetof(struct ks_dtrace_difv, dtdv_name) == 0x0, "ks_dtrace_difv.dtdv_name offset");
_Static_assert(offsetof(struct ks_dtrace_difv, dtdv_id) == 0x4, "ks_dtrace_difv.dtdv_id offset");
_Static_assert(offsetof(struct ks_dtrace_difv, dtdv_kind) == 0x8, "ks_dtrace_difv.dtdv_kind offset");
_Static_assert(offsetof(struct ks_dtrace_difv, dtdv_scope) == 0x9, "ks_dtrace_difv.dtdv_scope offset");
_Static_assert(offsetof(struct ks_dtrace_difv, dtdv_flags) == 0xA, "ks_dtrace_difv.dtdv_flags offset");
_Static_assert(offsetof(struct ks_dtrace_difv, dtdv_type) == 0xC, "ks_dtrace_difv.dtdv_type offset");
_Static_assert(sizeof(struct ks_dtrace_difv) == 0x14, "ks_dtrace_difv size");

/* refs: 2 */
struct ks_dtrace_dstate {
    void *dtds_base;
    unsigned long dtds_size;
    unsigned long dtds_hashsize;
    unsigned long dtds_chunksize;
    struct ks_dtrace_dynhash *dtds_hash;
    unsigned int dtds_state;
    struct ks_dtrace_dstate_percpu *dtds_percpu;
};
_Static_assert(offsetof(struct ks_dtrace_dstate, dtds_base) == 0x0, "ks_dtrace_dstate.dtds_base offset");
_Static_assert(offsetof(struct ks_dtrace_dstate, dtds_size) == 0x8, "ks_dtrace_dstate.dtds_size offset");
_Static_assert(offsetof(struct ks_dtrace_dstate, dtds_hashsize) == 0x10, "ks_dtrace_dstate.dtds_hashsize offset");
_Static_assert(offsetof(struct ks_dtrace_dstate, dtds_chunksize) == 0x18, "ks_dtrace_dstate.dtds_chunksize offset");
_Static_assert(offsetof(struct ks_dtrace_dstate, dtds_hash) == 0x20, "ks_dtrace_dstate.dtds_hash offset");
_Static_assert(offsetof(struct ks_dtrace_dstate, dtds_state) == 0x28, "ks_dtrace_dstate.dtds_state offset");
_Static_assert(offsetof(struct ks_dtrace_dstate, dtds_percpu) == 0x30, "ks_dtrace_dstate.dtds_percpu offset");
_Static_assert(sizeof(struct ks_dtrace_dstate) == 0x38, "ks_dtrace_dstate size");

/* refs: 2 */
struct ks_dtrace_dstate_percpu {
    struct ks_dtrace_dynvar *dtdsc_free;
    struct ks_dtrace_dynvar *dtdsc_dirty;
    struct ks_dtrace_dynvar *dtdsc_rinsing;
    struct ks_dtrace_dynvar *dtdsc_clean;
    unsigned long long dtdsc_drops;
    unsigned long long dtdsc_dirty_drops;
    unsigned long long dtdsc_rinsing_drops;
};
_Static_assert(offsetof(struct ks_dtrace_dstate_percpu, dtdsc_free) == 0x0, "ks_dtrace_dstate_percpu.dtdsc_free offset");
_Static_assert(offsetof(struct ks_dtrace_dstate_percpu, dtdsc_dirty) == 0x8, "ks_dtrace_dstate_percpu.dtdsc_dirty offset");
_Static_assert(offsetof(struct ks_dtrace_dstate_percpu, dtdsc_rinsing) == 0x10, "ks_dtrace_dstate_percpu.dtdsc_rinsing offset");
_Static_assert(offsetof(struct ks_dtrace_dstate_percpu, dtdsc_clean) == 0x18, "ks_dtrace_dstate_percpu.dtdsc_clean offset");
_Static_assert(offsetof(struct ks_dtrace_dstate_percpu, dtdsc_drops) == 0x20, "ks_dtrace_dstate_percpu.dtdsc_drops offset");
_Static_assert(offsetof(struct ks_dtrace_dstate_percpu, dtdsc_dirty_drops) == 0x28, "ks_dtrace_dstate_percpu.dtdsc_dirty_drops offset");
_Static_assert(offsetof(struct ks_dtrace_dstate_percpu, dtdsc_rinsing_drops) == 0x30, "ks_dtrace_dstate_percpu.dtdsc_rinsing_drops offset");
_Static_assert(sizeof(struct ks_dtrace_dstate_percpu) == 0x38, "ks_dtrace_dstate_percpu size");

/* refs: 2 */
struct ks_dtrace_dynhash {
    struct ks_dtrace_dynvar *dtdh_chain;
    unsigned long dtdh_lock;
    unsigned long dtdh_pad[6];
};
_Static_assert(offsetof(struct ks_dtrace_dynhash, dtdh_chain) == 0x0, "ks_dtrace_dynhash.dtdh_chain offset");
_Static_assert(offsetof(struct ks_dtrace_dynhash, dtdh_lock) == 0x8, "ks_dtrace_dynhash.dtdh_lock offset");
_Static_assert(offsetof(struct ks_dtrace_dynhash, dtdh_pad) == 0x10, "ks_dtrace_dynhash.dtdh_pad offset");
_Static_assert(sizeof(struct ks_dtrace_dynhash) == 0x40, "ks_dtrace_dynhash size");

/* refs: 2 */
struct ks_dtrace_key {
    unsigned long long dttk_value;
    unsigned long long dttk_size;
};
_Static_assert(offsetof(struct ks_dtrace_key, dttk_value) == 0x0, "ks_dtrace_key.dttk_value offset");
_Static_assert(offsetof(struct ks_dtrace_key, dttk_size) == 0x8, "ks_dtrace_key.dttk_size offset");
_Static_assert(sizeof(struct ks_dtrace_key) == 0x10, "ks_dtrace_key size");

/* refs: 2 */
struct ks_dtrace_tuple {
    unsigned int dtt_nkeys;
    unsigned int dtt_pad;
    struct ks_dtrace_key dtt_key[1];
};
_Static_assert(offsetof(struct ks_dtrace_tuple, dtt_nkeys) == 0x0, "ks_dtrace_tuple.dtt_nkeys offset");
_Static_assert(offsetof(struct ks_dtrace_tuple, dtt_pad) == 0x4, "ks_dtrace_tuple.dtt_pad offset");
_Static_assert(offsetof(struct ks_dtrace_tuple, dtt_key) == 0x8, "ks_dtrace_tuple.dtt_key offset");
_Static_assert(sizeof(struct ks_dtrace_tuple) == 0x18, "ks_dtrace_tuple size");

/* refs: 6 */
struct ks_dtrace_dynvar {
    unsigned long long dtdv_hashval;
    struct ks_dtrace_dynvar *dtdv_next;
    void *dtdv_data;
    struct ks_dtrace_tuple dtdv_tuple;
};
_Static_assert(offsetof(struct ks_dtrace_dynvar, dtdv_hashval) == 0x0, "ks_dtrace_dynvar.dtdv_hashval offset");
_Static_assert(offsetof(struct ks_dtrace_dynvar, dtdv_next) == 0x8, "ks_dtrace_dynvar.dtdv_next offset");
_Static_assert(offsetof(struct ks_dtrace_dynvar, dtdv_data) == 0x10, "ks_dtrace_dynvar.dtdv_data offset");
_Static_assert(offsetof(struct ks_dtrace_dynvar, dtdv_tuple) == 0x18, "ks_dtrace_dynvar.dtdv_tuple offset");
_Static_assert(sizeof(struct ks_dtrace_dynvar) == 0x30, "ks_dtrace_dynvar size");

/* refs: 5 */
struct ks_dtrace_ecb {
    unsigned int dte_epid;
    unsigned int dte_alignment;
    unsigned long dte_needed;
    unsigned long dte_size;
    struct ks_dtrace_predicate *dte_predicate;
    struct ks_dtrace_action *dte_action;
    struct ks_dtrace_ecb *dte_next;
    struct ks_dtrace_state *dte_state;
    unsigned int dte_cond;
    struct ks_dtrace_probe *dte_probe;
    struct ks_dtrace_action *dte_action_last;
    unsigned long long dte_uarg;
};
_Static_assert(offsetof(struct ks_dtrace_ecb, dte_epid) == 0x0, "ks_dtrace_ecb.dte_epid offset");
_Static_assert(offsetof(struct ks_dtrace_ecb, dte_alignment) == 0x4, "ks_dtrace_ecb.dte_alignment offset");
_Static_assert(offsetof(struct ks_dtrace_ecb, dte_needed) == 0x8, "ks_dtrace_ecb.dte_needed offset");
_Static_assert(offsetof(struct ks_dtrace_ecb, dte_size) == 0x10, "ks_dtrace_ecb.dte_size offset");
_Static_assert(offsetof(struct ks_dtrace_ecb, dte_predicate) == 0x18, "ks_dtrace_ecb.dte_predicate offset");
_Static_assert(offsetof(struct ks_dtrace_ecb, dte_action) == 0x20, "ks_dtrace_ecb.dte_action offset");
_Static_assert(offsetof(struct ks_dtrace_ecb, dte_next) == 0x28, "ks_dtrace_ecb.dte_next offset");
_Static_assert(offsetof(struct ks_dtrace_ecb, dte_state) == 0x30, "ks_dtrace_ecb.dte_state offset");
_Static_assert(offsetof(struct ks_dtrace_ecb, dte_cond) == 0x38, "ks_dtrace_ecb.dte_cond offset");
_Static_assert(offsetof(struct ks_dtrace_ecb, dte_probe) == 0x40, "ks_dtrace_ecb.dte_probe offset");
_Static_assert(offsetof(struct ks_dtrace_ecb, dte_action_last) == 0x48, "ks_dtrace_ecb.dte_action_last offset");
_Static_assert(offsetof(struct ks_dtrace_ecb, dte_uarg) == 0x50, "ks_dtrace_ecb.dte_uarg offset");
_Static_assert(sizeof(struct ks_dtrace_ecb) == 0x58, "ks_dtrace_ecb size");

/* refs: 2 */
struct ks_dtrace_format {
    unsigned long long dtf_refcount;
    char dtf_str[];
};
_Static_assert(offsetof(struct ks_dtrace_format, dtf_refcount) == 0x0, "ks_dtrace_format.dtf_refcount offset");
_Static_assert(offsetof(struct ks_dtrace_format, dtf_str) == 0x8, "ks_dtrace_format.dtf_str offset");
_Static_assert(sizeof(struct ks_dtrace_format) == 0x8, "ks_dtrace_format size");

/* refs: 2 */
struct ks_dtrace_helper_action {
    int dtha_generation;
    int dtha_nactions;
    struct ks_dtrace_difo *dtha_predicate;
    struct ks_dtrace_difo **dtha_actions;
    struct ks_dtrace_helper_action *dtha_next;
};
_Static_assert(offsetof(struct ks_dtrace_helper_action, dtha_generation) == 0x0, "ks_dtrace_helper_action.dtha_generation offset");
_Static_assert(offsetof(struct ks_dtrace_helper_action, dtha_nactions) == 0x4, "ks_dtrace_helper_action.dtha_nactions offset");
_Static_assert(offsetof(struct ks_dtrace_helper_action, dtha_predicate) == 0x8, "ks_dtrace_helper_action.dtha_predicate offset");
_Static_assert(offsetof(struct ks_dtrace_helper_action, dtha_actions) == 0x10, "ks_dtrace_helper_action.dtha_actions offset");
_Static_assert(offsetof(struct ks_dtrace_helper_action, dtha_next) == 0x18, "ks_dtrace_helper_action.dtha_next offset");
_Static_assert(sizeof(struct ks_dtrace_helper_action) == 0x20, "ks_dtrace_helper_action size");

/* refs: 2 */
struct ks_dtrace_helper_provider {
    int dthp_generation;
    unsigned int dthp_ref;
    struct ks_dof_helper dthp_prov;
};
_Static_assert(offsetof(struct ks_dtrace_helper_provider, dthp_generation) == 0x0, "ks_dtrace_helper_provider.dthp_generation offset");
_Static_assert(offsetof(struct ks_dtrace_helper_provider, dthp_ref) == 0x4, "ks_dtrace_helper_provider.dthp_ref offset");
_Static_assert(offsetof(struct ks_dtrace_helper_provider, dthp_prov) == 0x8, "ks_dtrace_helper_provider.dthp_prov offset");
_Static_assert(sizeof(struct ks_dtrace_helper_provider) == 0x58, "ks_dtrace_helper_provider size");

/* refs: 3 */
struct ks_dtrace_vstate {
    struct ks_dtrace_state *dtvs_state;
    struct ks_dtrace_statvar **dtvs_globals;
    int dtvs_nglobals;
    struct ks_dtrace_difv *dtvs_tlocals;
    int dtvs_ntlocals;
    struct ks_dtrace_statvar **dtvs_locals;
    int dtvs_nlocals;
    struct ks_dtrace_dstate dtvs_dynvars;
};
_Static_assert(offsetof(struct ks_dtrace_vstate, dtvs_state) == 0x0, "ks_dtrace_vstate.dtvs_state offset");
_Static_assert(offsetof(struct ks_dtrace_vstate, dtvs_globals) == 0x8, "ks_dtrace_vstate.dtvs_globals offset");
_Static_assert(offsetof(struct ks_dtrace_vstate, dtvs_nglobals) == 0x10, "ks_dtrace_vstate.dtvs_nglobals offset");
_Static_assert(offsetof(struct ks_dtrace_vstate, dtvs_tlocals) == 0x18, "ks_dtrace_vstate.dtvs_tlocals offset");
_Static_assert(offsetof(struct ks_dtrace_vstate, dtvs_ntlocals) == 0x20, "ks_dtrace_vstate.dtvs_ntlocals offset");
_Static_assert(offsetof(struct ks_dtrace_vstate, dtvs_locals) == 0x28, "ks_dtrace_vstate.dtvs_locals offset");
_Static_assert(offsetof(struct ks_dtrace_vstate, dtvs_nlocals) == 0x30, "ks_dtrace_vstate.dtvs_nlocals offset");
_Static_assert(offsetof(struct ks_dtrace_vstate, dtvs_dynvars) == 0x38, "ks_dtrace_vstate.dtvs_dynvars offset");
_Static_assert(sizeof(struct ks_dtrace_vstate) == 0x70, "ks_dtrace_vstate size");

/* refs: 1 */
struct ks_dtrace_helpers {
    struct ks_dtrace_helper_action **dthps_actions;
    struct ks_dtrace_vstate dthps_vstate;
    struct ks_dtrace_helper_provider **dthps_provs;
    unsigned int dthps_nprovs;
    unsigned int dthps_maxprovs;
    int dthps_generation;
    int dthps_pid;
    int dthps_deferred;
    struct ks_dtrace_helpers *dthps_next;
    struct ks_dtrace_helpers *dthps_prev;
};
_Static_assert(offsetof(struct ks_dtrace_helpers, dthps_actions) == 0x0, "ks_dtrace_helpers.dthps_actions offset");
_Static_assert(offsetof(struct ks_dtrace_helpers, dthps_vstate) == 0x8, "ks_dtrace_helpers.dthps_vstate offset");
_Static_assert(offsetof(struct ks_dtrace_helpers, dthps_provs) == 0x78, "ks_dtrace_helpers.dthps_provs offset");
_Static_assert(offsetof(struct ks_dtrace_helpers, dthps_nprovs) == 0x80, "ks_dtrace_helpers.dthps_nprovs offset");
_Static_assert(offsetof(struct ks_dtrace_helpers, dthps_maxprovs) == 0x84, "ks_dtrace_helpers.dthps_maxprovs offset");
_Static_assert(offsetof(struct ks_dtrace_helpers, dthps_generation) == 0x88, "ks_dtrace_helpers.dthps_generation offset");
_Static_assert(offsetof(struct ks_dtrace_helpers, dthps_pid) == 0x8C, "ks_dtrace_helpers.dthps_pid offset");
_Static_assert(offsetof(struct ks_dtrace_helpers, dthps_deferred) == 0x90, "ks_dtrace_helpers.dthps_deferred offset");
_Static_assert(offsetof(struct ks_dtrace_helpers, dthps_next) == 0x98, "ks_dtrace_helpers.dthps_next offset");
_Static_assert(offsetof(struct ks_dtrace_helpers, dthps_prev) == 0xA0, "ks_dtrace_helpers.dthps_prev offset");
_Static_assert(sizeof(struct ks_dtrace_helpers) == 0xA8, "ks_dtrace_helpers size");

/* refs: 2 */
struct ks_dtrace_pattr {
    struct ks_dtrace_attribute dtpa_provider;
    struct ks_dtrace_attribute dtpa_mod;
    struct ks_dtrace_attribute dtpa_func;
    struct ks_dtrace_attribute dtpa_name;
    struct ks_dtrace_attribute dtpa_args;
};
_Static_assert(offsetof(struct ks_dtrace_pattr, dtpa_provider) == 0x0, "ks_dtrace_pattr.dtpa_provider offset");
_Static_assert(offsetof(struct ks_dtrace_pattr, dtpa_mod) == 0x3, "ks_dtrace_pattr.dtpa_mod offset");
_Static_assert(offsetof(struct ks_dtrace_pattr, dtpa_func) == 0x6, "ks_dtrace_pattr.dtpa_func offset");
_Static_assert(offsetof(struct ks_dtrace_pattr, dtpa_name) == 0x9, "ks_dtrace_pattr.dtpa_name offset");
_Static_assert(offsetof(struct ks_dtrace_pattr, dtpa_args) == 0xC, "ks_dtrace_pattr.dtpa_args offset");
_Static_assert(sizeof(struct ks_dtrace_pattr) == 0xF, "ks_dtrace_pattr size");

/* refs: 2 */
struct ks_dtrace_pops {
    void *dtps_provide;
    void *dtps_provide_module;
    int *dtps_enable;
    void *dtps_disable;
    void *dtps_suspend;
    void *dtps_resume;
    void *dtps_getargdesc;
    unsigned long long *dtps_getargval;
    int *dtps_usermode;
    void *dtps_destroy;
};
_Static_assert(offsetof(struct ks_dtrace_pops, dtps_provide) == 0x0, "ks_dtrace_pops.dtps_provide offset");
_Static_assert(offsetof(struct ks_dtrace_pops, dtps_provide_module) == 0x8, "ks_dtrace_pops.dtps_provide_module offset");
_Static_assert(offsetof(struct ks_dtrace_pops, dtps_enable) == 0x10, "ks_dtrace_pops.dtps_enable offset");
_Static_assert(offsetof(struct ks_dtrace_pops, dtps_disable) == 0x18, "ks_dtrace_pops.dtps_disable offset");
_Static_assert(offsetof(struct ks_dtrace_pops, dtps_suspend) == 0x20, "ks_dtrace_pops.dtps_suspend offset");
_Static_assert(offsetof(struct ks_dtrace_pops, dtps_resume) == 0x28, "ks_dtrace_pops.dtps_resume offset");
_Static_assert(offsetof(struct ks_dtrace_pops, dtps_getargdesc) == 0x30, "ks_dtrace_pops.dtps_getargdesc offset");
_Static_assert(offsetof(struct ks_dtrace_pops, dtps_getargval) == 0x38, "ks_dtrace_pops.dtps_getargval offset");
_Static_assert(offsetof(struct ks_dtrace_pops, dtps_usermode) == 0x40, "ks_dtrace_pops.dtps_usermode offset");
_Static_assert(offsetof(struct ks_dtrace_pops, dtps_destroy) == 0x48, "ks_dtrace_pops.dtps_destroy offset");
_Static_assert(sizeof(struct ks_dtrace_pops) == 0x50, "ks_dtrace_pops size");

/* refs: 2 */
struct ks_dtrace_ppriv {
    unsigned int dtpp_flags;
    unsigned int dtpp_uid;
    unsigned int dtpp_zoneid;
};
_Static_assert(offsetof(struct ks_dtrace_ppriv, dtpp_flags) == 0x0, "ks_dtrace_ppriv.dtpp_flags offset");
_Static_assert(offsetof(struct ks_dtrace_ppriv, dtpp_uid) == 0x4, "ks_dtrace_ppriv.dtpp_uid offset");
_Static_assert(offsetof(struct ks_dtrace_ppriv, dtpp_zoneid) == 0x8, "ks_dtrace_ppriv.dtpp_zoneid offset");
_Static_assert(sizeof(struct ks_dtrace_ppriv) == 0xC, "ks_dtrace_ppriv size");

/* refs: 2 */
struct ks_dtrace_predicate {
    struct ks_dtrace_difo *dtp_difo;
    unsigned int dtp_cacheid;
    int dtp_refcnt;
};
_Static_assert(offsetof(struct ks_dtrace_predicate, dtp_difo) == 0x0, "ks_dtrace_predicate.dtp_difo offset");
_Static_assert(offsetof(struct ks_dtrace_predicate, dtp_cacheid) == 0x8, "ks_dtrace_predicate.dtp_cacheid offset");
_Static_assert(offsetof(struct ks_dtrace_predicate, dtp_refcnt) == 0xC, "ks_dtrace_predicate.dtp_refcnt offset");
_Static_assert(sizeof(struct ks_dtrace_predicate) == 0x10, "ks_dtrace_predicate size");

/* refs: 2 */
struct ks_dtrace_probe {
    unsigned int dtpr_id;
    struct ks_dtrace_ecb *dtpr_ecb;
    struct ks_dtrace_ecb *dtpr_ecb_last;
    void *dtpr_arg;
    unsigned int dtpr_predcache;
    int dtpr_aframes;
    struct ks_dtrace_provider *dtpr_provider;
    char *dtpr_mod;
    char *dtpr_func;
    char *dtpr_name;
    struct ks_dtrace_probe *dtpr_nextprov;
    struct ks_dtrace_probe *dtpr_prevprov;
    struct ks_dtrace_probe *dtpr_nextmod;
    struct ks_dtrace_probe *dtpr_prevmod;
    struct ks_dtrace_probe *dtpr_nextfunc;
    struct ks_dtrace_probe *dtpr_prevfunc;
    struct ks_dtrace_probe *dtpr_nextname;
    struct ks_dtrace_probe *dtpr_prevname;
    unsigned long long dtpr_gen;
};
_Static_assert(offsetof(struct ks_dtrace_probe, dtpr_id) == 0x0, "ks_dtrace_probe.dtpr_id offset");
_Static_assert(offsetof(struct ks_dtrace_probe, dtpr_ecb) == 0x8, "ks_dtrace_probe.dtpr_ecb offset");
_Static_assert(offsetof(struct ks_dtrace_probe, dtpr_ecb_last) == 0x10, "ks_dtrace_probe.dtpr_ecb_last offset");
_Static_assert(offsetof(struct ks_dtrace_probe, dtpr_arg) == 0x18, "ks_dtrace_probe.dtpr_arg offset");
_Static_assert(offsetof(struct ks_dtrace_probe, dtpr_predcache) == 0x20, "ks_dtrace_probe.dtpr_predcache offset");
_Static_assert(offsetof(struct ks_dtrace_probe, dtpr_aframes) == 0x24, "ks_dtrace_probe.dtpr_aframes offset");
_Static_assert(offsetof(struct ks_dtrace_probe, dtpr_provider) == 0x28, "ks_dtrace_probe.dtpr_provider offset");
_Static_assert(offsetof(struct ks_dtrace_probe, dtpr_mod) == 0x30, "ks_dtrace_probe.dtpr_mod offset");
_Static_assert(offsetof(struct ks_dtrace_probe, dtpr_func) == 0x38, "ks_dtrace_probe.dtpr_func offset");
_Static_assert(offsetof(struct ks_dtrace_probe, dtpr_name) == 0x40, "ks_dtrace_probe.dtpr_name offset");
_Static_assert(offsetof(struct ks_dtrace_probe, dtpr_nextprov) == 0x48, "ks_dtrace_probe.dtpr_nextprov offset");
_Static_assert(offsetof(struct ks_dtrace_probe, dtpr_prevprov) == 0x50, "ks_dtrace_probe.dtpr_prevprov offset");
_Static_assert(offsetof(struct ks_dtrace_probe, dtpr_nextmod) == 0x58, "ks_dtrace_probe.dtpr_nextmod offset");
_Static_assert(offsetof(struct ks_dtrace_probe, dtpr_prevmod) == 0x60, "ks_dtrace_probe.dtpr_prevmod offset");
_Static_assert(offsetof(struct ks_dtrace_probe, dtpr_nextfunc) == 0x68, "ks_dtrace_probe.dtpr_nextfunc offset");
_Static_assert(offsetof(struct ks_dtrace_probe, dtpr_prevfunc) == 0x70, "ks_dtrace_probe.dtpr_prevfunc offset");
_Static_assert(offsetof(struct ks_dtrace_probe, dtpr_nextname) == 0x78, "ks_dtrace_probe.dtpr_nextname offset");
_Static_assert(offsetof(struct ks_dtrace_probe, dtpr_prevname) == 0x80, "ks_dtrace_probe.dtpr_prevname offset");
_Static_assert(offsetof(struct ks_dtrace_probe, dtpr_gen) == 0x88, "ks_dtrace_probe.dtpr_gen offset");
_Static_assert(sizeof(struct ks_dtrace_probe) == 0x90, "ks_dtrace_probe size");

/* refs: 2 */
struct ks_dtrace_provider {
    struct ks_dtrace_pattr dtpv_attr;
    struct ks_dtrace_ppriv dtpv_priv;
    struct ks_dtrace_pops dtpv_pops;
    char *dtpv_name;
    void *dtpv_arg;
    unsigned int dtpv_defunct;
    struct ks_dtrace_provider *dtpv_next;
    unsigned long long dtpv_probe_count;
    unsigned long long dtpv_ecb_count;
};
_Static_assert(offsetof(struct ks_dtrace_provider, dtpv_attr) == 0x0, "ks_dtrace_provider.dtpv_attr offset");
_Static_assert(offsetof(struct ks_dtrace_provider, dtpv_priv) == 0x10, "ks_dtrace_provider.dtpv_priv offset");
_Static_assert(offsetof(struct ks_dtrace_provider, dtpv_pops) == 0x20, "ks_dtrace_provider.dtpv_pops offset");
_Static_assert(offsetof(struct ks_dtrace_provider, dtpv_name) == 0x70, "ks_dtrace_provider.dtpv_name offset");
_Static_assert(offsetof(struct ks_dtrace_provider, dtpv_arg) == 0x78, "ks_dtrace_provider.dtpv_arg offset");
_Static_assert(offsetof(struct ks_dtrace_provider, dtpv_defunct) == 0x80, "ks_dtrace_provider.dtpv_defunct offset");
_Static_assert(offsetof(struct ks_dtrace_provider, dtpv_next) == 0x88, "ks_dtrace_provider.dtpv_next offset");
_Static_assert(offsetof(struct ks_dtrace_provider, dtpv_probe_count) == 0x90, "ks_dtrace_provider.dtpv_probe_count offset");
_Static_assert(offsetof(struct ks_dtrace_provider, dtpv_ecb_count) == 0x98, "ks_dtrace_provider.dtpv_ecb_count offset");
_Static_assert(sizeof(struct ks_dtrace_provider) == 0xA0, "ks_dtrace_provider size");

/* refs: 3 */
struct ks_dtrace_ptss_page_entry {
    struct ks_dtrace_ptss_page_entry *next;
    unsigned long long addr;
    unsigned long long write_addr;
};
_Static_assert(offsetof(struct ks_dtrace_ptss_page_entry, next) == 0x0, "ks_dtrace_ptss_page_entry.next offset");
_Static_assert(offsetof(struct ks_dtrace_ptss_page_entry, addr) == 0x8, "ks_dtrace_ptss_page_entry.addr offset");
_Static_assert(offsetof(struct ks_dtrace_ptss_page_entry, write_addr) == 0x10, "ks_dtrace_ptss_page_entry.write_addr offset");
_Static_assert(sizeof(struct ks_dtrace_ptss_page_entry) == 0x18, "ks_dtrace_ptss_page_entry size");

/* refs: 1 */
struct ks_dtrace_ptss_page {
    struct ks_dtrace_ptss_page *next;
    struct ks_dtrace_ptss_page_entry entries[0x100];
};
_Static_assert(offsetof(struct ks_dtrace_ptss_page, next) == 0x0, "ks_dtrace_ptss_page.next offset");
_Static_assert(offsetof(struct ks_dtrace_ptss_page, entries) == 0x8, "ks_dtrace_ptss_page.entries offset");
_Static_assert(sizeof(struct ks_dtrace_ptss_page) == 0x1808, "ks_dtrace_ptss_page size");

/* refs: 2 */
struct ks_dtrace_speculation {
    unsigned int dtsp_state;
    int dtsp_cleaning;
    struct ks_dtrace_buffer *dtsp_buffer;
};
_Static_assert(offsetof(struct ks_dtrace_speculation, dtsp_state) == 0x0, "ks_dtrace_speculation.dtsp_state offset");
_Static_assert(offsetof(struct ks_dtrace_speculation, dtsp_cleaning) == 0x4, "ks_dtrace_speculation.dtsp_cleaning offset");
_Static_assert(offsetof(struct ks_dtrace_speculation, dtsp_buffer) == 0x8, "ks_dtrace_speculation.dtsp_buffer offset");
_Static_assert(sizeof(struct ks_dtrace_speculation) == 0x10, "ks_dtrace_speculation size");

/* refs: 3 */
struct ks_dtrace_state {
    int dts_dev;
    int dts_necbs;
    struct ks_dtrace_ecb **dts_ecbs;
    unsigned int dts_epid;
    unsigned long dts_needed;
    struct ks_dtrace_state *dts_anon;
    unsigned int dts_activity;
    struct ks_dtrace_vstate dts_vstate;
    struct ks_dtrace_buffer *dts_buffer;
    struct ks_dtrace_buffer *dts_aggbuffer;
    struct ks_dtrace_speculation *dts_speculations;
    int dts_nspeculations;
    int dts_naggregations;
    struct ks_dtrace_aggregation **dts_aggregations;
    struct ks_vmem *dts_aggid_arena;
    unsigned long long dts_errors;
    unsigned int dts_speculations_busy;
    unsigned int dts_speculations_unavail;
    unsigned int dts_stkstroverflows;
    unsigned int dts_dblerrors;
    unsigned int dts_reserve;
    long long dts_laststatus;
    unsigned long dts_cleaner;
    unsigned long dts_deadman;
    long long dts_alive;
    char dts_speculates;
    char dts_destructive;
    int dts_nformats;
    struct ks_dtrace_format **dts_formats;
    long long dts_options[0x21];
    struct ks_dtrace_cred dts_cred;
    unsigned long dts_nretained;
    unsigned long long dts_arg_error_illval;
    unsigned int dts_buf_over_limit;
    unsigned long long **dts_rstate;
};
_Static_assert(offsetof(struct ks_dtrace_state, dts_dev) == 0x0, "ks_dtrace_state.dts_dev offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_necbs) == 0x4, "ks_dtrace_state.dts_necbs offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_ecbs) == 0x8, "ks_dtrace_state.dts_ecbs offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_epid) == 0x10, "ks_dtrace_state.dts_epid offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_needed) == 0x18, "ks_dtrace_state.dts_needed offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_anon) == 0x20, "ks_dtrace_state.dts_anon offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_activity) == 0x28, "ks_dtrace_state.dts_activity offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_vstate) == 0x30, "ks_dtrace_state.dts_vstate offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_buffer) == 0xA0, "ks_dtrace_state.dts_buffer offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_aggbuffer) == 0xA8, "ks_dtrace_state.dts_aggbuffer offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_speculations) == 0xB0, "ks_dtrace_state.dts_speculations offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_nspeculations) == 0xB8, "ks_dtrace_state.dts_nspeculations offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_naggregations) == 0xBC, "ks_dtrace_state.dts_naggregations offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_aggregations) == 0xC0, "ks_dtrace_state.dts_aggregations offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_aggid_arena) == 0xC8, "ks_dtrace_state.dts_aggid_arena offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_errors) == 0xD0, "ks_dtrace_state.dts_errors offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_speculations_busy) == 0xD8, "ks_dtrace_state.dts_speculations_busy offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_speculations_unavail) == 0xDC, "ks_dtrace_state.dts_speculations_unavail offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_stkstroverflows) == 0xE0, "ks_dtrace_state.dts_stkstroverflows offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_dblerrors) == 0xE4, "ks_dtrace_state.dts_dblerrors offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_reserve) == 0xE8, "ks_dtrace_state.dts_reserve offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_laststatus) == 0xF0, "ks_dtrace_state.dts_laststatus offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_cleaner) == 0xF8, "ks_dtrace_state.dts_cleaner offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_deadman) == 0x100, "ks_dtrace_state.dts_deadman offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_alive) == 0x108, "ks_dtrace_state.dts_alive offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_speculates) == 0x110, "ks_dtrace_state.dts_speculates offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_destructive) == 0x111, "ks_dtrace_state.dts_destructive offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_nformats) == 0x114, "ks_dtrace_state.dts_nformats offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_formats) == 0x118, "ks_dtrace_state.dts_formats offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_options) == 0x120, "ks_dtrace_state.dts_options offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_cred) == 0x228, "ks_dtrace_state.dts_cred offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_nretained) == 0x238, "ks_dtrace_state.dts_nretained offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_arg_error_illval) == 0x240, "ks_dtrace_state.dts_arg_error_illval offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_buf_over_limit) == 0x248, "ks_dtrace_state.dts_buf_over_limit offset");
_Static_assert(offsetof(struct ks_dtrace_state, dts_rstate) == 0x250, "ks_dtrace_state.dts_rstate offset");
_Static_assert(sizeof(struct ks_dtrace_state) == 0x258, "ks_dtrace_state size");

/* refs: 3 */
struct ks_dtrace_statvar {
    unsigned long long dtsv_data;
    unsigned long dtsv_size;
    int dtsv_refcnt;
    struct ks_dtrace_difv dtsv_var;
};
_Static_assert(offsetof(struct ks_dtrace_statvar, dtsv_data) == 0x0, "ks_dtrace_statvar.dtsv_data offset");
_Static_assert(offsetof(struct ks_dtrace_statvar, dtsv_size) == 0x8, "ks_dtrace_statvar.dtsv_size offset");
_Static_assert(offsetof(struct ks_dtrace_statvar, dtsv_refcnt) == 0x10, "ks_dtrace_statvar.dtsv_refcnt offset");
_Static_assert(offsetof(struct ks_dtrace_statvar, dtsv_var) == 0x14, "ks_dtrace_statvar.dtsv_var offset");
_Static_assert(sizeof(struct ks_dtrace_statvar) == 0x28, "ks_dtrace_statvar size");

/* refs: 1 */
struct ks_duplication {
    unsigned int duplication_p;
};
_Static_assert(offsetof(struct ks_duplication, duplication_p) == 0x0, "ks_duplication.duplication_p offset");
_Static_assert(sizeof(struct ks_duplication) == 0x4, "ks_duplication size");

/* refs: 1 */
struct ks_dyld_uuid_info_64 {
    unsigned long long imageLoadAddress;
    unsigned char imageUUID[0x10];
};
_Static_assert(offsetof(struct ks_dyld_uuid_info_64, imageLoadAddress) == 0x0, "ks_dyld_uuid_info_64.imageLoadAddress offset");
_Static_assert(offsetof(struct ks_dyld_uuid_info_64, imageUUID) == 0x8, "ks_dyld_uuid_info_64.imageUUID offset");
_Static_assert(sizeof(struct ks_dyld_uuid_info_64) == 0x18, "ks_dyld_uuid_info_64 size");

/* refs: 1 */
struct ks_entry_template {
    char et_key[0x20];
    char et_group[0x20];
    char et_units[0x20];
    unsigned int et_flags;
    unsigned short et_size;
    unsigned short et_offset;
    struct ks_ledger_callback *et_callback;
};
_Static_assert(offsetof(struct ks_entry_template, et_key) == 0x0, "ks_entry_template.et_key offset");
_Static_assert(offsetof(struct ks_entry_template, et_group) == 0x20, "ks_entry_template.et_group offset");
_Static_assert(offsetof(struct ks_entry_template, et_units) == 0x40, "ks_entry_template.et_units offset");
_Static_assert(offsetof(struct ks_entry_template, et_flags) == 0x60, "ks_entry_template.et_flags offset");
_Static_assert(offsetof(struct ks_entry_template, et_size) == 0x64, "ks_entry_template.et_size offset");
_Static_assert(offsetof(struct ks_entry_template, et_offset) == 0x66, "ks_entry_template.et_offset offset");
_Static_assert(offsetof(struct ks_entry_template, et_callback) == 0x68, "ks_entry_template.et_callback offset");
_Static_assert(sizeof(struct ks_entry_template) == 0x70, "ks_entry_template size");

/* refs: 1 */
struct ks_eventhandler_entry_arg {
    unsigned char ee_fm_uuid[0x10];
    unsigned char ee_fr_uuid[0x10];
};
_Static_assert(offsetof(struct ks_eventhandler_entry_arg, ee_fm_uuid) == 0x0, "ks_eventhandler_entry_arg.ee_fm_uuid offset");
_Static_assert(offsetof(struct ks_eventhandler_entry_arg, ee_fr_uuid) == 0x10, "ks_eventhandler_entry_arg.ee_fr_uuid offset");
_Static_assert(sizeof(struct ks_eventhandler_entry_arg) == 0x20, "ks_eventhandler_entry_arg size");

/* refs: 4 */
struct ks_eventhandler_entry {
    struct {
        struct ks_eventhandler_entry *tqe_next;
        struct ks_eventhandler_entry **tqe_prev;
    } ee_link;
    int ee_priority;
    struct ks_eventhandler_entry_arg ee_arg;
};
_Static_assert(offsetof(struct ks_eventhandler_entry, ee_link) == 0x0, "ks_eventhandler_entry.ee_link offset");
_Static_assert(offsetof(struct ks_eventhandler_entry, ee_priority) == 0x10, "ks_eventhandler_entry.ee_priority offset");
_Static_assert(offsetof(struct ks_eventhandler_entry, ee_arg) == 0x14, "ks_eventhandler_entry.ee_arg offset");
_Static_assert(sizeof(struct ks_eventhandler_entry) == 0x38, "ks_eventhandler_entry size");

/* refs: 4 */
struct ks_eventhandler_list {
    char el_name[0x20];
    int el_flags;
    unsigned int el_runcount;
    struct ks_lck_mtx_s el_lock;
    struct {
        struct ks_eventhandler_list *tqe_next;
        struct ks_eventhandler_list **tqe_prev;
    } el_link;
    struct {
        struct ks_eventhandler_entry *tqh_first;
        struct ks_eventhandler_entry **tqh_last;
    } el_entries;
};
_Static_assert(offsetof(struct ks_eventhandler_list, el_name) == 0x0, "ks_eventhandler_list.el_name offset");
_Static_assert(offsetof(struct ks_eventhandler_list, el_flags) == 0x20, "ks_eventhandler_list.el_flags offset");
_Static_assert(offsetof(struct ks_eventhandler_list, el_runcount) == 0x24, "ks_eventhandler_list.el_runcount offset");
_Static_assert(offsetof(struct ks_eventhandler_list, el_lock) == 0x28, "ks_eventhandler_list.el_lock offset");
_Static_assert(offsetof(struct ks_eventhandler_list, el_link) == 0x38, "ks_eventhandler_list.el_link offset");
_Static_assert(offsetof(struct ks_eventhandler_list, el_entries) == 0x48, "ks_eventhandler_list.el_entries offset");
_Static_assert(sizeof(struct ks_eventhandler_list) == 0x58, "ks_eventhandler_list size");

/* refs: 1 */
struct ks_eventhandler_lists_ctxt {
    struct {
        struct ks_eventhandler_list *tqh_first;
        struct ks_eventhandler_list **tqh_last;
    } eventhandler_lists;
    int eventhandler_lists_initted;
    struct ks_lck_mtx_s eventhandler_mutex;
};
_Static_assert(offsetof(struct ks_eventhandler_lists_ctxt, eventhandler_lists) == 0x0, "ks_eventhandler_lists_ctxt.eventhandler_lists offset");
_Static_assert(offsetof(struct ks_eventhandler_lists_ctxt, eventhandler_lists_initted) == 0x10, "ks_eventhandler_lists_ctxt.eventhandler_lists_initted offset");
_Static_assert(offsetof(struct ks_eventhandler_lists_ctxt, eventhandler_mutex) == 0x18, "ks_eventhandler_lists_ctxt.eventhandler_mutex offset");
_Static_assert(sizeof(struct ks_eventhandler_lists_ctxt) == 0x28, "ks_eventhandler_lists_ctxt size");

/* refs: 2 */
struct ks_exception_action {
    struct ks_ipc_port *port;
    int flavor;
    int behavior;
    int privileged;
    int hardened;
    struct ks_label *label;
};
_Static_assert(offsetof(struct ks_exception_action, port) == 0x0, "ks_exception_action.port offset");
_Static_assert(offsetof(struct ks_exception_action, flavor) == 0x8, "ks_exception_action.flavor offset");
_Static_assert(offsetof(struct ks_exception_action, behavior) == 0xC, "ks_exception_action.behavior offset");
_Static_assert(offsetof(struct ks_exception_action, privileged) == 0x10, "ks_exception_action.privileged offset");
_Static_assert(offsetof(struct ks_exception_action, hardened) == 0x14, "ks_exception_action.hardened offset");
_Static_assert(offsetof(struct ks_exception_action, label) == 0x18, "ks_exception_action.label offset");
_Static_assert(sizeof(struct ks_exception_action) == 0x20, "ks_exception_action size");

/* refs: 1 */
struct ks_ext_ref {
    struct ks_mbuf *paired;
    unsigned short minref;
    unsigned short refcnt;
    unsigned short prefcnt;
    unsigned short flags;
    unsigned int priv;
};
_Static_assert(offsetof(struct ks_ext_ref, paired) == 0x0, "ks_ext_ref.paired offset");
_Static_assert(offsetof(struct ks_ext_ref, minref) == 0x8, "ks_ext_ref.minref offset");
_Static_assert(offsetof(struct ks_ext_ref, refcnt) == 0xA, "ks_ext_ref.refcnt offset");
_Static_assert(offsetof(struct ks_ext_ref, prefcnt) == 0xC, "ks_ext_ref.prefcnt offset");
_Static_assert(offsetof(struct ks_ext_ref, flags) == 0xE, "ks_ext_ref.flags offset");
_Static_assert(offsetof(struct ks_ext_ref, priv) == 0x10, "ks_ext_ref.priv offset");
_Static_assert(sizeof(struct ks_ext_ref) == 0x18, "ks_ext_ref size");

/* refs: 1 */
struct ks_fd_pcb_tree {
    struct ks_flow_divert_pcb *rbh_root;
};
_Static_assert(offsetof(struct ks_fd_pcb_tree, rbh_root) == 0x0, "ks_fd_pcb_tree.rbh_root offset");
_Static_assert(sizeof(struct ks_fd_pcb_tree) == 0x8, "ks_fd_pcb_tree size");

/* refs: 1 */
struct ks_fd_vn_data {
    struct ks_lck_mtx_s fv_lock;
    long long fv_offset;
    void *fv_dircookie;
    char *fv_buf;
    unsigned long fv_bufsiz;
    unsigned long fv_bufdone;
    unsigned long fv_bufallocsiz;
    long long fv_soff;
    long long fv_eoff;
    int fv_eofflag;
};
_Static_assert(offsetof(struct ks_fd_vn_data, fv_lock) == 0x0, "ks_fd_vn_data.fv_lock offset");
_Static_assert(offsetof(struct ks_fd_vn_data, fv_offset) == 0x10, "ks_fd_vn_data.fv_offset offset");
_Static_assert(offsetof(struct ks_fd_vn_data, fv_dircookie) == 0x18, "ks_fd_vn_data.fv_dircookie offset");
_Static_assert(offsetof(struct ks_fd_vn_data, fv_buf) == 0x20, "ks_fd_vn_data.fv_buf offset");
_Static_assert(offsetof(struct ks_fd_vn_data, fv_bufsiz) == 0x28, "ks_fd_vn_data.fv_bufsiz offset");
_Static_assert(offsetof(struct ks_fd_vn_data, fv_bufdone) == 0x30, "ks_fd_vn_data.fv_bufdone offset");
_Static_assert(offsetof(struct ks_fd_vn_data, fv_bufallocsiz) == 0x38, "ks_fd_vn_data.fv_bufallocsiz offset");
_Static_assert(offsetof(struct ks_fd_vn_data, fv_soff) == 0x40, "ks_fd_vn_data.fv_soff offset");
_Static_assert(offsetof(struct ks_fd_vn_data, fv_eoff) == 0x48, "ks_fd_vn_data.fv_eoff offset");
_Static_assert(offsetof(struct ks_fd_vn_data, fv_eofflag) == 0x50, "ks_fd_vn_data.fv_eofflag offset");
_Static_assert(sizeof(struct ks_fd_vn_data) == 0x58, "ks_fd_vn_data size");

/* refs: 1 */
struct ks_fifoinfo {
    unsigned int fi_flags;
    struct ks_socket *fi_readsock;
    struct ks_socket *fi_writesock;
    long fi_readers;
    long fi_writers;
    unsigned int fi_count;
};
_Static_assert(offsetof(struct ks_fifoinfo, fi_flags) == 0x0, "ks_fifoinfo.fi_flags offset");
_Static_assert(offsetof(struct ks_fifoinfo, fi_readsock) == 0x8, "ks_fifoinfo.fi_readsock offset");
_Static_assert(offsetof(struct ks_fifoinfo, fi_writesock) == 0x10, "ks_fifoinfo.fi_writesock offset");
_Static_assert(offsetof(struct ks_fifoinfo, fi_readers) == 0x18, "ks_fifoinfo.fi_readers offset");
_Static_assert(offsetof(struct ks_fifoinfo, fi_writers) == 0x20, "ks_fifoinfo.fi_writers offset");
_Static_assert(offsetof(struct ks_fifoinfo, fi_count) == 0x28, "ks_fifoinfo.fi_count offset");
_Static_assert(sizeof(struct ks_fifoinfo) == 0x30, "ks_fifoinfo size");

/* refs: 3 */
struct ks_file_lease {
    struct {
        struct ks_file_lease *le_next;
        struct ks_file_lease **le_prev;
    } fl_link;
    struct ks_fileglob *fl_fg;
    int fl_pid;
    int fl_type;
    unsigned int fl_flags;
    unsigned long long fl_release_start;
    unsigned long long fl_downgrade_start;
};
_Static_assert(offsetof(struct ks_file_lease, fl_link) == 0x0, "ks_file_lease.fl_link offset");
_Static_assert(offsetof(struct ks_file_lease, fl_fg) == 0x10, "ks_file_lease.fl_fg offset");
_Static_assert(offsetof(struct ks_file_lease, fl_pid) == 0x18, "ks_file_lease.fl_pid offset");
_Static_assert(offsetof(struct ks_file_lease, fl_type) == 0x1C, "ks_file_lease.fl_type offset");
_Static_assert(offsetof(struct ks_file_lease, fl_flags) == 0x20, "ks_file_lease.fl_flags offset");
_Static_assert(offsetof(struct ks_file_lease, fl_release_start) == 0x28, "ks_file_lease.fl_release_start offset");
_Static_assert(offsetof(struct ks_file_lease, fl_downgrade_start) == 0x30, "ks_file_lease.fl_downgrade_start offset");
_Static_assert(sizeof(struct ks_file_lease) == 0x38, "ks_file_lease size");

/* refs: 1 */
struct ks_filedesc {
    struct ks_lck_mtx_s fd_lock;
    unsigned char fd_fpdrainwait;
    unsigned char fd_flags;
    unsigned short fd_cmask;
    int fd_nfiles;
    int fd_afterlast;
    int fd_freefile;
    int fd_knlistsize;
    int unused_padding;
    struct ks_fileproc **fd_ofiles;
    char *fd_ofileflags;
    struct ks_klist *fd_knlist;
    struct ks_kqworkq *fd_wqkqueue;
    struct ks_vnode *fd_cdir;
    struct ks_vnode *fd_rdir;
    struct ks_lck_rw_s fd_dirs_lock;
    struct ks_lck_mtx_s fd_kqhashlock;
    unsigned long fd_kqhashmask;
    struct ks_kqwllist *fd_kqhash;
    struct ks_lck_mtx_s fd_knhashlock;
    unsigned long fd_knhashmask;
    struct ks_klist *fd_knhash;
};
_Static_assert(offsetof(struct ks_filedesc, fd_lock) == 0x0, "ks_filedesc.fd_lock offset");
_Static_assert(offsetof(struct ks_filedesc, fd_fpdrainwait) == 0x10, "ks_filedesc.fd_fpdrainwait offset");
_Static_assert(offsetof(struct ks_filedesc, fd_flags) == 0x11, "ks_filedesc.fd_flags offset");
_Static_assert(offsetof(struct ks_filedesc, fd_cmask) == 0x12, "ks_filedesc.fd_cmask offset");
_Static_assert(offsetof(struct ks_filedesc, fd_nfiles) == 0x14, "ks_filedesc.fd_nfiles offset");
_Static_assert(offsetof(struct ks_filedesc, fd_afterlast) == 0x18, "ks_filedesc.fd_afterlast offset");
_Static_assert(offsetof(struct ks_filedesc, fd_freefile) == 0x1C, "ks_filedesc.fd_freefile offset");
_Static_assert(offsetof(struct ks_filedesc, fd_knlistsize) == 0x20, "ks_filedesc.fd_knlistsize offset");
_Static_assert(offsetof(struct ks_filedesc, unused_padding) == 0x24, "ks_filedesc.unused_padding offset");
_Static_assert(offsetof(struct ks_filedesc, fd_ofiles) == 0x28, "ks_filedesc.fd_ofiles offset");
_Static_assert(offsetof(struct ks_filedesc, fd_ofileflags) == 0x30, "ks_filedesc.fd_ofileflags offset");
_Static_assert(offsetof(struct ks_filedesc, fd_knlist) == 0x38, "ks_filedesc.fd_knlist offset");
_Static_assert(offsetof(struct ks_filedesc, fd_wqkqueue) == 0x40, "ks_filedesc.fd_wqkqueue offset");
_Static_assert(offsetof(struct ks_filedesc, fd_cdir) == 0x48, "ks_filedesc.fd_cdir offset");
_Static_assert(offsetof(struct ks_filedesc, fd_rdir) == 0x50, "ks_filedesc.fd_rdir offset");
_Static_assert(offsetof(struct ks_filedesc, fd_dirs_lock) == 0x58, "ks_filedesc.fd_dirs_lock offset");
_Static_assert(offsetof(struct ks_filedesc, fd_kqhashlock) == 0x68, "ks_filedesc.fd_kqhashlock offset");
_Static_assert(offsetof(struct ks_filedesc, fd_kqhashmask) == 0x78, "ks_filedesc.fd_kqhashmask offset");
_Static_assert(offsetof(struct ks_filedesc, fd_kqhash) == 0x80, "ks_filedesc.fd_kqhash offset");
_Static_assert(offsetof(struct ks_filedesc, fd_knhashlock) == 0x88, "ks_filedesc.fd_knhashlock offset");
_Static_assert(offsetof(struct ks_filedesc, fd_knhashmask) == 0x98, "ks_filedesc.fd_knhashmask offset");
_Static_assert(offsetof(struct ks_filedesc, fd_knhash) == 0xA0, "ks_filedesc.fd_knhash offset");
_Static_assert(sizeof(struct ks_filedesc) == 0xA8, "ks_filedesc size");

/* refs: 4 */
struct ks_fileglob {
    struct {
        struct ks_fileglob *le_next;
        struct ks_fileglob **le_prev;
    } f_msglist;
    unsigned int fg_flag;
    unsigned int fg_count;
    unsigned int fg_msgcount;
    int fg_lflags;
    struct ks_ucred *fg_cred;
    const struct ks_fileops *fg_ops;
    long long fg_offset;
    unsigned long fg_data;
    struct ks_fd_vn_data *fg_vn_data;
    struct ks_lck_mtx_s fg_lock;
};
_Static_assert(offsetof(struct ks_fileglob, f_msglist) == 0x0, "ks_fileglob.f_msglist offset");
_Static_assert(offsetof(struct ks_fileglob, fg_flag) == 0x10, "ks_fileglob.fg_flag offset");
_Static_assert(offsetof(struct ks_fileglob, fg_count) == 0x14, "ks_fileglob.fg_count offset");
_Static_assert(offsetof(struct ks_fileglob, fg_msgcount) == 0x18, "ks_fileglob.fg_msgcount offset");
_Static_assert(offsetof(struct ks_fileglob, fg_lflags) == 0x1C, "ks_fileglob.fg_lflags offset");
_Static_assert(offsetof(struct ks_fileglob, fg_cred) == 0x20, "ks_fileglob.fg_cred offset");
_Static_assert(offsetof(struct ks_fileglob, fg_ops) == 0x28, "ks_fileglob.fg_ops offset");
_Static_assert(offsetof(struct ks_fileglob, fg_offset) == 0x30, "ks_fileglob.fg_offset offset");
_Static_assert(offsetof(struct ks_fileglob, fg_data) == 0x38, "ks_fileglob.fg_data offset");
_Static_assert(offsetof(struct ks_fileglob, fg_vn_data) == 0x40, "ks_fileglob.fg_vn_data offset");
_Static_assert(offsetof(struct ks_fileglob, fg_lock) == 0x48, "ks_fileglob.fg_lock offset");
_Static_assert(sizeof(struct ks_fileglob) == 0x58, "ks_fileglob size");

/* refs: 1 */
struct ks_fileops {
    unsigned int fo_type;
    int *fo_read;
    int *fo_write;
    int *fo_ioctl;
    int *fo_select;
    int *fo_close;
    int *fo_kqfilter;
    int *fo_drain;
};
_Static_assert(offsetof(struct ks_fileops, fo_type) == 0x0, "ks_fileops.fo_type offset");
_Static_assert(offsetof(struct ks_fileops, fo_read) == 0x8, "ks_fileops.fo_read offset");
_Static_assert(offsetof(struct ks_fileops, fo_write) == 0x10, "ks_fileops.fo_write offset");
_Static_assert(offsetof(struct ks_fileops, fo_ioctl) == 0x18, "ks_fileops.fo_ioctl offset");
_Static_assert(offsetof(struct ks_fileops, fo_select) == 0x20, "ks_fileops.fo_select offset");
_Static_assert(offsetof(struct ks_fileops, fo_close) == 0x28, "ks_fileops.fo_close offset");
_Static_assert(offsetof(struct ks_fileops, fo_kqfilter) == 0x30, "ks_fileops.fo_kqfilter offset");
_Static_assert(offsetof(struct ks_fileops, fo_drain) == 0x38, "ks_fileops.fo_drain offset");
_Static_assert(sizeof(struct ks_fileops) == 0x40, "ks_fileops size");

/* refs: 3 */
struct ks_fileproc {
    struct ks_os_refcnt fp_iocount;
    unsigned int fp_vflags;
    unsigned short fp_flags;
    unsigned short fp_guard_attrs;
    struct ks_fileglob *fp_glob;
    union {
        struct ks_select_set *fp_wset;
        struct ks_fileproc_guard *fp_guard;
    };
};
_Static_assert(offsetof(struct ks_fileproc, fp_iocount) == 0x0, "ks_fileproc.fp_iocount offset");
_Static_assert(offsetof(struct ks_fileproc, fp_vflags) == 0x4, "ks_fileproc.fp_vflags offset");
_Static_assert(offsetof(struct ks_fileproc, fp_flags) == 0x8, "ks_fileproc.fp_flags offset");
_Static_assert(offsetof(struct ks_fileproc, fp_guard_attrs) == 0xA, "ks_fileproc.fp_guard_attrs offset");
_Static_assert(offsetof(struct ks_fileproc, fp_glob) == 0x10, "ks_fileproc.fp_glob offset");
_Static_assert(sizeof(struct ks_fileproc) == 0x20, "ks_fileproc size");

/* refs: 1 */
struct ks_fileproc_guard {
    struct ks_select_set *fpg_wset;
    unsigned long long fpg_guard;
};
_Static_assert(offsetof(struct ks_fileproc_guard, fpg_wset) == 0x0, "ks_fileproc_guard.fpg_wset offset");
_Static_assert(offsetof(struct ks_fileproc_guard, fpg_guard) == 0x8, "ks_fileproc_guard.fpg_guard offset");
_Static_assert(sizeof(struct ks_fileproc_guard) == 0x10, "ks_fileproc_guard size");

/* refs: 1 */
struct ks_fl_head {
    struct ks_file_lease *lh_first;
};
_Static_assert(offsetof(struct ks_fl_head, lh_first) == 0x0, "ks_fl_head.lh_first offset");
_Static_assert(sizeof(struct ks_fl_head) == 0x8, "ks_fl_head size");

/* refs: 1 */
struct ks_flow_divert_trie {
    struct ks_flow_divert_trie_node *nodes;
    unsigned short *child_maps;
    unsigned char *bytes;
    void *memory;
    unsigned short nodes_count;
    unsigned short child_maps_count;
    unsigned short bytes_count;
    unsigned short nodes_free_next;
    unsigned short child_maps_free_next;
    unsigned short bytes_free_next;
    unsigned short root;
    unsigned long memory_size;
    unsigned long child_maps_size;
};
_Static_assert(offsetof(struct ks_flow_divert_trie, nodes) == 0x0, "ks_flow_divert_trie.nodes offset");
_Static_assert(offsetof(struct ks_flow_divert_trie, child_maps) == 0x8, "ks_flow_divert_trie.child_maps offset");
_Static_assert(offsetof(struct ks_flow_divert_trie, bytes) == 0x10, "ks_flow_divert_trie.bytes offset");
_Static_assert(offsetof(struct ks_flow_divert_trie, memory) == 0x18, "ks_flow_divert_trie.memory offset");
_Static_assert(offsetof(struct ks_flow_divert_trie, nodes_count) == 0x20, "ks_flow_divert_trie.nodes_count offset");
_Static_assert(offsetof(struct ks_flow_divert_trie, child_maps_count) == 0x22, "ks_flow_divert_trie.child_maps_count offset");
_Static_assert(offsetof(struct ks_flow_divert_trie, bytes_count) == 0x24, "ks_flow_divert_trie.bytes_count offset");
_Static_assert(offsetof(struct ks_flow_divert_trie, nodes_free_next) == 0x26, "ks_flow_divert_trie.nodes_free_next offset");
_Static_assert(offsetof(struct ks_flow_divert_trie, child_maps_free_next) == 0x28, "ks_flow_divert_trie.child_maps_free_next offset");
_Static_assert(offsetof(struct ks_flow_divert_trie, bytes_free_next) == 0x2A, "ks_flow_divert_trie.bytes_free_next offset");
_Static_assert(offsetof(struct ks_flow_divert_trie, root) == 0x2C, "ks_flow_divert_trie.root offset");
_Static_assert(offsetof(struct ks_flow_divert_trie, memory_size) == 0x30, "ks_flow_divert_trie.memory_size offset");
_Static_assert(offsetof(struct ks_flow_divert_trie, child_maps_size) == 0x38, "ks_flow_divert_trie.child_maps_size offset");
_Static_assert(sizeof(struct ks_flow_divert_trie) == 0x40, "ks_flow_divert_trie size");

/* refs: 1 */
struct ks_send_queue_head {
    struct ks_mbuf *mq_first;
    struct ks_mbuf **mq_last;
};
_Static_assert(offsetof(struct ks_send_queue_head, mq_first) == 0x0, "ks_send_queue_head.mq_first offset");
_Static_assert(offsetof(struct ks_send_queue_head, mq_last) == 0x8, "ks_send_queue_head.mq_last offset");
_Static_assert(sizeof(struct ks_send_queue_head) == 0x10, "ks_send_queue_head size");

/* refs: 3 */
struct ks_flow_divert_group {
    struct ks_lck_rw_s lck;
    struct {
        struct ks_flow_divert_group *tqe_next;
        struct ks_flow_divert_group **tqe_prev;
    } chain;
    struct ks_fd_pcb_tree pcb_tree;
    unsigned int ctl_unit;
    unsigned char atomic_bits;
    struct ks_send_queue_head send_queue;
    unsigned char *token_key;
    unsigned long token_key_size;
    unsigned int flags;
    struct ks_flow_divert_trie signing_id_trie;
    int ref_count;
    int in_process_pid;
    int order;
};
_Static_assert(offsetof(struct ks_flow_divert_group, lck) == 0x0, "ks_flow_divert_group.lck offset");
_Static_assert(offsetof(struct ks_flow_divert_group, chain) == 0x10, "ks_flow_divert_group.chain offset");
_Static_assert(offsetof(struct ks_flow_divert_group, pcb_tree) == 0x20, "ks_flow_divert_group.pcb_tree offset");
_Static_assert(offsetof(struct ks_flow_divert_group, ctl_unit) == 0x28, "ks_flow_divert_group.ctl_unit offset");
_Static_assert(offsetof(struct ks_flow_divert_group, atomic_bits) == 0x2C, "ks_flow_divert_group.atomic_bits offset");
_Static_assert(offsetof(struct ks_flow_divert_group, send_queue) == 0x30, "ks_flow_divert_group.send_queue offset");
_Static_assert(offsetof(struct ks_flow_divert_group, token_key) == 0x40, "ks_flow_divert_group.token_key offset");
_Static_assert(offsetof(struct ks_flow_divert_group, token_key_size) == 0x48, "ks_flow_divert_group.token_key_size offset");
_Static_assert(offsetof(struct ks_flow_divert_group, flags) == 0x50, "ks_flow_divert_group.flags offset");
_Static_assert(offsetof(struct ks_flow_divert_group, signing_id_trie) == 0x58, "ks_flow_divert_group.signing_id_trie offset");
_Static_assert(offsetof(struct ks_flow_divert_group, ref_count) == 0x98, "ks_flow_divert_group.ref_count offset");
_Static_assert(offsetof(struct ks_flow_divert_group, in_process_pid) == 0x9C, "ks_flow_divert_group.in_process_pid offset");
_Static_assert(offsetof(struct ks_flow_divert_group, order) == 0xA0, "ks_flow_divert_group.order offset");
_Static_assert(sizeof(struct ks_flow_divert_group) == 0xA8, "ks_flow_divert_group size");

/* refs: 6 */
struct ks_flow_divert_pcb {
    struct ks_lck_mtx_s mtx;
    struct ks_socket *so;
    struct {
        struct ks_flow_divert_pcb *rbe_left;
        struct ks_flow_divert_pcb *rbe_right;
        struct ks_flow_divert_pcb *rbe_parent;
    } rb_link;
    unsigned int hash;
    struct ks_mbuf *connect_token;
    unsigned int flags;
    unsigned int send_window;
    struct ks_flow_divert_group *group;
    unsigned int control_group_unit;
    unsigned int aggregate_unit;
    unsigned int policy_control_unit;
    int ref_count;
    unsigned long long bytes_written_by_app;
    unsigned long long bytes_sent;
    unsigned long long bytes_received;
    unsigned char log_level;
    struct {
        struct ks_flow_divert_pcb *sle_next;
    } tmp_list_entry;
    struct ks_mbuf *connect_packet;
    unsigned char *app_data;
    unsigned long app_data_length;
    union ks_sockaddr_in_4_6 local_endpoint;
    struct ks_sockaddr *original_remote_endpoint;
    struct ks_ifnet *original_last_outifp6;
    struct ks_ifnet *original_last_outifp;
    unsigned char original_vflag;
    _Bool plugin_locked;
};
_Static_assert(offsetof(struct ks_flow_divert_pcb, mtx) == 0x0, "ks_flow_divert_pcb.mtx offset");
_Static_assert(offsetof(struct ks_flow_divert_pcb, so) == 0x10, "ks_flow_divert_pcb.so offset");
_Static_assert(offsetof(struct ks_flow_divert_pcb, rb_link) == 0x18, "ks_flow_divert_pcb.rb_link offset");
_Static_assert(offsetof(struct ks_flow_divert_pcb, hash) == 0x30, "ks_flow_divert_pcb.hash offset");
_Static_assert(offsetof(struct ks_flow_divert_pcb, connect_token) == 0x38, "ks_flow_divert_pcb.connect_token offset");
_Static_assert(offsetof(struct ks_flow_divert_pcb, flags) == 0x40, "ks_flow_divert_pcb.flags offset");
_Static_assert(offsetof(struct ks_flow_divert_pcb, send_window) == 0x44, "ks_flow_divert_pcb.send_window offset");
_Static_assert(offsetof(struct ks_flow_divert_pcb, group) == 0x48, "ks_flow_divert_pcb.group offset");
_Static_assert(offsetof(struct ks_flow_divert_pcb, control_group_unit) == 0x50, "ks_flow_divert_pcb.control_group_unit offset");
_Static_assert(offsetof(struct ks_flow_divert_pcb, aggregate_unit) == 0x54, "ks_flow_divert_pcb.aggregate_unit offset");
_Static_assert(offsetof(struct ks_flow_divert_pcb, policy_control_unit) == 0x58, "ks_flow_divert_pcb.policy_control_unit offset");
_Static_assert(offsetof(struct ks_flow_divert_pcb, ref_count) == 0x5C, "ks_flow_divert_pcb.ref_count offset");
_Static_assert(offsetof(struct ks_flow_divert_pcb, bytes_written_by_app) == 0x60, "ks_flow_divert_pcb.bytes_written_by_app offset");
_Static_assert(offsetof(struct ks_flow_divert_pcb, bytes_sent) == 0x68, "ks_flow_divert_pcb.bytes_sent offset");
_Static_assert(offsetof(struct ks_flow_divert_pcb, bytes_received) == 0x70, "ks_flow_divert_pcb.bytes_received offset");
_Static_assert(offsetof(struct ks_flow_divert_pcb, log_level) == 0x78, "ks_flow_divert_pcb.log_level offset");
_Static_assert(offsetof(struct ks_flow_divert_pcb, tmp_list_entry) == 0x80, "ks_flow_divert_pcb.tmp_list_entry offset");
_Static_assert(offsetof(struct ks_flow_divert_pcb, connect_packet) == 0x88, "ks_flow_divert_pcb.connect_packet offset");
_Static_assert(offsetof(struct ks_flow_divert_pcb, app_data) == 0x90, "ks_flow_divert_pcb.app_data offset");
_Static_assert(offsetof(struct ks_flow_divert_pcb, app_data_length) == 0x98, "ks_flow_divert_pcb.app_data_length offset");
_Static_assert(offsetof(struct ks_flow_divert_pcb, local_endpoint) == 0xA0, "ks_flow_divert_pcb.local_endpoint offset");
_Static_assert(offsetof(struct ks_flow_divert_pcb, original_remote_endpoint) == 0xC0, "ks_flow_divert_pcb.original_remote_endpoint offset");
_Static_assert(offsetof(struct ks_flow_divert_pcb, original_last_outifp6) == 0xC8, "ks_flow_divert_pcb.original_last_outifp6 offset");
_Static_assert(offsetof(struct ks_flow_divert_pcb, original_last_outifp) == 0xD0, "ks_flow_divert_pcb.original_last_outifp offset");
_Static_assert(offsetof(struct ks_flow_divert_pcb, original_vflag) == 0xD8, "ks_flow_divert_pcb.original_vflag offset");
_Static_assert(offsetof(struct ks_flow_divert_pcb, plugin_locked) == 0xD9, "ks_flow_divert_pcb.plugin_locked offset");
_Static_assert(sizeof(struct ks_flow_divert_pcb) == 0xE0, "ks_flow_divert_pcb size");

/* refs: 2 */
struct ks_flow_divert_trie_node {
    unsigned short start;
    unsigned short length;
    unsigned short child_map;
};
_Static_assert(offsetof(struct ks_flow_divert_trie_node, start) == 0x0, "ks_flow_divert_trie_node.start offset");
_Static_assert(offsetof(struct ks_flow_divert_trie_node, length) == 0x2, "ks_flow_divert_trie_node.length offset");
_Static_assert(offsetof(struct ks_flow_divert_trie_node, child_map) == 0x4, "ks_flow_divert_trie_node.child_map offset");
_Static_assert(sizeof(struct ks_flow_divert_trie_node) == 0x6, "ks_flow_divert_trie_node size");

/* refs: 1 */
struct ks_flow_entry_linger_head {
    struct ks_flow_entry *tqh_first;
    struct ks_flow_entry **tqh_last;
};
_Static_assert(offsetof(struct ks_flow_entry_linger_head, tqh_first) == 0x0, "ks_flow_entry_linger_head.tqh_first offset");
_Static_assert(offsetof(struct ks_flow_entry_linger_head, tqh_last) == 0x8, "ks_flow_entry_linger_head.tqh_last offset");
_Static_assert(sizeof(struct ks_flow_entry_linger_head) == 0x10, "ks_flow_entry_linger_head size");

/* refs: 1 */
struct ks_flow_entry_rxstrc_head {
    struct ks_flow_entry *tqh_first;
    struct ks_flow_entry **tqh_last;
};
_Static_assert(offsetof(struct ks_flow_entry_rxstrc_head, tqh_first) == 0x0, "ks_flow_entry_rxstrc_head.tqh_first offset");
_Static_assert(offsetof(struct ks_flow_entry_rxstrc_head, tqh_last) == 0x8, "ks_flow_entry_rxstrc_head.tqh_last offset");
_Static_assert(sizeof(struct ks_flow_entry_rxstrc_head) == 0x10, "ks_flow_entry_rxstrc_head size");

/* refs: 3 */
struct ks_fsid {
    int val[2];
};
_Static_assert(offsetof(struct ks_fsid, val) == 0x0, "ks_fsid.val offset");
_Static_assert(sizeof(struct ks_fsid) == 0x8, "ks_fsid size");

/* refs: 1 */
struct ks_fsw_stats {
    unsigned long long _arr[0x7E];
} __attribute__((aligned(16)));
_Static_assert(offsetof(struct ks_fsw_stats, _arr) == 0x0, "ks_fsw_stats._arr offset");
_Static_assert(sizeof(struct ks_fsw_stats) == 0x3F0, "ks_fsw_stats size");

/* refs: 2 */
struct ks_gate {
    unsigned long gt_data;
    struct ks_turnstile *gt_turnstile;
    union {
        struct {
            unsigned int gt_refs : 16; /* bit offset 0 */
            unsigned int gt_alloc : 1; /* bit offset 16 */
            unsigned int gt_type : 2; /* bit offset 17 */
            unsigned int gt_flags_pad : 13; /* bit offset 19 */
        };
        unsigned int gt_flags;
    };
};
_Static_assert(offsetof(struct ks_gate, gt_data) == 0x0, "ks_gate.gt_data offset");
_Static_assert(offsetof(struct ks_gate, gt_turnstile) == 0x8, "ks_gate.gt_turnstile offset");
_Static_assert(sizeof(struct ks_gate) == 0x18, "ks_gate size");

/* refs: 1 */
struct ks_hardened_exception_action {
    struct ks_exception_action ea;
    unsigned int signed_pc_key;
    unsigned int exception;
};
_Static_assert(offsetof(struct ks_hardened_exception_action, ea) == 0x0, "ks_hardened_exception_action.ea offset");
_Static_assert(offsetof(struct ks_hardened_exception_action, signed_pc_key) == 0x20, "ks_hardened_exception_action.signed_pc_key offset");
_Static_assert(offsetof(struct ks_hardened_exception_action, exception) == 0x24, "ks_hardened_exception_action.exception offset");
_Static_assert(sizeof(struct ks_hardened_exception_action) == 0x28, "ks_hardened_exception_action size");

/* refs: 2 */
struct ks_heap_elem {
    unsigned long long key;
    struct ks__pktsched_pkt_ pkt;
};
_Static_assert(offsetof(struct ks_heap_elem, key) == 0x0, "ks_heap_elem.key offset");
_Static_assert(offsetof(struct ks_heap_elem, pkt) == 0x8, "ks_heap_elem.pkt offset");
_Static_assert(sizeof(struct ks_heap_elem) == 0x30, "ks_heap_elem size");

/* refs: 1 */
struct ks_heap {
    unsigned long limit;
    unsigned long size;
    struct ks_heap_elem p[];
};
_Static_assert(offsetof(struct ks_heap, limit) == 0x0, "ks_heap.limit offset");
_Static_assert(offsetof(struct ks_heap, size) == 0x8, "ks_heap.size offset");
_Static_assert(offsetof(struct ks_heap, p) == 0x10, "ks_heap.p offset");
_Static_assert(sizeof(struct ks_heap) == 0x10, "ks_heap size");

/* refs: 1 */
struct ks_icmp6_ifstat {
    unsigned long long ifs6_in_msg;
    unsigned long long ifs6_in_error;
    unsigned long long ifs6_in_dstunreach;
    unsigned long long ifs6_in_adminprohib;
    unsigned long long ifs6_in_timeexceed;
    unsigned long long ifs6_in_paramprob;
    unsigned long long ifs6_in_pkttoobig;
    unsigned long long ifs6_in_echo;
    unsigned long long ifs6_in_echoreply;
    unsigned long long ifs6_in_routersolicit;
    unsigned long long ifs6_in_routeradvert;
    unsigned long long ifs6_in_neighborsolicit;
    unsigned long long ifs6_in_neighboradvert;
    unsigned long long ifs6_in_redirect;
    unsigned long long ifs6_in_mldquery;
    unsigned long long ifs6_in_mldreport;
    unsigned long long ifs6_in_mlddone;
    unsigned long long ifs6_out_msg;
    unsigned long long ifs6_out_error;
    unsigned long long ifs6_out_dstunreach;
    unsigned long long ifs6_out_adminprohib;
    unsigned long long ifs6_out_timeexceed;
    unsigned long long ifs6_out_paramprob;
    unsigned long long ifs6_out_pkttoobig;
    unsigned long long ifs6_out_echo;
    unsigned long long ifs6_out_echoreply;
    unsigned long long ifs6_out_routersolicit;
    unsigned long long ifs6_out_routeradvert;
    unsigned long long ifs6_out_neighborsolicit;
    unsigned long long ifs6_out_neighboradvert;
    unsigned long long ifs6_out_redirect;
    unsigned long long ifs6_out_mldquery;
    unsigned long long ifs6_out_mldreport;
    unsigned long long ifs6_out_mlddone;
};
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_in_msg) == 0x0, "ks_icmp6_ifstat.ifs6_in_msg offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_in_error) == 0x8, "ks_icmp6_ifstat.ifs6_in_error offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_in_dstunreach) == 0x10, "ks_icmp6_ifstat.ifs6_in_dstunreach offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_in_adminprohib) == 0x18, "ks_icmp6_ifstat.ifs6_in_adminprohib offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_in_timeexceed) == 0x20, "ks_icmp6_ifstat.ifs6_in_timeexceed offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_in_paramprob) == 0x28, "ks_icmp6_ifstat.ifs6_in_paramprob offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_in_pkttoobig) == 0x30, "ks_icmp6_ifstat.ifs6_in_pkttoobig offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_in_echo) == 0x38, "ks_icmp6_ifstat.ifs6_in_echo offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_in_echoreply) == 0x40, "ks_icmp6_ifstat.ifs6_in_echoreply offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_in_routersolicit) == 0x48, "ks_icmp6_ifstat.ifs6_in_routersolicit offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_in_routeradvert) == 0x50, "ks_icmp6_ifstat.ifs6_in_routeradvert offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_in_neighborsolicit) == 0x58, "ks_icmp6_ifstat.ifs6_in_neighborsolicit offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_in_neighboradvert) == 0x60, "ks_icmp6_ifstat.ifs6_in_neighboradvert offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_in_redirect) == 0x68, "ks_icmp6_ifstat.ifs6_in_redirect offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_in_mldquery) == 0x70, "ks_icmp6_ifstat.ifs6_in_mldquery offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_in_mldreport) == 0x78, "ks_icmp6_ifstat.ifs6_in_mldreport offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_in_mlddone) == 0x80, "ks_icmp6_ifstat.ifs6_in_mlddone offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_out_msg) == 0x88, "ks_icmp6_ifstat.ifs6_out_msg offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_out_error) == 0x90, "ks_icmp6_ifstat.ifs6_out_error offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_out_dstunreach) == 0x98, "ks_icmp6_ifstat.ifs6_out_dstunreach offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_out_adminprohib) == 0xA0, "ks_icmp6_ifstat.ifs6_out_adminprohib offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_out_timeexceed) == 0xA8, "ks_icmp6_ifstat.ifs6_out_timeexceed offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_out_paramprob) == 0xB0, "ks_icmp6_ifstat.ifs6_out_paramprob offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_out_pkttoobig) == 0xB8, "ks_icmp6_ifstat.ifs6_out_pkttoobig offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_out_echo) == 0xC0, "ks_icmp6_ifstat.ifs6_out_echo offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_out_echoreply) == 0xC8, "ks_icmp6_ifstat.ifs6_out_echoreply offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_out_routersolicit) == 0xD0, "ks_icmp6_ifstat.ifs6_out_routersolicit offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_out_routeradvert) == 0xD8, "ks_icmp6_ifstat.ifs6_out_routeradvert offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_out_neighborsolicit) == 0xE0, "ks_icmp6_ifstat.ifs6_out_neighborsolicit offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_out_neighboradvert) == 0xE8, "ks_icmp6_ifstat.ifs6_out_neighboradvert offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_out_redirect) == 0xF0, "ks_icmp6_ifstat.ifs6_out_redirect offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_out_mldquery) == 0xF8, "ks_icmp6_ifstat.ifs6_out_mldquery offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_out_mldreport) == 0x100, "ks_icmp6_ifstat.ifs6_out_mldreport offset");
_Static_assert(offsetof(struct ks_icmp6_ifstat, ifs6_out_mlddone) == 0x108, "ks_icmp6_ifstat.ifs6_out_mlddone offset");
_Static_assert(sizeof(struct ks_icmp6_ifstat) == 0x110, "ks_icmp6_ifstat size");

/* refs: 2 */
struct ks_if_bandwidths {
    unsigned long long eff_bw;
    unsigned long long max_bw;
};
_Static_assert(offsetof(struct ks_if_bandwidths, eff_bw) == 0x0, "ks_if_bandwidths.eff_bw offset");
_Static_assert(offsetof(struct ks_if_bandwidths, max_bw) == 0x8, "ks_if_bandwidths.max_bw offset");
_Static_assert(sizeof(struct ks_if_bandwidths) == 0x10, "ks_if_bandwidths size");

/* refs: 1 */
struct ks_if_cellular_status_v1 {
    unsigned int valid_bitmask;
    unsigned int link_quality_metric;
    unsigned int ul_effective_bandwidth;
    unsigned int ul_max_bandwidth;
    unsigned int ul_min_latency;
    unsigned int ul_effective_latency;
    unsigned int ul_max_latency;
    unsigned int ul_retxt_level;
    unsigned int ul_bytes_lost;
    unsigned int ul_min_queue_size;
    unsigned int ul_avg_queue_size;
    unsigned int ul_max_queue_size;
    unsigned int dl_effective_bandwidth;
    unsigned int dl_max_bandwidth;
    unsigned int config_inactivity_time;
    unsigned int config_backoff_time;
    unsigned short mss_recommended;
    unsigned short reserved_1;
    unsigned int reserved_2;
    unsigned long long reserved_3;
    unsigned long long reserved_4;
    unsigned long long reserved_5;
    unsigned long long reserved_6;
};
_Static_assert(offsetof(struct ks_if_cellular_status_v1, valid_bitmask) == 0x0, "ks_if_cellular_status_v1.valid_bitmask offset");
_Static_assert(offsetof(struct ks_if_cellular_status_v1, link_quality_metric) == 0x4, "ks_if_cellular_status_v1.link_quality_metric offset");
_Static_assert(offsetof(struct ks_if_cellular_status_v1, ul_effective_bandwidth) == 0x8, "ks_if_cellular_status_v1.ul_effective_bandwidth offset");
_Static_assert(offsetof(struct ks_if_cellular_status_v1, ul_max_bandwidth) == 0xC, "ks_if_cellular_status_v1.ul_max_bandwidth offset");
_Static_assert(offsetof(struct ks_if_cellular_status_v1, ul_min_latency) == 0x10, "ks_if_cellular_status_v1.ul_min_latency offset");
_Static_assert(offsetof(struct ks_if_cellular_status_v1, ul_effective_latency) == 0x14, "ks_if_cellular_status_v1.ul_effective_latency offset");
_Static_assert(offsetof(struct ks_if_cellular_status_v1, ul_max_latency) == 0x18, "ks_if_cellular_status_v1.ul_max_latency offset");
_Static_assert(offsetof(struct ks_if_cellular_status_v1, ul_retxt_level) == 0x1C, "ks_if_cellular_status_v1.ul_retxt_level offset");
_Static_assert(offsetof(struct ks_if_cellular_status_v1, ul_bytes_lost) == 0x20, "ks_if_cellular_status_v1.ul_bytes_lost offset");
_Static_assert(offsetof(struct ks_if_cellular_status_v1, ul_min_queue_size) == 0x24, "ks_if_cellular_status_v1.ul_min_queue_size offset");
_Static_assert(offsetof(struct ks_if_cellular_status_v1, ul_avg_queue_size) == 0x28, "ks_if_cellular_status_v1.ul_avg_queue_size offset");
_Static_assert(offsetof(struct ks_if_cellular_status_v1, ul_max_queue_size) == 0x2C, "ks_if_cellular_status_v1.ul_max_queue_size offset");
_Static_assert(offsetof(struct ks_if_cellular_status_v1, dl_effective_bandwidth) == 0x30, "ks_if_cellular_status_v1.dl_effective_bandwidth offset");
_Static_assert(offsetof(struct ks_if_cellular_status_v1, dl_max_bandwidth) == 0x34, "ks_if_cellular_status_v1.dl_max_bandwidth offset");
_Static_assert(offsetof(struct ks_if_cellular_status_v1, config_inactivity_time) == 0x38, "ks_if_cellular_status_v1.config_inactivity_time offset");
_Static_assert(offsetof(struct ks_if_cellular_status_v1, config_backoff_time) == 0x3C, "ks_if_cellular_status_v1.config_backoff_time offset");
_Static_assert(offsetof(struct ks_if_cellular_status_v1, mss_recommended) == 0x40, "ks_if_cellular_status_v1.mss_recommended offset");
_Static_assert(offsetof(struct ks_if_cellular_status_v1, reserved_1) == 0x42, "ks_if_cellular_status_v1.reserved_1 offset");
_Static_assert(offsetof(struct ks_if_cellular_status_v1, reserved_2) == 0x44, "ks_if_cellular_status_v1.reserved_2 offset");
_Static_assert(offsetof(struct ks_if_cellular_status_v1, reserved_3) == 0x48, "ks_if_cellular_status_v1.reserved_3 offset");
_Static_assert(offsetof(struct ks_if_cellular_status_v1, reserved_4) == 0x50, "ks_if_cellular_status_v1.reserved_4 offset");
_Static_assert(offsetof(struct ks_if_cellular_status_v1, reserved_5) == 0x58, "ks_if_cellular_status_v1.reserved_5 offset");
_Static_assert(offsetof(struct ks_if_cellular_status_v1, reserved_6) == 0x60, "ks_if_cellular_status_v1.reserved_6 offset");
_Static_assert(sizeof(struct ks_if_cellular_status_v1) == 0x68, "ks_if_cellular_status_v1 size");

/* refs: 1 */
struct ks_if_cellular_status {
    struct ks_if_cellular_status_v1 if_cell_u;
};
_Static_assert(offsetof(struct ks_if_cellular_status, if_cell_u) == 0x0, "ks_if_cellular_status.if_cell_u offset");
_Static_assert(sizeof(struct ks_if_cellular_status) == 0x68, "ks_if_cellular_status size");

/* refs: 1 */
struct ks_if_data_internal {
    unsigned char ifi_type;
    unsigned char ifi_typelen;
    unsigned char ifi_physical;
    unsigned char ifi_addrlen;
    unsigned char ifi_hdrlen;
    unsigned char ifi_recvquota;
    unsigned char ifi_xmitquota;
    unsigned char ifi_unused1;
    unsigned int ifi_mtu;
    unsigned int ifi_metric;
    unsigned int ifi_baudrate;
    unsigned long long ifi_ipackets;
    unsigned long long ifi_ierrors;
    unsigned long long ifi_opackets;
    unsigned long long ifi_oerrors;
    unsigned long long ifi_collisions;
    unsigned long long ifi_ibytes;
    unsigned long long ifi_obytes;
    unsigned long long ifi_imcasts;
    unsigned long long ifi_omcasts;
    unsigned long long ifi_iqdrops;
    unsigned long long ifi_noproto;
    unsigned int ifi_recvtiming;
    unsigned int ifi_xmittiming;
    unsigned long long ifi_alignerrs;
    unsigned long long ifi_dt_bytes;
    unsigned long long ifi_fpackets;
    unsigned long long ifi_fbytes;
    unsigned long long ifi_link_heuristics_cnt;
    unsigned long long ifi_link_heuristics_time;
    unsigned long long ifi_congested_link_cnt;
    unsigned long long ifi_congested_link_time;
    unsigned long long ifi_lqm_good_cnt;
    unsigned long long ifi_lqm_good_time;
    unsigned long long ifi_lqm_poor_cnt;
    unsigned long long ifi_lqm_poor_time;
    unsigned long long ifi_lqm_min_viable_cnt;
    unsigned long long ifi_lqm_min_viable_time;
    unsigned long long ifi_lqm_bad_cnt;
    unsigned long long ifi_lqm_bad_time;
    struct ks_timeval ifi_lastchange;
    struct ks_timeval ifi_lastupdown;
    unsigned int ifi_hwassist;
    unsigned int ifi_tso_v4_mtu;
    unsigned int ifi_tso_v6_mtu;
};
_Static_assert(offsetof(struct ks_if_data_internal, ifi_type) == 0x0, "ks_if_data_internal.ifi_type offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_typelen) == 0x1, "ks_if_data_internal.ifi_typelen offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_physical) == 0x2, "ks_if_data_internal.ifi_physical offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_addrlen) == 0x3, "ks_if_data_internal.ifi_addrlen offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_hdrlen) == 0x4, "ks_if_data_internal.ifi_hdrlen offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_recvquota) == 0x5, "ks_if_data_internal.ifi_recvquota offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_xmitquota) == 0x6, "ks_if_data_internal.ifi_xmitquota offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_unused1) == 0x7, "ks_if_data_internal.ifi_unused1 offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_mtu) == 0x8, "ks_if_data_internal.ifi_mtu offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_metric) == 0xC, "ks_if_data_internal.ifi_metric offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_baudrate) == 0x10, "ks_if_data_internal.ifi_baudrate offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_ipackets) == 0x18, "ks_if_data_internal.ifi_ipackets offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_ierrors) == 0x20, "ks_if_data_internal.ifi_ierrors offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_opackets) == 0x28, "ks_if_data_internal.ifi_opackets offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_oerrors) == 0x30, "ks_if_data_internal.ifi_oerrors offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_collisions) == 0x38, "ks_if_data_internal.ifi_collisions offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_ibytes) == 0x40, "ks_if_data_internal.ifi_ibytes offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_obytes) == 0x48, "ks_if_data_internal.ifi_obytes offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_imcasts) == 0x50, "ks_if_data_internal.ifi_imcasts offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_omcasts) == 0x58, "ks_if_data_internal.ifi_omcasts offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_iqdrops) == 0x60, "ks_if_data_internal.ifi_iqdrops offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_noproto) == 0x68, "ks_if_data_internal.ifi_noproto offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_recvtiming) == 0x70, "ks_if_data_internal.ifi_recvtiming offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_xmittiming) == 0x74, "ks_if_data_internal.ifi_xmittiming offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_alignerrs) == 0x78, "ks_if_data_internal.ifi_alignerrs offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_dt_bytes) == 0x80, "ks_if_data_internal.ifi_dt_bytes offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_fpackets) == 0x88, "ks_if_data_internal.ifi_fpackets offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_fbytes) == 0x90, "ks_if_data_internal.ifi_fbytes offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_link_heuristics_cnt) == 0x98, "ks_if_data_internal.ifi_link_heuristics_cnt offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_link_heuristics_time) == 0xA0, "ks_if_data_internal.ifi_link_heuristics_time offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_congested_link_cnt) == 0xA8, "ks_if_data_internal.ifi_congested_link_cnt offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_congested_link_time) == 0xB0, "ks_if_data_internal.ifi_congested_link_time offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_lqm_good_cnt) == 0xB8, "ks_if_data_internal.ifi_lqm_good_cnt offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_lqm_good_time) == 0xC0, "ks_if_data_internal.ifi_lqm_good_time offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_lqm_poor_cnt) == 0xC8, "ks_if_data_internal.ifi_lqm_poor_cnt offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_lqm_poor_time) == 0xD0, "ks_if_data_internal.ifi_lqm_poor_time offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_lqm_min_viable_cnt) == 0xD8, "ks_if_data_internal.ifi_lqm_min_viable_cnt offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_lqm_min_viable_time) == 0xE0, "ks_if_data_internal.ifi_lqm_min_viable_time offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_lqm_bad_cnt) == 0xE8, "ks_if_data_internal.ifi_lqm_bad_cnt offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_lqm_bad_time) == 0xF0, "ks_if_data_internal.ifi_lqm_bad_time offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_lastchange) == 0xF8, "ks_if_data_internal.ifi_lastchange offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_lastupdown) == 0x108, "ks_if_data_internal.ifi_lastupdown offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_hwassist) == 0x118, "ks_if_data_internal.ifi_hwassist offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_tso_v4_mtu) == 0x11C, "ks_if_data_internal.ifi_tso_v4_mtu offset");
_Static_assert(offsetof(struct ks_if_data_internal, ifi_tso_v6_mtu) == 0x120, "ks_if_data_internal.ifi_tso_v6_mtu offset");
_Static_assert(sizeof(struct ks_if_data_internal) == 0x128, "ks_if_data_internal size");

/* refs: 1 */
struct ks_if_description {
    unsigned int ifd_maxlen;
    unsigned int ifd_len;
    unsigned char *ifd_desc;
};
_Static_assert(offsetof(struct ks_if_description, ifd_maxlen) == 0x0, "ks_if_description.ifd_maxlen offset");
_Static_assert(offsetof(struct ks_if_description, ifd_len) == 0x4, "ks_if_description.ifd_len offset");
_Static_assert(offsetof(struct ks_if_description, ifd_desc) == 0x8, "ks_if_description.ifd_desc offset");
_Static_assert(sizeof(struct ks_if_description) == 0x10, "ks_if_description size");

/* refs: 1 */
struct ks_if_interface_state {
    unsigned char valid_bitmask;
    unsigned char rrc_state;
    signed char lqm_state;
    unsigned char interface_availability;
};
_Static_assert(offsetof(struct ks_if_interface_state, valid_bitmask) == 0x0, "ks_if_interface_state.valid_bitmask offset");
_Static_assert(offsetof(struct ks_if_interface_state, rrc_state) == 0x1, "ks_if_interface_state.rrc_state offset");
_Static_assert(offsetof(struct ks_if_interface_state, lqm_state) == 0x2, "ks_if_interface_state.lqm_state offset");
_Static_assert(offsetof(struct ks_if_interface_state, interface_availability) == 0x3, "ks_if_interface_state.interface_availability offset");
_Static_assert(sizeof(struct ks_if_interface_state) == 0x4, "ks_if_interface_state size");

/* refs: 2 */
struct ks_if_latencies {
    unsigned long long eff_lt;
    unsigned long long max_lt;
};
_Static_assert(offsetof(struct ks_if_latencies, eff_lt) == 0x0, "ks_if_latencies.eff_lt offset");
_Static_assert(offsetof(struct ks_if_latencies, max_lt) == 0x8, "ks_if_latencies.max_lt offset");
_Static_assert(sizeof(struct ks_if_latencies) == 0x10, "ks_if_latencies size");

/* refs: 1 */
struct ks_if_lim_perf_stat {
    unsigned long long lim_dl_max_bandwidth;
    unsigned long long lim_ul_max_bandwidth;
    unsigned long long lim_total_txpkts;
    unsigned long long lim_total_rxpkts;
    unsigned long long lim_total_retxpkts;
    unsigned long long lim_packet_loss_percent;
    unsigned long long lim_total_oopkts;
    unsigned long long lim_packet_ooo_percent;
    unsigned long long lim_rtt_variance;
    unsigned long long lim_rtt_average;
    unsigned long long lim_rtt_min;
    unsigned long long lim_conn_timeouts;
    unsigned long long lim_conn_attempts;
    unsigned long long lim_conn_timeout_percent;
    unsigned long long lim_bk_txpkts;
    unsigned long long lim_dl_detected : 1; /* bit offset 960 */
    unsigned long long lim_ul_detected : 1; /* bit offset 961 */
};
_Static_assert(offsetof(struct ks_if_lim_perf_stat, lim_dl_max_bandwidth) == 0x0, "ks_if_lim_perf_stat.lim_dl_max_bandwidth offset");
_Static_assert(offsetof(struct ks_if_lim_perf_stat, lim_ul_max_bandwidth) == 0x8, "ks_if_lim_perf_stat.lim_ul_max_bandwidth offset");
_Static_assert(offsetof(struct ks_if_lim_perf_stat, lim_total_txpkts) == 0x10, "ks_if_lim_perf_stat.lim_total_txpkts offset");
_Static_assert(offsetof(struct ks_if_lim_perf_stat, lim_total_rxpkts) == 0x18, "ks_if_lim_perf_stat.lim_total_rxpkts offset");
_Static_assert(offsetof(struct ks_if_lim_perf_stat, lim_total_retxpkts) == 0x20, "ks_if_lim_perf_stat.lim_total_retxpkts offset");
_Static_assert(offsetof(struct ks_if_lim_perf_stat, lim_packet_loss_percent) == 0x28, "ks_if_lim_perf_stat.lim_packet_loss_percent offset");
_Static_assert(offsetof(struct ks_if_lim_perf_stat, lim_total_oopkts) == 0x30, "ks_if_lim_perf_stat.lim_total_oopkts offset");
_Static_assert(offsetof(struct ks_if_lim_perf_stat, lim_packet_ooo_percent) == 0x38, "ks_if_lim_perf_stat.lim_packet_ooo_percent offset");
_Static_assert(offsetof(struct ks_if_lim_perf_stat, lim_rtt_variance) == 0x40, "ks_if_lim_perf_stat.lim_rtt_variance offset");
_Static_assert(offsetof(struct ks_if_lim_perf_stat, lim_rtt_average) == 0x48, "ks_if_lim_perf_stat.lim_rtt_average offset");
_Static_assert(offsetof(struct ks_if_lim_perf_stat, lim_rtt_min) == 0x50, "ks_if_lim_perf_stat.lim_rtt_min offset");
_Static_assert(offsetof(struct ks_if_lim_perf_stat, lim_conn_timeouts) == 0x58, "ks_if_lim_perf_stat.lim_conn_timeouts offset");
_Static_assert(offsetof(struct ks_if_lim_perf_stat, lim_conn_attempts) == 0x60, "ks_if_lim_perf_stat.lim_conn_attempts offset");
_Static_assert(offsetof(struct ks_if_lim_perf_stat, lim_conn_timeout_percent) == 0x68, "ks_if_lim_perf_stat.lim_conn_timeout_percent offset");
_Static_assert(offsetof(struct ks_if_lim_perf_stat, lim_bk_txpkts) == 0x70, "ks_if_lim_perf_stat.lim_bk_txpkts offset");
_Static_assert(sizeof(struct ks_if_lim_perf_stat) == 0x80, "ks_if_lim_perf_stat size");

/* refs: 1 */
struct ks_if_wifi_status_v1 {
    unsigned int valid_bitmask;
    unsigned int link_quality_metric;
    unsigned int ul_effective_bandwidth;
    unsigned int ul_max_bandwidth;
    unsigned int ul_min_latency;
    unsigned int ul_effective_latency;
    unsigned int ul_max_latency;
    unsigned int ul_retxt_level;
    unsigned int ul_bytes_lost;
    unsigned int ul_error_rate;
    unsigned int dl_effective_bandwidth;
    unsigned int dl_max_bandwidth;
    unsigned int dl_min_latency;
    unsigned int dl_effective_latency;
    unsigned int dl_max_latency;
    unsigned int dl_error_rate;
    unsigned int config_frequency;
    unsigned int config_multicast_rate;
    unsigned int scan_count;
    unsigned int scan_duration;
    unsigned long long reserved_1;
    unsigned long long reserved_2;
    unsigned long long reserved_3;
    unsigned long long reserved_4;
};
_Static_assert(offsetof(struct ks_if_wifi_status_v1, valid_bitmask) == 0x0, "ks_if_wifi_status_v1.valid_bitmask offset");
_Static_assert(offsetof(struct ks_if_wifi_status_v1, link_quality_metric) == 0x4, "ks_if_wifi_status_v1.link_quality_metric offset");
_Static_assert(offsetof(struct ks_if_wifi_status_v1, ul_effective_bandwidth) == 0x8, "ks_if_wifi_status_v1.ul_effective_bandwidth offset");
_Static_assert(offsetof(struct ks_if_wifi_status_v1, ul_max_bandwidth) == 0xC, "ks_if_wifi_status_v1.ul_max_bandwidth offset");
_Static_assert(offsetof(struct ks_if_wifi_status_v1, ul_min_latency) == 0x10, "ks_if_wifi_status_v1.ul_min_latency offset");
_Static_assert(offsetof(struct ks_if_wifi_status_v1, ul_effective_latency) == 0x14, "ks_if_wifi_status_v1.ul_effective_latency offset");
_Static_assert(offsetof(struct ks_if_wifi_status_v1, ul_max_latency) == 0x18, "ks_if_wifi_status_v1.ul_max_latency offset");
_Static_assert(offsetof(struct ks_if_wifi_status_v1, ul_retxt_level) == 0x1C, "ks_if_wifi_status_v1.ul_retxt_level offset");
_Static_assert(offsetof(struct ks_if_wifi_status_v1, ul_bytes_lost) == 0x20, "ks_if_wifi_status_v1.ul_bytes_lost offset");
_Static_assert(offsetof(struct ks_if_wifi_status_v1, ul_error_rate) == 0x24, "ks_if_wifi_status_v1.ul_error_rate offset");
_Static_assert(offsetof(struct ks_if_wifi_status_v1, dl_effective_bandwidth) == 0x28, "ks_if_wifi_status_v1.dl_effective_bandwidth offset");
_Static_assert(offsetof(struct ks_if_wifi_status_v1, dl_max_bandwidth) == 0x2C, "ks_if_wifi_status_v1.dl_max_bandwidth offset");
_Static_assert(offsetof(struct ks_if_wifi_status_v1, dl_min_latency) == 0x30, "ks_if_wifi_status_v1.dl_min_latency offset");
_Static_assert(offsetof(struct ks_if_wifi_status_v1, dl_effective_latency) == 0x34, "ks_if_wifi_status_v1.dl_effective_latency offset");
_Static_assert(offsetof(struct ks_if_wifi_status_v1, dl_max_latency) == 0x38, "ks_if_wifi_status_v1.dl_max_latency offset");
_Static_assert(offsetof(struct ks_if_wifi_status_v1, dl_error_rate) == 0x3C, "ks_if_wifi_status_v1.dl_error_rate offset");
_Static_assert(offsetof(struct ks_if_wifi_status_v1, config_frequency) == 0x40, "ks_if_wifi_status_v1.config_frequency offset");
_Static_assert(offsetof(struct ks_if_wifi_status_v1, config_multicast_rate) == 0x44, "ks_if_wifi_status_v1.config_multicast_rate offset");
_Static_assert(offsetof(struct ks_if_wifi_status_v1, scan_count) == 0x48, "ks_if_wifi_status_v1.scan_count offset");
_Static_assert(offsetof(struct ks_if_wifi_status_v1, scan_duration) == 0x4C, "ks_if_wifi_status_v1.scan_duration offset");
_Static_assert(offsetof(struct ks_if_wifi_status_v1, reserved_1) == 0x50, "ks_if_wifi_status_v1.reserved_1 offset");
_Static_assert(offsetof(struct ks_if_wifi_status_v1, reserved_2) == 0x58, "ks_if_wifi_status_v1.reserved_2 offset");
_Static_assert(offsetof(struct ks_if_wifi_status_v1, reserved_3) == 0x60, "ks_if_wifi_status_v1.reserved_3 offset");
_Static_assert(offsetof(struct ks_if_wifi_status_v1, reserved_4) == 0x68, "ks_if_wifi_status_v1.reserved_4 offset");
_Static_assert(sizeof(struct ks_if_wifi_status_v1) == 0x70, "ks_if_wifi_status_v1 size");

/* refs: 1 */
struct ks_if_wifi_status {
    struct ks_if_wifi_status_v1 if_wifi_u;
};
_Static_assert(offsetof(struct ks_if_wifi_status, if_wifi_u) == 0x0, "ks_if_wifi_status.if_wifi_u offset");
_Static_assert(sizeof(struct ks_if_wifi_status) == 0x70, "ks_if_wifi_status size");

/* refs: 1 */
#pragma pack(push, 4)
struct ks_if_link_status {
    unsigned int ifsr_version;
    unsigned int ifsr_len;
    union {
        struct ks_if_cellular_status ifsr_cell;
        struct ks_if_wifi_status ifsr_wifi;
    } ifsr_u;
};
#pragma pack(pop)
_Static_assert(offsetof(struct ks_if_link_status, ifsr_version) == 0x0, "ks_if_link_status.ifsr_version offset");
_Static_assert(offsetof(struct ks_if_link_status, ifsr_len) == 0x4, "ks_if_link_status.ifsr_len offset");
_Static_assert(offsetof(struct ks_if_link_status, ifsr_u) == 0x8, "ks_if_link_status.ifsr_u offset");
_Static_assert(sizeof(struct ks_if_link_status) == 0x78, "ks_if_link_status size");

/* refs: 1 */
struct ks_lr_key_s {
    unsigned short proto;
    unsigned char addr[6];
};
_Static_assert(offsetof(struct ks_lr_key_s, proto) == 0x0, "ks_lr_key_s.proto offset");
_Static_assert(offsetof(struct ks_lr_key_s, addr) == 0x2, "ks_lr_key_s.addr offset");
_Static_assert(sizeof(struct ks_lr_key_s) == 0x8, "ks_lr_key_s size");

/* refs: 4 */
struct ks_if_llreach {
    struct ks_lck_mtx_s lr_lock;
    struct {
        struct ks_if_llreach *rbe_left;
        struct ks_if_llreach *rbe_right;
        struct ks_if_llreach *rbe_parent;
    } lr_link;
    struct ks_ifnet *lr_ifp;
    unsigned int lr_refcnt;
    unsigned int lr_reqcnt;
    unsigned int lr_debug;
    unsigned int lr_probes;
    unsigned long long lr_basecal;
    unsigned long long lr_baseup;
    unsigned long long lr_lastrcvd;
    unsigned int lr_basereachable;
    unsigned int lr_reachable;
    struct ks_lr_key_s lr_key;
    int lr_rssi;
    int lr_lqm;
    int lr_npm;
};
_Static_assert(offsetof(struct ks_if_llreach, lr_lock) == 0x0, "ks_if_llreach.lr_lock offset");
_Static_assert(offsetof(struct ks_if_llreach, lr_link) == 0x10, "ks_if_llreach.lr_link offset");
_Static_assert(offsetof(struct ks_if_llreach, lr_ifp) == 0x28, "ks_if_llreach.lr_ifp offset");
_Static_assert(offsetof(struct ks_if_llreach, lr_refcnt) == 0x30, "ks_if_llreach.lr_refcnt offset");
_Static_assert(offsetof(struct ks_if_llreach, lr_reqcnt) == 0x34, "ks_if_llreach.lr_reqcnt offset");
_Static_assert(offsetof(struct ks_if_llreach, lr_debug) == 0x38, "ks_if_llreach.lr_debug offset");
_Static_assert(offsetof(struct ks_if_llreach, lr_probes) == 0x3C, "ks_if_llreach.lr_probes offset");
_Static_assert(offsetof(struct ks_if_llreach, lr_basecal) == 0x40, "ks_if_llreach.lr_basecal offset");
_Static_assert(offsetof(struct ks_if_llreach, lr_baseup) == 0x48, "ks_if_llreach.lr_baseup offset");
_Static_assert(offsetof(struct ks_if_llreach, lr_lastrcvd) == 0x50, "ks_if_llreach.lr_lastrcvd offset");
_Static_assert(offsetof(struct ks_if_llreach, lr_basereachable) == 0x58, "ks_if_llreach.lr_basereachable offset");
_Static_assert(offsetof(struct ks_if_llreach, lr_reachable) == 0x5C, "ks_if_llreach.lr_reachable offset");
_Static_assert(offsetof(struct ks_if_llreach, lr_key) == 0x60, "ks_if_llreach.lr_key offset");
_Static_assert(offsetof(struct ks_if_llreach, lr_rssi) == 0x68, "ks_if_llreach.lr_rssi offset");
_Static_assert(offsetof(struct ks_if_llreach, lr_lqm) == 0x6C, "ks_if_llreach.lr_lqm offset");
_Static_assert(offsetof(struct ks_if_llreach, lr_npm) == 0x70, "ks_if_llreach.lr_npm offset");
_Static_assert(sizeof(struct ks_if_llreach) == 0x78, "ks_if_llreach size");

/* refs: 2 */
struct ks_if_nexus_flowswitch {
    unsigned char if_fsw_provider[0x10];
    unsigned char if_fsw_instance[0x10];
    unsigned char if_fsw_device[0x10];
    unsigned int if_fsw_ipaddr_gencnt;
};
_Static_assert(offsetof(struct ks_if_nexus_flowswitch, if_fsw_provider) == 0x0, "ks_if_nexus_flowswitch.if_fsw_provider offset");
_Static_assert(offsetof(struct ks_if_nexus_flowswitch, if_fsw_instance) == 0x10, "ks_if_nexus_flowswitch.if_fsw_instance offset");
_Static_assert(offsetof(struct ks_if_nexus_flowswitch, if_fsw_device) == 0x20, "ks_if_nexus_flowswitch.if_fsw_device offset");
_Static_assert(offsetof(struct ks_if_nexus_flowswitch, if_fsw_ipaddr_gencnt) == 0x30, "ks_if_nexus_flowswitch.if_fsw_ipaddr_gencnt offset");
_Static_assert(sizeof(struct ks_if_nexus_flowswitch) == 0x34, "ks_if_nexus_flowswitch size");

/* refs: 2 */
struct ks_if_nexus_netif {
    unsigned char if_nif_provider[0x10];
    unsigned char if_nif_instance[0x10];
    unsigned char if_nif_attach[0x10];
};
_Static_assert(offsetof(struct ks_if_nexus_netif, if_nif_provider) == 0x0, "ks_if_nexus_netif.if_nif_provider offset");
_Static_assert(offsetof(struct ks_if_nexus_netif, if_nif_instance) == 0x10, "ks_if_nexus_netif.if_nif_instance offset");
_Static_assert(offsetof(struct ks_if_nexus_netif, if_nif_attach) == 0x20, "ks_if_nexus_netif.if_nif_attach offset");
_Static_assert(sizeof(struct ks_if_nexus_netif) == 0x30, "ks_if_nexus_netif size");

/* refs: 1 */
struct ks_if_rxpoll_stats {
    unsigned int ifi_poll_off_req;
    unsigned int ifi_poll_off_err;
    unsigned int ifi_poll_on_req;
    unsigned int ifi_poll_on_err;
    unsigned int ifi_poll_wakeups_avg;
    unsigned int ifi_poll_wakeups_lowat;
    unsigned int ifi_poll_wakeups_hiwat;
    unsigned long long ifi_poll_packets;
    unsigned int ifi_poll_packets_avg;
    unsigned int ifi_poll_packets_min;
    unsigned int ifi_poll_packets_max;
    unsigned int ifi_poll_packets_lowat;
    unsigned int ifi_poll_packets_hiwat;
    unsigned long long ifi_poll_bytes;
    unsigned int ifi_poll_bytes_avg;
    unsigned int ifi_poll_bytes_min;
    unsigned int ifi_poll_bytes_max;
    unsigned int ifi_poll_bytes_lowat;
    unsigned int ifi_poll_bytes_hiwat;
    unsigned int ifi_poll_packets_limit;
    unsigned long long ifi_poll_interval_time;
};
_Static_assert(offsetof(struct ks_if_rxpoll_stats, ifi_poll_off_req) == 0x0, "ks_if_rxpoll_stats.ifi_poll_off_req offset");
_Static_assert(offsetof(struct ks_if_rxpoll_stats, ifi_poll_off_err) == 0x4, "ks_if_rxpoll_stats.ifi_poll_off_err offset");
_Static_assert(offsetof(struct ks_if_rxpoll_stats, ifi_poll_on_req) == 0x8, "ks_if_rxpoll_stats.ifi_poll_on_req offset");
_Static_assert(offsetof(struct ks_if_rxpoll_stats, ifi_poll_on_err) == 0xC, "ks_if_rxpoll_stats.ifi_poll_on_err offset");
_Static_assert(offsetof(struct ks_if_rxpoll_stats, ifi_poll_wakeups_avg) == 0x10, "ks_if_rxpoll_stats.ifi_poll_wakeups_avg offset");
_Static_assert(offsetof(struct ks_if_rxpoll_stats, ifi_poll_wakeups_lowat) == 0x14, "ks_if_rxpoll_stats.ifi_poll_wakeups_lowat offset");
_Static_assert(offsetof(struct ks_if_rxpoll_stats, ifi_poll_wakeups_hiwat) == 0x18, "ks_if_rxpoll_stats.ifi_poll_wakeups_hiwat offset");
_Static_assert(offsetof(struct ks_if_rxpoll_stats, ifi_poll_packets) == 0x20, "ks_if_rxpoll_stats.ifi_poll_packets offset");
_Static_assert(offsetof(struct ks_if_rxpoll_stats, ifi_poll_packets_avg) == 0x28, "ks_if_rxpoll_stats.ifi_poll_packets_avg offset");
_Static_assert(offsetof(struct ks_if_rxpoll_stats, ifi_poll_packets_min) == 0x2C, "ks_if_rxpoll_stats.ifi_poll_packets_min offset");
_Static_assert(offsetof(struct ks_if_rxpoll_stats, ifi_poll_packets_max) == 0x30, "ks_if_rxpoll_stats.ifi_poll_packets_max offset");
_Static_assert(offsetof(struct ks_if_rxpoll_stats, ifi_poll_packets_lowat) == 0x34, "ks_if_rxpoll_stats.ifi_poll_packets_lowat offset");
_Static_assert(offsetof(struct ks_if_rxpoll_stats, ifi_poll_packets_hiwat) == 0x38, "ks_if_rxpoll_stats.ifi_poll_packets_hiwat offset");
_Static_assert(offsetof(struct ks_if_rxpoll_stats, ifi_poll_bytes) == 0x40, "ks_if_rxpoll_stats.ifi_poll_bytes offset");
_Static_assert(offsetof(struct ks_if_rxpoll_stats, ifi_poll_bytes_avg) == 0x48, "ks_if_rxpoll_stats.ifi_poll_bytes_avg offset");
_Static_assert(offsetof(struct ks_if_rxpoll_stats, ifi_poll_bytes_min) == 0x4C, "ks_if_rxpoll_stats.ifi_poll_bytes_min offset");
_Static_assert(offsetof(struct ks_if_rxpoll_stats, ifi_poll_bytes_max) == 0x50, "ks_if_rxpoll_stats.ifi_poll_bytes_max offset");
_Static_assert(offsetof(struct ks_if_rxpoll_stats, ifi_poll_bytes_lowat) == 0x54, "ks_if_rxpoll_stats.ifi_poll_bytes_lowat offset");
_Static_assert(offsetof(struct ks_if_rxpoll_stats, ifi_poll_bytes_hiwat) == 0x58, "ks_if_rxpoll_stats.ifi_poll_bytes_hiwat offset");
_Static_assert(offsetof(struct ks_if_rxpoll_stats, ifi_poll_packets_limit) == 0x5C, "ks_if_rxpoll_stats.ifi_poll_packets_limit offset");
_Static_assert(offsetof(struct ks_if_rxpoll_stats, ifi_poll_interval_time) == 0x60, "ks_if_rxpoll_stats.ifi_poll_interval_time offset");
_Static_assert(sizeof(struct ks_if_rxpoll_stats) == 0x68, "ks_if_rxpoll_stats size");

/* refs: 5 */
struct ks_pktcntr {
    unsigned long long packets;
    unsigned long long bytes;
};
_Static_assert(offsetof(struct ks_pktcntr, packets) == 0x0, "ks_pktcntr.packets offset");
_Static_assert(offsetof(struct ks_pktcntr, bytes) == 0x8, "ks_pktcntr.bytes offset");
_Static_assert(sizeof(struct ks_pktcntr) == 0x10, "ks_pktcntr size");

/* refs: 1 */
struct ks_if_poll_params {
    unsigned short poll_req;
    unsigned short poll_update;
    unsigned int poll_flags;
    struct ks_timespec poll_cycle;
    struct ks_thread *poll_thread;
    unsigned int poll_mode;
    struct ks_pktcntr poll_tstats;
    struct ks_if_rxpoll_stats poll_pstats;
    struct ks_pktcntr poll_sstats;
    struct ks_timespec poll_mode_holdtime;
    struct ks_timespec poll_mode_lasttime;
    struct ks_timespec poll_sample_holdtime;
    struct ks_timespec poll_sample_lasttime;
    struct ks_timespec poll_dbg_lasttime;
};
_Static_assert(offsetof(struct ks_if_poll_params, poll_req) == 0x0, "ks_if_poll_params.poll_req offset");
_Static_assert(offsetof(struct ks_if_poll_params, poll_update) == 0x2, "ks_if_poll_params.poll_update offset");
_Static_assert(offsetof(struct ks_if_poll_params, poll_flags) == 0x4, "ks_if_poll_params.poll_flags offset");
_Static_assert(offsetof(struct ks_if_poll_params, poll_cycle) == 0x8, "ks_if_poll_params.poll_cycle offset");
_Static_assert(offsetof(struct ks_if_poll_params, poll_thread) == 0x18, "ks_if_poll_params.poll_thread offset");
_Static_assert(offsetof(struct ks_if_poll_params, poll_mode) == 0x20, "ks_if_poll_params.poll_mode offset");
_Static_assert(offsetof(struct ks_if_poll_params, poll_tstats) == 0x28, "ks_if_poll_params.poll_tstats offset");
_Static_assert(offsetof(struct ks_if_poll_params, poll_pstats) == 0x38, "ks_if_poll_params.poll_pstats offset");
_Static_assert(offsetof(struct ks_if_poll_params, poll_sstats) == 0xA0, "ks_if_poll_params.poll_sstats offset");
_Static_assert(offsetof(struct ks_if_poll_params, poll_mode_holdtime) == 0xB0, "ks_if_poll_params.poll_mode_holdtime offset");
_Static_assert(offsetof(struct ks_if_poll_params, poll_mode_lasttime) == 0xC0, "ks_if_poll_params.poll_mode_lasttime offset");
_Static_assert(offsetof(struct ks_if_poll_params, poll_sample_holdtime) == 0xD0, "ks_if_poll_params.poll_sample_holdtime offset");
_Static_assert(offsetof(struct ks_if_poll_params, poll_sample_lasttime) == 0xE0, "ks_if_poll_params.poll_sample_lasttime offset");
_Static_assert(offsetof(struct ks_if_poll_params, poll_dbg_lasttime) == 0xF0, "ks_if_poll_params.poll_dbg_lasttime offset");
_Static_assert(sizeof(struct ks_if_poll_params) == 0x100, "ks_if_poll_params size");

/* refs: 2 */
struct ks_if_proto {
    struct {
        struct ks_if_proto *sle_next;
    } next_hash;
    unsigned int refcount;
    unsigned int detached;
    struct ks_ifnet *ifp;
    unsigned int protocol_family;
    int proto_kpi;
    struct {
        int *input;
        int *pre_output;
        void *event;
        int *ioctl;
        int *detached;
        int *resolve_multi;
        int *send_arp;
    } kpi;
};
_Static_assert(offsetof(struct ks_if_proto, next_hash) == 0x0, "ks_if_proto.next_hash offset");
_Static_assert(offsetof(struct ks_if_proto, refcount) == 0x8, "ks_if_proto.refcount offset");
_Static_assert(offsetof(struct ks_if_proto, detached) == 0xC, "ks_if_proto.detached offset");
_Static_assert(offsetof(struct ks_if_proto, ifp) == 0x10, "ks_if_proto.ifp offset");
_Static_assert(offsetof(struct ks_if_proto, protocol_family) == 0x18, "ks_if_proto.protocol_family offset");
_Static_assert(offsetof(struct ks_if_proto, proto_kpi) == 0x1C, "ks_if_proto.proto_kpi offset");
_Static_assert(offsetof(struct ks_if_proto, kpi) == 0x20, "ks_if_proto.kpi offset");
_Static_assert(sizeof(struct ks_if_proto) == 0x58, "ks_if_proto size");

/* refs: 2 */
struct ks_if_tcp_ecn_perf_stat {
    unsigned long long total_txpkts;
    unsigned long long total_rxmitpkts;
    unsigned long long total_rxpkts;
    unsigned long long total_oopkts;
    unsigned long long total_reorderpkts;
    unsigned long long rtt_avg;
    unsigned long long rtt_var;
    unsigned long long sack_episodes;
    unsigned long long rxmit_drop;
    unsigned long long rst_drop;
    unsigned long long oo_percent;
    unsigned long long reorder_percent;
    unsigned long long rxmit_percent;
};
_Static_assert(offsetof(struct ks_if_tcp_ecn_perf_stat, total_txpkts) == 0x0, "ks_if_tcp_ecn_perf_stat.total_txpkts offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_perf_stat, total_rxmitpkts) == 0x8, "ks_if_tcp_ecn_perf_stat.total_rxmitpkts offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_perf_stat, total_rxpkts) == 0x10, "ks_if_tcp_ecn_perf_stat.total_rxpkts offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_perf_stat, total_oopkts) == 0x18, "ks_if_tcp_ecn_perf_stat.total_oopkts offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_perf_stat, total_reorderpkts) == 0x20, "ks_if_tcp_ecn_perf_stat.total_reorderpkts offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_perf_stat, rtt_avg) == 0x28, "ks_if_tcp_ecn_perf_stat.rtt_avg offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_perf_stat, rtt_var) == 0x30, "ks_if_tcp_ecn_perf_stat.rtt_var offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_perf_stat, sack_episodes) == 0x38, "ks_if_tcp_ecn_perf_stat.sack_episodes offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_perf_stat, rxmit_drop) == 0x40, "ks_if_tcp_ecn_perf_stat.rxmit_drop offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_perf_stat, rst_drop) == 0x48, "ks_if_tcp_ecn_perf_stat.rst_drop offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_perf_stat, oo_percent) == 0x50, "ks_if_tcp_ecn_perf_stat.oo_percent offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_perf_stat, reorder_percent) == 0x58, "ks_if_tcp_ecn_perf_stat.reorder_percent offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_perf_stat, rxmit_percent) == 0x60, "ks_if_tcp_ecn_perf_stat.rxmit_percent offset");
_Static_assert(sizeof(struct ks_if_tcp_ecn_perf_stat) == 0x68, "ks_if_tcp_ecn_perf_stat size");

/* refs: 2 */
struct ks_if_tcp_ecn_stat {
    unsigned long long timestamp;
    unsigned long long ecn_client_setup;
    unsigned long long ecn_server_setup;
    unsigned long long ecn_client_success;
    unsigned long long ecn_server_success;
    unsigned long long ecn_peer_nosupport;
    unsigned long long ecn_syn_lost;
    unsigned long long ecn_synack_lost;
    unsigned long long ecn_recv_ce;
    unsigned long long ecn_recv_ece;
    unsigned long long ecn_conn_recv_ce;
    unsigned long long ecn_conn_recv_ece;
    unsigned long long ecn_conn_plnoce;
    unsigned long long ecn_conn_plce;
    unsigned long long ecn_conn_noplce;
    unsigned long long ecn_fallback_synloss;
    unsigned long long ecn_fallback_reorder;
    unsigned long long ecn_fallback_ce;
    unsigned long long ecn_off_conn;
    unsigned long long ecn_total_conn;
    unsigned long long ecn_fallback_droprst;
    unsigned long long ecn_fallback_droprxmt;
    unsigned long long ecn_fallback_synrst;
    struct ks_if_tcp_ecn_perf_stat ecn_on;
    struct ks_if_tcp_ecn_perf_stat ecn_off;
};
_Static_assert(offsetof(struct ks_if_tcp_ecn_stat, timestamp) == 0x0, "ks_if_tcp_ecn_stat.timestamp offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_stat, ecn_client_setup) == 0x8, "ks_if_tcp_ecn_stat.ecn_client_setup offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_stat, ecn_server_setup) == 0x10, "ks_if_tcp_ecn_stat.ecn_server_setup offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_stat, ecn_client_success) == 0x18, "ks_if_tcp_ecn_stat.ecn_client_success offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_stat, ecn_server_success) == 0x20, "ks_if_tcp_ecn_stat.ecn_server_success offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_stat, ecn_peer_nosupport) == 0x28, "ks_if_tcp_ecn_stat.ecn_peer_nosupport offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_stat, ecn_syn_lost) == 0x30, "ks_if_tcp_ecn_stat.ecn_syn_lost offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_stat, ecn_synack_lost) == 0x38, "ks_if_tcp_ecn_stat.ecn_synack_lost offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_stat, ecn_recv_ce) == 0x40, "ks_if_tcp_ecn_stat.ecn_recv_ce offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_stat, ecn_recv_ece) == 0x48, "ks_if_tcp_ecn_stat.ecn_recv_ece offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_stat, ecn_conn_recv_ce) == 0x50, "ks_if_tcp_ecn_stat.ecn_conn_recv_ce offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_stat, ecn_conn_recv_ece) == 0x58, "ks_if_tcp_ecn_stat.ecn_conn_recv_ece offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_stat, ecn_conn_plnoce) == 0x60, "ks_if_tcp_ecn_stat.ecn_conn_plnoce offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_stat, ecn_conn_plce) == 0x68, "ks_if_tcp_ecn_stat.ecn_conn_plce offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_stat, ecn_conn_noplce) == 0x70, "ks_if_tcp_ecn_stat.ecn_conn_noplce offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_stat, ecn_fallback_synloss) == 0x78, "ks_if_tcp_ecn_stat.ecn_fallback_synloss offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_stat, ecn_fallback_reorder) == 0x80, "ks_if_tcp_ecn_stat.ecn_fallback_reorder offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_stat, ecn_fallback_ce) == 0x88, "ks_if_tcp_ecn_stat.ecn_fallback_ce offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_stat, ecn_off_conn) == 0x90, "ks_if_tcp_ecn_stat.ecn_off_conn offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_stat, ecn_total_conn) == 0x98, "ks_if_tcp_ecn_stat.ecn_total_conn offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_stat, ecn_fallback_droprst) == 0xA0, "ks_if_tcp_ecn_stat.ecn_fallback_droprst offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_stat, ecn_fallback_droprxmt) == 0xA8, "ks_if_tcp_ecn_stat.ecn_fallback_droprxmt offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_stat, ecn_fallback_synrst) == 0xB0, "ks_if_tcp_ecn_stat.ecn_fallback_synrst offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_stat, ecn_on) == 0xB8, "ks_if_tcp_ecn_stat.ecn_on offset");
_Static_assert(offsetof(struct ks_if_tcp_ecn_stat, ecn_off) == 0x120, "ks_if_tcp_ecn_stat.ecn_off offset");
_Static_assert(sizeof(struct ks_if_tcp_ecn_stat) == 0x188, "ks_if_tcp_ecn_stat size");

/* refs: 1 */
struct ks_if_traffic_class {
    unsigned long long ifi_ibepackets;
    unsigned long long ifi_ibebytes;
    unsigned long long ifi_obepackets;
    unsigned long long ifi_obebytes;
    unsigned long long ifi_ibkpackets;
    unsigned long long ifi_ibkbytes;
    unsigned long long ifi_obkpackets;
    unsigned long long ifi_obkbytes;
    unsigned long long ifi_ivipackets;
    unsigned long long ifi_ivibytes;
    unsigned long long ifi_ovipackets;
    unsigned long long ifi_ovibytes;
    unsigned long long ifi_ivopackets;
    unsigned long long ifi_ivobytes;
    unsigned long long ifi_ovopackets;
    unsigned long long ifi_ovobytes;
    unsigned long long ifi_ipvpackets;
    unsigned long long ifi_ipvbytes;
    unsigned long long ifi_opvpackets;
    unsigned long long ifi_opvbytes;
};
_Static_assert(offsetof(struct ks_if_traffic_class, ifi_ibepackets) == 0x0, "ks_if_traffic_class.ifi_ibepackets offset");
_Static_assert(offsetof(struct ks_if_traffic_class, ifi_ibebytes) == 0x8, "ks_if_traffic_class.ifi_ibebytes offset");
_Static_assert(offsetof(struct ks_if_traffic_class, ifi_obepackets) == 0x10, "ks_if_traffic_class.ifi_obepackets offset");
_Static_assert(offsetof(struct ks_if_traffic_class, ifi_obebytes) == 0x18, "ks_if_traffic_class.ifi_obebytes offset");
_Static_assert(offsetof(struct ks_if_traffic_class, ifi_ibkpackets) == 0x20, "ks_if_traffic_class.ifi_ibkpackets offset");
_Static_assert(offsetof(struct ks_if_traffic_class, ifi_ibkbytes) == 0x28, "ks_if_traffic_class.ifi_ibkbytes offset");
_Static_assert(offsetof(struct ks_if_traffic_class, ifi_obkpackets) == 0x30, "ks_if_traffic_class.ifi_obkpackets offset");
_Static_assert(offsetof(struct ks_if_traffic_class, ifi_obkbytes) == 0x38, "ks_if_traffic_class.ifi_obkbytes offset");
_Static_assert(offsetof(struct ks_if_traffic_class, ifi_ivipackets) == 0x40, "ks_if_traffic_class.ifi_ivipackets offset");
_Static_assert(offsetof(struct ks_if_traffic_class, ifi_ivibytes) == 0x48, "ks_if_traffic_class.ifi_ivibytes offset");
_Static_assert(offsetof(struct ks_if_traffic_class, ifi_ovipackets) == 0x50, "ks_if_traffic_class.ifi_ovipackets offset");
_Static_assert(offsetof(struct ks_if_traffic_class, ifi_ovibytes) == 0x58, "ks_if_traffic_class.ifi_ovibytes offset");
_Static_assert(offsetof(struct ks_if_traffic_class, ifi_ivopackets) == 0x60, "ks_if_traffic_class.ifi_ivopackets offset");
_Static_assert(offsetof(struct ks_if_traffic_class, ifi_ivobytes) == 0x68, "ks_if_traffic_class.ifi_ivobytes offset");
_Static_assert(offsetof(struct ks_if_traffic_class, ifi_ovopackets) == 0x70, "ks_if_traffic_class.ifi_ovopackets offset");
_Static_assert(offsetof(struct ks_if_traffic_class, ifi_ovobytes) == 0x78, "ks_if_traffic_class.ifi_ovobytes offset");
_Static_assert(offsetof(struct ks_if_traffic_class, ifi_ipvpackets) == 0x80, "ks_if_traffic_class.ifi_ipvpackets offset");
_Static_assert(offsetof(struct ks_if_traffic_class, ifi_ipvbytes) == 0x88, "ks_if_traffic_class.ifi_ipvbytes offset");
_Static_assert(offsetof(struct ks_if_traffic_class, ifi_opvpackets) == 0x90, "ks_if_traffic_class.ifi_opvpackets offset");
_Static_assert(offsetof(struct ks_if_traffic_class, ifi_opvbytes) == 0x98, "ks_if_traffic_class.ifi_opvbytes offset");
_Static_assert(sizeof(struct ks_if_traffic_class) == 0xA0, "ks_if_traffic_class size");

/* refs: 8 */
struct ks_ifaddr {
    struct ks_lck_mtx_s ifa_lock;
    struct ks_os_refcnt ifa_refcnt;
    unsigned int ifa_debug;
    struct ks_sockaddr *ifa_addr;
    struct ks_sockaddr *ifa_dstaddr;
    struct ks_sockaddr *ifa_netmask;
    struct ks_ifnet *ifa_ifp;
    struct {
        struct ks_ifaddr *tqe_next;
        struct ks_ifaddr **tqe_prev;
    } ifa_link;
    void *ifa_rtrequest;
    unsigned int ifa_flags;
    int ifa_metric;
    void *ifa_free;
    void *ifa_del_wc;
    int ifa_del_waiters;
};
_Static_assert(offsetof(struct ks_ifaddr, ifa_lock) == 0x0, "ks_ifaddr.ifa_lock offset");
_Static_assert(offsetof(struct ks_ifaddr, ifa_refcnt) == 0x10, "ks_ifaddr.ifa_refcnt offset");
_Static_assert(offsetof(struct ks_ifaddr, ifa_debug) == 0x14, "ks_ifaddr.ifa_debug offset");
_Static_assert(offsetof(struct ks_ifaddr, ifa_addr) == 0x18, "ks_ifaddr.ifa_addr offset");
_Static_assert(offsetof(struct ks_ifaddr, ifa_dstaddr) == 0x20, "ks_ifaddr.ifa_dstaddr offset");
_Static_assert(offsetof(struct ks_ifaddr, ifa_netmask) == 0x28, "ks_ifaddr.ifa_netmask offset");
_Static_assert(offsetof(struct ks_ifaddr, ifa_ifp) == 0x30, "ks_ifaddr.ifa_ifp offset");
_Static_assert(offsetof(struct ks_ifaddr, ifa_link) == 0x38, "ks_ifaddr.ifa_link offset");
_Static_assert(offsetof(struct ks_ifaddr, ifa_rtrequest) == 0x48, "ks_ifaddr.ifa_rtrequest offset");
_Static_assert(offsetof(struct ks_ifaddr, ifa_flags) == 0x50, "ks_ifaddr.ifa_flags offset");
_Static_assert(offsetof(struct ks_ifaddr, ifa_metric) == 0x54, "ks_ifaddr.ifa_metric offset");
_Static_assert(offsetof(struct ks_ifaddr, ifa_free) == 0x58, "ks_ifaddr.ifa_free offset");
_Static_assert(offsetof(struct ks_ifaddr, ifa_del_wc) == 0x60, "ks_ifaddr.ifa_del_wc offset");
_Static_assert(offsetof(struct ks_ifaddr, ifa_del_waiters) == 0x68, "ks_ifaddr.ifa_del_waiters offset");
_Static_assert(sizeof(struct ks_ifaddr) == 0x70, "ks_ifaddr size");

/* refs: 1 */
struct ks_ifaddrhead {
    struct ks_ifaddr *tqh_first;
    struct ks_ifaddr **tqh_last;
};
_Static_assert(offsetof(struct ks_ifaddrhead, tqh_first) == 0x0, "ks_ifaddrhead.tqh_first offset");
_Static_assert(offsetof(struct ks_ifaddrhead, tqh_last) == 0x8, "ks_ifaddrhead.tqh_last offset");
_Static_assert(sizeof(struct ks_ifaddrhead) == 0x10, "ks_ifaddrhead size");

/* refs: 1 */
struct ks_ifclassq_disc_slot {
    unsigned int qid;
    void *cl;
};
_Static_assert(offsetof(struct ks_ifclassq_disc_slot, qid) == 0x0, "ks_ifclassq_disc_slot.qid offset");
_Static_assert(offsetof(struct ks_ifclassq_disc_slot, cl) == 0x8, "ks_ifclassq_disc_slot.cl offset");
_Static_assert(sizeof(struct ks_ifclassq_disc_slot) == 0x10, "ks_ifclassq_disc_slot size");

/* refs: 5 */
struct ks_sysctl_oid {
    struct ks_sysctl_oid_list *oid_parent;
    struct {
        struct ks_sysctl_oid *sle_next;
    } oid_link;
    int oid_number;
    int oid_kind;
    void *oid_arg1;
    int oid_arg2;
    const char *oid_name;
    int *oid_handler;
    const char *oid_fmt;
    const char *oid_descr;
    int oid_version;
    int oid_refcnt;
};
_Static_assert(offsetof(struct ks_sysctl_oid, oid_parent) == 0x0, "ks_sysctl_oid.oid_parent offset");
_Static_assert(offsetof(struct ks_sysctl_oid, oid_link) == 0x8, "ks_sysctl_oid.oid_link offset");
_Static_assert(offsetof(struct ks_sysctl_oid, oid_number) == 0x10, "ks_sysctl_oid.oid_number offset");
_Static_assert(offsetof(struct ks_sysctl_oid, oid_kind) == 0x14, "ks_sysctl_oid.oid_kind offset");
_Static_assert(offsetof(struct ks_sysctl_oid, oid_arg1) == 0x18, "ks_sysctl_oid.oid_arg1 offset");
_Static_assert(offsetof(struct ks_sysctl_oid, oid_arg2) == 0x20, "ks_sysctl_oid.oid_arg2 offset");
_Static_assert(offsetof(struct ks_sysctl_oid, oid_name) == 0x28, "ks_sysctl_oid.oid_name offset");
_Static_assert(offsetof(struct ks_sysctl_oid, oid_handler) == 0x30, "ks_sysctl_oid.oid_handler offset");
_Static_assert(offsetof(struct ks_sysctl_oid, oid_fmt) == 0x38, "ks_sysctl_oid.oid_fmt offset");
_Static_assert(offsetof(struct ks_sysctl_oid, oid_descr) == 0x40, "ks_sysctl_oid.oid_descr offset");
_Static_assert(offsetof(struct ks_sysctl_oid, oid_version) == 0x48, "ks_sysctl_oid.oid_version offset");
_Static_assert(offsetof(struct ks_sysctl_oid, oid_refcnt) == 0x4C, "ks_sysctl_oid.oid_refcnt offset");
_Static_assert(sizeof(struct ks_sysctl_oid) == 0x50, "ks_sysctl_oid size");

/* refs: 3 */
struct ks_sysctl_oid_list {
    struct ks_sysctl_oid *slh_first;
};
_Static_assert(offsetof(struct ks_sysctl_oid_list, slh_first) == 0x0, "ks_sysctl_oid_list.slh_first offset");
_Static_assert(sizeof(struct ks_sysctl_oid_list) == 0x8, "ks_sysctl_oid_list size");

/* refs: 2 */
struct ks_ifcq_sysctl_oid {
    struct ks_sysctl_oid_list ifcq_oid_list;
    struct ks_sysctl_oid ifcq_oid;
    char ifcq_name[0x20];
};
_Static_assert(offsetof(struct ks_ifcq_sysctl_oid, ifcq_oid_list) == 0x0, "ks_ifcq_sysctl_oid.ifcq_oid_list offset");
_Static_assert(offsetof(struct ks_ifcq_sysctl_oid, ifcq_oid) == 0x8, "ks_ifcq_sysctl_oid.ifcq_oid offset");
_Static_assert(offsetof(struct ks_ifcq_sysctl_oid, ifcq_name) == 0x58, "ks_ifcq_sysctl_oid.ifcq_name offset");
_Static_assert(sizeof(struct ks_ifcq_sysctl_oid) == 0x78, "ks_ifcq_sysctl_oid size");

/* refs: 1 */
struct ks_tb_regulator {
    unsigned long long tbr_rate_raw;
    unsigned int tbr_percent;
    long long tbr_rate;
    long long tbr_depth;
    long long tbr_token;
    long long tbr_filluptime;
    unsigned long long tbr_last;
};
_Static_assert(offsetof(struct ks_tb_regulator, tbr_rate_raw) == 0x0, "ks_tb_regulator.tbr_rate_raw offset");
_Static_assert(offsetof(struct ks_tb_regulator, tbr_percent) == 0x8, "ks_tb_regulator.tbr_percent offset");
_Static_assert(offsetof(struct ks_tb_regulator, tbr_rate) == 0x10, "ks_tb_regulator.tbr_rate offset");
_Static_assert(offsetof(struct ks_tb_regulator, tbr_depth) == 0x18, "ks_tb_regulator.tbr_depth offset");
_Static_assert(offsetof(struct ks_tb_regulator, tbr_token) == 0x20, "ks_tb_regulator.tbr_token offset");
_Static_assert(offsetof(struct ks_tb_regulator, tbr_filluptime) == 0x28, "ks_tb_regulator.tbr_filluptime offset");
_Static_assert(offsetof(struct ks_tb_regulator, tbr_last) == 0x30, "ks_tb_regulator.tbr_last offset");
_Static_assert(sizeof(struct ks_tb_regulator) == 0x38, "ks_tb_regulator size");

/* refs: 2 */
struct ks_ifclassq {
    struct ks_lck_mtx_s ifcq_lock;
    struct ks_os_refcnt ifcq_refcnt;
    struct ks_ifnet *ifcq_ifp;
    unsigned int ifcq_len;
    unsigned int ifcq_maxlen;
    struct ks_pktcntr ifcq_xmitcnt;
    struct ks_pktcntr ifcq_dropcnt;
    unsigned int ifcq_type;
    unsigned int ifcq_flags;
    unsigned int ifcq_sflags;
    unsigned int ifcq_target_qdelay;
    unsigned int ifcq_bytes;
    unsigned int ifcq_pkt_drop_limit;
    void *ifcq_disc;
    struct ks_pktsched_ops *ifcq_ops;
    struct ks_ifclassq_disc_slot ifcq_disc_slots[10];
    struct ks_tb_regulator ifcq_tbr;
    struct ks_ifcq_sysctl_oid ifcq_oid;
};
_Static_assert(offsetof(struct ks_ifclassq, ifcq_lock) == 0x0, "ks_ifclassq.ifcq_lock offset");
_Static_assert(offsetof(struct ks_ifclassq, ifcq_refcnt) == 0x10, "ks_ifclassq.ifcq_refcnt offset");
_Static_assert(offsetof(struct ks_ifclassq, ifcq_ifp) == 0x18, "ks_ifclassq.ifcq_ifp offset");
_Static_assert(offsetof(struct ks_ifclassq, ifcq_len) == 0x20, "ks_ifclassq.ifcq_len offset");
_Static_assert(offsetof(struct ks_ifclassq, ifcq_maxlen) == 0x24, "ks_ifclassq.ifcq_maxlen offset");
_Static_assert(offsetof(struct ks_ifclassq, ifcq_xmitcnt) == 0x28, "ks_ifclassq.ifcq_xmitcnt offset");
_Static_assert(offsetof(struct ks_ifclassq, ifcq_dropcnt) == 0x38, "ks_ifclassq.ifcq_dropcnt offset");
_Static_assert(offsetof(struct ks_ifclassq, ifcq_type) == 0x48, "ks_ifclassq.ifcq_type offset");
_Static_assert(offsetof(struct ks_ifclassq, ifcq_flags) == 0x4C, "ks_ifclassq.ifcq_flags offset");
_Static_assert(offsetof(struct ks_ifclassq, ifcq_sflags) == 0x50, "ks_ifclassq.ifcq_sflags offset");
_Static_assert(offsetof(struct ks_ifclassq, ifcq_target_qdelay) == 0x54, "ks_ifclassq.ifcq_target_qdelay offset");
_Static_assert(offsetof(struct ks_ifclassq, ifcq_bytes) == 0x58, "ks_ifclassq.ifcq_bytes offset");
_Static_assert(offsetof(struct ks_ifclassq, ifcq_pkt_drop_limit) == 0x5C, "ks_ifclassq.ifcq_pkt_drop_limit offset");
_Static_assert(offsetof(struct ks_ifclassq, ifcq_disc) == 0x60, "ks_ifclassq.ifcq_disc offset");
_Static_assert(offsetof(struct ks_ifclassq, ifcq_ops) == 0x68, "ks_ifclassq.ifcq_ops offset");
_Static_assert(offsetof(struct ks_ifclassq, ifcq_disc_slots) == 0x70, "ks_ifclassq.ifcq_disc_slots offset");
_Static_assert(offsetof(struct ks_ifclassq, ifcq_tbr) == 0x110, "ks_ifclassq.ifcq_tbr offset");
_Static_assert(offsetof(struct ks_ifclassq, ifcq_oid) == 0x148, "ks_ifclassq.ifcq_oid offset");
_Static_assert(sizeof(struct ks_ifclassq) == 0x1C0, "ks_ifclassq size");

/* refs: 5 */
struct ks_ifmultiaddr {
    struct ks_lck_mtx_s ifma_lock;
    unsigned int ifma_refcount;
    unsigned int ifma_anoncnt;
    unsigned int ifma_reqcnt;
    unsigned int ifma_debug;
    unsigned int ifma_flags;
    struct {
        struct ks_ifmultiaddr *le_next;
        struct ks_ifmultiaddr **le_prev;
    } ifma_link;
    struct ks_sockaddr *ifma_addr;
    struct ks_ifmultiaddr *ifma_ll;
    struct ks_ifnet *ifma_ifp;
    void *ifma_protospec;
    void *ifma_trace;
};
_Static_assert(offsetof(struct ks_ifmultiaddr, ifma_lock) == 0x0, "ks_ifmultiaddr.ifma_lock offset");
_Static_assert(offsetof(struct ks_ifmultiaddr, ifma_refcount) == 0x10, "ks_ifmultiaddr.ifma_refcount offset");
_Static_assert(offsetof(struct ks_ifmultiaddr, ifma_anoncnt) == 0x14, "ks_ifmultiaddr.ifma_anoncnt offset");
_Static_assert(offsetof(struct ks_ifmultiaddr, ifma_reqcnt) == 0x18, "ks_ifmultiaddr.ifma_reqcnt offset");
_Static_assert(offsetof(struct ks_ifmultiaddr, ifma_debug) == 0x1C, "ks_ifmultiaddr.ifma_debug offset");
_Static_assert(offsetof(struct ks_ifmultiaddr, ifma_flags) == 0x20, "ks_ifmultiaddr.ifma_flags offset");
_Static_assert(offsetof(struct ks_ifmultiaddr, ifma_link) == 0x28, "ks_ifmultiaddr.ifma_link offset");
_Static_assert(offsetof(struct ks_ifmultiaddr, ifma_addr) == 0x38, "ks_ifmultiaddr.ifma_addr offset");
_Static_assert(offsetof(struct ks_ifmultiaddr, ifma_ll) == 0x40, "ks_ifmultiaddr.ifma_ll offset");
_Static_assert(offsetof(struct ks_ifmultiaddr, ifma_ifp) == 0x48, "ks_ifmultiaddr.ifma_ifp offset");
_Static_assert(offsetof(struct ks_ifmultiaddr, ifma_protospec) == 0x50, "ks_ifmultiaddr.ifma_protospec offset");
_Static_assert(offsetof(struct ks_ifmultiaddr, ifma_trace) == 0x58, "ks_ifmultiaddr.ifma_trace offset");
_Static_assert(sizeof(struct ks_ifmultiaddr) == 0x60, "ks_ifmultiaddr size");

/* refs: 1 */
struct ks_ifmultihead {
    struct ks_ifmultiaddr *lh_first;
};
_Static_assert(offsetof(struct ks_ifmultihead, lh_first) == 0x0, "ks_ifmultihead.lh_first offset");
_Static_assert(sizeof(struct ks_ifmultihead) == 0x8, "ks_ifmultihead size");

/* refs: 1 */
struct ks_ifnet_filter_head {
    struct ks_ifnet_filter *tqh_first;
    struct ks_ifnet_filter **tqh_last;
};
_Static_assert(offsetof(struct ks_ifnet_filter_head, tqh_first) == 0x0, "ks_ifnet_filter_head.tqh_first offset");
_Static_assert(offsetof(struct ks_ifnet_filter_head, tqh_last) == 0x8, "ks_ifnet_filter_head.tqh_last offset");
_Static_assert(sizeof(struct ks_ifnet_filter_head) == 0x10, "ks_ifnet_filter_head size");

/* refs: 1 */
struct ks_ll_reach_tree {
    struct ks_if_llreach *rbh_root;
};
_Static_assert(offsetof(struct ks_ll_reach_tree, rbh_root) == 0x0, "ks_ll_reach_tree.rbh_root offset");
_Static_assert(sizeof(struct ks_ll_reach_tree) == 0x8, "ks_ll_reach_tree size");

/* refs: 2 */
struct ks_route {
    struct ks_rtentry *ro_rt;
    struct ks_ifaddr *ro_srcia;
    unsigned int ro_flags;
    struct ks_sockaddr ro_dst;
};
_Static_assert(offsetof(struct ks_route, ro_rt) == 0x0, "ks_route.ro_rt offset");
_Static_assert(offsetof(struct ks_route, ro_srcia) == 0x8, "ks_route.ro_srcia offset");
_Static_assert(offsetof(struct ks_route, ro_flags) == 0x10, "ks_route.ro_flags offset");
_Static_assert(offsetof(struct ks_route, ro_dst) == 0x14, "ks_route.ro_dst offset");
_Static_assert(sizeof(struct ks_route) == 0x28, "ks_route size");

/* refs: 1 */
struct ks_route_in6 {
    struct ks_rtentry *ro_rt;
    struct ks_ifaddr *ro_srcia;
    unsigned int ro_flags;
    struct ks_sockaddr_in6 ro_dst;
};
_Static_assert(offsetof(struct ks_route_in6, ro_rt) == 0x0, "ks_route_in6.ro_rt offset");
_Static_assert(offsetof(struct ks_route_in6, ro_srcia) == 0x8, "ks_route_in6.ro_srcia offset");
_Static_assert(offsetof(struct ks_route_in6, ro_flags) == 0x10, "ks_route_in6.ro_flags offset");
_Static_assert(offsetof(struct ks_route_in6, ro_dst) == 0x14, "ks_route_in6.ro_dst offset");
_Static_assert(sizeof(struct ks_route_in6) == 0x30, "ks_route_in6 size");

/* refs: 31 */
struct ks_ifnet {
    struct ks_lck_rw_s if_lock;
    void *if_softc;
    const char *if_name;
    const char *if_xname;
    struct ks_if_description if_desc;
    struct {
        struct ks_ifnet *tqe_next;
        struct ks_ifnet **tqe_prev;
    } if_link;
    struct {
        struct ks_ifnet *tqe_next;
        struct ks_ifnet **tqe_prev;
    } if_detaching_link;
    struct {
        struct ks_ifnet *tqe_next;
        struct ks_ifnet **tqe_prev;
    } if_ordered_link;
    struct ks_lck_mtx_s if_ref_lock;
    unsigned int if_refflags;
    struct ks_os_refcnt if_refio;
    unsigned int if_threads_pending;
    unsigned int if_datamov;
    unsigned int if_suspend;
    struct ks_ifaddrhead if_addrhead;
    struct ks_ifaddr *if_lladdr;
    unsigned int if_qosmarking_mode;
    int if_pcount;
    struct ks_bpf_if *if_bpf;
    unsigned short if_index;
    short if_unit;
    short if_timer;
    short if_flags;
    unsigned int if_eflags;
    unsigned int if_xflags;
    int if_capabilities;
    int if_capenable;
    void *if_linkmib;
    unsigned int if_linkmiblen;
    struct ks_if_data_internal if_data __attribute__((aligned(8)));
    unsigned int if_family;
    unsigned int if_subfamily;
    unsigned int peer_egress_functional_type;
    unsigned long if_family_cookie;
    int *if_input_dlil;
    int *if_output_dlil;
    void *if_start;
    int *if_output;
    int *if_pre_enqueue;
    int *if_output_ctl;
    void *if_input_poll;
    int *if_input_ctl;
    int *if_ioctl;
    int *if_set_bpf_tap;
    void *if_free;
    int *if_demux;
    void *if_event;
    int *if_framer_legacy;
    int *if_framer;
    int *if_add_proto;
    int *if_del_proto;
    int *if_check_multi;
    unsigned long if_proto_hash_count;
    struct ks_proto_hash_entry *if_proto_hash;
    void *if_detach;
    unsigned int if_flowhash;
    struct ks_lck_mtx_s if_start_lock;
    unsigned int if_start_flags;
    unsigned int if_start_req;
    unsigned char if_start_embryonic;
    unsigned char if_start_active;
    unsigned short if_start_delayed;
    unsigned short if_start_delay_qlen;
    unsigned short if_start_delay_idle;
    unsigned long long if_start_delay_swin;
    unsigned int if_start_delay_cnt;
    unsigned int if_start_delay_timeout;
    struct ks_timespec if_start_cycle;
    struct ks_thread *if_start_thread;
    struct ks_ifclassq *if_snd;
    unsigned int if_output_sched_model;
    struct ks_if_bandwidths if_output_bw;
    struct ks_if_bandwidths if_input_bw;
    struct ks_if_latencies if_output_lt;
    struct ks_if_latencies if_input_lt;
    struct ks_lck_mtx_s if_flt_lock;
    unsigned int if_flt_busy;
    unsigned int if_flt_waiters;
    struct ks_ifnet_filter_head if_flt_head;
    unsigned int if_flt_non_os_count;
    unsigned int if_flt_no_tso_count;
    struct ks_ifmultihead if_multiaddrs;
    unsigned int if_updatemcasts;
    int if_amcount;
    struct ks_lck_mtx_s if_addrconfig_lock;
    struct ks_in_multi *if_allhostsinm;
    struct ks_lck_mtx_s if_poll_lock;
    struct ks_if_poll_params rxpoll_params;
    struct ks_dlil_threading_info *if_inp;
    struct ks_thread_call *if_dt_tcall;
    struct {
        unsigned int length;
        unsigned char *ptr;
    } if_broadcast;
    struct ks_pfi_kif *if_pf_kif;
    struct ks_nexus_ifnet_ops *if_na_ops;
    struct ks_nexus_netif_adapter *if_na;
    struct ks_if_nexus_netif if_nx_netif;
    struct ks_if_nexus_flowswitch if_nx_flowswitch;
    unsigned short if_tx_headroom;
    unsigned short if_tx_trailer;
    unsigned int if_rx_mit_ival;
    unsigned int if_start_waiters;
    void *if_save_start;
    int *if_save_output;
    void *if_fsw_rx_cb;
    void *if_fsw_rx_cb_arg;
    unsigned int if_fsw_rx_cb_ref;
    unsigned int if_delegate_parent_ref;
    struct ks_ifnet *if_delegate_parent;
    struct ks_lck_mtx_s if_delegate_lock;
    void *if_detach_notify;
    void *if_detach_notify_arg;
    struct ks_lck_mtx_s if_cached_route_lock;
    unsigned int if_fwd_cacheok;
    struct ks_route if_fwd_route;
    struct ks_route if_src_route;
    struct ks_route_in6 if_src_route6;
    struct ks_lck_rw_s if_llreach_lock;
    struct ks_ll_reach_tree if_ll_srcs;
    void *if_bridge;
    unsigned int if_idle_flags;
    unsigned int if_idle_new_flags;
    unsigned int if_idle_new_flags_mask;
    unsigned int if_route_refcnt;
    unsigned int if_rt_sendts;
    struct ks_if_traffic_class if_tc __attribute__((aligned(8)));
    struct ks_igmp_ifinfo *if_igi;
    struct ks_mld_ifinfo *if_mli;
    struct ks_tcpstat_local *if_tcp_stat;
    struct ks_udpstat_local *if_udp_stat;
    struct {
        int level;
        unsigned int flags;
        int category;
        int subcategory;
    } if_log;
    struct {
        struct ks_ifnet *ifp;
        unsigned int type;
        unsigned int family;
        unsigned int subfamily;
        unsigned int expensive : 1; /* bit offset 160 */
        unsigned int constrained : 1; /* bit offset 161 */
        unsigned int ultra_constrained : 1; /* bit offset 162 */
    } if_delegated;
    unsigned char (*if_agentids)[0x10];
    unsigned int if_agentcount;
    unsigned int if_low_power_gencnt;
    unsigned int if_generation;
    unsigned int if_fg_sendts;
    unsigned long long if_data_threshold;
    long long if_sndbyte_total __attribute__((aligned(8)));
    long long if_sndbyte_unsent __attribute__((aligned(8)));
    unsigned int if_unsent_data_cnt;
    int if_inet6_ioctl_busy;
    struct ks_lck_mtx_s if_inet6_ioctl_lock;
    struct ks_lck_rw_s if_inetdata_lock;
    struct ks_in_ifextra *if_inetdata;
    struct ks_lck_rw_s if_inet6data_lock;
    struct ks_in6_ifextra *if_inet6data;
    struct ks_lck_rw_s if_link_status_lock;
    struct ks_if_link_status *if_link_status;
    struct ks_if_interface_state if_interface_state;
    unsigned long long if_link_heuristics_start_time;
    unsigned long long if_congested_link_start_time;
    unsigned long long if_lqmstate_start_time;
    struct ks_thread_call *if_link_heuristics_tcall;
    struct ks_if_tcp_ecn_stat *if_ipv4_stat;
    struct ks_if_tcp_ecn_stat *if_ipv6_stat;
    struct {
        struct ks_ns_token *lh_first;
    } if_netns_tokens;
    struct ks_if_lim_perf_stat if_lim_stat;
    unsigned int if_tcp_kao_max;
    unsigned int if_tcp_kao_cnt;
    struct ks_netem *if_input_netem;
    struct ks_netem *if_output_netem;
    unsigned char if_ipv6_router_mode;
    unsigned char if_estimated_up_bucket;
    unsigned char if_estimated_down_bucket;
    unsigned char if_radio_type;
    unsigned char if_radio_channel;
    unsigned char network_id[0x20];
    unsigned char network_id_len;
    unsigned char if_l4s_mode;
    _Atomic _Bool if_mcast_add_signaled;
    _Atomic _Bool if_mcast_del_signaled;
    unsigned int if_inet_traffic_rule_count;
    unsigned int if_eth_traffic_rule_count;
    unsigned int if_traffic_rule_genid;
    unsigned long long if_creation_generation_id;
};
_Static_assert(offsetof(struct ks_ifnet, if_lock) == 0x0, "ks_ifnet.if_lock offset");
_Static_assert(offsetof(struct ks_ifnet, if_softc) == 0x10, "ks_ifnet.if_softc offset");
_Static_assert(offsetof(struct ks_ifnet, if_name) == 0x18, "ks_ifnet.if_name offset");
_Static_assert(offsetof(struct ks_ifnet, if_xname) == 0x20, "ks_ifnet.if_xname offset");
_Static_assert(offsetof(struct ks_ifnet, if_desc) == 0x28, "ks_ifnet.if_desc offset");
_Static_assert(offsetof(struct ks_ifnet, if_link) == 0x38, "ks_ifnet.if_link offset");
_Static_assert(offsetof(struct ks_ifnet, if_detaching_link) == 0x48, "ks_ifnet.if_detaching_link offset");
_Static_assert(offsetof(struct ks_ifnet, if_ordered_link) == 0x58, "ks_ifnet.if_ordered_link offset");
_Static_assert(offsetof(struct ks_ifnet, if_ref_lock) == 0x68, "ks_ifnet.if_ref_lock offset");
_Static_assert(offsetof(struct ks_ifnet, if_refflags) == 0x78, "ks_ifnet.if_refflags offset");
_Static_assert(offsetof(struct ks_ifnet, if_refio) == 0x7C, "ks_ifnet.if_refio offset");
_Static_assert(offsetof(struct ks_ifnet, if_threads_pending) == 0x80, "ks_ifnet.if_threads_pending offset");
_Static_assert(offsetof(struct ks_ifnet, if_datamov) == 0x84, "ks_ifnet.if_datamov offset");
_Static_assert(offsetof(struct ks_ifnet, if_suspend) == 0x88, "ks_ifnet.if_suspend offset");
_Static_assert(offsetof(struct ks_ifnet, if_addrhead) == 0x90, "ks_ifnet.if_addrhead offset");
_Static_assert(offsetof(struct ks_ifnet, if_lladdr) == 0xA0, "ks_ifnet.if_lladdr offset");
_Static_assert(offsetof(struct ks_ifnet, if_qosmarking_mode) == 0xA8, "ks_ifnet.if_qosmarking_mode offset");
_Static_assert(offsetof(struct ks_ifnet, if_pcount) == 0xAC, "ks_ifnet.if_pcount offset");
_Static_assert(offsetof(struct ks_ifnet, if_bpf) == 0xB0, "ks_ifnet.if_bpf offset");
_Static_assert(offsetof(struct ks_ifnet, if_index) == 0xB8, "ks_ifnet.if_index offset");
_Static_assert(offsetof(struct ks_ifnet, if_unit) == 0xBA, "ks_ifnet.if_unit offset");
_Static_assert(offsetof(struct ks_ifnet, if_timer) == 0xBC, "ks_ifnet.if_timer offset");
_Static_assert(offsetof(struct ks_ifnet, if_flags) == 0xBE, "ks_ifnet.if_flags offset");
_Static_assert(offsetof(struct ks_ifnet, if_eflags) == 0xC0, "ks_ifnet.if_eflags offset");
_Static_assert(offsetof(struct ks_ifnet, if_xflags) == 0xC4, "ks_ifnet.if_xflags offset");
_Static_assert(offsetof(struct ks_ifnet, if_capabilities) == 0xC8, "ks_ifnet.if_capabilities offset");
_Static_assert(offsetof(struct ks_ifnet, if_capenable) == 0xCC, "ks_ifnet.if_capenable offset");
_Static_assert(offsetof(struct ks_ifnet, if_linkmib) == 0xD0, "ks_ifnet.if_linkmib offset");
_Static_assert(offsetof(struct ks_ifnet, if_linkmiblen) == 0xD8, "ks_ifnet.if_linkmiblen offset");
_Static_assert(offsetof(struct ks_ifnet, if_data) == 0xE0, "ks_ifnet.if_data offset");
_Static_assert(offsetof(struct ks_ifnet, if_family) == 0x208, "ks_ifnet.if_family offset");
_Static_assert(offsetof(struct ks_ifnet, if_subfamily) == 0x20C, "ks_ifnet.if_subfamily offset");
_Static_assert(offsetof(struct ks_ifnet, peer_egress_functional_type) == 0x210, "ks_ifnet.peer_egress_functional_type offset");
_Static_assert(offsetof(struct ks_ifnet, if_family_cookie) == 0x218, "ks_ifnet.if_family_cookie offset");
_Static_assert(offsetof(struct ks_ifnet, if_input_dlil) == 0x220, "ks_ifnet.if_input_dlil offset");
_Static_assert(offsetof(struct ks_ifnet, if_output_dlil) == 0x228, "ks_ifnet.if_output_dlil offset");
_Static_assert(offsetof(struct ks_ifnet, if_start) == 0x230, "ks_ifnet.if_start offset");
_Static_assert(offsetof(struct ks_ifnet, if_output) == 0x238, "ks_ifnet.if_output offset");
_Static_assert(offsetof(struct ks_ifnet, if_pre_enqueue) == 0x240, "ks_ifnet.if_pre_enqueue offset");
_Static_assert(offsetof(struct ks_ifnet, if_output_ctl) == 0x248, "ks_ifnet.if_output_ctl offset");
_Static_assert(offsetof(struct ks_ifnet, if_input_poll) == 0x250, "ks_ifnet.if_input_poll offset");
_Static_assert(offsetof(struct ks_ifnet, if_input_ctl) == 0x258, "ks_ifnet.if_input_ctl offset");
_Static_assert(offsetof(struct ks_ifnet, if_ioctl) == 0x260, "ks_ifnet.if_ioctl offset");
_Static_assert(offsetof(struct ks_ifnet, if_set_bpf_tap) == 0x268, "ks_ifnet.if_set_bpf_tap offset");
_Static_assert(offsetof(struct ks_ifnet, if_free) == 0x270, "ks_ifnet.if_free offset");
_Static_assert(offsetof(struct ks_ifnet, if_demux) == 0x278, "ks_ifnet.if_demux offset");
_Static_assert(offsetof(struct ks_ifnet, if_event) == 0x280, "ks_ifnet.if_event offset");
_Static_assert(offsetof(struct ks_ifnet, if_framer_legacy) == 0x288, "ks_ifnet.if_framer_legacy offset");
_Static_assert(offsetof(struct ks_ifnet, if_framer) == 0x290, "ks_ifnet.if_framer offset");
_Static_assert(offsetof(struct ks_ifnet, if_add_proto) == 0x298, "ks_ifnet.if_add_proto offset");
_Static_assert(offsetof(struct ks_ifnet, if_del_proto) == 0x2A0, "ks_ifnet.if_del_proto offset");
_Static_assert(offsetof(struct ks_ifnet, if_check_multi) == 0x2A8, "ks_ifnet.if_check_multi offset");
_Static_assert(offsetof(struct ks_ifnet, if_proto_hash_count) == 0x2B0, "ks_ifnet.if_proto_hash_count offset");
_Static_assert(offsetof(struct ks_ifnet, if_proto_hash) == 0x2B8, "ks_ifnet.if_proto_hash offset");
_Static_assert(offsetof(struct ks_ifnet, if_detach) == 0x2C0, "ks_ifnet.if_detach offset");
_Static_assert(offsetof(struct ks_ifnet, if_flowhash) == 0x2C8, "ks_ifnet.if_flowhash offset");
_Static_assert(offsetof(struct ks_ifnet, if_start_lock) == 0x2D0, "ks_ifnet.if_start_lock offset");
_Static_assert(offsetof(struct ks_ifnet, if_start_flags) == 0x2E0, "ks_ifnet.if_start_flags offset");
_Static_assert(offsetof(struct ks_ifnet, if_start_req) == 0x2E4, "ks_ifnet.if_start_req offset");
_Static_assert(offsetof(struct ks_ifnet, if_start_embryonic) == 0x2E8, "ks_ifnet.if_start_embryonic offset");
_Static_assert(offsetof(struct ks_ifnet, if_start_active) == 0x2E9, "ks_ifnet.if_start_active offset");
_Static_assert(offsetof(struct ks_ifnet, if_start_delayed) == 0x2EA, "ks_ifnet.if_start_delayed offset");
_Static_assert(offsetof(struct ks_ifnet, if_start_delay_qlen) == 0x2EC, "ks_ifnet.if_start_delay_qlen offset");
_Static_assert(offsetof(struct ks_ifnet, if_start_delay_idle) == 0x2EE, "ks_ifnet.if_start_delay_idle offset");
_Static_assert(offsetof(struct ks_ifnet, if_start_delay_swin) == 0x2F0, "ks_ifnet.if_start_delay_swin offset");
_Static_assert(offsetof(struct ks_ifnet, if_start_delay_cnt) == 0x2F8, "ks_ifnet.if_start_delay_cnt offset");
_Static_assert(offsetof(struct ks_ifnet, if_start_delay_timeout) == 0x2FC, "ks_ifnet.if_start_delay_timeout offset");
_Static_assert(offsetof(struct ks_ifnet, if_start_cycle) == 0x300, "ks_ifnet.if_start_cycle offset");
_Static_assert(offsetof(struct ks_ifnet, if_start_thread) == 0x310, "ks_ifnet.if_start_thread offset");
_Static_assert(offsetof(struct ks_ifnet, if_snd) == 0x318, "ks_ifnet.if_snd offset");
_Static_assert(offsetof(struct ks_ifnet, if_output_sched_model) == 0x320, "ks_ifnet.if_output_sched_model offset");
_Static_assert(offsetof(struct ks_ifnet, if_output_bw) == 0x328, "ks_ifnet.if_output_bw offset");
_Static_assert(offsetof(struct ks_ifnet, if_input_bw) == 0x338, "ks_ifnet.if_input_bw offset");
_Static_assert(offsetof(struct ks_ifnet, if_output_lt) == 0x348, "ks_ifnet.if_output_lt offset");
_Static_assert(offsetof(struct ks_ifnet, if_input_lt) == 0x358, "ks_ifnet.if_input_lt offset");
_Static_assert(offsetof(struct ks_ifnet, if_flt_lock) == 0x368, "ks_ifnet.if_flt_lock offset");
_Static_assert(offsetof(struct ks_ifnet, if_flt_busy) == 0x378, "ks_ifnet.if_flt_busy offset");
_Static_assert(offsetof(struct ks_ifnet, if_flt_waiters) == 0x37C, "ks_ifnet.if_flt_waiters offset");
_Static_assert(offsetof(struct ks_ifnet, if_flt_head) == 0x380, "ks_ifnet.if_flt_head offset");
_Static_assert(offsetof(struct ks_ifnet, if_flt_non_os_count) == 0x390, "ks_ifnet.if_flt_non_os_count offset");
_Static_assert(offsetof(struct ks_ifnet, if_flt_no_tso_count) == 0x394, "ks_ifnet.if_flt_no_tso_count offset");
_Static_assert(offsetof(struct ks_ifnet, if_multiaddrs) == 0x398, "ks_ifnet.if_multiaddrs offset");
_Static_assert(offsetof(struct ks_ifnet, if_updatemcasts) == 0x3A0, "ks_ifnet.if_updatemcasts offset");
_Static_assert(offsetof(struct ks_ifnet, if_amcount) == 0x3A4, "ks_ifnet.if_amcount offset");
_Static_assert(offsetof(struct ks_ifnet, if_addrconfig_lock) == 0x3A8, "ks_ifnet.if_addrconfig_lock offset");
_Static_assert(offsetof(struct ks_ifnet, if_allhostsinm) == 0x3B8, "ks_ifnet.if_allhostsinm offset");
_Static_assert(offsetof(struct ks_ifnet, if_poll_lock) == 0x3C0, "ks_ifnet.if_poll_lock offset");
_Static_assert(offsetof(struct ks_ifnet, rxpoll_params) == 0x3D0, "ks_ifnet.rxpoll_params offset");
_Static_assert(offsetof(struct ks_ifnet, if_inp) == 0x4D0, "ks_ifnet.if_inp offset");
_Static_assert(offsetof(struct ks_ifnet, if_dt_tcall) == 0x4D8, "ks_ifnet.if_dt_tcall offset");
_Static_assert(offsetof(struct ks_ifnet, if_broadcast) == 0x4E0, "ks_ifnet.if_broadcast offset");
_Static_assert(offsetof(struct ks_ifnet, if_pf_kif) == 0x4F0, "ks_ifnet.if_pf_kif offset");
_Static_assert(offsetof(struct ks_ifnet, if_na_ops) == 0x4F8, "ks_ifnet.if_na_ops offset");
_Static_assert(offsetof(struct ks_ifnet, if_na) == 0x500, "ks_ifnet.if_na offset");
_Static_assert(offsetof(struct ks_ifnet, if_nx_netif) == 0x508, "ks_ifnet.if_nx_netif offset");
_Static_assert(offsetof(struct ks_ifnet, if_nx_flowswitch) == 0x538, "ks_ifnet.if_nx_flowswitch offset");
_Static_assert(offsetof(struct ks_ifnet, if_tx_headroom) == 0x56C, "ks_ifnet.if_tx_headroom offset");
_Static_assert(offsetof(struct ks_ifnet, if_tx_trailer) == 0x56E, "ks_ifnet.if_tx_trailer offset");
_Static_assert(offsetof(struct ks_ifnet, if_rx_mit_ival) == 0x570, "ks_ifnet.if_rx_mit_ival offset");
_Static_assert(offsetof(struct ks_ifnet, if_start_waiters) == 0x574, "ks_ifnet.if_start_waiters offset");
_Static_assert(offsetof(struct ks_ifnet, if_save_start) == 0x578, "ks_ifnet.if_save_start offset");
_Static_assert(offsetof(struct ks_ifnet, if_save_output) == 0x580, "ks_ifnet.if_save_output offset");
_Static_assert(offsetof(struct ks_ifnet, if_fsw_rx_cb) == 0x588, "ks_ifnet.if_fsw_rx_cb offset");
_Static_assert(offsetof(struct ks_ifnet, if_fsw_rx_cb_arg) == 0x590, "ks_ifnet.if_fsw_rx_cb_arg offset");
_Static_assert(offsetof(struct ks_ifnet, if_fsw_rx_cb_ref) == 0x598, "ks_ifnet.if_fsw_rx_cb_ref offset");
_Static_assert(offsetof(struct ks_ifnet, if_delegate_parent_ref) == 0x59C, "ks_ifnet.if_delegate_parent_ref offset");
_Static_assert(offsetof(struct ks_ifnet, if_delegate_parent) == 0x5A0, "ks_ifnet.if_delegate_parent offset");
_Static_assert(offsetof(struct ks_ifnet, if_delegate_lock) == 0x5A8, "ks_ifnet.if_delegate_lock offset");
_Static_assert(offsetof(struct ks_ifnet, if_detach_notify) == 0x5B8, "ks_ifnet.if_detach_notify offset");
_Static_assert(offsetof(struct ks_ifnet, if_detach_notify_arg) == 0x5C0, "ks_ifnet.if_detach_notify_arg offset");
_Static_assert(offsetof(struct ks_ifnet, if_cached_route_lock) == 0x5C8, "ks_ifnet.if_cached_route_lock offset");
_Static_assert(offsetof(struct ks_ifnet, if_fwd_cacheok) == 0x5D8, "ks_ifnet.if_fwd_cacheok offset");
_Static_assert(offsetof(struct ks_ifnet, if_fwd_route) == 0x5E0, "ks_ifnet.if_fwd_route offset");
_Static_assert(offsetof(struct ks_ifnet, if_src_route) == 0x608, "ks_ifnet.if_src_route offset");
_Static_assert(offsetof(struct ks_ifnet, if_src_route6) == 0x630, "ks_ifnet.if_src_route6 offset");
_Static_assert(offsetof(struct ks_ifnet, if_llreach_lock) == 0x660, "ks_ifnet.if_llreach_lock offset");
_Static_assert(offsetof(struct ks_ifnet, if_ll_srcs) == 0x670, "ks_ifnet.if_ll_srcs offset");
_Static_assert(offsetof(struct ks_ifnet, if_bridge) == 0x678, "ks_ifnet.if_bridge offset");
_Static_assert(offsetof(struct ks_ifnet, if_idle_flags) == 0x680, "ks_ifnet.if_idle_flags offset");
_Static_assert(offsetof(struct ks_ifnet, if_idle_new_flags) == 0x684, "ks_ifnet.if_idle_new_flags offset");
_Static_assert(offsetof(struct ks_ifnet, if_idle_new_flags_mask) == 0x688, "ks_ifnet.if_idle_new_flags_mask offset");
_Static_assert(offsetof(struct ks_ifnet, if_route_refcnt) == 0x68C, "ks_ifnet.if_route_refcnt offset");
_Static_assert(offsetof(struct ks_ifnet, if_rt_sendts) == 0x690, "ks_ifnet.if_rt_sendts offset");
_Static_assert(offsetof(struct ks_ifnet, if_tc) == 0x698, "ks_ifnet.if_tc offset");
_Static_assert(offsetof(struct ks_ifnet, if_igi) == 0x738, "ks_ifnet.if_igi offset");
_Static_assert(offsetof(struct ks_ifnet, if_mli) == 0x740, "ks_ifnet.if_mli offset");
_Static_assert(offsetof(struct ks_ifnet, if_tcp_stat) == 0x748, "ks_ifnet.if_tcp_stat offset");
_Static_assert(offsetof(struct ks_ifnet, if_udp_stat) == 0x750, "ks_ifnet.if_udp_stat offset");
_Static_assert(offsetof(struct ks_ifnet, if_log) == 0x758, "ks_ifnet.if_log offset");
_Static_assert(offsetof(struct ks_ifnet, if_delegated) == 0x768, "ks_ifnet.if_delegated offset");
_Static_assert(offsetof(struct ks_ifnet, if_agentids) == 0x780, "ks_ifnet.if_agentids offset");
_Static_assert(offsetof(struct ks_ifnet, if_agentcount) == 0x788, "ks_ifnet.if_agentcount offset");
_Static_assert(offsetof(struct ks_ifnet, if_low_power_gencnt) == 0x78C, "ks_ifnet.if_low_power_gencnt offset");
_Static_assert(offsetof(struct ks_ifnet, if_generation) == 0x790, "ks_ifnet.if_generation offset");
_Static_assert(offsetof(struct ks_ifnet, if_fg_sendts) == 0x794, "ks_ifnet.if_fg_sendts offset");
_Static_assert(offsetof(struct ks_ifnet, if_data_threshold) == 0x798, "ks_ifnet.if_data_threshold offset");
_Static_assert(offsetof(struct ks_ifnet, if_sndbyte_total) == 0x7A0, "ks_ifnet.if_sndbyte_total offset");
_Static_assert(offsetof(struct ks_ifnet, if_sndbyte_unsent) == 0x7A8, "ks_ifnet.if_sndbyte_unsent offset");
_Static_assert(offsetof(struct ks_ifnet, if_unsent_data_cnt) == 0x7B0, "ks_ifnet.if_unsent_data_cnt offset");
_Static_assert(offsetof(struct ks_ifnet, if_inet6_ioctl_busy) == 0x7B4, "ks_ifnet.if_inet6_ioctl_busy offset");
_Static_assert(offsetof(struct ks_ifnet, if_inet6_ioctl_lock) == 0x7B8, "ks_ifnet.if_inet6_ioctl_lock offset");
_Static_assert(offsetof(struct ks_ifnet, if_inetdata_lock) == 0x7C8, "ks_ifnet.if_inetdata_lock offset");
_Static_assert(offsetof(struct ks_ifnet, if_inetdata) == 0x7D8, "ks_ifnet.if_inetdata offset");
_Static_assert(offsetof(struct ks_ifnet, if_inet6data_lock) == 0x7E0, "ks_ifnet.if_inet6data_lock offset");
_Static_assert(offsetof(struct ks_ifnet, if_inet6data) == 0x7F0, "ks_ifnet.if_inet6data offset");
_Static_assert(offsetof(struct ks_ifnet, if_link_status_lock) == 0x7F8, "ks_ifnet.if_link_status_lock offset");
_Static_assert(offsetof(struct ks_ifnet, if_link_status) == 0x808, "ks_ifnet.if_link_status offset");
_Static_assert(offsetof(struct ks_ifnet, if_interface_state) == 0x810, "ks_ifnet.if_interface_state offset");
_Static_assert(offsetof(struct ks_ifnet, if_link_heuristics_start_time) == 0x818, "ks_ifnet.if_link_heuristics_start_time offset");
_Static_assert(offsetof(struct ks_ifnet, if_congested_link_start_time) == 0x820, "ks_ifnet.if_congested_link_start_time offset");
_Static_assert(offsetof(struct ks_ifnet, if_lqmstate_start_time) == 0x828, "ks_ifnet.if_lqmstate_start_time offset");
_Static_assert(offsetof(struct ks_ifnet, if_link_heuristics_tcall) == 0x830, "ks_ifnet.if_link_heuristics_tcall offset");
_Static_assert(offsetof(struct ks_ifnet, if_ipv4_stat) == 0x838, "ks_ifnet.if_ipv4_stat offset");
_Static_assert(offsetof(struct ks_ifnet, if_ipv6_stat) == 0x840, "ks_ifnet.if_ipv6_stat offset");
_Static_assert(offsetof(struct ks_ifnet, if_netns_tokens) == 0x848, "ks_ifnet.if_netns_tokens offset");
_Static_assert(offsetof(struct ks_ifnet, if_lim_stat) == 0x850, "ks_ifnet.if_lim_stat offset");
_Static_assert(offsetof(struct ks_ifnet, if_tcp_kao_max) == 0x8D0, "ks_ifnet.if_tcp_kao_max offset");
_Static_assert(offsetof(struct ks_ifnet, if_tcp_kao_cnt) == 0x8D4, "ks_ifnet.if_tcp_kao_cnt offset");
_Static_assert(offsetof(struct ks_ifnet, if_input_netem) == 0x8D8, "ks_ifnet.if_input_netem offset");
_Static_assert(offsetof(struct ks_ifnet, if_output_netem) == 0x8E0, "ks_ifnet.if_output_netem offset");
_Static_assert(offsetof(struct ks_ifnet, if_ipv6_router_mode) == 0x8E8, "ks_ifnet.if_ipv6_router_mode offset");
_Static_assert(offsetof(struct ks_ifnet, if_estimated_up_bucket) == 0x8E9, "ks_ifnet.if_estimated_up_bucket offset");
_Static_assert(offsetof(struct ks_ifnet, if_estimated_down_bucket) == 0x8EA, "ks_ifnet.if_estimated_down_bucket offset");
_Static_assert(offsetof(struct ks_ifnet, if_radio_type) == 0x8EB, "ks_ifnet.if_radio_type offset");
_Static_assert(offsetof(struct ks_ifnet, if_radio_channel) == 0x8EC, "ks_ifnet.if_radio_channel offset");
_Static_assert(offsetof(struct ks_ifnet, network_id) == 0x8ED, "ks_ifnet.network_id offset");
_Static_assert(offsetof(struct ks_ifnet, network_id_len) == 0x90D, "ks_ifnet.network_id_len offset");
_Static_assert(offsetof(struct ks_ifnet, if_l4s_mode) == 0x90E, "ks_ifnet.if_l4s_mode offset");
_Static_assert(offsetof(struct ks_ifnet, if_mcast_add_signaled) == 0x90F, "ks_ifnet.if_mcast_add_signaled offset");
_Static_assert(offsetof(struct ks_ifnet, if_mcast_del_signaled) == 0x910, "ks_ifnet.if_mcast_del_signaled offset");
_Static_assert(offsetof(struct ks_ifnet, if_inet_traffic_rule_count) == 0x914, "ks_ifnet.if_inet_traffic_rule_count offset");
_Static_assert(offsetof(struct ks_ifnet, if_eth_traffic_rule_count) == 0x918, "ks_ifnet.if_eth_traffic_rule_count offset");
_Static_assert(offsetof(struct ks_ifnet, if_traffic_rule_genid) == 0x91C, "ks_ifnet.if_traffic_rule_genid offset");
_Static_assert(offsetof(struct ks_ifnet, if_creation_generation_id) == 0x920, "ks_ifnet.if_creation_generation_id offset");
_Static_assert(sizeof(struct ks_ifnet) == 0x928, "ks_ifnet size");

/* refs: 4 */
struct ks_ifnet_filter {
    struct {
        struct ks_ifnet_filter *tqe_next;
        struct ks_ifnet_filter **tqe_prev;
    } filt_next;
    unsigned int filt_skip;
    unsigned int filt_flags;
    struct ks_ifnet *filt_ifp;
    const char *filt_name;
    void *filt_cookie;
    unsigned int filt_protocol;
    int *filt_input;
    int *filt_output;
    void *filt_event;
    int *filt_ioctl;
    void *filt_detached;
};
_Static_assert(offsetof(struct ks_ifnet_filter, filt_next) == 0x0, "ks_ifnet_filter.filt_next offset");
_Static_assert(offsetof(struct ks_ifnet_filter, filt_skip) == 0x10, "ks_ifnet_filter.filt_skip offset");
_Static_assert(offsetof(struct ks_ifnet_filter, filt_flags) == 0x14, "ks_ifnet_filter.filt_flags offset");
_Static_assert(offsetof(struct ks_ifnet_filter, filt_ifp) == 0x18, "ks_ifnet_filter.filt_ifp offset");
_Static_assert(offsetof(struct ks_ifnet_filter, filt_name) == 0x20, "ks_ifnet_filter.filt_name offset");
_Static_assert(offsetof(struct ks_ifnet_filter, filt_cookie) == 0x28, "ks_ifnet_filter.filt_cookie offset");
_Static_assert(offsetof(struct ks_ifnet_filter, filt_protocol) == 0x30, "ks_ifnet_filter.filt_protocol offset");
_Static_assert(offsetof(struct ks_ifnet_filter, filt_input) == 0x38, "ks_ifnet_filter.filt_input offset");
_Static_assert(offsetof(struct ks_ifnet_filter, filt_output) == 0x40, "ks_ifnet_filter.filt_output offset");
_Static_assert(offsetof(struct ks_ifnet_filter, filt_event) == 0x48, "ks_ifnet_filter.filt_event offset");
_Static_assert(offsetof(struct ks_ifnet_filter, filt_ioctl) == 0x50, "ks_ifnet_filter.filt_ioctl offset");
_Static_assert(offsetof(struct ks_ifnet_filter, filt_detached) == 0x58, "ks_ifnet_filter.filt_detached offset");
_Static_assert(sizeof(struct ks_ifnet_filter) == 0x60, "ks_ifnet_filter size");

/* refs: 6 */
struct ks_ifqueue {
    void *ifq_head;
    void *ifq_tail;
    int ifq_len;
    int ifq_maxlen;
    int ifq_drops;
};
_Static_assert(offsetof(struct ks_ifqueue, ifq_head) == 0x0, "ks_ifqueue.ifq_head offset");
_Static_assert(offsetof(struct ks_ifqueue, ifq_tail) == 0x8, "ks_ifqueue.ifq_tail offset");
_Static_assert(offsetof(struct ks_ifqueue, ifq_len) == 0x10, "ks_ifqueue.ifq_len offset");
_Static_assert(offsetof(struct ks_ifqueue, ifq_maxlen) == 0x14, "ks_ifqueue.ifq_maxlen offset");
_Static_assert(offsetof(struct ks_ifqueue, ifq_drops) == 0x18, "ks_ifqueue.ifq_drops offset");
_Static_assert(sizeof(struct ks_ifqueue) == 0x20, "ks_ifqueue size");

/* refs: 4 */
struct ks_igmp_ifinfo {
    struct ks_lck_mtx_s igi_lock;
    unsigned int igi_refcnt;
    unsigned int igi_debug;
    struct {
        struct ks_igmp_ifinfo *le_next;
        struct ks_igmp_ifinfo **le_prev;
    } igi_link;
    struct ks_ifnet *igi_ifp;
    unsigned int igi_version;
    unsigned int igi_v1_timer;
    unsigned int igi_v2_timer;
    unsigned int igi_v3_timer;
    unsigned int igi_flags;
    unsigned int igi_rv;
    unsigned int igi_qi;
    unsigned int igi_qri;
    unsigned int igi_uri;
    struct {
        struct ks_in_multi *slh_first;
    } igi_relinmhead;
    struct ks_ifqueue igi_gq;
    struct ks_ifqueue igi_v2q;
};
_Static_assert(offsetof(struct ks_igmp_ifinfo, igi_lock) == 0x0, "ks_igmp_ifinfo.igi_lock offset");
_Static_assert(offsetof(struct ks_igmp_ifinfo, igi_refcnt) == 0x10, "ks_igmp_ifinfo.igi_refcnt offset");
_Static_assert(offsetof(struct ks_igmp_ifinfo, igi_debug) == 0x14, "ks_igmp_ifinfo.igi_debug offset");
_Static_assert(offsetof(struct ks_igmp_ifinfo, igi_link) == 0x18, "ks_igmp_ifinfo.igi_link offset");
_Static_assert(offsetof(struct ks_igmp_ifinfo, igi_ifp) == 0x28, "ks_igmp_ifinfo.igi_ifp offset");
_Static_assert(offsetof(struct ks_igmp_ifinfo, igi_version) == 0x30, "ks_igmp_ifinfo.igi_version offset");
_Static_assert(offsetof(struct ks_igmp_ifinfo, igi_v1_timer) == 0x34, "ks_igmp_ifinfo.igi_v1_timer offset");
_Static_assert(offsetof(struct ks_igmp_ifinfo, igi_v2_timer) == 0x38, "ks_igmp_ifinfo.igi_v2_timer offset");
_Static_assert(offsetof(struct ks_igmp_ifinfo, igi_v3_timer) == 0x3C, "ks_igmp_ifinfo.igi_v3_timer offset");
_Static_assert(offsetof(struct ks_igmp_ifinfo, igi_flags) == 0x40, "ks_igmp_ifinfo.igi_flags offset");
_Static_assert(offsetof(struct ks_igmp_ifinfo, igi_rv) == 0x44, "ks_igmp_ifinfo.igi_rv offset");
_Static_assert(offsetof(struct ks_igmp_ifinfo, igi_qi) == 0x48, "ks_igmp_ifinfo.igi_qi offset");
_Static_assert(offsetof(struct ks_igmp_ifinfo, igi_qri) == 0x4C, "ks_igmp_ifinfo.igi_qri offset");
_Static_assert(offsetof(struct ks_igmp_ifinfo, igi_uri) == 0x50, "ks_igmp_ifinfo.igi_uri offset");
_Static_assert(offsetof(struct ks_igmp_ifinfo, igi_relinmhead) == 0x58, "ks_igmp_ifinfo.igi_relinmhead offset");
_Static_assert(offsetof(struct ks_igmp_ifinfo, igi_gq) == 0x60, "ks_igmp_ifinfo.igi_gq offset");
_Static_assert(offsetof(struct ks_igmp_ifinfo, igi_v2q) == 0x80, "ks_igmp_ifinfo.igi_v2q offset");
_Static_assert(sizeof(struct ks_igmp_ifinfo) == 0xA0, "ks_igmp_ifinfo size");

/* refs: 1 */
struct ks_im6s_st {
    unsigned short ex;
    unsigned short in;
};
_Static_assert(offsetof(struct ks_im6s_st, ex) == 0x0, "ks_im6s_st.ex offset");
_Static_assert(offsetof(struct ks_im6s_st, in) == 0x2, "ks_im6s_st.in offset");
_Static_assert(sizeof(struct ks_im6s_st) == 0x4, "ks_im6s_st size");

/* refs: 1 */
struct ks_ip_px_smpx_s {
    void *array;
    void *data;
    unsigned long long datalen;
};
_Static_assert(offsetof(struct ks_ip_px_smpx_s, array) == 0x0, "ks_ip_px_smpx_s.array offset");
_Static_assert(offsetof(struct ks_ip_px_smpx_s, data) == 0x8, "ks_ip_px_smpx_s.data offset");
_Static_assert(offsetof(struct ks_ip_px_smpx_s, datalen) == 0x10, "ks_ip_px_smpx_s.datalen offset");
_Static_assert(sizeof(struct ks_ip_px_smpx_s) == 0x18, "ks_ip_px_smpx_s size");

/* refs: 1 */
struct ks_image_params {
    unsigned long long ip_user_fname;
    unsigned long long ip_user_argv;
    unsigned long long ip_user_envv;
    int ip_seg;
    struct ks_vnode *ip_vp;
    struct ks_vnode_attr *ip_vattr;
    struct ks_vnode_attr *ip_origvattr;
    int ip_origcputype;
    int ip_origcpusubtype;
    char *ip_vdata;
    int ip_flags;
    int ip_argc;
    int ip_envc;
    int ip_applec;
    char *ip_startargv;
    char *ip_endargv;
    char *ip_endenvv;
    char *ip_strings;
    char *ip_strendp;
    char *ip_subsystem_root_path;
    int ip_argspace;
    int ip_strspace;
    unsigned long long ip_arch_offset;
    unsigned long long ip_arch_size;
    char ip_interp_buffer[0x200];
    int ip_interp_sugid_fd;
    struct ks_vfs_context *ip_vfs_context;
    struct ks_nameidata *ip_ndp;
    struct ks_thread *ip_new_thread;
    struct ks_label *ip_execlabelp;
    struct ks_label *ip_scriptlabelp;
    struct ks_vnode *ip_scriptvp;
    unsigned int ip_csflags;
    int ip_mac_return;
    void *ip_px_sa;
    void *ip_px_sfa;
    void *ip_px_spa;
    struct ks__vm_map *ip_free_map;
    struct ks_ip_px_smpx_s ip_px_smpx;
    void *ip_px_persona;
    void *ip_px_pcred_info;
    void *ip_cs_error;
    char *ip_inherited_shared_region_id;
    unsigned long long ip_dyld_fsid;
    unsigned long long ip_dyld_fsobjid;
    unsigned long long ip_inherited_jop_pid;
    unsigned int ip_simulator_binary;
};
_Static_assert(offsetof(struct ks_image_params, ip_user_fname) == 0x0, "ks_image_params.ip_user_fname offset");
_Static_assert(offsetof(struct ks_image_params, ip_user_argv) == 0x8, "ks_image_params.ip_user_argv offset");
_Static_assert(offsetof(struct ks_image_params, ip_user_envv) == 0x10, "ks_image_params.ip_user_envv offset");
_Static_assert(offsetof(struct ks_image_params, ip_seg) == 0x18, "ks_image_params.ip_seg offset");
_Static_assert(offsetof(struct ks_image_params, ip_vp) == 0x20, "ks_image_params.ip_vp offset");
_Static_assert(offsetof(struct ks_image_params, ip_vattr) == 0x28, "ks_image_params.ip_vattr offset");
_Static_assert(offsetof(struct ks_image_params, ip_origvattr) == 0x30, "ks_image_params.ip_origvattr offset");
_Static_assert(offsetof(struct ks_image_params, ip_origcputype) == 0x38, "ks_image_params.ip_origcputype offset");
_Static_assert(offsetof(struct ks_image_params, ip_origcpusubtype) == 0x3C, "ks_image_params.ip_origcpusubtype offset");
_Static_assert(offsetof(struct ks_image_params, ip_vdata) == 0x40, "ks_image_params.ip_vdata offset");
_Static_assert(offsetof(struct ks_image_params, ip_flags) == 0x48, "ks_image_params.ip_flags offset");
_Static_assert(offsetof(struct ks_image_params, ip_argc) == 0x4C, "ks_image_params.ip_argc offset");
_Static_assert(offsetof(struct ks_image_params, ip_envc) == 0x50, "ks_image_params.ip_envc offset");
_Static_assert(offsetof(struct ks_image_params, ip_applec) == 0x54, "ks_image_params.ip_applec offset");
_Static_assert(offsetof(struct ks_image_params, ip_startargv) == 0x58, "ks_image_params.ip_startargv offset");
_Static_assert(offsetof(struct ks_image_params, ip_endargv) == 0x60, "ks_image_params.ip_endargv offset");
_Static_assert(offsetof(struct ks_image_params, ip_endenvv) == 0x68, "ks_image_params.ip_endenvv offset");
_Static_assert(offsetof(struct ks_image_params, ip_strings) == 0x70, "ks_image_params.ip_strings offset");
_Static_assert(offsetof(struct ks_image_params, ip_strendp) == 0x78, "ks_image_params.ip_strendp offset");
_Static_assert(offsetof(struct ks_image_params, ip_subsystem_root_path) == 0x80, "ks_image_params.ip_subsystem_root_path offset");
_Static_assert(offsetof(struct ks_image_params, ip_argspace) == 0x88, "ks_image_params.ip_argspace offset");
_Static_assert(offsetof(struct ks_image_params, ip_strspace) == 0x8C, "ks_image_params.ip_strspace offset");
_Static_assert(offsetof(struct ks_image_params, ip_arch_offset) == 0x90, "ks_image_params.ip_arch_offset offset");
_Static_assert(offsetof(struct ks_image_params, ip_arch_size) == 0x98, "ks_image_params.ip_arch_size offset");
_Static_assert(offsetof(struct ks_image_params, ip_interp_buffer) == 0xA0, "ks_image_params.ip_interp_buffer offset");
_Static_assert(offsetof(struct ks_image_params, ip_interp_sugid_fd) == 0x2A0, "ks_image_params.ip_interp_sugid_fd offset");
_Static_assert(offsetof(struct ks_image_params, ip_vfs_context) == 0x2A8, "ks_image_params.ip_vfs_context offset");
_Static_assert(offsetof(struct ks_image_params, ip_ndp) == 0x2B0, "ks_image_params.ip_ndp offset");
_Static_assert(offsetof(struct ks_image_params, ip_new_thread) == 0x2B8, "ks_image_params.ip_new_thread offset");
_Static_assert(offsetof(struct ks_image_params, ip_execlabelp) == 0x2C0, "ks_image_params.ip_execlabelp offset");
_Static_assert(offsetof(struct ks_image_params, ip_scriptlabelp) == 0x2C8, "ks_image_params.ip_scriptlabelp offset");
_Static_assert(offsetof(struct ks_image_params, ip_scriptvp) == 0x2D0, "ks_image_params.ip_scriptvp offset");
_Static_assert(offsetof(struct ks_image_params, ip_csflags) == 0x2D8, "ks_image_params.ip_csflags offset");
_Static_assert(offsetof(struct ks_image_params, ip_mac_return) == 0x2DC, "ks_image_params.ip_mac_return offset");
_Static_assert(offsetof(struct ks_image_params, ip_px_sa) == 0x2E0, "ks_image_params.ip_px_sa offset");
_Static_assert(offsetof(struct ks_image_params, ip_px_sfa) == 0x2E8, "ks_image_params.ip_px_sfa offset");
_Static_assert(offsetof(struct ks_image_params, ip_px_spa) == 0x2F0, "ks_image_params.ip_px_spa offset");
_Static_assert(offsetof(struct ks_image_params, ip_free_map) == 0x2F8, "ks_image_params.ip_free_map offset");
_Static_assert(offsetof(struct ks_image_params, ip_px_smpx) == 0x300, "ks_image_params.ip_px_smpx offset");
_Static_assert(offsetof(struct ks_image_params, ip_px_persona) == 0x318, "ks_image_params.ip_px_persona offset");
_Static_assert(offsetof(struct ks_image_params, ip_px_pcred_info) == 0x320, "ks_image_params.ip_px_pcred_info offset");
_Static_assert(offsetof(struct ks_image_params, ip_cs_error) == 0x328, "ks_image_params.ip_cs_error offset");
_Static_assert(offsetof(struct ks_image_params, ip_inherited_shared_region_id) == 0x330, "ks_image_params.ip_inherited_shared_region_id offset");
_Static_assert(offsetof(struct ks_image_params, ip_dyld_fsid) == 0x338, "ks_image_params.ip_dyld_fsid offset");
_Static_assert(offsetof(struct ks_image_params, ip_dyld_fsobjid) == 0x340, "ks_image_params.ip_dyld_fsobjid offset");
_Static_assert(offsetof(struct ks_image_params, ip_inherited_jop_pid) == 0x348, "ks_image_params.ip_inherited_jop_pid offset");
_Static_assert(offsetof(struct ks_image_params, ip_simulator_binary) == 0x350, "ks_image_params.ip_simulator_binary offset");
_Static_assert(sizeof(struct ks_image_params) == 0x358, "ks_image_params size");

/* refs: 1 */
struct ks_ims_st {
    unsigned short ex;
    unsigned short in;
};
_Static_assert(offsetof(struct ks_ims_st, ex) == 0x0, "ks_ims_st.ex offset");
_Static_assert(offsetof(struct ks_ims_st, in) == 0x2, "ks_ims_st.in offset");
_Static_assert(sizeof(struct ks_ims_st) == 0x4, "ks_ims_st size");

/* refs: 1 */
struct ks_in6_cga_modifier {
    unsigned char octets[0x10];
};
_Static_assert(offsetof(struct ks_in6_cga_modifier, octets) == 0x0, "ks_in6_cga_modifier.octets offset");
_Static_assert(sizeof(struct ks_in6_cga_modifier) == 0x10, "ks_in6_cga_modifier size");

/* refs: 1 */
struct ks_in6_ifstat {
    unsigned long long ifs6_in_receive;
    unsigned long long ifs6_in_hdrerr;
    unsigned long long ifs6_in_toobig;
    unsigned long long ifs6_in_noroute;
    unsigned long long ifs6_in_addrerr;
    unsigned long long ifs6_in_protounknown;
    unsigned long long ifs6_in_truncated;
    unsigned long long ifs6_in_discard;
    unsigned long long ifs6_in_deliver;
    unsigned long long ifs6_out_forward;
    unsigned long long ifs6_out_request;
    unsigned long long ifs6_out_discard;
    unsigned long long ifs6_out_fragok;
    unsigned long long ifs6_out_fragfail;
    unsigned long long ifs6_out_fragcreat;
    unsigned long long ifs6_reass_reqd;
    unsigned long long ifs6_reass_ok;
    unsigned long long ifs6_atmfrag_rcvd;
    unsigned long long ifs6_reass_fail;
    unsigned long long ifs6_in_mcast;
    unsigned long long ifs6_out_mcast;
    unsigned long long ifs6_cantfoward_icmp6;
    unsigned long long ifs6_addr_expiry_cnt;
    unsigned long long ifs6_pfx_expiry_cnt;
    unsigned long long ifs6_defrtr_expiry_cnt;
};
_Static_assert(offsetof(struct ks_in6_ifstat, ifs6_in_receive) == 0x0, "ks_in6_ifstat.ifs6_in_receive offset");
_Static_assert(offsetof(struct ks_in6_ifstat, ifs6_in_hdrerr) == 0x8, "ks_in6_ifstat.ifs6_in_hdrerr offset");
_Static_assert(offsetof(struct ks_in6_ifstat, ifs6_in_toobig) == 0x10, "ks_in6_ifstat.ifs6_in_toobig offset");
_Static_assert(offsetof(struct ks_in6_ifstat, ifs6_in_noroute) == 0x18, "ks_in6_ifstat.ifs6_in_noroute offset");
_Static_assert(offsetof(struct ks_in6_ifstat, ifs6_in_addrerr) == 0x20, "ks_in6_ifstat.ifs6_in_addrerr offset");
_Static_assert(offsetof(struct ks_in6_ifstat, ifs6_in_protounknown) == 0x28, "ks_in6_ifstat.ifs6_in_protounknown offset");
_Static_assert(offsetof(struct ks_in6_ifstat, ifs6_in_truncated) == 0x30, "ks_in6_ifstat.ifs6_in_truncated offset");
_Static_assert(offsetof(struct ks_in6_ifstat, ifs6_in_discard) == 0x38, "ks_in6_ifstat.ifs6_in_discard offset");
_Static_assert(offsetof(struct ks_in6_ifstat, ifs6_in_deliver) == 0x40, "ks_in6_ifstat.ifs6_in_deliver offset");
_Static_assert(offsetof(struct ks_in6_ifstat, ifs6_out_forward) == 0x48, "ks_in6_ifstat.ifs6_out_forward offset");
_Static_assert(offsetof(struct ks_in6_ifstat, ifs6_out_request) == 0x50, "ks_in6_ifstat.ifs6_out_request offset");
_Static_assert(offsetof(struct ks_in6_ifstat, ifs6_out_discard) == 0x58, "ks_in6_ifstat.ifs6_out_discard offset");
_Static_assert(offsetof(struct ks_in6_ifstat, ifs6_out_fragok) == 0x60, "ks_in6_ifstat.ifs6_out_fragok offset");
_Static_assert(offsetof(struct ks_in6_ifstat, ifs6_out_fragfail) == 0x68, "ks_in6_ifstat.ifs6_out_fragfail offset");
_Static_assert(offsetof(struct ks_in6_ifstat, ifs6_out_fragcreat) == 0x70, "ks_in6_ifstat.ifs6_out_fragcreat offset");
_Static_assert(offsetof(struct ks_in6_ifstat, ifs6_reass_reqd) == 0x78, "ks_in6_ifstat.ifs6_reass_reqd offset");
_Static_assert(offsetof(struct ks_in6_ifstat, ifs6_reass_ok) == 0x80, "ks_in6_ifstat.ifs6_reass_ok offset");
_Static_assert(offsetof(struct ks_in6_ifstat, ifs6_atmfrag_rcvd) == 0x88, "ks_in6_ifstat.ifs6_atmfrag_rcvd offset");
_Static_assert(offsetof(struct ks_in6_ifstat, ifs6_reass_fail) == 0x90, "ks_in6_ifstat.ifs6_reass_fail offset");
_Static_assert(offsetof(struct ks_in6_ifstat, ifs6_in_mcast) == 0x98, "ks_in6_ifstat.ifs6_in_mcast offset");
_Static_assert(offsetof(struct ks_in6_ifstat, ifs6_out_mcast) == 0xA0, "ks_in6_ifstat.ifs6_out_mcast offset");
_Static_assert(offsetof(struct ks_in6_ifstat, ifs6_cantfoward_icmp6) == 0xA8, "ks_in6_ifstat.ifs6_cantfoward_icmp6 offset");
_Static_assert(offsetof(struct ks_in6_ifstat, ifs6_addr_expiry_cnt) == 0xB0, "ks_in6_ifstat.ifs6_addr_expiry_cnt offset");
_Static_assert(offsetof(struct ks_in6_ifstat, ifs6_pfx_expiry_cnt) == 0xB8, "ks_in6_ifstat.ifs6_pfx_expiry_cnt offset");
_Static_assert(offsetof(struct ks_in6_ifstat, ifs6_defrtr_expiry_cnt) == 0xC0, "ks_in6_ifstat.ifs6_defrtr_expiry_cnt offset");
_Static_assert(sizeof(struct ks_in6_ifstat) == 0xC8, "ks_in6_ifstat size");

/* refs: 1 */
struct ks_ipv6_prefix {
    struct ks_in6_addr ipv6_prefix;
    unsigned int prefix_len;
};
_Static_assert(offsetof(struct ks_ipv6_prefix, ipv6_prefix) == 0x0, "ks_ipv6_prefix.ipv6_prefix offset");
_Static_assert(offsetof(struct ks_ipv6_prefix, prefix_len) == 0x10, "ks_ipv6_prefix.prefix_len offset");
_Static_assert(sizeof(struct ks_ipv6_prefix) == 0x14, "ks_ipv6_prefix size");

/* refs: 1 */
struct ks_nd_ifinfo {
    struct ks_lck_mtx_s lock;
    int initialized;
    unsigned int linkmtu;
    unsigned int maxmtu;
    unsigned int basereachable;
    unsigned int reachable;
    unsigned int retrans;
    unsigned int flags;
    int recalctm;
    unsigned char chlim;
    unsigned char _pad[3];
    unsigned char randomseed0[8];
    unsigned char randomseed1[8];
    unsigned char randomid[8];
    int nprefixes;
    int ndefrouters;
    int cga_initialized;
    struct ks_in6_cga_modifier local_cga_modifier;
    unsigned char cga_collision_count;
};
_Static_assert(offsetof(struct ks_nd_ifinfo, lock) == 0x0, "ks_nd_ifinfo.lock offset");
_Static_assert(offsetof(struct ks_nd_ifinfo, initialized) == 0x10, "ks_nd_ifinfo.initialized offset");
_Static_assert(offsetof(struct ks_nd_ifinfo, linkmtu) == 0x14, "ks_nd_ifinfo.linkmtu offset");
_Static_assert(offsetof(struct ks_nd_ifinfo, maxmtu) == 0x18, "ks_nd_ifinfo.maxmtu offset");
_Static_assert(offsetof(struct ks_nd_ifinfo, basereachable) == 0x1C, "ks_nd_ifinfo.basereachable offset");
_Static_assert(offsetof(struct ks_nd_ifinfo, reachable) == 0x20, "ks_nd_ifinfo.reachable offset");
_Static_assert(offsetof(struct ks_nd_ifinfo, retrans) == 0x24, "ks_nd_ifinfo.retrans offset");
_Static_assert(offsetof(struct ks_nd_ifinfo, flags) == 0x28, "ks_nd_ifinfo.flags offset");
_Static_assert(offsetof(struct ks_nd_ifinfo, recalctm) == 0x2C, "ks_nd_ifinfo.recalctm offset");
_Static_assert(offsetof(struct ks_nd_ifinfo, chlim) == 0x30, "ks_nd_ifinfo.chlim offset");
_Static_assert(offsetof(struct ks_nd_ifinfo, _pad) == 0x31, "ks_nd_ifinfo._pad offset");
_Static_assert(offsetof(struct ks_nd_ifinfo, randomseed0) == 0x34, "ks_nd_ifinfo.randomseed0 offset");
_Static_assert(offsetof(struct ks_nd_ifinfo, randomseed1) == 0x3C, "ks_nd_ifinfo.randomseed1 offset");
_Static_assert(offsetof(struct ks_nd_ifinfo, randomid) == 0x44, "ks_nd_ifinfo.randomid offset");
_Static_assert(offsetof(struct ks_nd_ifinfo, nprefixes) == 0x4C, "ks_nd_ifinfo.nprefixes offset");
_Static_assert(offsetof(struct ks_nd_ifinfo, ndefrouters) == 0x50, "ks_nd_ifinfo.ndefrouters offset");
_Static_assert(offsetof(struct ks_nd_ifinfo, cga_initialized) == 0x54, "ks_nd_ifinfo.cga_initialized offset");
_Static_assert(offsetof(struct ks_nd_ifinfo, local_cga_modifier) == 0x58, "ks_nd_ifinfo.local_cga_modifier offset");
_Static_assert(offsetof(struct ks_nd_ifinfo, cga_collision_count) == 0x68, "ks_nd_ifinfo.cga_collision_count offset");
_Static_assert(sizeof(struct ks_nd_ifinfo) == 0x70, "ks_nd_ifinfo size");

/* refs: 1 */
struct ks_scope6_id {
    unsigned int s6id_list[0x10];
};
_Static_assert(offsetof(struct ks_scope6_id, s6id_list) == 0x0, "ks_scope6_id.s6id_list offset");
_Static_assert(sizeof(struct ks_scope6_id) == 0x40, "ks_scope6_id size");

/* refs: 1 */
struct ks_in6_ifextra {
    struct ks_scope6_id scope6_id;
    struct ks_in6_ifstat in6_ifstat;
    struct ks_icmp6_ifstat icmp6_ifstat;
    struct ks_nd_ifinfo nd_ifinfo;
    unsigned int netsig_len;
    unsigned char netsig[0x14];
    struct ks_ipv6_prefix nat64_prefixes[4];
};
_Static_assert(offsetof(struct ks_in6_ifextra, scope6_id) == 0x0, "ks_in6_ifextra.scope6_id offset");
_Static_assert(offsetof(struct ks_in6_ifextra, in6_ifstat) == 0x40, "ks_in6_ifextra.in6_ifstat offset");
_Static_assert(offsetof(struct ks_in6_ifextra, icmp6_ifstat) == 0x108, "ks_in6_ifextra.icmp6_ifstat offset");
_Static_assert(offsetof(struct ks_in6_ifextra, nd_ifinfo) == 0x218, "ks_in6_ifextra.nd_ifinfo offset");
_Static_assert(offsetof(struct ks_in6_ifextra, netsig_len) == 0x288, "ks_in6_ifextra.netsig_len offset");
_Static_assert(offsetof(struct ks_in6_ifextra, netsig) == 0x28C, "ks_in6_ifextra.netsig offset");
_Static_assert(offsetof(struct ks_in6_ifextra, nat64_prefixes) == 0x2A0, "ks_in6_ifextra.nat64_prefixes offset");
_Static_assert(sizeof(struct ks_in6_ifextra) == 0x2F0, "ks_in6_ifextra size");

/* refs: 1 */
struct ks_in6m_st {
    unsigned short iss_fmode;
    unsigned short iss_asm;
    unsigned short iss_ex;
    unsigned short iss_in;
    unsigned short iss_rec;
};
_Static_assert(offsetof(struct ks_in6m_st, iss_fmode) == 0x0, "ks_in6m_st.iss_fmode offset");
_Static_assert(offsetof(struct ks_in6m_st, iss_asm) == 0x2, "ks_in6m_st.iss_asm offset");
_Static_assert(offsetof(struct ks_in6m_st, iss_ex) == 0x4, "ks_in6m_st.iss_ex offset");
_Static_assert(offsetof(struct ks_in6m_st, iss_in) == 0x6, "ks_in6m_st.iss_in offset");
_Static_assert(offsetof(struct ks_in6m_st, iss_rec) == 0x8, "ks_in6m_st.iss_rec offset");
_Static_assert(sizeof(struct ks_in6m_st) == 0xA, "ks_in6m_st size");

/* refs: 1 */
struct ks_ip6_msource_tree {
    struct ks_ip6_msource *rbh_root;
};
_Static_assert(offsetof(struct ks_ip6_msource_tree, rbh_root) == 0x0, "ks_ip6_msource_tree.rbh_root offset");
_Static_assert(sizeof(struct ks_ip6_msource_tree) == 0x8, "ks_ip6_msource_tree size");

/* refs: 5 */
struct ks_in6_multi {
    struct ks_lck_mtx_s in6m_lock;
    unsigned int in6m_refcount;
    unsigned int in6m_reqcnt;
    unsigned int in6m_debug;
    struct {
        struct ks_in6_multi *le_next;
        struct ks_in6_multi **le_prev;
    } in6m_entry;
    struct ks_in6_addr in6m_addr;
    unsigned int ifscope;
    struct ks_ifnet *in6m_ifp;
    struct ks_ifmultiaddr *in6m_ifma;
    unsigned int in6m_state;
    unsigned int in6m_timer;
    _Bool in6m_in_nrele;
    struct ks_mld_ifinfo *in6m_mli;
    struct {
        struct ks_in6_multi *sle_next;
    } in6m_dtle;
    struct {
        struct ks_in6_multi *sle_next;
    } in6m_nrele;
    unsigned int in6m_nrelecnt;
    struct ks_ip6_msource_tree in6m_srcs;
    unsigned long in6m_nsrc;
    struct ks_ifqueue in6m_scq;
    struct ks_timeval in6m_lastgsrtv;
    unsigned short in6m_sctimer;
    unsigned short in6m_scrv;
    struct ks_in6m_st in6m_st[2];
    void *in6m_trace;
};
_Static_assert(offsetof(struct ks_in6_multi, in6m_lock) == 0x0, "ks_in6_multi.in6m_lock offset");
_Static_assert(offsetof(struct ks_in6_multi, in6m_refcount) == 0x10, "ks_in6_multi.in6m_refcount offset");
_Static_assert(offsetof(struct ks_in6_multi, in6m_reqcnt) == 0x14, "ks_in6_multi.in6m_reqcnt offset");
_Static_assert(offsetof(struct ks_in6_multi, in6m_debug) == 0x18, "ks_in6_multi.in6m_debug offset");
_Static_assert(offsetof(struct ks_in6_multi, in6m_entry) == 0x20, "ks_in6_multi.in6m_entry offset");
_Static_assert(offsetof(struct ks_in6_multi, in6m_addr) == 0x30, "ks_in6_multi.in6m_addr offset");
_Static_assert(offsetof(struct ks_in6_multi, ifscope) == 0x40, "ks_in6_multi.ifscope offset");
_Static_assert(offsetof(struct ks_in6_multi, in6m_ifp) == 0x48, "ks_in6_multi.in6m_ifp offset");
_Static_assert(offsetof(struct ks_in6_multi, in6m_ifma) == 0x50, "ks_in6_multi.in6m_ifma offset");
_Static_assert(offsetof(struct ks_in6_multi, in6m_state) == 0x58, "ks_in6_multi.in6m_state offset");
_Static_assert(offsetof(struct ks_in6_multi, in6m_timer) == 0x5C, "ks_in6_multi.in6m_timer offset");
_Static_assert(offsetof(struct ks_in6_multi, in6m_in_nrele) == 0x60, "ks_in6_multi.in6m_in_nrele offset");
_Static_assert(offsetof(struct ks_in6_multi, in6m_mli) == 0x68, "ks_in6_multi.in6m_mli offset");
_Static_assert(offsetof(struct ks_in6_multi, in6m_dtle) == 0x70, "ks_in6_multi.in6m_dtle offset");
_Static_assert(offsetof(struct ks_in6_multi, in6m_nrele) == 0x78, "ks_in6_multi.in6m_nrele offset");
_Static_assert(offsetof(struct ks_in6_multi, in6m_nrelecnt) == 0x80, "ks_in6_multi.in6m_nrelecnt offset");
_Static_assert(offsetof(struct ks_in6_multi, in6m_srcs) == 0x88, "ks_in6_multi.in6m_srcs offset");
_Static_assert(offsetof(struct ks_in6_multi, in6m_nsrc) == 0x90, "ks_in6_multi.in6m_nsrc offset");
_Static_assert(offsetof(struct ks_in6_multi, in6m_scq) == 0x98, "ks_in6_multi.in6m_scq offset");
_Static_assert(offsetof(struct ks_in6_multi, in6m_lastgsrtv) == 0xB8, "ks_in6_multi.in6m_lastgsrtv offset");
_Static_assert(offsetof(struct ks_in6_multi, in6m_sctimer) == 0xC8, "ks_in6_multi.in6m_sctimer offset");
_Static_assert(offsetof(struct ks_in6_multi, in6m_scrv) == 0xCA, "ks_in6_multi.in6m_scrv offset");
_Static_assert(offsetof(struct ks_in6_multi, in6m_st) == 0xCC, "ks_in6_multi.in6m_st offset");
_Static_assert(offsetof(struct ks_in6_multi, in6m_trace) == 0xE0, "ks_in6_multi.in6m_trace offset");
_Static_assert(sizeof(struct ks_in6_multi) == 0xE8, "ks_in6_multi size");

/* refs: 2 */
struct ks_in_addr_4in6 {
    unsigned int ia46_pad32[3];
    struct ks_in_addr ia46_addr4;
};
_Static_assert(offsetof(struct ks_in_addr_4in6, ia46_pad32) == 0x0, "ks_in_addr_4in6.ia46_pad32 offset");
_Static_assert(offsetof(struct ks_in_addr_4in6, ia46_addr4) == 0xC, "ks_in_addr_4in6.ia46_addr4 offset");
_Static_assert(sizeof(struct ks_in_addr_4in6) == 0x10, "ks_in_addr_4in6 size");

/* refs: 1 */
struct ks_in_ifextra {
    unsigned int netsig_len;
    unsigned char netsig[0x14];
};
_Static_assert(offsetof(struct ks_in_ifextra, netsig_len) == 0x0, "ks_in_ifextra.netsig_len offset");
_Static_assert(offsetof(struct ks_in_ifextra, netsig) == 0x4, "ks_in_ifextra.netsig offset");
_Static_assert(sizeof(struct ks_in_ifextra) == 0x18, "ks_in_ifextra size");

/* refs: 1 */
struct ks_inm_st {
    unsigned short iss_fmode;
    unsigned short iss_asm;
    unsigned short iss_ex;
    unsigned short iss_in;
    unsigned short iss_rec;
};
_Static_assert(offsetof(struct ks_inm_st, iss_fmode) == 0x0, "ks_inm_st.iss_fmode offset");
_Static_assert(offsetof(struct ks_inm_st, iss_asm) == 0x2, "ks_inm_st.iss_asm offset");
_Static_assert(offsetof(struct ks_inm_st, iss_ex) == 0x4, "ks_inm_st.iss_ex offset");
_Static_assert(offsetof(struct ks_inm_st, iss_in) == 0x6, "ks_inm_st.iss_in offset");
_Static_assert(offsetof(struct ks_inm_st, iss_rec) == 0x8, "ks_inm_st.iss_rec offset");
_Static_assert(sizeof(struct ks_inm_st) == 0xA, "ks_inm_st size");

/* refs: 1 */
struct ks_ip_msource_tree {
    struct ks_ip_msource *rbh_root;
};
_Static_assert(offsetof(struct ks_ip_msource_tree, rbh_root) == 0x0, "ks_ip_msource_tree.rbh_root offset");
_Static_assert(sizeof(struct ks_ip_msource_tree) == 0x8, "ks_ip_msource_tree size");

/* refs: 6 */
struct ks_in_multi {
    struct ks_lck_mtx_s inm_lock;
    unsigned int inm_refcount;
    unsigned int inm_reqcnt;
    unsigned int inm_debug;
    struct {
        struct ks_in_multi *le_next;
        struct ks_in_multi **le_prev;
    } inm_link;
    struct ks_in_addr inm_addr;
    struct ks_ifnet *inm_ifp;
    struct ks_ifmultiaddr *inm_ifma;
    unsigned int inm_timer;
    unsigned int inm_state;
    _Bool inm_in_nrele;
    struct ks_igmp_ifinfo *inm_igi;
    struct {
        struct ks_in_multi *sle_next;
    } inm_dtle;
    struct {
        struct ks_in_multi *sle_next;
    } inm_nrele;
    unsigned int inm_nrelecnt;
    struct ks_ip_msource_tree inm_srcs;
    unsigned long inm_nsrc;
    struct ks_ifqueue inm_scq;
    struct ks_timeval inm_lastgsrtv;
    unsigned short inm_sctimer;
    unsigned short inm_scrv;
    struct ks_inm_st inm_st[2];
    void *inm_trace;
};
_Static_assert(offsetof(struct ks_in_multi, inm_lock) == 0x0, "ks_in_multi.inm_lock offset");
_Static_assert(offsetof(struct ks_in_multi, inm_refcount) == 0x10, "ks_in_multi.inm_refcount offset");
_Static_assert(offsetof(struct ks_in_multi, inm_reqcnt) == 0x14, "ks_in_multi.inm_reqcnt offset");
_Static_assert(offsetof(struct ks_in_multi, inm_debug) == 0x18, "ks_in_multi.inm_debug offset");
_Static_assert(offsetof(struct ks_in_multi, inm_link) == 0x20, "ks_in_multi.inm_link offset");
_Static_assert(offsetof(struct ks_in_multi, inm_addr) == 0x30, "ks_in_multi.inm_addr offset");
_Static_assert(offsetof(struct ks_in_multi, inm_ifp) == 0x38, "ks_in_multi.inm_ifp offset");
_Static_assert(offsetof(struct ks_in_multi, inm_ifma) == 0x40, "ks_in_multi.inm_ifma offset");
_Static_assert(offsetof(struct ks_in_multi, inm_timer) == 0x48, "ks_in_multi.inm_timer offset");
_Static_assert(offsetof(struct ks_in_multi, inm_state) == 0x4C, "ks_in_multi.inm_state offset");
_Static_assert(offsetof(struct ks_in_multi, inm_in_nrele) == 0x50, "ks_in_multi.inm_in_nrele offset");
_Static_assert(offsetof(struct ks_in_multi, inm_igi) == 0x58, "ks_in_multi.inm_igi offset");
_Static_assert(offsetof(struct ks_in_multi, inm_dtle) == 0x60, "ks_in_multi.inm_dtle offset");
_Static_assert(offsetof(struct ks_in_multi, inm_nrele) == 0x68, "ks_in_multi.inm_nrele offset");
_Static_assert(offsetof(struct ks_in_multi, inm_nrelecnt) == 0x70, "ks_in_multi.inm_nrelecnt offset");
_Static_assert(offsetof(struct ks_in_multi, inm_srcs) == 0x78, "ks_in_multi.inm_srcs offset");
_Static_assert(offsetof(struct ks_in_multi, inm_nsrc) == 0x80, "ks_in_multi.inm_nsrc offset");
_Static_assert(offsetof(struct ks_in_multi, inm_scq) == 0x88, "ks_in_multi.inm_scq offset");
_Static_assert(offsetof(struct ks_in_multi, inm_lastgsrtv) == 0xA8, "ks_in_multi.inm_lastgsrtv offset");
_Static_assert(offsetof(struct ks_in_multi, inm_sctimer) == 0xB8, "ks_in_multi.inm_sctimer offset");
_Static_assert(offsetof(struct ks_in_multi, inm_scrv) == 0xBA, "ks_in_multi.inm_scrv offset");
_Static_assert(offsetof(struct ks_in_multi, inm_st) == 0xBC, "ks_in_multi.inm_st offset");
_Static_assert(offsetof(struct ks_in_multi, inm_trace) == 0xD0, "ks_in_multi.inm_trace offset");
_Static_assert(sizeof(struct ks_in_multi) == 0xD8, "ks_in_multi size");

/* refs: 1 */
struct ks_internal_state {
    int dummy;
};
_Static_assert(offsetof(struct ks_internal_state, dummy) == 0x0, "ks_internal_state.dummy offset");
_Static_assert(sizeof(struct ks_internal_state) == 0x4, "ks_internal_state size");

/* refs: 4 */
struct ks_ip6_msource {
    struct {
        struct ks_ip6_msource *rbe_left;
        struct ks_ip6_msource *rbe_right;
        struct ks_ip6_msource *rbe_parent;
    } im6s_link;
    struct ks_in6_addr im6s_addr;
    struct ks_im6s_st im6s_st[2];
    unsigned char im6s_stp;
};
_Static_assert(offsetof(struct ks_ip6_msource, im6s_link) == 0x0, "ks_ip6_msource.im6s_link offset");
_Static_assert(offsetof(struct ks_ip6_msource, im6s_addr) == 0x18, "ks_ip6_msource.im6s_addr offset");
_Static_assert(offsetof(struct ks_ip6_msource, im6s_st) == 0x28, "ks_ip6_msource.im6s_st offset");
_Static_assert(offsetof(struct ks_ip6_msource, im6s_stp) == 0x30, "ks_ip6_msource.im6s_stp offset");
_Static_assert(sizeof(struct ks_ip6_msource) == 0x38, "ks_ip6_msource size");

/* refs: 4 */
struct ks_ip_msource {
    struct {
        struct ks_ip_msource *rbe_left;
        struct ks_ip_msource *rbe_right;
        struct ks_ip_msource *rbe_parent;
    } ims_link;
    unsigned int ims_haddr;
    struct ks_ims_st ims_st[2];
    unsigned char ims_stp;
};
_Static_assert(offsetof(struct ks_ip_msource, ims_link) == 0x0, "ks_ip_msource.ims_link offset");
_Static_assert(offsetof(struct ks_ip_msource, ims_haddr) == 0x18, "ks_ip_msource.ims_haddr offset");
_Static_assert(offsetof(struct ks_ip_msource, ims_st) == 0x1C, "ks_ip_msource.ims_st offset");
_Static_assert(offsetof(struct ks_ip_msource, ims_stp) == 0x24, "ks_ip_msource.ims_stp offset");
_Static_assert(sizeof(struct ks_ip_msource) == 0x28, "ks_ip_msource size");

/* refs: 2 */
struct ks_ipc_conn_port_label {
};

/* refs: 2 */
struct ks_ipc_entry_table {
};

/* refs: 2 */
struct ks_ipc_importance_elem {
    unsigned int iie_bits;
    unsigned int iie_made;
    struct ks_queue_entry iie_kmsgs;
    unsigned int iie_externcnt;
    unsigned int iie_externdrop;
};
_Static_assert(offsetof(struct ks_ipc_importance_elem, iie_bits) == 0x0, "ks_ipc_importance_elem.iie_bits offset");
_Static_assert(offsetof(struct ks_ipc_importance_elem, iie_made) == 0x4, "ks_ipc_importance_elem.iie_made offset");
_Static_assert(offsetof(struct ks_ipc_importance_elem, iie_kmsgs) == 0x8, "ks_ipc_importance_elem.iie_kmsgs offset");
_Static_assert(offsetof(struct ks_ipc_importance_elem, iie_externcnt) == 0x18, "ks_ipc_importance_elem.iie_externcnt offset");
_Static_assert(offsetof(struct ks_ipc_importance_elem, iie_externdrop) == 0x1C, "ks_ipc_importance_elem.iie_externdrop offset");
_Static_assert(sizeof(struct ks_ipc_importance_elem) == 0x20, "ks_ipc_importance_elem size");

/* refs: 3 */
struct ks_ipc_importance_task {
    struct ks_ipc_importance_elem iit_elem;
    struct ks_task *iit_task;
    struct ks_queue_entry iit_inherits;
    struct ks_queue_entry *iit_updateq;
    struct ks_queue_entry iit_updates;
    struct ks_queue_entry iit_props;
    unsigned long long iit_updatetime;
    unsigned long long iit_transitions;
    unsigned int iit_assertcnt;
    unsigned int iit_legacy_externcnt;
    unsigned int iit_legacy_externdrop;
    unsigned int iit_receiver : 1; /* bit offset 992 */
    unsigned int iit_denap : 1; /* bit offset 993 */
    unsigned int iit_donor : 1; /* bit offset 994 */
    unsigned int iit_live_donor : 1; /* bit offset 995 */
    unsigned int iit_updatepolicy : 1; /* bit offset 996 */
    unsigned int iit_reserved : 3; /* bit offset 997 */
    unsigned int iit_filelocks : 24; /* bit offset 1000 */
};
_Static_assert(offsetof(struct ks_ipc_importance_task, iit_elem) == 0x0, "ks_ipc_importance_task.iit_elem offset");
_Static_assert(offsetof(struct ks_ipc_importance_task, iit_task) == 0x20, "ks_ipc_importance_task.iit_task offset");
_Static_assert(offsetof(struct ks_ipc_importance_task, iit_inherits) == 0x28, "ks_ipc_importance_task.iit_inherits offset");
_Static_assert(offsetof(struct ks_ipc_importance_task, iit_updateq) == 0x38, "ks_ipc_importance_task.iit_updateq offset");
_Static_assert(offsetof(struct ks_ipc_importance_task, iit_updates) == 0x40, "ks_ipc_importance_task.iit_updates offset");
_Static_assert(offsetof(struct ks_ipc_importance_task, iit_props) == 0x50, "ks_ipc_importance_task.iit_props offset");
_Static_assert(offsetof(struct ks_ipc_importance_task, iit_updatetime) == 0x60, "ks_ipc_importance_task.iit_updatetime offset");
_Static_assert(offsetof(struct ks_ipc_importance_task, iit_transitions) == 0x68, "ks_ipc_importance_task.iit_transitions offset");
_Static_assert(offsetof(struct ks_ipc_importance_task, iit_assertcnt) == 0x70, "ks_ipc_importance_task.iit_assertcnt offset");
_Static_assert(offsetof(struct ks_ipc_importance_task, iit_legacy_externcnt) == 0x74, "ks_ipc_importance_task.iit_legacy_externcnt offset");
_Static_assert(offsetof(struct ks_ipc_importance_task, iit_legacy_externdrop) == 0x78, "ks_ipc_importance_task.iit_legacy_externdrop offset");
_Static_assert(sizeof(struct ks_ipc_importance_task) == 0x80, "ks_ipc_importance_task size");

/* refs: 3 */
struct ks_ipc_kmsg {
    struct ks_queue_entry ikm_link;
    struct ks_ipc_port *ikm_voucher_port;
    struct ks_ipc_importance_elem *ikm_importance;
    struct ks_queue_entry ikm_inheritance;
    unsigned short ikm_aux_size;
    unsigned char ikm_keep_alive;
    unsigned char __ikm_padding;
    unsigned int ikm_ppriority;
    unsigned int ikm_signature;
    unsigned short ikm_flags;
    unsigned char ikm_qos_override;
    unsigned int ikm_voucher_type : 6; /* bit offset 504 */
    unsigned char ikm_type : 2; /* bit offset 510 */
    union {
        unsigned int ikm_big_data[0x30];
        struct {
            unsigned int ikm_small_data[0x2A];
            void *ikm_kdata;
            void *ikm_udata;
            unsigned int ikm_kdata_size;
            unsigned int ikm_udata_size;
        } __attribute__((aligned(4)));
    };
};
_Static_assert(offsetof(struct ks_ipc_kmsg, ikm_link) == 0x0, "ks_ipc_kmsg.ikm_link offset");
_Static_assert(offsetof(struct ks_ipc_kmsg, ikm_voucher_port) == 0x10, "ks_ipc_kmsg.ikm_voucher_port offset");
_Static_assert(offsetof(struct ks_ipc_kmsg, ikm_importance) == 0x18, "ks_ipc_kmsg.ikm_importance offset");
_Static_assert(offsetof(struct ks_ipc_kmsg, ikm_inheritance) == 0x20, "ks_ipc_kmsg.ikm_inheritance offset");
_Static_assert(offsetof(struct ks_ipc_kmsg, ikm_aux_size) == 0x30, "ks_ipc_kmsg.ikm_aux_size offset");
_Static_assert(offsetof(struct ks_ipc_kmsg, ikm_keep_alive) == 0x32, "ks_ipc_kmsg.ikm_keep_alive offset");
_Static_assert(offsetof(struct ks_ipc_kmsg, __ikm_padding) == 0x33, "ks_ipc_kmsg.__ikm_padding offset");
_Static_assert(offsetof(struct ks_ipc_kmsg, ikm_ppriority) == 0x34, "ks_ipc_kmsg.ikm_ppriority offset");
_Static_assert(offsetof(struct ks_ipc_kmsg, ikm_signature) == 0x38, "ks_ipc_kmsg.ikm_signature offset");
_Static_assert(offsetof(struct ks_ipc_kmsg, ikm_flags) == 0x3C, "ks_ipc_kmsg.ikm_flags offset");
_Static_assert(offsetof(struct ks_ipc_kmsg, ikm_qos_override) == 0x3E, "ks_ipc_kmsg.ikm_qos_override offset");
_Static_assert(sizeof(struct ks_ipc_kmsg) == 0x100, "ks_ipc_kmsg size");

/* refs: 1 */
struct ks_ipc_kobject_label {
    unsigned long long ikol_label;
    struct ks_ipc_port *ikol_alt_port;
};
_Static_assert(offsetof(struct ks_ipc_kobject_label, ikol_label) == 0x0, "ks_ipc_kobject_label.ikol_label offset");
_Static_assert(offsetof(struct ks_ipc_kobject_label, ikol_alt_port) == 0x8, "ks_ipc_kobject_label.ikol_alt_port offset");
_Static_assert(sizeof(struct ks_ipc_kobject_label) == 0x10, "ks_ipc_kobject_label size");

/* refs: 1 */
struct ks_ipc_mqueue {
    struct ks_circle_queue_head imq_messages;
    unsigned int imq_seqno;
    unsigned int imq_receiver_name;
    unsigned short imq_msgcount;
    unsigned short imq_qlimit;
    unsigned int imq_context;
    union {
        struct ks_klist imq_klist;
        struct ks_knote *imq_inheritor_knote;
        struct ks_turnstile *imq_inheritor_turnstile;
        struct ks_thread *imq_inheritor_thread_ref;
        struct ks_thread *imq_srp_owner_thread;
    };
};
_Static_assert(offsetof(struct ks_ipc_mqueue, imq_messages) == 0x0, "ks_ipc_mqueue.imq_messages offset");
_Static_assert(offsetof(struct ks_ipc_mqueue, imq_seqno) == 0x8, "ks_ipc_mqueue.imq_seqno offset");
_Static_assert(offsetof(struct ks_ipc_mqueue, imq_receiver_name) == 0xC, "ks_ipc_mqueue.imq_receiver_name offset");
_Static_assert(offsetof(struct ks_ipc_mqueue, imq_msgcount) == 0x10, "ks_ipc_mqueue.imq_msgcount offset");
_Static_assert(offsetof(struct ks_ipc_mqueue, imq_qlimit) == 0x12, "ks_ipc_mqueue.imq_qlimit offset");
_Static_assert(offsetof(struct ks_ipc_mqueue, imq_context) == 0x14, "ks_ipc_mqueue.imq_context offset");
_Static_assert(sizeof(struct ks_ipc_mqueue) == 0x20, "ks_ipc_mqueue size");

/* refs: 4 */
struct ks_ipc_object {
    union {
        struct {
            unsigned char io_type;
            unsigned char io_state : 3; /* bit offset 8 */
            unsigned char io_filtered : 1; /* bit offset 11 */
            unsigned char __io_unused1 : 4; /* bit offset 12 */
            _Bool io_label_lock;
            unsigned char __io_unused2;
        };
        unsigned int io_bits;
    };
    unsigned int io_references;
    union {
        const void *iol_pointer;
        unsigned long iol_value;
        struct ks_ipc_service_port_label *iol_service;
        struct ks_ipc_conn_port_label *iol_connection;
        struct ks_ipc_kobject_label *iol_kobject;
        struct ks_mk_timer *iol_mktimer;
    };
};
_Static_assert(offsetof(struct ks_ipc_object, io_references) == 0x4, "ks_ipc_object.io_references offset");
_Static_assert(sizeof(struct ks_ipc_object) == 0x10, "ks_ipc_object size");

/* refs: 28 */
struct ks_ipc_port {
    struct ks_ipc_object ip_object;
    union {
        struct {
            unsigned int ip_waitq_type : 3; /* bit offset 0 */
            unsigned int ip_waitq_fifo : 1; /* bit offset 3 */
            unsigned int ip_waitq_preposted : 1; /* bit offset 4 */
            unsigned int ip_fullwaiters : 1; /* bit offset 5 */
            unsigned int ip_sprequests : 1; /* bit offset 6 */
            unsigned int ip_spimportant : 1; /* bit offset 7 */
            unsigned int ip_impdonation : 1; /* bit offset 8 */
            unsigned int ip_tempowner : 1; /* bit offset 9 */
            unsigned int ip_guarded : 1; /* bit offset 10 */
            unsigned int ip_strict_guard : 1; /* bit offset 11 */
            unsigned int ip_sync_link_state : 3; /* bit offset 12 */
            unsigned int ip_sync_bootstrap_checkin : 1; /* bit offset 15 */
            unsigned int ip_tg_block_tracking : 1; /* bit offset 16 */
            unsigned int ip_has_watchport : 1; /* bit offset 17 */
            unsigned int ip_kernel_iotier_override : 2; /* bit offset 18 */
            unsigned int ip_kernel_qos_override : 3; /* bit offset 20 */
            unsigned int ip_srp_lost_link : 1; /* bit offset 23 */
            unsigned int ip_srp_msg_sent : 1; /* bit offset 24 */
            unsigned int __ip_unused : 7; /* bit offset 25 */
        };
        struct ks_waitq ip_waitq __attribute__((aligned(8)));
    };
    struct ks_ipc_mqueue ip_messages;
    union {
        struct ks_ipc_space *ip_receiver;
        struct ks_ipc_port *ip_destination;
        unsigned long ip_timestamp;
    };
    union {
        unsigned long ip_kobject;
        struct ks_ipc_port *ip_nsrequest;
    };
    union {
        struct ks_ipc_importance_task *ip_imp_task;
        struct ks_ipc_port *ip_sync_inheritor_port;
        struct ks_knote *ip_sync_inheritor_knote;
        struct ks_turnstile *ip_sync_inheritor_ts;
    };
    union {
        int ip_pid;
        struct ks_task_watchport_elem *ip_twe;
        struct ks_ipc_port *ip_pdrequest;
    };
    struct ks_ipc_port_request_table *ip_requests;
    struct ks_turnstile *ip_send_turnstile;
    unsigned long long ip_context;
    unsigned int ip_impcount;
    unsigned int ip_mscount;
    unsigned int ip_srights;
    unsigned int ip_sorights;
};
_Static_assert(offsetof(struct ks_ipc_port, ip_object) == 0x0, "ks_ipc_port.ip_object offset");
_Static_assert(offsetof(struct ks_ipc_port, ip_messages) == 0x28, "ks_ipc_port.ip_messages offset");
_Static_assert(offsetof(struct ks_ipc_port, ip_requests) == 0x68, "ks_ipc_port.ip_requests offset");
_Static_assert(offsetof(struct ks_ipc_port, ip_send_turnstile) == 0x70, "ks_ipc_port.ip_send_turnstile offset");
_Static_assert(offsetof(struct ks_ipc_port, ip_context) == 0x78, "ks_ipc_port.ip_context offset");
_Static_assert(offsetof(struct ks_ipc_port, ip_impcount) == 0x80, "ks_ipc_port.ip_impcount offset");
_Static_assert(offsetof(struct ks_ipc_port, ip_mscount) == 0x84, "ks_ipc_port.ip_mscount offset");
_Static_assert(offsetof(struct ks_ipc_port, ip_srights) == 0x88, "ks_ipc_port.ip_srights offset");
_Static_assert(offsetof(struct ks_ipc_port, ip_sorights) == 0x8C, "ks_ipc_port.ip_sorights offset");
_Static_assert(sizeof(struct ks_ipc_port) == 0x90, "ks_ipc_port size");

/* refs: 2 */
struct ks_ipc_port_request_table {
};

/* refs: 2 */
struct ks_waitq_set {
    struct {
        unsigned int wqset_type : 3; /* bit offset 0 */
        unsigned int wqset_fifo : 1; /* bit offset 3 */
        unsigned int wqset_preposted : 1; /* bit offset 4 */
        unsigned int wqset_index : 27; /* bit offset 5 */
    };
    union ks_hw_lck_ticket_s wqset_interlock;
    unsigned char wqset_padding[0];
    union {
        struct ks_circle_queue_head wqset_queue;
        struct ks_priority_queue_sched_max wqset_prio_queue;
        struct ks_turnstile *wqset_ts;
    };
    union {
        struct ks_circle_queue_head wqset_links;
        struct ks_waitq_link_list_entry wqset_sellinks;
        void *wqset_inheritor;
        struct ks_mpsc_queue_chain wqset_defer;
    };
    struct ks_circle_queue_head wqset_preposts;
};
_Static_assert(offsetof(struct ks_waitq_set, wqset_interlock) == 0x4, "ks_waitq_set.wqset_interlock offset");
_Static_assert(offsetof(struct ks_waitq_set, wqset_padding) == 0x8, "ks_waitq_set.wqset_padding offset");
_Static_assert(offsetof(struct ks_waitq_set, wqset_preposts) == 0x18, "ks_waitq_set.wqset_preposts offset");
_Static_assert(sizeof(struct ks_waitq_set) == 0x20, "ks_waitq_set size");

/* refs: 1 */
struct ks_ipc_pset {
    struct ks_ipc_object ips_object;
    struct ks_waitq_set ips_wqset;
    struct ks_klist ips_klist;
};
_Static_assert(offsetof(struct ks_ipc_pset, ips_object) == 0x0, "ks_ipc_pset.ips_object offset");
_Static_assert(offsetof(struct ks_ipc_pset, ips_wqset) == 0x10, "ks_ipc_pset.ips_wqset offset");
_Static_assert(offsetof(struct ks_ipc_pset, ips_klist) == 0x30, "ks_ipc_pset.ips_klist offset");
_Static_assert(sizeof(struct ks_ipc_pset) == 0x38, "ks_ipc_pset size");

/* refs: 1 */
struct ks_ipc_service_port_label {
    struct ks_ipc_conn_port_label *ispl_sblabel;
    unsigned long ispl_launchd_context;
    unsigned int ispl_launchd_name;
    unsigned char ispl_throttled : 1; /* bit offset 160 */
    unsigned char __ispl_unused : 7; /* bit offset 161 */
    unsigned char ispl_domain;
    char *ispl_service_name;
};
_Static_assert(offsetof(struct ks_ipc_service_port_label, ispl_sblabel) == 0x0, "ks_ipc_service_port_label.ispl_sblabel offset");
_Static_assert(offsetof(struct ks_ipc_service_port_label, ispl_launchd_context) == 0x8, "ks_ipc_service_port_label.ispl_launchd_context offset");
_Static_assert(offsetof(struct ks_ipc_service_port_label, ispl_launchd_name) == 0x10, "ks_ipc_service_port_label.ispl_launchd_name offset");
_Static_assert(offsetof(struct ks_ipc_service_port_label, ispl_domain) == 0x15, "ks_ipc_service_port_label.ispl_domain offset");
_Static_assert(offsetof(struct ks_ipc_service_port_label, ispl_service_name) == 0x18, "ks_ipc_service_port_label.ispl_service_name offset");
_Static_assert(sizeof(struct ks_ipc_service_port_label) == 0x20, "ks_ipc_service_port_label size");

/* refs: 4 */
struct ks_lck_ticket_s {
    unsigned int __lck_ticket_unused : 24; /* bit offset 0 */
    unsigned int lck_ticket_type : 8; /* bit offset 24 */
    unsigned int lck_ticket_padding;
    union ks_hw_lck_ticket_s tu;
    unsigned int lck_ticket_owner;
};
_Static_assert(offsetof(struct ks_lck_ticket_s, lck_ticket_padding) == 0x4, "ks_lck_ticket_s.lck_ticket_padding offset");
_Static_assert(offsetof(struct ks_lck_ticket_s, tu) == 0x8, "ks_lck_ticket_s.tu offset");
_Static_assert(offsetof(struct ks_lck_ticket_s, lck_ticket_owner) == 0xC, "ks_lck_ticket_s.lck_ticket_owner offset");
_Static_assert(sizeof(struct ks_lck_ticket_s) == 0x10, "ks_lck_ticket_s size");

/* refs: 2 */
struct ks_ipc_space {
    struct ks_lck_ticket_s is_lock;
    unsigned int is_bits;
    unsigned int is_table_hashed;
    unsigned int is_table_free;
    unsigned int is_entropy[1];
    struct ks_bool_gen is_prng;
    struct {
        struct ks_ipc_entry_table *__smr_ptr;
    } is_table;
    struct ks_task *is_task;
    unsigned long is_policy;
    struct ks_thread *is_grower;
    unsigned long long is_label;
    unsigned int is_low_mod;
    unsigned int is_high_mod;
    unsigned char is_telemetry;
};
_Static_assert(offsetof(struct ks_ipc_space, is_lock) == 0x0, "ks_ipc_space.is_lock offset");
_Static_assert(offsetof(struct ks_ipc_space, is_bits) == 0x10, "ks_ipc_space.is_bits offset");
_Static_assert(offsetof(struct ks_ipc_space, is_table_hashed) == 0x14, "ks_ipc_space.is_table_hashed offset");
_Static_assert(offsetof(struct ks_ipc_space, is_table_free) == 0x18, "ks_ipc_space.is_table_free offset");
_Static_assert(offsetof(struct ks_ipc_space, is_entropy) == 0x1C, "ks_ipc_space.is_entropy offset");
_Static_assert(offsetof(struct ks_ipc_space, is_prng) == 0x20, "ks_ipc_space.is_prng offset");
_Static_assert(offsetof(struct ks_ipc_space, is_table) == 0x48, "ks_ipc_space.is_table offset");
_Static_assert(offsetof(struct ks_ipc_space, is_task) == 0x50, "ks_ipc_space.is_task offset");
_Static_assert(offsetof(struct ks_ipc_space, is_policy) == 0x58, "ks_ipc_space.is_policy offset");
_Static_assert(offsetof(struct ks_ipc_space, is_grower) == 0x60, "ks_ipc_space.is_grower offset");
_Static_assert(offsetof(struct ks_ipc_space, is_label) == 0x68, "ks_ipc_space.is_label offset");
_Static_assert(offsetof(struct ks_ipc_space, is_low_mod) == 0x70, "ks_ipc_space.is_low_mod offset");
_Static_assert(offsetof(struct ks_ipc_space, is_high_mod) == 0x74, "ks_ipc_space.is_high_mod offset");
_Static_assert(offsetof(struct ks_ipc_space, is_telemetry) == 0x78, "ks_ipc_space.is_telemetry offset");
_Static_assert(sizeof(struct ks_ipc_space) == 0x80, "ks_ipc_space size");

/* refs: 3 */
struct ks_itimerval {
    struct ks_timeval it_interval;
    struct ks_timeval it_value;
};
_Static_assert(offsetof(struct ks_itimerval, it_interval) == 0x0, "ks_itimerval.it_interval offset");
_Static_assert(offsetof(struct ks_itimerval, it_value) == 0x10, "ks_itimerval.it_value offset");
_Static_assert(sizeof(struct ks_itimerval) == 0x20, "ks_itimerval size");

/* refs: 3 */
struct ks_kaudit_record {
    struct ks_audit_record k_ar;
    unsigned int k_ar_commit;
    void *k_udata;
    unsigned int k_ulen;
    struct ks_uthread *k_uthread;
    struct {
        struct ks_kaudit_record *tqe_next;
        struct ks_kaudit_record **tqe_prev;
    } k_q;
};
_Static_assert(offsetof(struct ks_kaudit_record, k_ar) == 0x0, "ks_kaudit_record.k_ar offset");
_Static_assert(offsetof(struct ks_kaudit_record, k_ar_commit) == 0x5F8, "ks_kaudit_record.k_ar_commit offset");
_Static_assert(offsetof(struct ks_kaudit_record, k_udata) == 0x600, "ks_kaudit_record.k_udata offset");
_Static_assert(offsetof(struct ks_kaudit_record, k_ulen) == 0x608, "ks_kaudit_record.k_ulen offset");
_Static_assert(offsetof(struct ks_kaudit_record, k_uthread) == 0x610, "ks_kaudit_record.k_uthread offset");
_Static_assert(offsetof(struct ks_kaudit_record, k_q) == 0x618, "ks_kaudit_record.k_q offset");
_Static_assert(sizeof(struct ks_kaudit_record) == 0x628, "ks_kaudit_record size");

/* refs: 4 */
union ks_guid_t {
    unsigned char g_guid[0x10];
    unsigned int g_guid_asint[4];
};
_Static_assert(offsetof(union ks_guid_t, g_guid) == 0x0, "ks_guid_t.g_guid offset");
_Static_assert(offsetof(union ks_guid_t, g_guid_asint) == 0x0, "ks_guid_t.g_guid_asint offset");

/* refs: 1 */
struct ks_kauth_ace {
    union ks_guid_t ace_applicable;
    unsigned int ace_flags;
    unsigned int ace_rights;
};
_Static_assert(offsetof(struct ks_kauth_ace, ace_applicable) == 0x0, "ks_kauth_ace.ace_applicable offset");
_Static_assert(offsetof(struct ks_kauth_ace, ace_flags) == 0x10, "ks_kauth_ace.ace_flags offset");
_Static_assert(offsetof(struct ks_kauth_ace, ace_rights) == 0x14, "ks_kauth_ace.ace_rights offset");
_Static_assert(sizeof(struct ks_kauth_ace) == 0x18, "ks_kauth_ace size");

/* refs: 2 */
struct ks_kauth_acl {
    unsigned int acl_entrycount;
    unsigned int acl_flags;
    struct ks_kauth_ace acl_ace[1];
};
_Static_assert(offsetof(struct ks_kauth_acl, acl_entrycount) == 0x0, "ks_kauth_acl.acl_entrycount offset");
_Static_assert(offsetof(struct ks_kauth_acl, acl_flags) == 0x4, "ks_kauth_acl.acl_flags offset");
_Static_assert(offsetof(struct ks_kauth_acl, acl_ace) == 0x8, "ks_kauth_acl.acl_ace offset");
_Static_assert(sizeof(struct ks_kauth_acl) == 0x20, "ks_kauth_acl size");

/* refs: 2 */
struct ks_z_stream_s {
    unsigned char *next_in;
    unsigned int avail_in;
    unsigned long total_in;
    unsigned char *next_out;
    unsigned int avail_out;
    unsigned long total_out;
    char *msg;
    struct ks_internal_state *state;
    void **zalloc;
    void *zfree;
    void *opaque;
    int data_type;
    unsigned long adler;
    unsigned long reserved;
};
_Static_assert(offsetof(struct ks_z_stream_s, next_in) == 0x0, "ks_z_stream_s.next_in offset");
_Static_assert(offsetof(struct ks_z_stream_s, avail_in) == 0x8, "ks_z_stream_s.avail_in offset");
_Static_assert(offsetof(struct ks_z_stream_s, total_in) == 0x10, "ks_z_stream_s.total_in offset");
_Static_assert(offsetof(struct ks_z_stream_s, next_out) == 0x18, "ks_z_stream_s.next_out offset");
_Static_assert(offsetof(struct ks_z_stream_s, avail_out) == 0x20, "ks_z_stream_s.avail_out offset");
_Static_assert(offsetof(struct ks_z_stream_s, total_out) == 0x28, "ks_z_stream_s.total_out offset");
_Static_assert(offsetof(struct ks_z_stream_s, msg) == 0x30, "ks_z_stream_s.msg offset");
_Static_assert(offsetof(struct ks_z_stream_s, state) == 0x38, "ks_z_stream_s.state offset");
_Static_assert(offsetof(struct ks_z_stream_s, zalloc) == 0x40, "ks_z_stream_s.zalloc offset");
_Static_assert(offsetof(struct ks_z_stream_s, zfree) == 0x48, "ks_z_stream_s.zfree offset");
_Static_assert(offsetof(struct ks_z_stream_s, opaque) == 0x50, "ks_z_stream_s.opaque offset");
_Static_assert(offsetof(struct ks_z_stream_s, data_type) == 0x58, "ks_z_stream_s.data_type offset");
_Static_assert(offsetof(struct ks_z_stream_s, adler) == 0x60, "ks_z_stream_s.adler offset");
_Static_assert(offsetof(struct ks_z_stream_s, reserved) == 0x68, "ks_z_stream_s.reserved offset");
_Static_assert(sizeof(struct ks_z_stream_s) == 0x70, "ks_z_stream_s size");

/* refs: 1 */
struct ks_kcdata_compress_descriptor {
    struct ks_z_stream_s kcd_cd_zs;
    void *kcd_cd_base;
    unsigned long long kcd_cd_offset;
    unsigned long kcd_cd_maxoffset;
    unsigned long long kcd_cd_mark_begin;
    unsigned long long kcd_cd_flags;
    unsigned long long kcd_cd_compression_type;
    void *kcd_cd_memcpy_f;
    unsigned long long kcd_cd_totalout_addr;
    unsigned long long kcd_cd_totalin_addr;
};
_Static_assert(offsetof(struct ks_kcdata_compress_descriptor, kcd_cd_zs) == 0x0, "ks_kcdata_compress_descriptor.kcd_cd_zs offset");
_Static_assert(offsetof(struct ks_kcdata_compress_descriptor, kcd_cd_base) == 0x70, "ks_kcdata_compress_descriptor.kcd_cd_base offset");
_Static_assert(offsetof(struct ks_kcdata_compress_descriptor, kcd_cd_offset) == 0x78, "ks_kcdata_compress_descriptor.kcd_cd_offset offset");
_Static_assert(offsetof(struct ks_kcdata_compress_descriptor, kcd_cd_maxoffset) == 0x80, "ks_kcdata_compress_descriptor.kcd_cd_maxoffset offset");
_Static_assert(offsetof(struct ks_kcdata_compress_descriptor, kcd_cd_mark_begin) == 0x88, "ks_kcdata_compress_descriptor.kcd_cd_mark_begin offset");
_Static_assert(offsetof(struct ks_kcdata_compress_descriptor, kcd_cd_flags) == 0x90, "ks_kcdata_compress_descriptor.kcd_cd_flags offset");
_Static_assert(offsetof(struct ks_kcdata_compress_descriptor, kcd_cd_compression_type) == 0x98, "ks_kcdata_compress_descriptor.kcd_cd_compression_type offset");
_Static_assert(offsetof(struct ks_kcdata_compress_descriptor, kcd_cd_memcpy_f) == 0xA0, "ks_kcdata_compress_descriptor.kcd_cd_memcpy_f offset");
_Static_assert(offsetof(struct ks_kcdata_compress_descriptor, kcd_cd_totalout_addr) == 0xA8, "ks_kcdata_compress_descriptor.kcd_cd_totalout_addr offset");
_Static_assert(offsetof(struct ks_kcdata_compress_descriptor, kcd_cd_totalin_addr) == 0xB0, "ks_kcdata_compress_descriptor.kcd_cd_totalin_addr offset");
_Static_assert(sizeof(struct ks_kcdata_compress_descriptor) == 0xB8, "ks_kcdata_compress_descriptor size");

/* refs: 3 */
struct ks_kcdata_descriptor {
    unsigned int kcd_length;
    unsigned short kcd_flags;
    unsigned short kcd_user_flags;
    unsigned long long kcd_addr_begin;
    unsigned long long kcd_addr_end;
    struct ks_kcdata_compress_descriptor kcd_comp_d;
    unsigned int kcd_endalloced;
    struct ks_kcdata_descriptor **kcd_alloc_callback;
};
_Static_assert(offsetof(struct ks_kcdata_descriptor, kcd_length) == 0x0, "ks_kcdata_descriptor.kcd_length offset");
_Static_assert(offsetof(struct ks_kcdata_descriptor, kcd_flags) == 0x4, "ks_kcdata_descriptor.kcd_flags offset");
_Static_assert(offsetof(struct ks_kcdata_descriptor, kcd_user_flags) == 0x6, "ks_kcdata_descriptor.kcd_user_flags offset");
_Static_assert(offsetof(struct ks_kcdata_descriptor, kcd_addr_begin) == 0x8, "ks_kcdata_descriptor.kcd_addr_begin offset");
_Static_assert(offsetof(struct ks_kcdata_descriptor, kcd_addr_end) == 0x10, "ks_kcdata_descriptor.kcd_addr_end offset");
_Static_assert(offsetof(struct ks_kcdata_descriptor, kcd_comp_d) == 0x18, "ks_kcdata_descriptor.kcd_comp_d offset");
_Static_assert(offsetof(struct ks_kcdata_descriptor, kcd_endalloced) == 0xD0, "ks_kcdata_descriptor.kcd_endalloced offset");
_Static_assert(offsetof(struct ks_kcdata_descriptor, kcd_alloc_callback) == 0xD8, "ks_kcdata_descriptor.kcd_alloc_callback offset");
_Static_assert(sizeof(struct ks_kcdata_descriptor) == 0xE0, "ks_kcdata_descriptor size");

/* refs: 3 */
struct ks_skmem_arena_mmap_info {
    struct {
        struct ks_skmem_arena_mmap_info *sle_next;
    } ami_link;
    struct ks_skmem_arena *ami_arena;
    struct ks_IOSKMapper *ami_mapref;
    struct ks_task *ami_maptask;
    unsigned long long ami_mapaddr;
    unsigned long long ami_mapsize;
    int ami_redirect;
};
_Static_assert(offsetof(struct ks_skmem_arena_mmap_info, ami_link) == 0x0, "ks_skmem_arena_mmap_info.ami_link offset");
_Static_assert(offsetof(struct ks_skmem_arena_mmap_info, ami_arena) == 0x8, "ks_skmem_arena_mmap_info.ami_arena offset");
_Static_assert(offsetof(struct ks_skmem_arena_mmap_info, ami_mapref) == 0x10, "ks_skmem_arena_mmap_info.ami_mapref offset");
_Static_assert(offsetof(struct ks_skmem_arena_mmap_info, ami_maptask) == 0x18, "ks_skmem_arena_mmap_info.ami_maptask offset");
_Static_assert(offsetof(struct ks_skmem_arena_mmap_info, ami_mapaddr) == 0x20, "ks_skmem_arena_mmap_info.ami_mapaddr offset");
_Static_assert(offsetof(struct ks_skmem_arena_mmap_info, ami_mapsize) == 0x28, "ks_skmem_arena_mmap_info.ami_mapsize offset");
_Static_assert(offsetof(struct ks_skmem_arena_mmap_info, ami_redirect) == 0x30, "ks_skmem_arena_mmap_info.ami_redirect offset");
_Static_assert(sizeof(struct ks_skmem_arena_mmap_info) == 0x38, "ks_skmem_arena_mmap_info size");

/* refs: 11 */
struct ks_kern_channel {
    struct ks_lck_mtx_s ch_lock;
    struct ks_nexus_adapter *ch_na;
    struct ks_kern_nexus *ch_nexus;
    struct ks_ch_info *ch_info;
    struct ks_kern_pbufpool *ch_pp;
    unsigned int ch_refcnt;
    unsigned int ch_flags;
    unsigned int ch_first[6];
    unsigned int ch_last[6];
    struct ks___user_channel_schema *ch_schema;
    struct ks_ch_selinfo *ch_si[6];
    struct {
        struct ks_kern_channel *stqe_next;
    } ch_link;
    struct {
        struct ks_kern_channel *stqe_next;
    } ch_link_if_adv;
    void *ch_ctx;
    unsigned long long ch_schema_offset;
    struct ks_skmem_arena_mmap_info ch_mmap;
    int ch_fd;
    int ch_pid;
    char ch_name[0x20];
};
_Static_assert(offsetof(struct ks_kern_channel, ch_lock) == 0x0, "ks_kern_channel.ch_lock offset");
_Static_assert(offsetof(struct ks_kern_channel, ch_na) == 0x10, "ks_kern_channel.ch_na offset");
_Static_assert(offsetof(struct ks_kern_channel, ch_nexus) == 0x18, "ks_kern_channel.ch_nexus offset");
_Static_assert(offsetof(struct ks_kern_channel, ch_info) == 0x20, "ks_kern_channel.ch_info offset");
_Static_assert(offsetof(struct ks_kern_channel, ch_pp) == 0x28, "ks_kern_channel.ch_pp offset");
_Static_assert(offsetof(struct ks_kern_channel, ch_refcnt) == 0x30, "ks_kern_channel.ch_refcnt offset");
_Static_assert(offsetof(struct ks_kern_channel, ch_flags) == 0x34, "ks_kern_channel.ch_flags offset");
_Static_assert(offsetof(struct ks_kern_channel, ch_first) == 0x38, "ks_kern_channel.ch_first offset");
_Static_assert(offsetof(struct ks_kern_channel, ch_last) == 0x50, "ks_kern_channel.ch_last offset");
_Static_assert(offsetof(struct ks_kern_channel, ch_schema) == 0x68, "ks_kern_channel.ch_schema offset");
_Static_assert(offsetof(struct ks_kern_channel, ch_si) == 0x70, "ks_kern_channel.ch_si offset");
_Static_assert(offsetof(struct ks_kern_channel, ch_link) == 0xA0, "ks_kern_channel.ch_link offset");
_Static_assert(offsetof(struct ks_kern_channel, ch_link_if_adv) == 0xA8, "ks_kern_channel.ch_link_if_adv offset");
_Static_assert(offsetof(struct ks_kern_channel, ch_ctx) == 0xB0, "ks_kern_channel.ch_ctx offset");
_Static_assert(offsetof(struct ks_kern_channel, ch_schema_offset) == 0xB8, "ks_kern_channel.ch_schema_offset offset");
_Static_assert(offsetof(struct ks_kern_channel, ch_mmap) == 0xC0, "ks_kern_channel.ch_mmap offset");
_Static_assert(offsetof(struct ks_kern_channel, ch_fd) == 0xF8, "ks_kern_channel.ch_fd offset");
_Static_assert(offsetof(struct ks_kern_channel, ch_pid) == 0xFC, "ks_kern_channel.ch_pid offset");
_Static_assert(offsetof(struct ks_kern_channel, ch_name) == 0x100, "ks_kern_channel.ch_name offset");
_Static_assert(sizeof(struct ks_kern_channel) == 0x120, "ks_kern_channel size");

/* refs: 1 */
struct ks_kern_nexus_advisory {
    struct ks_skmem_region *nxv_reg;
    void *nxv_adv;
    unsigned int nxv_adv_type;
    union {
        struct ks_sk_nexusadv *flowswitch_nxv_adv;
        struct ks_netif_nexus_advisory *netif_nxv_adv;
    };
    unsigned int nxv_adv_size;
};
_Static_assert(offsetof(struct ks_kern_nexus_advisory, nxv_reg) == 0x0, "ks_kern_nexus_advisory.nxv_reg offset");
_Static_assert(offsetof(struct ks_kern_nexus_advisory, nxv_adv) == 0x8, "ks_kern_nexus_advisory.nxv_adv offset");
_Static_assert(offsetof(struct ks_kern_nexus_advisory, nxv_adv_type) == 0x10, "ks_kern_nexus_advisory.nxv_adv_type offset");
_Static_assert(offsetof(struct ks_kern_nexus_advisory, nxv_adv_size) == 0x20, "ks_kern_nexus_advisory.nxv_adv_size offset");
_Static_assert(sizeof(struct ks_kern_nexus_advisory) == 0x28, "ks_kern_nexus_advisory size");

/* refs: 10 */
struct ks_kern_nexus {
    unsigned int nx_refcnt;
    unsigned int nx_flags;
    void *nx_ctx;
    void *nx_ctx_release;
    struct ks_kern_nexus_provider *nx_prov;
    unsigned long long nx_id;
    unsigned char nx_uuid[0x10];
    struct {
        struct ks_kern_nexus *stqe_next;
    } nx_prov_link;
    struct {
        struct ks_kern_nexus *rbe_left;
        struct ks_kern_nexus *rbe_right;
        struct ks_kern_nexus *rbe_parent;
    } nx_link;
    struct {
        struct ks_kern_channel *stqh_first;
        struct ks_kern_channel **stqh_last;
    } nx_ch_head;
    unsigned int nx_ch_count;
    struct {
        struct ks_kern_channel *stqh_first;
        struct ks_kern_channel **stqh_last;
    } nx_ch_nonxref_head;
    struct ks_lck_rw_s nx_ch_if_adv_lock;
    struct {
        struct ks_kern_channel *stqh_first;
        struct ks_kern_channel **stqh_last;
    } nx_ch_if_adv_head;
    void *nx_arg;
    struct ks_kern_pbufpool *nx_rx_pp;
    struct ks_kern_pbufpool *nx_tx_pp;
    struct ks_kern_nexus_advisory nx_adv;
    struct ks_nx_port_info *nx_ports;
    unsigned long long *nx_ports_bmap;
    unsigned short nx_active_ports;
    unsigned short nx_num_ports;
    unsigned long nx_ports_bmap_size;
};
_Static_assert(offsetof(struct ks_kern_nexus, nx_refcnt) == 0x0, "ks_kern_nexus.nx_refcnt offset");
_Static_assert(offsetof(struct ks_kern_nexus, nx_flags) == 0x4, "ks_kern_nexus.nx_flags offset");
_Static_assert(offsetof(struct ks_kern_nexus, nx_ctx) == 0x8, "ks_kern_nexus.nx_ctx offset");
_Static_assert(offsetof(struct ks_kern_nexus, nx_ctx_release) == 0x10, "ks_kern_nexus.nx_ctx_release offset");
_Static_assert(offsetof(struct ks_kern_nexus, nx_prov) == 0x18, "ks_kern_nexus.nx_prov offset");
_Static_assert(offsetof(struct ks_kern_nexus, nx_id) == 0x20, "ks_kern_nexus.nx_id offset");
_Static_assert(offsetof(struct ks_kern_nexus, nx_uuid) == 0x28, "ks_kern_nexus.nx_uuid offset");
_Static_assert(offsetof(struct ks_kern_nexus, nx_prov_link) == 0x38, "ks_kern_nexus.nx_prov_link offset");
_Static_assert(offsetof(struct ks_kern_nexus, nx_link) == 0x40, "ks_kern_nexus.nx_link offset");
_Static_assert(offsetof(struct ks_kern_nexus, nx_ch_head) == 0x58, "ks_kern_nexus.nx_ch_head offset");
_Static_assert(offsetof(struct ks_kern_nexus, nx_ch_count) == 0x68, "ks_kern_nexus.nx_ch_count offset");
_Static_assert(offsetof(struct ks_kern_nexus, nx_ch_nonxref_head) == 0x70, "ks_kern_nexus.nx_ch_nonxref_head offset");
_Static_assert(offsetof(struct ks_kern_nexus, nx_ch_if_adv_lock) == 0x80, "ks_kern_nexus.nx_ch_if_adv_lock offset");
_Static_assert(offsetof(struct ks_kern_nexus, nx_ch_if_adv_head) == 0x90, "ks_kern_nexus.nx_ch_if_adv_head offset");
_Static_assert(offsetof(struct ks_kern_nexus, nx_arg) == 0xA0, "ks_kern_nexus.nx_arg offset");
_Static_assert(offsetof(struct ks_kern_nexus, nx_rx_pp) == 0xA8, "ks_kern_nexus.nx_rx_pp offset");
_Static_assert(offsetof(struct ks_kern_nexus, nx_tx_pp) == 0xB0, "ks_kern_nexus.nx_tx_pp offset");
_Static_assert(offsetof(struct ks_kern_nexus, nx_adv) == 0xB8, "ks_kern_nexus.nx_adv offset");
_Static_assert(offsetof(struct ks_kern_nexus, nx_ports) == 0xE0, "ks_kern_nexus.nx_ports offset");
_Static_assert(offsetof(struct ks_kern_nexus, nx_ports_bmap) == 0xE8, "ks_kern_nexus.nx_ports_bmap offset");
_Static_assert(offsetof(struct ks_kern_nexus, nx_active_ports) == 0xF0, "ks_kern_nexus.nx_active_ports offset");
_Static_assert(offsetof(struct ks_kern_nexus, nx_num_ports) == 0xF2, "ks_kern_nexus.nx_num_ports offset");
_Static_assert(offsetof(struct ks_kern_nexus, nx_ports_bmap_size) == 0xF8, "ks_kern_nexus.nx_ports_bmap_size offset");
_Static_assert(sizeof(struct ks_kern_nexus) == 0x100, "ks_kern_nexus size");

/* refs: 1 */
struct ks_kern_nexus_domain_provider_init {
    unsigned int nxdpi_version;
    unsigned int nxdpi_flags;
    int *nxdpi_init;
    void *nxdpi_fini;
};
_Static_assert(offsetof(struct ks_kern_nexus_domain_provider_init, nxdpi_version) == 0x0, "ks_kern_nexus_domain_provider_init.nxdpi_version offset");
_Static_assert(offsetof(struct ks_kern_nexus_domain_provider_init, nxdpi_flags) == 0x4, "ks_kern_nexus_domain_provider_init.nxdpi_flags offset");
_Static_assert(offsetof(struct ks_kern_nexus_domain_provider_init, nxdpi_init) == 0x8, "ks_kern_nexus_domain_provider_init.nxdpi_init offset");
_Static_assert(offsetof(struct ks_kern_nexus_domain_provider_init, nxdpi_fini) == 0x10, "ks_kern_nexus_domain_provider_init.nxdpi_fini offset");
_Static_assert(sizeof(struct ks_kern_nexus_domain_provider_init) == 0x18, "ks_kern_nexus_domain_provider_init size");

/* refs: 1 */
struct ks_nxdom_prov_cb {
    int *dp_cb_init;
    void *dp_cb_fini;
    int *dp_cb_params;
    int *dp_cb_mem_new;
    int *dp_cb_config;
    int *dp_cb_nx_ctor;
    void *dp_cb_nx_dtor;
    int *dp_cb_nx_mem_info;
    unsigned long *dp_cb_nx_mib_get;
    int *dp_cb_nx_stop;
};
_Static_assert(offsetof(struct ks_nxdom_prov_cb, dp_cb_init) == 0x0, "ks_nxdom_prov_cb.dp_cb_init offset");
_Static_assert(offsetof(struct ks_nxdom_prov_cb, dp_cb_fini) == 0x8, "ks_nxdom_prov_cb.dp_cb_fini offset");
_Static_assert(offsetof(struct ks_nxdom_prov_cb, dp_cb_params) == 0x10, "ks_nxdom_prov_cb.dp_cb_params offset");
_Static_assert(offsetof(struct ks_nxdom_prov_cb, dp_cb_mem_new) == 0x18, "ks_nxdom_prov_cb.dp_cb_mem_new offset");
_Static_assert(offsetof(struct ks_nxdom_prov_cb, dp_cb_config) == 0x20, "ks_nxdom_prov_cb.dp_cb_config offset");
_Static_assert(offsetof(struct ks_nxdom_prov_cb, dp_cb_nx_ctor) == 0x28, "ks_nxdom_prov_cb.dp_cb_nx_ctor offset");
_Static_assert(offsetof(struct ks_nxdom_prov_cb, dp_cb_nx_dtor) == 0x30, "ks_nxdom_prov_cb.dp_cb_nx_dtor offset");
_Static_assert(offsetof(struct ks_nxdom_prov_cb, dp_cb_nx_mem_info) == 0x38, "ks_nxdom_prov_cb.dp_cb_nx_mem_info offset");
_Static_assert(offsetof(struct ks_nxdom_prov_cb, dp_cb_nx_mib_get) == 0x40, "ks_nxdom_prov_cb.dp_cb_nx_mib_get offset");
_Static_assert(offsetof(struct ks_nxdom_prov_cb, dp_cb_nx_stop) == 0x48, "ks_nxdom_prov_cb.dp_cb_nx_stop offset");
_Static_assert(sizeof(struct ks_nxdom_prov_cb) == 0x50, "ks_nxdom_prov_cb size");

/* refs: 6 */
struct ks_kern_nexus_domain_provider {
    struct {
        struct ks_kern_nexus_domain_provider *stqe_next;
    } nxdom_prov_link;
    struct {
        struct ks_kern_nexus_domain_provider *stqe_next;
    } nxdom_prov_detaching_link;
    char nxdom_prov_name[0x40];
    unsigned char nxdom_prov_uuid[0x10];
    unsigned long long nxdom_prov_gencnt;
    unsigned int nxdom_prov_refcnt;
    unsigned int nxdom_prov_flags;
    struct ks_nxdom *nxdom_prov_dom;
    struct ks_kern_nexus_domain_provider_init nxdom_prov_ext;
    struct ks_nxdom_prov_cb nxdom_prov_cb;
};
_Static_assert(offsetof(struct ks_kern_nexus_domain_provider, nxdom_prov_link) == 0x0, "ks_kern_nexus_domain_provider.nxdom_prov_link offset");
_Static_assert(offsetof(struct ks_kern_nexus_domain_provider, nxdom_prov_detaching_link) == 0x8, "ks_kern_nexus_domain_provider.nxdom_prov_detaching_link offset");
_Static_assert(offsetof(struct ks_kern_nexus_domain_provider, nxdom_prov_name) == 0x10, "ks_kern_nexus_domain_provider.nxdom_prov_name offset");
_Static_assert(offsetof(struct ks_kern_nexus_domain_provider, nxdom_prov_uuid) == 0x50, "ks_kern_nexus_domain_provider.nxdom_prov_uuid offset");
_Static_assert(offsetof(struct ks_kern_nexus_domain_provider, nxdom_prov_gencnt) == 0x60, "ks_kern_nexus_domain_provider.nxdom_prov_gencnt offset");
_Static_assert(offsetof(struct ks_kern_nexus_domain_provider, nxdom_prov_refcnt) == 0x68, "ks_kern_nexus_domain_provider.nxdom_prov_refcnt offset");
_Static_assert(offsetof(struct ks_kern_nexus_domain_provider, nxdom_prov_flags) == 0x6C, "ks_kern_nexus_domain_provider.nxdom_prov_flags offset");
_Static_assert(offsetof(struct ks_kern_nexus_domain_provider, nxdom_prov_dom) == 0x70, "ks_kern_nexus_domain_provider.nxdom_prov_dom offset");
_Static_assert(offsetof(struct ks_kern_nexus_domain_provider, nxdom_prov_ext) == 0x78, "ks_kern_nexus_domain_provider.nxdom_prov_ext offset");
_Static_assert(offsetof(struct ks_kern_nexus_domain_provider, nxdom_prov_cb) == 0x90, "ks_kern_nexus_domain_provider.nxdom_prov_cb offset");
_Static_assert(sizeof(struct ks_kern_nexus_domain_provider) == 0xE0, "ks_kern_nexus_domain_provider size");

/* refs: 1 */
struct ks_kern_nexus_netif_llink_init {
    unsigned int nli_flags;
    unsigned char nli_num_qsets;
    void *nli_ctx;
    unsigned long long nli_link_id;
    struct ks_kern_nexus_netif_llink_qset_init *nli_qsets;
};
_Static_assert(offsetof(struct ks_kern_nexus_netif_llink_init, nli_flags) == 0x0, "ks_kern_nexus_netif_llink_init.nli_flags offset");
_Static_assert(offsetof(struct ks_kern_nexus_netif_llink_init, nli_num_qsets) == 0x4, "ks_kern_nexus_netif_llink_init.nli_num_qsets offset");
_Static_assert(offsetof(struct ks_kern_nexus_netif_llink_init, nli_ctx) == 0x8, "ks_kern_nexus_netif_llink_init.nli_ctx offset");
_Static_assert(offsetof(struct ks_kern_nexus_netif_llink_init, nli_link_id) == 0x10, "ks_kern_nexus_netif_llink_init.nli_link_id offset");
_Static_assert(offsetof(struct ks_kern_nexus_netif_llink_init, nli_qsets) == 0x18, "ks_kern_nexus_netif_llink_init.nli_qsets offset");
_Static_assert(sizeof(struct ks_kern_nexus_netif_llink_init) == 0x20, "ks_kern_nexus_netif_llink_init size");

/* refs: 1 */
struct ks_kern_nexus_netif_provider_init {
    unsigned int nxnpi_version;
    unsigned int nxnpi_flags;
    int *nxnpi_pre_connect;
    int *nxnpi_connected;
    void *nxnpi_pre_disconnect;
    void *nxnpi_disconnected;
    int *nxnpi_qset_init;
    void *nxnpi_qset_fini;
    int *nxnpi_queue_init;
    void *nxnpi_queue_fini;
    int *nxnpi_tx_qset_notify;
    int *nxnpi_config_capab;
    int *nxnpi_queue_tx_push;
};
_Static_assert(offsetof(struct ks_kern_nexus_netif_provider_init, nxnpi_version) == 0x0, "ks_kern_nexus_netif_provider_init.nxnpi_version offset");
_Static_assert(offsetof(struct ks_kern_nexus_netif_provider_init, nxnpi_flags) == 0x4, "ks_kern_nexus_netif_provider_init.nxnpi_flags offset");
_Static_assert(offsetof(struct ks_kern_nexus_netif_provider_init, nxnpi_pre_connect) == 0x8, "ks_kern_nexus_netif_provider_init.nxnpi_pre_connect offset");
_Static_assert(offsetof(struct ks_kern_nexus_netif_provider_init, nxnpi_connected) == 0x10, "ks_kern_nexus_netif_provider_init.nxnpi_connected offset");
_Static_assert(offsetof(struct ks_kern_nexus_netif_provider_init, nxnpi_pre_disconnect) == 0x18, "ks_kern_nexus_netif_provider_init.nxnpi_pre_disconnect offset");
_Static_assert(offsetof(struct ks_kern_nexus_netif_provider_init, nxnpi_disconnected) == 0x20, "ks_kern_nexus_netif_provider_init.nxnpi_disconnected offset");
_Static_assert(offsetof(struct ks_kern_nexus_netif_provider_init, nxnpi_qset_init) == 0x28, "ks_kern_nexus_netif_provider_init.nxnpi_qset_init offset");
_Static_assert(offsetof(struct ks_kern_nexus_netif_provider_init, nxnpi_qset_fini) == 0x30, "ks_kern_nexus_netif_provider_init.nxnpi_qset_fini offset");
_Static_assert(offsetof(struct ks_kern_nexus_netif_provider_init, nxnpi_queue_init) == 0x38, "ks_kern_nexus_netif_provider_init.nxnpi_queue_init offset");
_Static_assert(offsetof(struct ks_kern_nexus_netif_provider_init, nxnpi_queue_fini) == 0x40, "ks_kern_nexus_netif_provider_init.nxnpi_queue_fini offset");
_Static_assert(offsetof(struct ks_kern_nexus_netif_provider_init, nxnpi_tx_qset_notify) == 0x48, "ks_kern_nexus_netif_provider_init.nxnpi_tx_qset_notify offset");
_Static_assert(offsetof(struct ks_kern_nexus_netif_provider_init, nxnpi_config_capab) == 0x50, "ks_kern_nexus_netif_provider_init.nxnpi_config_capab offset");
_Static_assert(offsetof(struct ks_kern_nexus_netif_provider_init, nxnpi_queue_tx_push) == 0x58, "ks_kern_nexus_netif_provider_init.nxnpi_queue_tx_push offset");
_Static_assert(sizeof(struct ks_kern_nexus_netif_provider_init) == 0x60, "ks_kern_nexus_netif_provider_init size");

/* refs: 1 */
struct ks_kern_nexus_provider_init {
    unsigned int nxpi_version;
    unsigned int nxpi_flags;
    int *nxpi_pre_connect;
    int *nxpi_connected;
    void *nxpi_pre_disconnect;
    void *nxpi_disconnected;
    int *nxpi_ring_init;
    void *nxpi_ring_fini;
    int *nxpi_slot_init;
    void *nxpi_slot_fini;
    int *nxpi_sync_tx;
    int *nxpi_sync_rx;
    int *nxpi_tx_doorbell;
    int *nxpi_rx_sync_packets;
    int *nxpi_tx_sync_packets;
    int *nxpi_config_capab;
};
_Static_assert(offsetof(struct ks_kern_nexus_provider_init, nxpi_version) == 0x0, "ks_kern_nexus_provider_init.nxpi_version offset");
_Static_assert(offsetof(struct ks_kern_nexus_provider_init, nxpi_flags) == 0x4, "ks_kern_nexus_provider_init.nxpi_flags offset");
_Static_assert(offsetof(struct ks_kern_nexus_provider_init, nxpi_pre_connect) == 0x8, "ks_kern_nexus_provider_init.nxpi_pre_connect offset");
_Static_assert(offsetof(struct ks_kern_nexus_provider_init, nxpi_connected) == 0x10, "ks_kern_nexus_provider_init.nxpi_connected offset");
_Static_assert(offsetof(struct ks_kern_nexus_provider_init, nxpi_pre_disconnect) == 0x18, "ks_kern_nexus_provider_init.nxpi_pre_disconnect offset");
_Static_assert(offsetof(struct ks_kern_nexus_provider_init, nxpi_disconnected) == 0x20, "ks_kern_nexus_provider_init.nxpi_disconnected offset");
_Static_assert(offsetof(struct ks_kern_nexus_provider_init, nxpi_ring_init) == 0x28, "ks_kern_nexus_provider_init.nxpi_ring_init offset");
_Static_assert(offsetof(struct ks_kern_nexus_provider_init, nxpi_ring_fini) == 0x30, "ks_kern_nexus_provider_init.nxpi_ring_fini offset");
_Static_assert(offsetof(struct ks_kern_nexus_provider_init, nxpi_slot_init) == 0x38, "ks_kern_nexus_provider_init.nxpi_slot_init offset");
_Static_assert(offsetof(struct ks_kern_nexus_provider_init, nxpi_slot_fini) == 0x40, "ks_kern_nexus_provider_init.nxpi_slot_fini offset");
_Static_assert(offsetof(struct ks_kern_nexus_provider_init, nxpi_sync_tx) == 0x48, "ks_kern_nexus_provider_init.nxpi_sync_tx offset");
_Static_assert(offsetof(struct ks_kern_nexus_provider_init, nxpi_sync_rx) == 0x50, "ks_kern_nexus_provider_init.nxpi_sync_rx offset");
_Static_assert(offsetof(struct ks_kern_nexus_provider_init, nxpi_tx_doorbell) == 0x58, "ks_kern_nexus_provider_init.nxpi_tx_doorbell offset");
_Static_assert(offsetof(struct ks_kern_nexus_provider_init, nxpi_rx_sync_packets) == 0x60, "ks_kern_nexus_provider_init.nxpi_rx_sync_packets offset");
_Static_assert(offsetof(struct ks_kern_nexus_provider_init, nxpi_tx_sync_packets) == 0x68, "ks_kern_nexus_provider_init.nxpi_tx_sync_packets offset");
_Static_assert(offsetof(struct ks_kern_nexus_provider_init, nxpi_config_capab) == 0x70, "ks_kern_nexus_provider_init.nxpi_config_capab offset");
_Static_assert(sizeof(struct ks_kern_nexus_provider_init) == 0x78, "ks_kern_nexus_provider_init size");

/* refs: 3 */
struct ks_skmem_region_params {
    const char *srp_name;
    unsigned int srp_id;
    unsigned int srp_cflags;
    unsigned int srp_r_seg_size;
    unsigned int srp_c_seg_size;
    unsigned int srp_seg_cnt;
    unsigned int srp_r_obj_size;
    unsigned int srp_r_obj_cnt;
    unsigned int srp_c_obj_size;
    unsigned int srp_c_obj_cnt;
    unsigned long srp_align;
    unsigned int srp_md_type;
    unsigned int srp_md_subtype;
    unsigned short srp_max_frags;
};
_Static_assert(offsetof(struct ks_skmem_region_params, srp_name) == 0x0, "ks_skmem_region_params.srp_name offset");
_Static_assert(offsetof(struct ks_skmem_region_params, srp_id) == 0x8, "ks_skmem_region_params.srp_id offset");
_Static_assert(offsetof(struct ks_skmem_region_params, srp_cflags) == 0xC, "ks_skmem_region_params.srp_cflags offset");
_Static_assert(offsetof(struct ks_skmem_region_params, srp_r_seg_size) == 0x10, "ks_skmem_region_params.srp_r_seg_size offset");
_Static_assert(offsetof(struct ks_skmem_region_params, srp_c_seg_size) == 0x14, "ks_skmem_region_params.srp_c_seg_size offset");
_Static_assert(offsetof(struct ks_skmem_region_params, srp_seg_cnt) == 0x18, "ks_skmem_region_params.srp_seg_cnt offset");
_Static_assert(offsetof(struct ks_skmem_region_params, srp_r_obj_size) == 0x1C, "ks_skmem_region_params.srp_r_obj_size offset");
_Static_assert(offsetof(struct ks_skmem_region_params, srp_r_obj_cnt) == 0x20, "ks_skmem_region_params.srp_r_obj_cnt offset");
_Static_assert(offsetof(struct ks_skmem_region_params, srp_c_obj_size) == 0x24, "ks_skmem_region_params.srp_c_obj_size offset");
_Static_assert(offsetof(struct ks_skmem_region_params, srp_c_obj_cnt) == 0x28, "ks_skmem_region_params.srp_c_obj_cnt offset");
_Static_assert(offsetof(struct ks_skmem_region_params, srp_align) == 0x30, "ks_skmem_region_params.srp_align offset");
_Static_assert(offsetof(struct ks_skmem_region_params, srp_md_type) == 0x38, "ks_skmem_region_params.srp_md_type offset");
_Static_assert(offsetof(struct ks_skmem_region_params, srp_md_subtype) == 0x3C, "ks_skmem_region_params.srp_md_subtype offset");
_Static_assert(offsetof(struct ks_skmem_region_params, srp_max_frags) == 0x40, "ks_skmem_region_params.srp_max_frags offset");
_Static_assert(sizeof(struct ks_skmem_region_params) == 0x48, "ks_skmem_region_params size");

/* refs: 2 */
struct ks_kern_nexus_provider {
    unsigned int nxprov_refcnt;
    unsigned int nxprov_flags;
    struct {
        struct ks_kern_nexus_provider *stqe_next;
    } nxprov_link;
    struct {
        struct ks_kern_nexus *stqh_first;
        struct ks_kern_nexus **stqh_last;
    } nxprov_nx_head;
    unsigned int nxprov_nx_count;
    struct ks_nxctl *nxprov_ctl;
    unsigned char nxprov_uuid[0x10];
    struct ks_kern_nexus_domain_provider *nxprov_dom_prov;
    union {
        struct ks_kern_nexus_provider_init nxprov_ext;
        struct ks_kern_nexus_netif_provider_init nxprov_netif_ext;
    };
    struct ks_nxprov_params *nxprov_params;
    struct ks_skmem_region_params nxprov_region_params[0x1C];
};
_Static_assert(offsetof(struct ks_kern_nexus_provider, nxprov_refcnt) == 0x0, "ks_kern_nexus_provider.nxprov_refcnt offset");
_Static_assert(offsetof(struct ks_kern_nexus_provider, nxprov_flags) == 0x4, "ks_kern_nexus_provider.nxprov_flags offset");
_Static_assert(offsetof(struct ks_kern_nexus_provider, nxprov_link) == 0x8, "ks_kern_nexus_provider.nxprov_link offset");
_Static_assert(offsetof(struct ks_kern_nexus_provider, nxprov_nx_head) == 0x10, "ks_kern_nexus_provider.nxprov_nx_head offset");
_Static_assert(offsetof(struct ks_kern_nexus_provider, nxprov_nx_count) == 0x20, "ks_kern_nexus_provider.nxprov_nx_count offset");
_Static_assert(offsetof(struct ks_kern_nexus_provider, nxprov_ctl) == 0x28, "ks_kern_nexus_provider.nxprov_ctl offset");
_Static_assert(offsetof(struct ks_kern_nexus_provider, nxprov_uuid) == 0x30, "ks_kern_nexus_provider.nxprov_uuid offset");
_Static_assert(offsetof(struct ks_kern_nexus_provider, nxprov_dom_prov) == 0x40, "ks_kern_nexus_provider.nxprov_dom_prov offset");
_Static_assert(offsetof(struct ks_kern_nexus_provider, nxprov_params) == 0xC0, "ks_kern_nexus_provider.nxprov_params offset");
_Static_assert(offsetof(struct ks_kern_nexus_provider, nxprov_region_params) == 0xC8, "ks_kern_nexus_provider.nxprov_region_params offset");
_Static_assert(sizeof(struct ks_kern_nexus_provider) == 0x8A8, "ks_kern_nexus_provider size");

/* refs: 6 */
struct ks_kern_pbufpool {
    struct ks_lck_mtx_s pp_lock;
    unsigned int pp_refcnt;
    unsigned int pp_flags;
    unsigned int pp_buf_obj_size[2];
    unsigned int pp_buf_size[2];
    unsigned short pp_max_frags;
    struct ks_skmem_cache *pp_buf_cache[2];
    struct ks_skmem_cache *pp_kmd_cache;
    struct ks_skmem_cache *pp_kbft_cache[2];
    struct ks_skmem_region *pp_buf_region[2];
    struct ks_skmem_region *pp_kmd_region;
    struct ks_skmem_region *pp_umd_region;
    struct ks_skmem_region *pp_ubft_region;
    struct ks_skmem_region *pp_kbft_region;
    struct ks_kern_pbufpool_u_bkt *pp_u_hash_table;
    unsigned long long pp_u_bufinuse;
    struct ks_kern_pbufpool_u_bft_bkt *pp_u_bft_hash_table;
    unsigned long long pp_u_bftinuse;
    void *pp_ctx;
    void *pp_ctx_retain;
    void *pp_ctx_release;
    unsigned int pp_md_type;
    unsigned int pp_md_subtype;
    unsigned int pp_midx_start;
    unsigned int pp_bidx_start;
    char pp_name[0x40];
    int *pp_pbuf_seg_ctor;
    void *pp_pbuf_seg_dtor;
    unsigned int pp_u_hash_table_size;
    unsigned int pp_u_bft_hash_table_size;
};
_Static_assert(offsetof(struct ks_kern_pbufpool, pp_lock) == 0x0, "ks_kern_pbufpool.pp_lock offset");
_Static_assert(offsetof(struct ks_kern_pbufpool, pp_refcnt) == 0x10, "ks_kern_pbufpool.pp_refcnt offset");
_Static_assert(offsetof(struct ks_kern_pbufpool, pp_flags) == 0x14, "ks_kern_pbufpool.pp_flags offset");
_Static_assert(offsetof(struct ks_kern_pbufpool, pp_buf_obj_size) == 0x18, "ks_kern_pbufpool.pp_buf_obj_size offset");
_Static_assert(offsetof(struct ks_kern_pbufpool, pp_buf_size) == 0x20, "ks_kern_pbufpool.pp_buf_size offset");
_Static_assert(offsetof(struct ks_kern_pbufpool, pp_max_frags) == 0x28, "ks_kern_pbufpool.pp_max_frags offset");
_Static_assert(offsetof(struct ks_kern_pbufpool, pp_buf_cache) == 0x30, "ks_kern_pbufpool.pp_buf_cache offset");
_Static_assert(offsetof(struct ks_kern_pbufpool, pp_kmd_cache) == 0x40, "ks_kern_pbufpool.pp_kmd_cache offset");
_Static_assert(offsetof(struct ks_kern_pbufpool, pp_kbft_cache) == 0x48, "ks_kern_pbufpool.pp_kbft_cache offset");
_Static_assert(offsetof(struct ks_kern_pbufpool, pp_buf_region) == 0x58, "ks_kern_pbufpool.pp_buf_region offset");
_Static_assert(offsetof(struct ks_kern_pbufpool, pp_kmd_region) == 0x68, "ks_kern_pbufpool.pp_kmd_region offset");
_Static_assert(offsetof(struct ks_kern_pbufpool, pp_umd_region) == 0x70, "ks_kern_pbufpool.pp_umd_region offset");
_Static_assert(offsetof(struct ks_kern_pbufpool, pp_ubft_region) == 0x78, "ks_kern_pbufpool.pp_ubft_region offset");
_Static_assert(offsetof(struct ks_kern_pbufpool, pp_kbft_region) == 0x80, "ks_kern_pbufpool.pp_kbft_region offset");
_Static_assert(offsetof(struct ks_kern_pbufpool, pp_u_hash_table) == 0x88, "ks_kern_pbufpool.pp_u_hash_table offset");
_Static_assert(offsetof(struct ks_kern_pbufpool, pp_u_bufinuse) == 0x90, "ks_kern_pbufpool.pp_u_bufinuse offset");
_Static_assert(offsetof(struct ks_kern_pbufpool, pp_u_bft_hash_table) == 0x98, "ks_kern_pbufpool.pp_u_bft_hash_table offset");
_Static_assert(offsetof(struct ks_kern_pbufpool, pp_u_bftinuse) == 0xA0, "ks_kern_pbufpool.pp_u_bftinuse offset");
_Static_assert(offsetof(struct ks_kern_pbufpool, pp_ctx) == 0xA8, "ks_kern_pbufpool.pp_ctx offset");
_Static_assert(offsetof(struct ks_kern_pbufpool, pp_ctx_retain) == 0xB0, "ks_kern_pbufpool.pp_ctx_retain offset");
_Static_assert(offsetof(struct ks_kern_pbufpool, pp_ctx_release) == 0xB8, "ks_kern_pbufpool.pp_ctx_release offset");
_Static_assert(offsetof(struct ks_kern_pbufpool, pp_md_type) == 0xC0, "ks_kern_pbufpool.pp_md_type offset");
_Static_assert(offsetof(struct ks_kern_pbufpool, pp_md_subtype) == 0xC4, "ks_kern_pbufpool.pp_md_subtype offset");
_Static_assert(offsetof(struct ks_kern_pbufpool, pp_midx_start) == 0xC8, "ks_kern_pbufpool.pp_midx_start offset");
_Static_assert(offsetof(struct ks_kern_pbufpool, pp_bidx_start) == 0xCC, "ks_kern_pbufpool.pp_bidx_start offset");
_Static_assert(offsetof(struct ks_kern_pbufpool, pp_name) == 0xD0, "ks_kern_pbufpool.pp_name offset");
_Static_assert(offsetof(struct ks_kern_pbufpool, pp_pbuf_seg_ctor) == 0x110, "ks_kern_pbufpool.pp_pbuf_seg_ctor offset");
_Static_assert(offsetof(struct ks_kern_pbufpool, pp_pbuf_seg_dtor) == 0x118, "ks_kern_pbufpool.pp_pbuf_seg_dtor offset");
_Static_assert(offsetof(struct ks_kern_pbufpool, pp_u_hash_table_size) == 0x120, "ks_kern_pbufpool.pp_u_hash_table_size offset");
_Static_assert(offsetof(struct ks_kern_pbufpool, pp_u_bft_hash_table_size) == 0x124, "ks_kern_pbufpool.pp_u_bft_hash_table_size offset");
_Static_assert(sizeof(struct ks_kern_pbufpool) == 0x128, "ks_kern_pbufpool size");

/* refs: 1 */
struct ks_kern_sigaltstack {
    unsigned long long ss_sp;
    unsigned long long ss_size;
    int ss_flags;
};
_Static_assert(offsetof(struct ks_kern_sigaltstack, ss_sp) == 0x0, "ks_kern_sigaltstack.ss_sp offset");
_Static_assert(offsetof(struct ks_kern_sigaltstack, ss_size) == 0x8, "ks_kern_sigaltstack.ss_size offset");
_Static_assert(offsetof(struct ks_kern_sigaltstack, ss_flags) == 0x10, "ks_kern_sigaltstack.ss_flags offset");
_Static_assert(sizeof(struct ks_kern_sigaltstack) == 0x18, "ks_kern_sigaltstack size");

/* refs: 1 */
struct ks_kevent_ctx_s {
    unsigned long long kec_data_avail;
    union {
        unsigned long long kec_data_out;
        struct ks_pollfd *kec_poll_fds;
    };
    unsigned long long kec_data_size;
    unsigned long long kec_data_resid;
    unsigned long long kec_deadline;
    struct ks_fileproc *kec_fp;
    int kec_fd;
    int kec_process_nevents;
    int kec_process_noutputs;
    unsigned int kec_process_flags;
    unsigned long long kec_process_eventlist;
};
_Static_assert(offsetof(struct ks_kevent_ctx_s, kec_data_avail) == 0x0, "ks_kevent_ctx_s.kec_data_avail offset");
_Static_assert(offsetof(struct ks_kevent_ctx_s, kec_data_size) == 0x10, "ks_kevent_ctx_s.kec_data_size offset");
_Static_assert(offsetof(struct ks_kevent_ctx_s, kec_data_resid) == 0x18, "ks_kevent_ctx_s.kec_data_resid offset");
_Static_assert(offsetof(struct ks_kevent_ctx_s, kec_deadline) == 0x20, "ks_kevent_ctx_s.kec_deadline offset");
_Static_assert(offsetof(struct ks_kevent_ctx_s, kec_fp) == 0x28, "ks_kevent_ctx_s.kec_fp offset");
_Static_assert(offsetof(struct ks_kevent_ctx_s, kec_fd) == 0x30, "ks_kevent_ctx_s.kec_fd offset");
_Static_assert(offsetof(struct ks_kevent_ctx_s, kec_process_nevents) == 0x34, "ks_kevent_ctx_s.kec_process_nevents offset");
_Static_assert(offsetof(struct ks_kevent_ctx_s, kec_process_noutputs) == 0x38, "ks_kevent_ctx_s.kec_process_noutputs offset");
_Static_assert(offsetof(struct ks_kevent_ctx_s, kec_process_flags) == 0x3C, "ks_kevent_ctx_s.kec_process_flags offset");
_Static_assert(offsetof(struct ks_kevent_ctx_s, kec_process_eventlist) == 0x40, "ks_kevent_ctx_s.kec_process_eventlist offset");
_Static_assert(sizeof(struct ks_kevent_ctx_s) == 0x48, "ks_kevent_ctx_s size");

/* refs: 1 */
struct ks_kevent_internal_s {
    unsigned long long kei_ident;
    signed char kei_filter;
    unsigned char kei_filtid;
    unsigned short kei_flags;
    int kei_qos;
    unsigned long long kei_udata;
    unsigned int kei_fflags;
    unsigned int kei_sfflags;
    long long kei_sdata;
    unsigned long long kei_ext[4];
};
_Static_assert(offsetof(struct ks_kevent_internal_s, kei_ident) == 0x0, "ks_kevent_internal_s.kei_ident offset");
_Static_assert(offsetof(struct ks_kevent_internal_s, kei_filter) == 0x8, "ks_kevent_internal_s.kei_filter offset");
_Static_assert(offsetof(struct ks_kevent_internal_s, kei_filtid) == 0x9, "ks_kevent_internal_s.kei_filtid offset");
_Static_assert(offsetof(struct ks_kevent_internal_s, kei_flags) == 0xA, "ks_kevent_internal_s.kei_flags offset");
_Static_assert(offsetof(struct ks_kevent_internal_s, kei_qos) == 0xC, "ks_kevent_internal_s.kei_qos offset");
_Static_assert(offsetof(struct ks_kevent_internal_s, kei_udata) == 0x10, "ks_kevent_internal_s.kei_udata offset");
_Static_assert(offsetof(struct ks_kevent_internal_s, kei_fflags) == 0x18, "ks_kevent_internal_s.kei_fflags offset");
_Static_assert(offsetof(struct ks_kevent_internal_s, kei_sfflags) == 0x1C, "ks_kevent_internal_s.kei_sfflags offset");
_Static_assert(offsetof(struct ks_kevent_internal_s, kei_sdata) == 0x20, "ks_kevent_internal_s.kei_sdata offset");
_Static_assert(offsetof(struct ks_kevent_internal_s, kei_ext) == 0x28, "ks_kevent_internal_s.kei_ext offset");
_Static_assert(sizeof(struct ks_kevent_internal_s) == 0x48, "ks_kevent_internal_s size");

/* refs: 11 */
struct ks_knote {
    struct {
        struct ks_knote *tqe_next;
        struct ks_knote **tqe_prev;
    } kn_tqe;
    struct {
        struct ks_knote *sle_next;
    } kn_link;
    struct {
        struct ks_knote *sle_next;
    } kn_selnext;
    unsigned short kn_status : 12; /* bit offset 256 */
    unsigned long kn_qos_index : 4; /* bit offset 268 */
    unsigned long kn_qos_override : 3; /* bit offset 272 */
    unsigned long kn_is_fd : 1; /* bit offset 275 */
    unsigned long kn_vnode_kqok : 1; /* bit offset 276 */
    unsigned long kn_vnode_use_ofst : 1; /* bit offset 277 */
    unsigned long kn_kq_packed : 42; /* bit offset 278 */
    union {
        unsigned long kn_hook;
        unsigned int kn_hook32;
    };
    union {
        struct ks_fileproc *kn_fp;
        struct ks_proc *kn_proc;
        struct ks_ipc_port *kn_ipc_port;
        struct ks_ipc_pset *kn_ipc_pset;
        struct ks_thread_call *kn_thcall;
        struct ks_thread *kn_thread;
    };
    struct ks_kevent_internal_s kn_kevent;
};
_Static_assert(offsetof(struct ks_knote, kn_tqe) == 0x0, "ks_knote.kn_tqe offset");
_Static_assert(offsetof(struct ks_knote, kn_link) == 0x10, "ks_knote.kn_link offset");
_Static_assert(offsetof(struct ks_knote, kn_selnext) == 0x18, "ks_knote.kn_selnext offset");
_Static_assert(offsetof(struct ks_knote, kn_kevent) == 0x38, "ks_knote.kn_kevent offset");
_Static_assert(sizeof(struct ks_knote) == 0x80, "ks_knote size");

/* refs: 4 */
struct ks_knote_lock_ctx {
    struct ks_knote *knlc_knote;
    struct ks_thread *knlc_thread;
    unsigned long knlc_waiters;
    struct {
        struct ks_knote_lock_ctx *le_next;
        struct ks_knote_lock_ctx **le_prev;
    } knlc_link;
};
_Static_assert(offsetof(struct ks_knote_lock_ctx, knlc_knote) == 0x0, "ks_knote_lock_ctx.knlc_knote offset");
_Static_assert(offsetof(struct ks_knote_lock_ctx, knlc_thread) == 0x8, "ks_knote_lock_ctx.knlc_thread offset");
_Static_assert(offsetof(struct ks_knote_lock_ctx, knlc_waiters) == 0x10, "ks_knote_lock_ctx.knlc_waiters offset");
_Static_assert(offsetof(struct ks_knote_lock_ctx, knlc_link) == 0x18, "ks_knote_lock_ctx.knlc_link offset");
_Static_assert(sizeof(struct ks_knote_lock_ctx) == 0x28, "ks_knote_lock_ctx size");

/* refs: 1 */
struct ks_knote_locks {
    struct ks_knote_lock_ctx *lh_first;
};
_Static_assert(offsetof(struct ks_knote_locks, lh_first) == 0x0, "ks_knote_locks.lh_first offset");
_Static_assert(sizeof(struct ks_knote_locks) == 0x8, "ks_knote_locks size");

/* refs: 4 */
struct ks_kqtailq {
    struct ks_knote *tqh_first;
    struct ks_knote **tqh_last;
};
_Static_assert(offsetof(struct ks_kqtailq, tqh_first) == 0x0, "ks_kqtailq.tqh_first offset");
_Static_assert(offsetof(struct ks_kqtailq, tqh_last) == 0x8, "ks_kqtailq.tqh_last offset");
_Static_assert(sizeof(struct ks_kqtailq) == 0x10, "ks_kqtailq size");

/* refs: 2 */
struct ks_kqueue {
    struct ks_lck_spin_s kq_lock;
    unsigned short kq_state;
    unsigned short kq_level;
    unsigned int kq_count;
    struct ks_proc *kq_p;
    struct ks_knote_locks kq_knlocks;
};
_Static_assert(offsetof(struct ks_kqueue, kq_lock) == 0x0, "ks_kqueue.kq_lock offset");
_Static_assert(offsetof(struct ks_kqueue, kq_state) == 0x10, "ks_kqueue.kq_state offset");
_Static_assert(offsetof(struct ks_kqueue, kq_level) == 0x12, "ks_kqueue.kq_level offset");
_Static_assert(offsetof(struct ks_kqueue, kq_count) == 0x14, "ks_kqueue.kq_count offset");
_Static_assert(offsetof(struct ks_kqueue, kq_p) == 0x18, "ks_kqueue.kq_p offset");
_Static_assert(offsetof(struct ks_kqueue, kq_knlocks) == 0x20, "ks_kqueue.kq_knlocks offset");
_Static_assert(sizeof(struct ks_kqueue) == 0x28, "ks_kqueue size");

/* refs: 1 */
struct ks_kqwllist {
    struct ks_kqworkloop *lh_first;
};
_Static_assert(offsetof(struct ks_kqwllist, lh_first) == 0x0, "ks_kqwllist.lh_first offset");
_Static_assert(sizeof(struct ks_kqwllist) == 0x8, "ks_kqwllist size");

/* refs: 6 */
struct ks_priority_queue_entry_sched {
    struct ks_priority_queue_entry_sched *next;
    struct ks_priority_queue_entry_sched *prev;
    long key : 16; /* bit offset 128 */
    long child : 48; /* bit offset 144 */
};
_Static_assert(offsetof(struct ks_priority_queue_entry_sched, next) == 0x0, "ks_priority_queue_entry_sched.next offset");
_Static_assert(offsetof(struct ks_priority_queue_entry_sched, prev) == 0x8, "ks_priority_queue_entry_sched.prev offset");
_Static_assert(sizeof(struct ks_priority_queue_entry_sched) == 0x18, "ks_priority_queue_entry_sched size");

/* refs: 9 */
struct ks_workq_threadreq_s {
    union {
        struct ks_priority_queue_entry_sched tr_entry;
        struct {
            struct ks_workq_threadreq_s *stqe_next;
        } tr_link;
        struct {
            struct ks_thread *tr_thread;
            struct ks_work_interval *tr_work_interval;
        };
    };
    unsigned short tr_count;
    unsigned char tr_flags;
    unsigned char tr_state;
    unsigned char tr_qos;
    unsigned char tr_kq_override_index;
    unsigned char tr_kq_qos_index;
};
_Static_assert(offsetof(struct ks_workq_threadreq_s, tr_count) == 0x18, "ks_workq_threadreq_s.tr_count offset");
_Static_assert(offsetof(struct ks_workq_threadreq_s, tr_flags) == 0x1A, "ks_workq_threadreq_s.tr_flags offset");
_Static_assert(offsetof(struct ks_workq_threadreq_s, tr_state) == 0x1B, "ks_workq_threadreq_s.tr_state offset");
_Static_assert(offsetof(struct ks_workq_threadreq_s, tr_qos) == 0x1C, "ks_workq_threadreq_s.tr_qos offset");
_Static_assert(offsetof(struct ks_workq_threadreq_s, tr_kq_override_index) == 0x1D, "ks_workq_threadreq_s.tr_kq_override_index offset");
_Static_assert(offsetof(struct ks_workq_threadreq_s, tr_kq_qos_index) == 0x1E, "ks_workq_threadreq_s.tr_kq_qos_index offset");
_Static_assert(sizeof(struct ks_workq_threadreq_s) == 0x20, "ks_workq_threadreq_s size");

/* refs: 4 */
struct ks_kqworkloop {
    struct ks_kqueue kqwl_kqueue;
    struct ks_kqtailq kqwl_queue[6];
    struct ks_kqtailq kqwl_suppressed;
    struct ks_workq_threadreq_s kqwl_request;
    struct ks_thread_group *kqwl_preadopt_tg;
    struct ks_lck_spin_s kqwl_statelock;
    struct ks_thread *kqwl_owner;
    unsigned int kqwl_retains;
    unsigned char kqwl_wakeup_qos;
    unsigned char kqwl_iotier_override;
    unsigned short kqwl_preadopt_tg_needs_redrive;
    struct ks_turnstile *kqwl_turnstile;
    unsigned long long kqwl_dynamicid;
    unsigned long long kqwl_params;
    struct {
        struct ks_kqworkloop *le_next;
        struct ks_kqworkloop **le_prev;
    } kqwl_hashlink;
};
_Static_assert(offsetof(struct ks_kqworkloop, kqwl_kqueue) == 0x0, "ks_kqworkloop.kqwl_kqueue offset");
_Static_assert(offsetof(struct ks_kqworkloop, kqwl_queue) == 0x28, "ks_kqworkloop.kqwl_queue offset");
_Static_assert(offsetof(struct ks_kqworkloop, kqwl_suppressed) == 0x88, "ks_kqworkloop.kqwl_suppressed offset");
_Static_assert(offsetof(struct ks_kqworkloop, kqwl_request) == 0x98, "ks_kqworkloop.kqwl_request offset");
_Static_assert(offsetof(struct ks_kqworkloop, kqwl_preadopt_tg) == 0xB8, "ks_kqworkloop.kqwl_preadopt_tg offset");
_Static_assert(offsetof(struct ks_kqworkloop, kqwl_statelock) == 0xC0, "ks_kqworkloop.kqwl_statelock offset");
_Static_assert(offsetof(struct ks_kqworkloop, kqwl_owner) == 0xD0, "ks_kqworkloop.kqwl_owner offset");
_Static_assert(offsetof(struct ks_kqworkloop, kqwl_retains) == 0xD8, "ks_kqworkloop.kqwl_retains offset");
_Static_assert(offsetof(struct ks_kqworkloop, kqwl_wakeup_qos) == 0xDC, "ks_kqworkloop.kqwl_wakeup_qos offset");
_Static_assert(offsetof(struct ks_kqworkloop, kqwl_iotier_override) == 0xDD, "ks_kqworkloop.kqwl_iotier_override offset");
_Static_assert(offsetof(struct ks_kqworkloop, kqwl_preadopt_tg_needs_redrive) == 0xDE, "ks_kqworkloop.kqwl_preadopt_tg_needs_redrive offset");
_Static_assert(offsetof(struct ks_kqworkloop, kqwl_turnstile) == 0xE0, "ks_kqworkloop.kqwl_turnstile offset");
_Static_assert(offsetof(struct ks_kqworkloop, kqwl_dynamicid) == 0xE8, "ks_kqworkloop.kqwl_dynamicid offset");
_Static_assert(offsetof(struct ks_kqworkloop, kqwl_params) == 0xF0, "ks_kqworkloop.kqwl_params offset");
_Static_assert(offsetof(struct ks_kqworkloop, kqwl_hashlink) == 0xF8, "ks_kqworkloop.kqwl_hashlink offset");
_Static_assert(sizeof(struct ks_kqworkloop) == 0x108, "ks_kqworkloop size");

/* refs: 1 */
struct ks_kqworkq {
    struct ks_kqueue kqwq_kqueue;
    struct ks_kqtailq kqwq_queue[7];
    struct ks_kqtailq kqwq_suppressed[7];
    struct ks_workq_threadreq_s kqwq_request[7];
};
_Static_assert(offsetof(struct ks_kqworkq, kqwq_kqueue) == 0x0, "ks_kqworkq.kqwq_kqueue offset");
_Static_assert(offsetof(struct ks_kqworkq, kqwq_queue) == 0x28, "ks_kqworkq.kqwq_queue offset");
_Static_assert(offsetof(struct ks_kqworkq, kqwq_suppressed) == 0x98, "ks_kqworkq.kqwq_suppressed offset");
_Static_assert(offsetof(struct ks_kqworkq, kqwq_request) == 0x108, "ks_kqworkq.kqwq_request offset");
_Static_assert(sizeof(struct ks_kqworkq) == 0x1E8, "ks_kqworkq size");

/* refs: 1 */
struct ks_ksyn_waitq_element {
    char opaque[0x30];
};
_Static_assert(offsetof(struct ks_ksyn_waitq_element, opaque) == 0x0, "ks_ksyn_waitq_element.opaque offset");
_Static_assert(sizeof(struct ks_ksyn_waitq_element) == 0x30, "ks_ksyn_waitq_element size");

/* refs: 7 */
struct ks_label {
    struct ks_label **l_owner;
    long l_perpolicy[7];
};
_Static_assert(offsetof(struct ks_label, l_owner) == 0x0, "ks_label.l_owner offset");
_Static_assert(offsetof(struct ks_label, l_perpolicy) == 0x8, "ks_label.l_perpolicy offset");
_Static_assert(sizeof(struct ks_label) == 0x40, "ks_label size");

/* refs: 1 */
struct ks_latency {
    unsigned int latency_ms;
    unsigned int jitter_ms;
    unsigned long long prev_time_to_send;
};
_Static_assert(offsetof(struct ks_latency, latency_ms) == 0x0, "ks_latency.latency_ms offset");
_Static_assert(offsetof(struct ks_latency, jitter_ms) == 0x4, "ks_latency.jitter_ms offset");
_Static_assert(offsetof(struct ks_latency, prev_time_to_send) == 0x8, "ks_latency.prev_time_to_send offset");
_Static_assert(sizeof(struct ks_latency) == 0x10, "ks_latency size");

/* refs: 1 */
struct ks_ledger_entry_small {
    unsigned int les_flags;
    long long les_credit __attribute__((aligned(8)));
} __attribute__((aligned(8)));
_Static_assert(offsetof(struct ks_ledger_entry_small, les_flags) == 0x0, "ks_ledger_entry_small.les_flags offset");
_Static_assert(offsetof(struct ks_ledger_entry_small, les_credit) == 0x8, "ks_ledger_entry_small.les_credit offset");
_Static_assert(sizeof(struct ks_ledger_entry_small) == 0x10, "ks_ledger_entry_small size");

/* refs: 9 */
struct ks_ledger {
    unsigned long long l_id;
    struct ks_os_refcnt l_refs;
    int l_size;
    struct ks_ledger_template *l_template;
    struct ks_ledger_entry_small l_entries[] __attribute__((aligned(8)));
};
_Static_assert(offsetof(struct ks_ledger, l_id) == 0x0, "ks_ledger.l_id offset");
_Static_assert(offsetof(struct ks_ledger, l_refs) == 0x8, "ks_ledger.l_refs offset");
_Static_assert(offsetof(struct ks_ledger, l_size) == 0xC, "ks_ledger.l_size offset");
_Static_assert(offsetof(struct ks_ledger, l_template) == 0x10, "ks_ledger.l_template offset");
_Static_assert(offsetof(struct ks_ledger, l_entries) == 0x18, "ks_ledger.l_entries offset");
_Static_assert(sizeof(struct ks_ledger) == 0x18, "ks_ledger size");

/* refs: 1 */
struct ks_ledger_callback {
    void *lc_func;
    const void *lc_param0;
    const void *lc_param1;
};
_Static_assert(offsetof(struct ks_ledger_callback, lc_func) == 0x0, "ks_ledger_callback.lc_func offset");
_Static_assert(offsetof(struct ks_ledger_callback, lc_param0) == 0x8, "ks_ledger_callback.lc_param0 offset");
_Static_assert(offsetof(struct ks_ledger_callback, lc_param1) == 0x10, "ks_ledger_callback.lc_param1 offset");
_Static_assert(sizeof(struct ks_ledger_callback) == 0x18, "ks_ledger_callback size");

/* refs: 1 */
struct ks_ledger_template {
    const char *lt_name;
    int lt_refs;
    unsigned int lt_inuse;
    struct ks_lck_mtx_s lt_lock;
    struct ks_zone *lt_zone;
    _Bool lt_initialized;
    unsigned short lt_next_offset;
    unsigned short lt_cnt;
    unsigned short lt_table_size;
    struct ks_entry_template *lt_entries;
    unsigned short *lt_entries_lut;
    unsigned short lt_counters;
    unsigned short lt_counter_offset;
    struct ks_zone *lt_counter_zone;
    char lt_counter_zone_name[0x20];
};
_Static_assert(offsetof(struct ks_ledger_template, lt_name) == 0x0, "ks_ledger_template.lt_name offset");
_Static_assert(offsetof(struct ks_ledger_template, lt_refs) == 0x8, "ks_ledger_template.lt_refs offset");
_Static_assert(offsetof(struct ks_ledger_template, lt_inuse) == 0xC, "ks_ledger_template.lt_inuse offset");
_Static_assert(offsetof(struct ks_ledger_template, lt_lock) == 0x10, "ks_ledger_template.lt_lock offset");
_Static_assert(offsetof(struct ks_ledger_template, lt_zone) == 0x20, "ks_ledger_template.lt_zone offset");
_Static_assert(offsetof(struct ks_ledger_template, lt_initialized) == 0x28, "ks_ledger_template.lt_initialized offset");
_Static_assert(offsetof(struct ks_ledger_template, lt_next_offset) == 0x2A, "ks_ledger_template.lt_next_offset offset");
_Static_assert(offsetof(struct ks_ledger_template, lt_cnt) == 0x2C, "ks_ledger_template.lt_cnt offset");
_Static_assert(offsetof(struct ks_ledger_template, lt_table_size) == 0x2E, "ks_ledger_template.lt_table_size offset");
_Static_assert(offsetof(struct ks_ledger_template, lt_entries) == 0x30, "ks_ledger_template.lt_entries offset");
_Static_assert(offsetof(struct ks_ledger_template, lt_entries_lut) == 0x38, "ks_ledger_template.lt_entries_lut offset");
_Static_assert(offsetof(struct ks_ledger_template, lt_counters) == 0x40, "ks_ledger_template.lt_counters offset");
_Static_assert(offsetof(struct ks_ledger_template, lt_counter_offset) == 0x42, "ks_ledger_template.lt_counter_offset offset");
_Static_assert(offsetof(struct ks_ledger_template, lt_counter_zone) == 0x48, "ks_ledger_template.lt_counter_zone offset");
_Static_assert(offsetof(struct ks_ledger_template, lt_counter_zone_name) == 0x50, "ks_ledger_template.lt_counter_zone_name offset");
_Static_assert(sizeof(struct ks_ledger_template) == 0x70, "ks_ledger_template size");

/* refs: 1 */
struct ks_locklist {
    struct ks_lockf *tqh_first;
    struct ks_lockf **tqh_last;
};
_Static_assert(offsetof(struct ks_locklist, tqh_first) == 0x0, "ks_locklist.tqh_first offset");
_Static_assert(offsetof(struct ks_locklist, tqh_last) == 0x8, "ks_locklist.tqh_last offset");
_Static_assert(sizeof(struct ks_locklist) == 0x10, "ks_locklist size");

/* refs: 5 */
struct ks_lockf {
    short lf_flags;
    short lf_type;
    int lf_boosted;
    long long lf_start;
    long long lf_end;
    char *lf_id;
    struct ks_lockf **lf_head;
    struct ks_vnode *lf_vnode;
    struct ks_lockf *lf_next;
    struct ks_locklist lf_blkhd;
    struct {
        struct ks_lockf *tqe_next;
        struct ks_lockf **tqe_prev;
    } lf_block;
    struct ks_proc *lf_owner;
};
_Static_assert(offsetof(struct ks_lockf, lf_flags) == 0x0, "ks_lockf.lf_flags offset");
_Static_assert(offsetof(struct ks_lockf, lf_type) == 0x2, "ks_lockf.lf_type offset");
_Static_assert(offsetof(struct ks_lockf, lf_boosted) == 0x4, "ks_lockf.lf_boosted offset");
_Static_assert(offsetof(struct ks_lockf, lf_start) == 0x8, "ks_lockf.lf_start offset");
_Static_assert(offsetof(struct ks_lockf, lf_end) == 0x10, "ks_lockf.lf_end offset");
_Static_assert(offsetof(struct ks_lockf, lf_id) == 0x18, "ks_lockf.lf_id offset");
_Static_assert(offsetof(struct ks_lockf, lf_head) == 0x20, "ks_lockf.lf_head offset");
_Static_assert(offsetof(struct ks_lockf, lf_vnode) == 0x28, "ks_lockf.lf_vnode offset");
_Static_assert(offsetof(struct ks_lockf, lf_next) == 0x30, "ks_lockf.lf_next offset");
_Static_assert(offsetof(struct ks_lockf, lf_blkhd) == 0x38, "ks_lockf.lf_blkhd offset");
_Static_assert(offsetof(struct ks_lockf, lf_block) == 0x48, "ks_lockf.lf_block offset");
_Static_assert(offsetof(struct ks_lockf, lf_owner) == 0x58, "ks_lockf.lf_owner offset");
_Static_assert(sizeof(struct ks_lockf) == 0x60, "ks_lockf size");

/* refs: 1 */
struct ks_loss {
    unsigned int state;
    unsigned int p_gr_gl;
    unsigned int p_gr_bl;
    unsigned int p_bl_br;
    unsigned int p_bl_gr;
    unsigned int p_br_bl;
    unsigned int recovery_ms;
    unsigned long long recovery_window;
};
_Static_assert(offsetof(struct ks_loss, state) == 0x0, "ks_loss.state offset");
_Static_assert(offsetof(struct ks_loss, p_gr_gl) == 0x4, "ks_loss.p_gr_gl offset");
_Static_assert(offsetof(struct ks_loss, p_gr_bl) == 0x8, "ks_loss.p_gr_bl offset");
_Static_assert(offsetof(struct ks_loss, p_bl_br) == 0xC, "ks_loss.p_bl_br offset");
_Static_assert(offsetof(struct ks_loss, p_bl_gr) == 0x10, "ks_loss.p_bl_gr offset");
_Static_assert(offsetof(struct ks_loss, p_br_bl) == 0x14, "ks_loss.p_br_bl offset");
_Static_assert(offsetof(struct ks_loss, recovery_ms) == 0x18, "ks_loss.recovery_ms offset");
_Static_assert(offsetof(struct ks_loss, recovery_window) == 0x20, "ks_loss.recovery_window offset");
_Static_assert(sizeof(struct ks_loss) == 0x28, "ks_loss size");

/* refs: 1 */
struct ks_m_ext {
    char *ext_buf;
    void *ext_free;
    unsigned int ext_size;
    char *ext_arg;
    struct ks_ext_ref *ext_refflags;
};
_Static_assert(offsetof(struct ks_m_ext, ext_buf) == 0x0, "ks_m_ext.ext_buf offset");
_Static_assert(offsetof(struct ks_m_ext, ext_free) == 0x8, "ks_m_ext.ext_free offset");
_Static_assert(offsetof(struct ks_m_ext, ext_size) == 0x10, "ks_m_ext.ext_size offset");
_Static_assert(offsetof(struct ks_m_ext, ext_arg) == 0x18, "ks_m_ext.ext_arg offset");
_Static_assert(offsetof(struct ks_m_ext, ext_refflags) == 0x20, "ks_m_ext.ext_refflags offset");
_Static_assert(sizeof(struct ks_m_ext) == 0x28, "ks_m_ext size");

/* refs: 1 */
struct ks_m_hdr {
    struct ks_mbuf *mh_next;
    struct ks_mbuf *mh_nextpkt;
    unsigned long mh_data;
    int mh_len;
    unsigned short mh_type;
    unsigned short mh_flags;
};
_Static_assert(offsetof(struct ks_m_hdr, mh_next) == 0x0, "ks_m_hdr.mh_next offset");
_Static_assert(offsetof(struct ks_m_hdr, mh_nextpkt) == 0x8, "ks_m_hdr.mh_nextpkt offset");
_Static_assert(offsetof(struct ks_m_hdr, mh_data) == 0x10, "ks_m_hdr.mh_data offset");
_Static_assert(offsetof(struct ks_m_hdr, mh_len) == 0x18, "ks_m_hdr.mh_len offset");
_Static_assert(offsetof(struct ks_m_hdr, mh_type) == 0x1C, "ks_m_hdr.mh_type offset");
_Static_assert(offsetof(struct ks_m_hdr, mh_flags) == 0x1E, "ks_m_hdr.mh_flags offset");
_Static_assert(sizeof(struct ks_m_hdr) == 0x20, "ks_m_hdr size");

/* refs: 1 */
struct ks_packet_tags {
    struct ks_m_tag *slh_first;
};
_Static_assert(offsetof(struct ks_packet_tags, slh_first) == 0x0, "ks_packet_tags.slh_first offset");
_Static_assert(sizeof(struct ks_packet_tags) == 0x8, "ks_packet_tags size");

/* refs: 1 */
union ks_builtin_mtag {
    struct {
        struct ks_proto_mtag_ _proto_mtag;
        struct ks_pf_mtag _pf_mtag;
        struct ks_necp_mtag_ _necp_mtag;
    } _net_mtag;
    struct ks_driver_mtag_ _drv_mtag;
};
_Static_assert(offsetof(union ks_builtin_mtag, _net_mtag) == 0x0, "ks_builtin_mtag._net_mtag offset");
_Static_assert(offsetof(union ks_builtin_mtag, _drv_mtag) == 0x0, "ks_builtin_mtag._drv_mtag offset");

/* refs: 1 */
struct ks_pkthdr {
    struct ks_ifnet *rcvif;
    void *pkt_hdr;
    int len;
    unsigned int csum_flags;
    union {
        struct {
            unsigned short val;
            unsigned short start;
        } _csum_rx;
        struct {
            unsigned short start;
            unsigned short stuff;
        } _csum_tx;
        unsigned int csum_data;
    };
    unsigned short vlan_tag;
    unsigned char pkt_proto;
    unsigned char pkt_flowsrc;
    unsigned int pkt_flowid;
    unsigned int pkt_flags;
    unsigned int pkt_svc;
    unsigned int pkt_compl_context;
    union {
        struct {
            unsigned short src;
            unsigned short src_flags;
            unsigned short dst;
            unsigned short dst_flags;
        } _pkt_iaif;
        unsigned long long pkt_ifainfo;
        struct {
            unsigned int if_data;
            unsigned int sndbuf_data;
        } _pkt_bsr;
    };
    unsigned long long pkt_timestamp;
    unsigned long long pkt_deadline;
    struct ks_packet_tags tags;
    union ks_builtin_mtag builtin_mtag;
    unsigned int comp_gencnt;
    unsigned int pkt_crumbs : 16; /* bit offset 992 */
    unsigned int pkt_compl_callbacks : 8; /* bit offset 1008 */
    unsigned int pkt_ext_flags : 6; /* bit offset 1016 */
    unsigned int pkt_unused : 2; /* bit offset 1022 */
    struct {
        union {
            unsigned char __mpriv8[0x10];
            unsigned short __mpriv16[8];
            struct {
                union {
                    unsigned char __val8[4];
                    unsigned short __val16[2];
                    unsigned int __val32;
                } __mpriv32_u;
            } __mpriv32[4];
            unsigned long long __mpriv64[2];
        } __mpriv_u;
    } pkt_mpriv __attribute__((aligned(4)));
};
_Static_assert(offsetof(struct ks_pkthdr, rcvif) == 0x0, "ks_pkthdr.rcvif offset");
_Static_assert(offsetof(struct ks_pkthdr, pkt_hdr) == 0x8, "ks_pkthdr.pkt_hdr offset");
_Static_assert(offsetof(struct ks_pkthdr, len) == 0x10, "ks_pkthdr.len offset");
_Static_assert(offsetof(struct ks_pkthdr, csum_flags) == 0x14, "ks_pkthdr.csum_flags offset");
_Static_assert(offsetof(struct ks_pkthdr, vlan_tag) == 0x1C, "ks_pkthdr.vlan_tag offset");
_Static_assert(offsetof(struct ks_pkthdr, pkt_proto) == 0x1E, "ks_pkthdr.pkt_proto offset");
_Static_assert(offsetof(struct ks_pkthdr, pkt_flowsrc) == 0x1F, "ks_pkthdr.pkt_flowsrc offset");
_Static_assert(offsetof(struct ks_pkthdr, pkt_flowid) == 0x20, "ks_pkthdr.pkt_flowid offset");
_Static_assert(offsetof(struct ks_pkthdr, pkt_flags) == 0x24, "ks_pkthdr.pkt_flags offset");
_Static_assert(offsetof(struct ks_pkthdr, pkt_svc) == 0x28, "ks_pkthdr.pkt_svc offset");
_Static_assert(offsetof(struct ks_pkthdr, pkt_compl_context) == 0x2C, "ks_pkthdr.pkt_compl_context offset");
_Static_assert(offsetof(struct ks_pkthdr, pkt_timestamp) == 0x38, "ks_pkthdr.pkt_timestamp offset");
_Static_assert(offsetof(struct ks_pkthdr, pkt_deadline) == 0x40, "ks_pkthdr.pkt_deadline offset");
_Static_assert(offsetof(struct ks_pkthdr, tags) == 0x48, "ks_pkthdr.tags offset");
_Static_assert(offsetof(struct ks_pkthdr, builtin_mtag) == 0x50, "ks_pkthdr.builtin_mtag offset");
_Static_assert(offsetof(struct ks_pkthdr, comp_gencnt) == 0x78, "ks_pkthdr.comp_gencnt offset");
_Static_assert(offsetof(struct ks_pkthdr, pkt_mpriv) == 0x80, "ks_pkthdr.pkt_mpriv offset");
_Static_assert(sizeof(struct ks_pkthdr) == 0x90, "ks_pkthdr size");

/* refs: 1 */
struct ks_m_hdr_common {
    struct ks_m_hdr M_hdr;
    struct ks_m_ext M_ext __attribute__((aligned(16)));
    unsigned long long m_hdr_crumbs;
    struct ks_pkthdr M_pkthdr __attribute__((aligned(16)));
};
_Static_assert(offsetof(struct ks_m_hdr_common, M_hdr) == 0x0, "ks_m_hdr_common.M_hdr offset");
_Static_assert(offsetof(struct ks_m_hdr_common, M_ext) == 0x20, "ks_m_hdr_common.M_ext offset");
_Static_assert(offsetof(struct ks_m_hdr_common, m_hdr_crumbs) == 0x48, "ks_m_hdr_common.m_hdr_crumbs offset");
_Static_assert(offsetof(struct ks_m_hdr_common, M_pkthdr) == 0x50, "ks_m_hdr_common.M_pkthdr offset");
_Static_assert(sizeof(struct ks_m_hdr_common) == 0xE0, "ks_m_hdr_common size");

/* refs: 2 */
struct ks_m_tag {
    unsigned long long m_tag_cookie;
    struct {
        struct ks_m_tag *sle_next;
    } m_tag_link;
    void *m_tag_data;
    unsigned short m_tag_type;
    unsigned short m_tag_len;
    unsigned int m_tag_id;
    void *m_tag_mb_cl;
};
_Static_assert(offsetof(struct ks_m_tag, m_tag_cookie) == 0x0, "ks_m_tag.m_tag_cookie offset");
_Static_assert(offsetof(struct ks_m_tag, m_tag_link) == 0x8, "ks_m_tag.m_tag_link offset");
_Static_assert(offsetof(struct ks_m_tag, m_tag_data) == 0x10, "ks_m_tag.m_tag_data offset");
_Static_assert(offsetof(struct ks_m_tag, m_tag_type) == 0x18, "ks_m_tag.m_tag_type offset");
_Static_assert(offsetof(struct ks_m_tag, m_tag_len) == 0x1A, "ks_m_tag.m_tag_len offset");
_Static_assert(offsetof(struct ks_m_tag, m_tag_id) == 0x1C, "ks_m_tag.m_tag_id offset");
_Static_assert(offsetof(struct ks_m_tag, m_tag_mb_cl) == 0x20, "ks_m_tag.m_tag_mb_cl offset");
_Static_assert(sizeof(struct ks_m_tag) == 0x28, "ks_m_tag size");

/* refs: 3 */
struct ks_mac_audit_record {
    int type;
    int length;
    unsigned char *data;
    struct {
        struct ks_mac_audit_record *le_next;
        struct ks_mac_audit_record **le_prev;
    } records;
};
_Static_assert(offsetof(struct ks_mac_audit_record, type) == 0x0, "ks_mac_audit_record.type offset");
_Static_assert(offsetof(struct ks_mac_audit_record, length) == 0x4, "ks_mac_audit_record.length offset");
_Static_assert(offsetof(struct ks_mac_audit_record, data) == 0x8, "ks_mac_audit_record.data offset");
_Static_assert(offsetof(struct ks_mac_audit_record, records) == 0x10, "ks_mac_audit_record.records offset");
_Static_assert(sizeof(struct ks_mac_audit_record) == 0x20, "ks_mac_audit_record size");

/* refs: 1 */
struct ks_mac_audit_record_list_t {
    struct ks_mac_audit_record *lh_first;
};
_Static_assert(offsetof(struct ks_mac_audit_record_list_t, lh_first) == 0x0, "ks_mac_audit_record_list_t.lh_first offset");
_Static_assert(sizeof(struct ks_mac_audit_record_list_t) == 0x8, "ks_mac_audit_record_list_t size");

/* refs: 2 */
struct ks_mach_msg_recv_bufs_t {
    unsigned long long recv_msg_addr;
    unsigned long long recv_aux_addr;
    unsigned int recv_msg_size;
    unsigned int recv_aux_size;
};
_Static_assert(offsetof(struct ks_mach_msg_recv_bufs_t, recv_msg_addr) == 0x0, "ks_mach_msg_recv_bufs_t.recv_msg_addr offset");
_Static_assert(offsetof(struct ks_mach_msg_recv_bufs_t, recv_aux_addr) == 0x8, "ks_mach_msg_recv_bufs_t.recv_aux_addr offset");
_Static_assert(offsetof(struct ks_mach_msg_recv_bufs_t, recv_msg_size) == 0x10, "ks_mach_msg_recv_bufs_t.recv_msg_size offset");
_Static_assert(offsetof(struct ks_mach_msg_recv_bufs_t, recv_aux_size) == 0x14, "ks_mach_msg_recv_bufs_t.recv_aux_size offset");
_Static_assert(sizeof(struct ks_mach_msg_recv_bufs_t) == 0x18, "ks_mach_msg_recv_bufs_t size");

/* refs: 1 */
struct ks_perfcontrol_state {
    unsigned long long opaque[8] __attribute__((aligned(8)));
};
_Static_assert(offsetof(struct ks_perfcontrol_state, opaque) == 0x0, "ks_perfcontrol_state.opaque offset");
_Static_assert(sizeof(struct ks_perfcontrol_state) == 0x40, "ks_perfcontrol_state size");

/* refs: 1 */
struct ks_machine_thread {
    unsigned int arm_machine_flags;
    struct ks_arm_context *contextData;
    struct ks_arm_saved_state *upcb;
    struct ks_arm_neon_saved_state *uNeon;
    struct ks_arm_saved_state *kpcb;
    union {
        struct ks_arm_state_hdr *umatrix_hdr;
        struct ks_arm_amx_saved_state *uamx;
    };
    long x86_64_compat;
    unsigned long long recover_far;
    struct ks_arm_debug_aggregate_state *DebugData;
    unsigned long cthread_self;
    unsigned long long recover_esr;
    void *kstackptr;
    struct ks_perfcontrol_state perfctrl_state;
    unsigned long long aprr_shadow_mask_el0_value;
    unsigned long long jitbox_ctl_el0;
    union {
        long pcpu_data_base_and_cpu_number;
        unsigned short cpu_number;
    };
    struct ks_cpu_data *CpuDatap;
    unsigned int preemption_count;
    unsigned short exception_trace_code;
    _Bool vcpu_dirtied_matrix_context;
    unsigned long long rop_pid;
    unsigned long long jop_pid;
    unsigned long long sprr_kern_perm;
    _Bool reserved15;
};
_Static_assert(offsetof(struct ks_machine_thread, arm_machine_flags) == 0x0, "ks_machine_thread.arm_machine_flags offset");
_Static_assert(offsetof(struct ks_machine_thread, contextData) == 0x8, "ks_machine_thread.contextData offset");
_Static_assert(offsetof(struct ks_machine_thread, upcb) == 0x10, "ks_machine_thread.upcb offset");
_Static_assert(offsetof(struct ks_machine_thread, uNeon) == 0x18, "ks_machine_thread.uNeon offset");
_Static_assert(offsetof(struct ks_machine_thread, kpcb) == 0x20, "ks_machine_thread.kpcb offset");
_Static_assert(offsetof(struct ks_machine_thread, x86_64_compat) == 0x30, "ks_machine_thread.x86_64_compat offset");
_Static_assert(offsetof(struct ks_machine_thread, recover_far) == 0x38, "ks_machine_thread.recover_far offset");
_Static_assert(offsetof(struct ks_machine_thread, DebugData) == 0x40, "ks_machine_thread.DebugData offset");
_Static_assert(offsetof(struct ks_machine_thread, cthread_self) == 0x48, "ks_machine_thread.cthread_self offset");
_Static_assert(offsetof(struct ks_machine_thread, recover_esr) == 0x50, "ks_machine_thread.recover_esr offset");
_Static_assert(offsetof(struct ks_machine_thread, kstackptr) == 0x58, "ks_machine_thread.kstackptr offset");
_Static_assert(offsetof(struct ks_machine_thread, perfctrl_state) == 0x60, "ks_machine_thread.perfctrl_state offset");
_Static_assert(offsetof(struct ks_machine_thread, aprr_shadow_mask_el0_value) == 0xA0, "ks_machine_thread.aprr_shadow_mask_el0_value offset");
_Static_assert(offsetof(struct ks_machine_thread, jitbox_ctl_el0) == 0xA8, "ks_machine_thread.jitbox_ctl_el0 offset");
_Static_assert(offsetof(struct ks_machine_thread, CpuDatap) == 0xB8, "ks_machine_thread.CpuDatap offset");
_Static_assert(offsetof(struct ks_machine_thread, preemption_count) == 0xC0, "ks_machine_thread.preemption_count offset");
_Static_assert(offsetof(struct ks_machine_thread, exception_trace_code) == 0xC4, "ks_machine_thread.exception_trace_code offset");
_Static_assert(offsetof(struct ks_machine_thread, vcpu_dirtied_matrix_context) == 0xC6, "ks_machine_thread.vcpu_dirtied_matrix_context offset");
_Static_assert(offsetof(struct ks_machine_thread, rop_pid) == 0xC8, "ks_machine_thread.rop_pid offset");
_Static_assert(offsetof(struct ks_machine_thread, jop_pid) == 0xD0, "ks_machine_thread.jop_pid offset");
_Static_assert(offsetof(struct ks_machine_thread, sprr_kern_perm) == 0xD8, "ks_machine_thread.sprr_kern_perm offset");
_Static_assert(offsetof(struct ks_machine_thread, reserved15) == 0xE0, "ks_machine_thread.reserved15 offset");
_Static_assert(sizeof(struct ks_machine_thread) == 0xE8, "ks_machine_thread size");

/* refs: 19 */
struct ks_mbuf {
    struct ks_m_hdr_common M_hdr_common;
    char M_dat[0x120] __attribute__((aligned(16)));
};
_Static_assert(offsetof(struct ks_mbuf, M_hdr_common) == 0x0, "ks_mbuf.M_hdr_common offset");
_Static_assert(offsetof(struct ks_mbuf, M_dat) == 0xE0, "ks_mbuf.M_dat offset");
_Static_assert(sizeof(struct ks_mbuf) == 0x200, "ks_mbuf size");

/* refs: 1 */
struct ks_mem_acct {
    long long ma_allocated;
    int *ma_percpu;
    unsigned long long ma_hardlimit;
    unsigned char ma_percent;
    unsigned long long ma_peak;
    char ma_name[0x10];
};
_Static_assert(offsetof(struct ks_mem_acct, ma_allocated) == 0x0, "ks_mem_acct.ma_allocated offset");
_Static_assert(offsetof(struct ks_mem_acct, ma_percpu) == 0x8, "ks_mem_acct.ma_percpu offset");
_Static_assert(offsetof(struct ks_mem_acct, ma_hardlimit) == 0x10, "ks_mem_acct.ma_hardlimit offset");
_Static_assert(offsetof(struct ks_mem_acct, ma_percent) == 0x18, "ks_mem_acct.ma_percent offset");
_Static_assert(offsetof(struct ks_mem_acct, ma_peak) == 0x20, "ks_mem_acct.ma_peak offset");
_Static_assert(offsetof(struct ks_mem_acct, ma_name) == 0x28, "ks_mem_acct.ma_name offset");
_Static_assert(sizeof(struct ks_mem_acct) == 0x38, "ks_mem_acct size");

/* refs: 3 */
struct ks_memory_object {
    unsigned int mo_ikot;
    unsigned int mo_ref;
    const struct ks_memory_object_pager_ops *mo_pager_ops;
    struct ks_vm_object *mo_control;
    unsigned int mo_last_unmap_ctid;
};
_Static_assert(offsetof(struct ks_memory_object, mo_ikot) == 0x0, "ks_memory_object.mo_ikot offset");
_Static_assert(offsetof(struct ks_memory_object, mo_ref) == 0x4, "ks_memory_object.mo_ref offset");
_Static_assert(offsetof(struct ks_memory_object, mo_pager_ops) == 0x8, "ks_memory_object.mo_pager_ops offset");
_Static_assert(offsetof(struct ks_memory_object, mo_control) == 0x10, "ks_memory_object.mo_control offset");
_Static_assert(offsetof(struct ks_memory_object, mo_last_unmap_ctid) == 0x18, "ks_memory_object.mo_last_unmap_ctid offset");
_Static_assert(sizeof(struct ks_memory_object) == 0x20, "ks_memory_object size");

/* refs: 1 */
struct ks_memory_object_pager_ops {
    void *memory_object_reference;
    void *memory_object_deallocate;
    int *memory_object_init;
    int *memory_object_terminate;
    int *memory_object_data_request;
    int *memory_object_data_return;
    int *memory_object_data_initialize;
    void *__obsolete_memory_object_data_unlock;
    void *__obsolete_memory_object_synchronize;
    int *memory_object_map;
    int *memory_object_last_unmap;
    void *__obsolete_memory_object_data_reclaim;
    int *memory_object_backing_object;
    const char *memory_object_pager_name;
};
_Static_assert(offsetof(struct ks_memory_object_pager_ops, memory_object_reference) == 0x0, "ks_memory_object_pager_ops.memory_object_reference offset");
_Static_assert(offsetof(struct ks_memory_object_pager_ops, memory_object_deallocate) == 0x8, "ks_memory_object_pager_ops.memory_object_deallocate offset");
_Static_assert(offsetof(struct ks_memory_object_pager_ops, memory_object_init) == 0x10, "ks_memory_object_pager_ops.memory_object_init offset");
_Static_assert(offsetof(struct ks_memory_object_pager_ops, memory_object_terminate) == 0x18, "ks_memory_object_pager_ops.memory_object_terminate offset");
_Static_assert(offsetof(struct ks_memory_object_pager_ops, memory_object_data_request) == 0x20, "ks_memory_object_pager_ops.memory_object_data_request offset");
_Static_assert(offsetof(struct ks_memory_object_pager_ops, memory_object_data_return) == 0x28, "ks_memory_object_pager_ops.memory_object_data_return offset");
_Static_assert(offsetof(struct ks_memory_object_pager_ops, memory_object_data_initialize) == 0x30, "ks_memory_object_pager_ops.memory_object_data_initialize offset");
_Static_assert(offsetof(struct ks_memory_object_pager_ops, __obsolete_memory_object_data_unlock) == 0x38, "ks_memory_object_pager_ops.__obsolete_memory_object_data_unlock offset");
_Static_assert(offsetof(struct ks_memory_object_pager_ops, __obsolete_memory_object_synchronize) == 0x40, "ks_memory_object_pager_ops.__obsolete_memory_object_synchronize offset");
_Static_assert(offsetof(struct ks_memory_object_pager_ops, memory_object_map) == 0x48, "ks_memory_object_pager_ops.memory_object_map offset");
_Static_assert(offsetof(struct ks_memory_object_pager_ops, memory_object_last_unmap) == 0x50, "ks_memory_object_pager_ops.memory_object_last_unmap offset");
_Static_assert(offsetof(struct ks_memory_object_pager_ops, __obsolete_memory_object_data_reclaim) == 0x58, "ks_memory_object_pager_ops.__obsolete_memory_object_data_reclaim offset");
_Static_assert(offsetof(struct ks_memory_object_pager_ops, memory_object_backing_object) == 0x60, "ks_memory_object_pager_ops.memory_object_backing_object offset");
_Static_assert(offsetof(struct ks_memory_object_pager_ops, memory_object_pager_name) == 0x68, "ks_memory_object_pager_ops.memory_object_pager_name offset");
_Static_assert(sizeof(struct ks_memory_object_pager_ops) == 0x70, "ks_memory_object_pager_ops size");

/* refs: 2 */
struct ks_mit_cfg_tbl {
    unsigned int cfg_plowat;
    unsigned int cfg_phiwat;
    unsigned int cfg_blowat;
    unsigned int cfg_bhiwat;
    unsigned int cfg_ival;
};
_Static_assert(offsetof(struct ks_mit_cfg_tbl, cfg_plowat) == 0x0, "ks_mit_cfg_tbl.cfg_plowat offset");
_Static_assert(offsetof(struct ks_mit_cfg_tbl, cfg_phiwat) == 0x4, "ks_mit_cfg_tbl.cfg_phiwat offset");
_Static_assert(offsetof(struct ks_mit_cfg_tbl, cfg_blowat) == 0x8, "ks_mit_cfg_tbl.cfg_blowat offset");
_Static_assert(offsetof(struct ks_mit_cfg_tbl, cfg_bhiwat) == 0xC, "ks_mit_cfg_tbl.cfg_bhiwat offset");
_Static_assert(offsetof(struct ks_mit_cfg_tbl, cfg_ival) == 0x10, "ks_mit_cfg_tbl.cfg_ival offset");
_Static_assert(sizeof(struct ks_mit_cfg_tbl) == 0x14, "ks_mit_cfg_tbl size");

/* refs: 3 */
struct ks_priority_queue_entry_deadline {
    struct ks_priority_queue_entry_deadline *next;
    struct ks_priority_queue_entry_deadline *prev;
    long __key : 16; /* bit offset 128 */
    long child : 48; /* bit offset 144 */
    unsigned long long deadline;
};
_Static_assert(offsetof(struct ks_priority_queue_entry_deadline, next) == 0x0, "ks_priority_queue_entry_deadline.next offset");
_Static_assert(offsetof(struct ks_priority_queue_entry_deadline, prev) == 0x8, "ks_priority_queue_entry_deadline.prev offset");
_Static_assert(offsetof(struct ks_priority_queue_entry_deadline, deadline) == 0x18, "ks_priority_queue_entry_deadline.deadline offset");
_Static_assert(sizeof(struct ks_priority_queue_entry_deadline) == 0x20, "ks_priority_queue_entry_deadline size");

/* refs: 14 */
struct ks_thread_call {
    unsigned long long tc_soft_deadline;
    struct ks_priority_queue_entry_deadline tc_pqlink;
    struct ks_queue_entry *tc_queue;
    struct ks_queue_entry tc_qlink;
    unsigned short tc_index;
    unsigned short tc_flags;
    int tc_refs;
    unsigned long long tc_ttd;
    unsigned long long tc_pending_timestamp;
    void *tc_func;
    void *tc_param0;
    void *tc_param1;
    unsigned long long tc_submit_count;
    unsigned long long tc_finish_count;
};
_Static_assert(offsetof(struct ks_thread_call, tc_soft_deadline) == 0x0, "ks_thread_call.tc_soft_deadline offset");
_Static_assert(offsetof(struct ks_thread_call, tc_pqlink) == 0x8, "ks_thread_call.tc_pqlink offset");
_Static_assert(offsetof(struct ks_thread_call, tc_queue) == 0x28, "ks_thread_call.tc_queue offset");
_Static_assert(offsetof(struct ks_thread_call, tc_qlink) == 0x30, "ks_thread_call.tc_qlink offset");
_Static_assert(offsetof(struct ks_thread_call, tc_index) == 0x40, "ks_thread_call.tc_index offset");
_Static_assert(offsetof(struct ks_thread_call, tc_flags) == 0x42, "ks_thread_call.tc_flags offset");
_Static_assert(offsetof(struct ks_thread_call, tc_refs) == 0x44, "ks_thread_call.tc_refs offset");
_Static_assert(offsetof(struct ks_thread_call, tc_ttd) == 0x48, "ks_thread_call.tc_ttd offset");
_Static_assert(offsetof(struct ks_thread_call, tc_pending_timestamp) == 0x50, "ks_thread_call.tc_pending_timestamp offset");
_Static_assert(offsetof(struct ks_thread_call, tc_func) == 0x58, "ks_thread_call.tc_func offset");
_Static_assert(offsetof(struct ks_thread_call, tc_param0) == 0x60, "ks_thread_call.tc_param0 offset");
_Static_assert(offsetof(struct ks_thread_call, tc_param1) == 0x68, "ks_thread_call.tc_param1 offset");
_Static_assert(offsetof(struct ks_thread_call, tc_submit_count) == 0x70, "ks_thread_call.tc_submit_count offset");
_Static_assert(offsetof(struct ks_thread_call, tc_finish_count) == 0x78, "ks_thread_call.tc_finish_count offset");
_Static_assert(sizeof(struct ks_thread_call) == 0x80, "ks_thread_call size");

/* refs: 1 */
struct ks_mk_timer {
    struct ks_lck_spin_s lock;
    struct ks_thread_call mkt_thread_call;
    _Bool is_dead;
    _Bool is_armed;
    int active;
    struct ks_ipc_port *port;
    struct ks_ipc_kmsg *prealloc;
};
_Static_assert(offsetof(struct ks_mk_timer, lock) == 0x0, "ks_mk_timer.lock offset");
_Static_assert(offsetof(struct ks_mk_timer, mkt_thread_call) == 0x10, "ks_mk_timer.mkt_thread_call offset");
_Static_assert(offsetof(struct ks_mk_timer, is_dead) == 0x90, "ks_mk_timer.is_dead offset");
_Static_assert(offsetof(struct ks_mk_timer, is_armed) == 0x91, "ks_mk_timer.is_armed offset");
_Static_assert(offsetof(struct ks_mk_timer, active) == 0x94, "ks_mk_timer.active offset");
_Static_assert(offsetof(struct ks_mk_timer, port) == 0x98, "ks_mk_timer.port offset");
_Static_assert(offsetof(struct ks_mk_timer, prealloc) == 0xA0, "ks_mk_timer.prealloc offset");
_Static_assert(sizeof(struct ks_mk_timer) == 0xA8, "ks_mk_timer size");

/* refs: 4 */
struct ks_mld_ifinfo {
    struct ks_lck_mtx_s mli_lock;
    unsigned int mli_refcnt;
    unsigned int mli_debug;
    struct {
        struct ks_mld_ifinfo *le_next;
        struct ks_mld_ifinfo **le_prev;
    } mli_link;
    struct ks_ifnet *mli_ifp;
    unsigned int mli_version;
    unsigned int mli_v1_timer;
    unsigned int mli_v2_timer;
    unsigned int mli_flags;
    unsigned int mli_rv;
    unsigned int mli_qi;
    unsigned int mli_qri;
    unsigned int mli_uri;
    struct {
        struct ks_in6_multi *slh_first;
    } mli_relinmhead;
    struct ks_ifqueue mli_gq;
    struct ks_ifqueue mli_v1q;
};
_Static_assert(offsetof(struct ks_mld_ifinfo, mli_lock) == 0x0, "ks_mld_ifinfo.mli_lock offset");
_Static_assert(offsetof(struct ks_mld_ifinfo, mli_refcnt) == 0x10, "ks_mld_ifinfo.mli_refcnt offset");
_Static_assert(offsetof(struct ks_mld_ifinfo, mli_debug) == 0x14, "ks_mld_ifinfo.mli_debug offset");
_Static_assert(offsetof(struct ks_mld_ifinfo, mli_link) == 0x18, "ks_mld_ifinfo.mli_link offset");
_Static_assert(offsetof(struct ks_mld_ifinfo, mli_ifp) == 0x28, "ks_mld_ifinfo.mli_ifp offset");
_Static_assert(offsetof(struct ks_mld_ifinfo, mli_version) == 0x30, "ks_mld_ifinfo.mli_version offset");
_Static_assert(offsetof(struct ks_mld_ifinfo, mli_v1_timer) == 0x34, "ks_mld_ifinfo.mli_v1_timer offset");
_Static_assert(offsetof(struct ks_mld_ifinfo, mli_v2_timer) == 0x38, "ks_mld_ifinfo.mli_v2_timer offset");
_Static_assert(offsetof(struct ks_mld_ifinfo, mli_flags) == 0x3C, "ks_mld_ifinfo.mli_flags offset");
_Static_assert(offsetof(struct ks_mld_ifinfo, mli_rv) == 0x40, "ks_mld_ifinfo.mli_rv offset");
_Static_assert(offsetof(struct ks_mld_ifinfo, mli_qi) == 0x44, "ks_mld_ifinfo.mli_qi offset");
_Static_assert(offsetof(struct ks_mld_ifinfo, mli_qri) == 0x48, "ks_mld_ifinfo.mli_qri offset");
_Static_assert(offsetof(struct ks_mld_ifinfo, mli_uri) == 0x4C, "ks_mld_ifinfo.mli_uri offset");
_Static_assert(offsetof(struct ks_mld_ifinfo, mli_relinmhead) == 0x50, "ks_mld_ifinfo.mli_relinmhead offset");
_Static_assert(offsetof(struct ks_mld_ifinfo, mli_gq) == 0x58, "ks_mld_ifinfo.mli_gq offset");
_Static_assert(offsetof(struct ks_mld_ifinfo, mli_v1q) == 0x78, "ks_mld_ifinfo.mli_v1q offset");
_Static_assert(sizeof(struct ks_mld_ifinfo) == 0x98, "ks_mld_ifinfo size");

/* refs: 1 */
#pragma pack(push, 4)
struct ks_vfsstatfs {
    unsigned int f_bsize;
    unsigned long f_iosize;
    unsigned long long f_blocks;
    unsigned long long f_bfree;
    unsigned long long f_bavail;
    unsigned long long f_bused;
    unsigned long long f_files;
    unsigned long long f_ffree;
    struct ks_fsid f_fsid;
    unsigned int f_owner;
    unsigned long long f_flags;
    char f_fstypename[0x10];
    char f_mntonname[0x400];
    char f_mntfromname[0x400];
    unsigned int f_fssubtype;
    void *f_reserved[2];
};
#pragma pack(pop)
_Static_assert(offsetof(struct ks_vfsstatfs, f_bsize) == 0x0, "ks_vfsstatfs.f_bsize offset");
_Static_assert(offsetof(struct ks_vfsstatfs, f_iosize) == 0x4, "ks_vfsstatfs.f_iosize offset");
_Static_assert(offsetof(struct ks_vfsstatfs, f_blocks) == 0xC, "ks_vfsstatfs.f_blocks offset");
_Static_assert(offsetof(struct ks_vfsstatfs, f_bfree) == 0x14, "ks_vfsstatfs.f_bfree offset");
_Static_assert(offsetof(struct ks_vfsstatfs, f_bavail) == 0x1C, "ks_vfsstatfs.f_bavail offset");
_Static_assert(offsetof(struct ks_vfsstatfs, f_bused) == 0x24, "ks_vfsstatfs.f_bused offset");
_Static_assert(offsetof(struct ks_vfsstatfs, f_files) == 0x2C, "ks_vfsstatfs.f_files offset");
_Static_assert(offsetof(struct ks_vfsstatfs, f_ffree) == 0x34, "ks_vfsstatfs.f_ffree offset");
_Static_assert(offsetof(struct ks_vfsstatfs, f_fsid) == 0x3C, "ks_vfsstatfs.f_fsid offset");
_Static_assert(offsetof(struct ks_vfsstatfs, f_owner) == 0x44, "ks_vfsstatfs.f_owner offset");
_Static_assert(offsetof(struct ks_vfsstatfs, f_flags) == 0x48, "ks_vfsstatfs.f_flags offset");
_Static_assert(offsetof(struct ks_vfsstatfs, f_fstypename) == 0x50, "ks_vfsstatfs.f_fstypename offset");
_Static_assert(offsetof(struct ks_vfsstatfs, f_mntonname) == 0x60, "ks_vfsstatfs.f_mntonname offset");
_Static_assert(offsetof(struct ks_vfsstatfs, f_mntfromname) == 0x460, "ks_vfsstatfs.f_mntfromname offset");
_Static_assert(offsetof(struct ks_vfsstatfs, f_fssubtype) == 0x860, "ks_vfsstatfs.f_fssubtype offset");
_Static_assert(offsetof(struct ks_vfsstatfs, f_reserved) == 0x864, "ks_vfsstatfs.f_reserved offset");
_Static_assert(sizeof(struct ks_vfsstatfs) == 0x874, "ks_vfsstatfs size");

/* refs: 3 */
struct ks_vnodelst {
    struct ks_vnode *tqh_first;
    struct ks_vnode **tqh_last;
};
_Static_assert(offsetof(struct ks_vnodelst, tqh_first) == 0x0, "ks_vnodelst.tqh_first offset");
_Static_assert(offsetof(struct ks_vnodelst, tqh_last) == 0x8, "ks_vnodelst.tqh_last offset");
_Static_assert(sizeof(struct ks_vnodelst) == 0x10, "ks_vnodelst size");

/* refs: 5 */
struct ks_mount {
    struct {
        struct ks_mount *tqe_next;
        struct ks_mount **tqe_prev;
    } mnt_list;
    int mnt_count;
    struct ks_lck_mtx_s mnt_mlock;
    const struct ks_vfsops *mnt_op;
    struct ks_vfstable *mnt_vtable;
    struct ks_vnode *mnt_vnodecovered;
    struct ks_vnodelst mnt_vnodelist;
    struct ks_vnodelst mnt_workerqueue;
    struct ks_vnodelst mnt_newvnodes;
    unsigned int mnt_flag;
    unsigned int mnt_kern_flag;
    unsigned int mnt_compound_ops;
    unsigned int mnt_lflag;
    unsigned int mnt_maxsymlinklen;
    struct ks_vfsstatfs mnt_vfsstat __attribute__((aligned(4)));
    long long *mnt_data;
    unsigned int mnt_maxreadcnt;
    unsigned int mnt_maxwritecnt;
    unsigned int mnt_segreadcnt;
    unsigned int mnt_segwritecnt;
    unsigned int mnt_maxsegreadsize;
    unsigned int mnt_maxsegwritesize;
    unsigned int mnt_alignmentmask;
    unsigned int mnt_devblocksize;
    unsigned int mnt_ioqueue_depth;
    unsigned int mnt_ioscale;
    unsigned int mnt_ioflags;
    unsigned int mnt_minsaturationbytecount;
    unsigned int mnt_pending_write_size __attribute__((aligned(4)));
    unsigned int mnt_pending_read_size __attribute__((aligned(4)));
    struct ks_timeval mnt_last_write_issued_timestamp;
    struct ks_timeval mnt_last_write_completed_timestamp;
    long long mnt_max_swappin_available;
    struct ks_lck_rw_s mnt_rwlock;
    struct ks_lck_mtx_s mnt_renamelock;
    struct ks_vnode *mnt_devvp;
    unsigned int mnt_devbsdunit;
    unsigned long long mnt_throttle_mask;
    void *mnt_throttle_info;
    int mnt_crossref;
    int mnt_iterref;
    int mnt_numtriggers;
    void *mnt_triggercallback;
    void *mnt_triggerdata;
    unsigned int mnt_fsowner;
    unsigned int mnt_fsgroup;
    struct ks_label *mnt_mntlabel;
    struct ks_vnode *mnt_realrootvp;
    unsigned int mnt_realrootvp_vid;
    unsigned int mnt_generation;
    int mnt_authcache_ttl;
    char fstypename_override[0x10];
    unsigned int mnt_iobufinuse;
    void *mnt_disk_conditioner_info;
    struct ks_lck_mtx_s mnt_iter_lock;
    unsigned long long mnt_mount_id;
    unsigned int mnt_supl_kern_flag;
};
_Static_assert(offsetof(struct ks_mount, mnt_list) == 0x0, "ks_mount.mnt_list offset");
_Static_assert(offsetof(struct ks_mount, mnt_count) == 0x10, "ks_mount.mnt_count offset");
_Static_assert(offsetof(struct ks_mount, mnt_mlock) == 0x18, "ks_mount.mnt_mlock offset");
_Static_assert(offsetof(struct ks_mount, mnt_op) == 0x28, "ks_mount.mnt_op offset");
_Static_assert(offsetof(struct ks_mount, mnt_vtable) == 0x30, "ks_mount.mnt_vtable offset");
_Static_assert(offsetof(struct ks_mount, mnt_vnodecovered) == 0x38, "ks_mount.mnt_vnodecovered offset");
_Static_assert(offsetof(struct ks_mount, mnt_vnodelist) == 0x40, "ks_mount.mnt_vnodelist offset");
_Static_assert(offsetof(struct ks_mount, mnt_workerqueue) == 0x50, "ks_mount.mnt_workerqueue offset");
_Static_assert(offsetof(struct ks_mount, mnt_newvnodes) == 0x60, "ks_mount.mnt_newvnodes offset");
_Static_assert(offsetof(struct ks_mount, mnt_flag) == 0x70, "ks_mount.mnt_flag offset");
_Static_assert(offsetof(struct ks_mount, mnt_kern_flag) == 0x74, "ks_mount.mnt_kern_flag offset");
_Static_assert(offsetof(struct ks_mount, mnt_compound_ops) == 0x78, "ks_mount.mnt_compound_ops offset");
_Static_assert(offsetof(struct ks_mount, mnt_lflag) == 0x7C, "ks_mount.mnt_lflag offset");
_Static_assert(offsetof(struct ks_mount, mnt_maxsymlinklen) == 0x80, "ks_mount.mnt_maxsymlinklen offset");
_Static_assert(offsetof(struct ks_mount, mnt_vfsstat) == 0x84, "ks_mount.mnt_vfsstat offset");
_Static_assert(offsetof(struct ks_mount, mnt_data) == 0x8F8, "ks_mount.mnt_data offset");
_Static_assert(offsetof(struct ks_mount, mnt_maxreadcnt) == 0x900, "ks_mount.mnt_maxreadcnt offset");
_Static_assert(offsetof(struct ks_mount, mnt_maxwritecnt) == 0x904, "ks_mount.mnt_maxwritecnt offset");
_Static_assert(offsetof(struct ks_mount, mnt_segreadcnt) == 0x908, "ks_mount.mnt_segreadcnt offset");
_Static_assert(offsetof(struct ks_mount, mnt_segwritecnt) == 0x90C, "ks_mount.mnt_segwritecnt offset");
_Static_assert(offsetof(struct ks_mount, mnt_maxsegreadsize) == 0x910, "ks_mount.mnt_maxsegreadsize offset");
_Static_assert(offsetof(struct ks_mount, mnt_maxsegwritesize) == 0x914, "ks_mount.mnt_maxsegwritesize offset");
_Static_assert(offsetof(struct ks_mount, mnt_alignmentmask) == 0x918, "ks_mount.mnt_alignmentmask offset");
_Static_assert(offsetof(struct ks_mount, mnt_devblocksize) == 0x91C, "ks_mount.mnt_devblocksize offset");
_Static_assert(offsetof(struct ks_mount, mnt_ioqueue_depth) == 0x920, "ks_mount.mnt_ioqueue_depth offset");
_Static_assert(offsetof(struct ks_mount, mnt_ioscale) == 0x924, "ks_mount.mnt_ioscale offset");
_Static_assert(offsetof(struct ks_mount, mnt_ioflags) == 0x928, "ks_mount.mnt_ioflags offset");
_Static_assert(offsetof(struct ks_mount, mnt_minsaturationbytecount) == 0x92C, "ks_mount.mnt_minsaturationbytecount offset");
_Static_assert(offsetof(struct ks_mount, mnt_pending_write_size) == 0x930, "ks_mount.mnt_pending_write_size offset");
_Static_assert(offsetof(struct ks_mount, mnt_pending_read_size) == 0x934, "ks_mount.mnt_pending_read_size offset");
_Static_assert(offsetof(struct ks_mount, mnt_last_write_issued_timestamp) == 0x938, "ks_mount.mnt_last_write_issued_timestamp offset");
_Static_assert(offsetof(struct ks_mount, mnt_last_write_completed_timestamp) == 0x948, "ks_mount.mnt_last_write_completed_timestamp offset");
_Static_assert(offsetof(struct ks_mount, mnt_max_swappin_available) == 0x958, "ks_mount.mnt_max_swappin_available offset");
_Static_assert(offsetof(struct ks_mount, mnt_rwlock) == 0x960, "ks_mount.mnt_rwlock offset");
_Static_assert(offsetof(struct ks_mount, mnt_renamelock) == 0x970, "ks_mount.mnt_renamelock offset");
_Static_assert(offsetof(struct ks_mount, mnt_devvp) == 0x980, "ks_mount.mnt_devvp offset");
_Static_assert(offsetof(struct ks_mount, mnt_devbsdunit) == 0x988, "ks_mount.mnt_devbsdunit offset");
_Static_assert(offsetof(struct ks_mount, mnt_throttle_mask) == 0x990, "ks_mount.mnt_throttle_mask offset");
_Static_assert(offsetof(struct ks_mount, mnt_throttle_info) == 0x998, "ks_mount.mnt_throttle_info offset");
_Static_assert(offsetof(struct ks_mount, mnt_crossref) == 0x9A0, "ks_mount.mnt_crossref offset");
_Static_assert(offsetof(struct ks_mount, mnt_iterref) == 0x9A4, "ks_mount.mnt_iterref offset");
_Static_assert(offsetof(struct ks_mount, mnt_numtriggers) == 0x9A8, "ks_mount.mnt_numtriggers offset");
_Static_assert(offsetof(struct ks_mount, mnt_triggercallback) == 0x9B0, "ks_mount.mnt_triggercallback offset");
_Static_assert(offsetof(struct ks_mount, mnt_triggerdata) == 0x9B8, "ks_mount.mnt_triggerdata offset");
_Static_assert(offsetof(struct ks_mount, mnt_fsowner) == 0x9C0, "ks_mount.mnt_fsowner offset");
_Static_assert(offsetof(struct ks_mount, mnt_fsgroup) == 0x9C4, "ks_mount.mnt_fsgroup offset");
_Static_assert(offsetof(struct ks_mount, mnt_mntlabel) == 0x9C8, "ks_mount.mnt_mntlabel offset");
_Static_assert(offsetof(struct ks_mount, mnt_realrootvp) == 0x9D0, "ks_mount.mnt_realrootvp offset");
_Static_assert(offsetof(struct ks_mount, mnt_realrootvp_vid) == 0x9D8, "ks_mount.mnt_realrootvp_vid offset");
_Static_assert(offsetof(struct ks_mount, mnt_generation) == 0x9DC, "ks_mount.mnt_generation offset");
_Static_assert(offsetof(struct ks_mount, mnt_authcache_ttl) == 0x9E0, "ks_mount.mnt_authcache_ttl offset");
_Static_assert(offsetof(struct ks_mount, fstypename_override) == 0x9E4, "ks_mount.fstypename_override offset");
_Static_assert(offsetof(struct ks_mount, mnt_iobufinuse) == 0x9F4, "ks_mount.mnt_iobufinuse offset");
_Static_assert(offsetof(struct ks_mount, mnt_disk_conditioner_info) == 0x9F8, "ks_mount.mnt_disk_conditioner_info offset");
_Static_assert(offsetof(struct ks_mount, mnt_iter_lock) == 0xA00, "ks_mount.mnt_iter_lock offset");
_Static_assert(offsetof(struct ks_mount, mnt_mount_id) == 0xA10, "ks_mount.mnt_mount_id offset");
_Static_assert(offsetof(struct ks_mount, mnt_supl_kern_flag) == 0xA18, "ks_mount.mnt_supl_kern_flag offset");
_Static_assert(sizeof(struct ks_mount) == 0xA20, "ks_mount size");

/* refs: 2 */
struct ks_smrq_link {
    struct ks___smrq_link_t next;
    struct ks___smrq_link_t *prev;
};
_Static_assert(offsetof(struct ks_smrq_link, next) == 0x0, "ks_smrq_link.next offset");
_Static_assert(offsetof(struct ks_smrq_link, prev) == 0x8, "ks_smrq_link.prev offset");
_Static_assert(sizeof(struct ks_smrq_link) == 0x10, "ks_smrq_link size");

/* refs: 9 */
struct ks_namecache {
    struct {
        struct ks_namecache *tqe_next;
        struct ks_namecache **tqe_prev;
    } nc_entry;
    struct {
        struct ks_namecache *tqe_next;
        struct ks_namecache **tqe_prev;
    } nc_child;
    struct {
        struct ks_namecache *le_next;
        struct ks_namecache **le_prev;
    } nc_un;
    struct ks_smrq_link nc_hash;
    unsigned int nc_vid;
    unsigned int nc_counter;
    struct ks_vnode *nc_dvp;
    struct ks_vnode *nc_vp;
    unsigned int nc_hashval;
    const char *nc_name;
};
_Static_assert(offsetof(struct ks_namecache, nc_entry) == 0x0, "ks_namecache.nc_entry offset");
_Static_assert(offsetof(struct ks_namecache, nc_child) == 0x10, "ks_namecache.nc_child offset");
_Static_assert(offsetof(struct ks_namecache, nc_un) == 0x20, "ks_namecache.nc_un offset");
_Static_assert(offsetof(struct ks_namecache, nc_hash) == 0x30, "ks_namecache.nc_hash offset");
_Static_assert(offsetof(struct ks_namecache, nc_vid) == 0x40, "ks_namecache.nc_vid offset");
_Static_assert(offsetof(struct ks_namecache, nc_counter) == 0x44, "ks_namecache.nc_counter offset");
_Static_assert(offsetof(struct ks_namecache, nc_dvp) == 0x48, "ks_namecache.nc_dvp offset");
_Static_assert(offsetof(struct ks_namecache, nc_vp) == 0x50, "ks_namecache.nc_vp offset");
_Static_assert(offsetof(struct ks_namecache, nc_hashval) == 0x58, "ks_namecache.nc_hashval offset");
_Static_assert(offsetof(struct ks_namecache, nc_name) == 0x60, "ks_namecache.nc_name offset");
_Static_assert(sizeof(struct ks_namecache) == 0x68, "ks_namecache size");

/* refs: 2 */
struct ks_nameidata {
    unsigned long long ni_dirp;
    unsigned int ni_segflg;
    unsigned int ni_op;
    struct ks_vnode *ni_startdir;
    struct ks_vnode *ni_rootdir;
    struct ks_vnode *ni_usedvp;
    struct ks_vnode *ni_vp;
    struct ks_vnode *ni_dvp;
    unsigned int ni_pathlen;
    char *ni_next;
    char ni_pathbuf[0x100];
    unsigned long ni_loopcnt;
    struct ks_componentname ni_cnd;
    int ni_flag;
    int ni_ncgeneration;
};
_Static_assert(offsetof(struct ks_nameidata, ni_dirp) == 0x0, "ks_nameidata.ni_dirp offset");
_Static_assert(offsetof(struct ks_nameidata, ni_segflg) == 0x8, "ks_nameidata.ni_segflg offset");
_Static_assert(offsetof(struct ks_nameidata, ni_op) == 0xC, "ks_nameidata.ni_op offset");
_Static_assert(offsetof(struct ks_nameidata, ni_startdir) == 0x10, "ks_nameidata.ni_startdir offset");
_Static_assert(offsetof(struct ks_nameidata, ni_rootdir) == 0x18, "ks_nameidata.ni_rootdir offset");
_Static_assert(offsetof(struct ks_nameidata, ni_usedvp) == 0x20, "ks_nameidata.ni_usedvp offset");
_Static_assert(offsetof(struct ks_nameidata, ni_vp) == 0x28, "ks_nameidata.ni_vp offset");
_Static_assert(offsetof(struct ks_nameidata, ni_dvp) == 0x30, "ks_nameidata.ni_dvp offset");
_Static_assert(offsetof(struct ks_nameidata, ni_pathlen) == 0x38, "ks_nameidata.ni_pathlen offset");
_Static_assert(offsetof(struct ks_nameidata, ni_next) == 0x40, "ks_nameidata.ni_next offset");
_Static_assert(offsetof(struct ks_nameidata, ni_pathbuf) == 0x48, "ks_nameidata.ni_pathbuf offset");
_Static_assert(offsetof(struct ks_nameidata, ni_loopcnt) == 0x148, "ks_nameidata.ni_loopcnt offset");
_Static_assert(offsetof(struct ks_nameidata, ni_cnd) == 0x150, "ks_nameidata.ni_cnd offset");
_Static_assert(offsetof(struct ks_nameidata, ni_flag) == 0x190, "ks_nameidata.ni_flag offset");
_Static_assert(offsetof(struct ks_nameidata, ni_ncgeneration) == 0x194, "ks_nameidata.ni_ncgeneration offset");
_Static_assert(sizeof(struct ks_nameidata) == 0x198, "ks_nameidata size");

/* refs: 1 */
struct ks_reordering {
    unsigned int reordering_p;
    unsigned int reordering_ms;
};
_Static_assert(offsetof(struct ks_reordering, reordering_p) == 0x0, "ks_reordering.reordering_p offset");
_Static_assert(offsetof(struct ks_reordering, reordering_ms) == 0x4, "ks_reordering.reordering_ms offset");
_Static_assert(sizeof(struct ks_reordering) == 0x8, "ks_reordering size");

/* refs: 3 */
struct ks_netem {
    struct ks_lck_mtx_s netem_lock;
    char netem_name[0x40];
    unsigned int netem_flags;
    struct ks_ifnet *netem_ifp;
    struct ks_thread *netem_output_thread;
    void *netem_output_handle;
    int *netem_output;
    unsigned int netem_output_max_batch_size;
    unsigned int netem_output_ival_ms;
    struct ks_heap *netem_heap;
    unsigned int netem_model;
    int *netem_enqueue;
    struct ks_bandwidth netem_bandwidth_model;
    struct ks_corruption netem_corruption_model;
    struct ks_duplication netem_duplication_model;
    struct ks_latency netem_latency_model;
    struct ks_loss netem_loss_model;
    struct ks_reordering netem_reordering_model;
};
_Static_assert(offsetof(struct ks_netem, netem_lock) == 0x0, "ks_netem.netem_lock offset");
_Static_assert(offsetof(struct ks_netem, netem_name) == 0x10, "ks_netem.netem_name offset");
_Static_assert(offsetof(struct ks_netem, netem_flags) == 0x50, "ks_netem.netem_flags offset");
_Static_assert(offsetof(struct ks_netem, netem_ifp) == 0x58, "ks_netem.netem_ifp offset");
_Static_assert(offsetof(struct ks_netem, netem_output_thread) == 0x60, "ks_netem.netem_output_thread offset");
_Static_assert(offsetof(struct ks_netem, netem_output_handle) == 0x68, "ks_netem.netem_output_handle offset");
_Static_assert(offsetof(struct ks_netem, netem_output) == 0x70, "ks_netem.netem_output offset");
_Static_assert(offsetof(struct ks_netem, netem_output_max_batch_size) == 0x78, "ks_netem.netem_output_max_batch_size offset");
_Static_assert(offsetof(struct ks_netem, netem_output_ival_ms) == 0x7C, "ks_netem.netem_output_ival_ms offset");
_Static_assert(offsetof(struct ks_netem, netem_heap) == 0x80, "ks_netem.netem_heap offset");
_Static_assert(offsetof(struct ks_netem, netem_model) == 0x88, "ks_netem.netem_model offset");
_Static_assert(offsetof(struct ks_netem, netem_enqueue) == 0x90, "ks_netem.netem_enqueue offset");
_Static_assert(offsetof(struct ks_netem, netem_bandwidth_model) == 0x98, "ks_netem.netem_bandwidth_model offset");
_Static_assert(offsetof(struct ks_netem, netem_corruption_model) == 0xA8, "ks_netem.netem_corruption_model offset");
_Static_assert(offsetof(struct ks_netem, netem_duplication_model) == 0xAC, "ks_netem.netem_duplication_model offset");
_Static_assert(offsetof(struct ks_netem, netem_latency_model) == 0xB0, "ks_netem.netem_latency_model offset");
_Static_assert(offsetof(struct ks_netem, netem_loss_model) == 0xC0, "ks_netem.netem_loss_model offset");
_Static_assert(offsetof(struct ks_netem, netem_reordering_model) == 0xE8, "ks_netem.netem_reordering_model offset");
_Static_assert(sizeof(struct ks_netem) == 0xF0, "ks_netem size");

/* refs: 2 */
struct ks_netif_agent_flow {
    struct {
        struct ks_netif_agent_flow *sle_next;
    } naf_link;
    unsigned char naf_flow_uuid[0x10];
    unsigned char naf_bind_key[0x10];
    unsigned short naf_nx_port;
    unsigned int naf_flags;
    int naf_pid;
    union ks_sockaddr_in_4_6 naf_daddr;
    union ks_sockaddr_in_4_6 naf_saddr;
};
_Static_assert(offsetof(struct ks_netif_agent_flow, naf_link) == 0x0, "ks_netif_agent_flow.naf_link offset");
_Static_assert(offsetof(struct ks_netif_agent_flow, naf_flow_uuid) == 0x8, "ks_netif_agent_flow.naf_flow_uuid offset");
_Static_assert(offsetof(struct ks_netif_agent_flow, naf_bind_key) == 0x18, "ks_netif_agent_flow.naf_bind_key offset");
_Static_assert(offsetof(struct ks_netif_agent_flow, naf_nx_port) == 0x28, "ks_netif_agent_flow.naf_nx_port offset");
_Static_assert(offsetof(struct ks_netif_agent_flow, naf_flags) == 0x2C, "ks_netif_agent_flow.naf_flags offset");
_Static_assert(offsetof(struct ks_netif_agent_flow, naf_pid) == 0x30, "ks_netif_agent_flow.naf_pid offset");
_Static_assert(offsetof(struct ks_netif_agent_flow, naf_daddr) == 0x34, "ks_netif_agent_flow.naf_daddr offset");
_Static_assert(offsetof(struct ks_netif_agent_flow, naf_saddr) == 0x50, "ks_netif_agent_flow.naf_saddr offset");
_Static_assert(sizeof(struct ks_netif_agent_flow) == 0x70, "ks_netif_agent_flow size");

/* refs: 1 */
struct ks_netif_agent_flow_head {
    struct ks_netif_agent_flow *slh_first;
};
_Static_assert(offsetof(struct ks_netif_agent_flow_head, slh_first) == 0x0, "ks_netif_agent_flow_head.slh_first offset");
_Static_assert(sizeof(struct ks_netif_agent_flow_head) == 0x8, "ks_netif_agent_flow_head size");

/* refs: 4 */
struct ks_netif_filter {
    struct {
        struct ks_netif_filter *stqe_next;
    } nf_link;
    unsigned short nf_port;
    unsigned int nf_refcnt;
    void *nf_cb_arg;
    int *nf_cb_func;
};
_Static_assert(offsetof(struct ks_netif_filter, nf_link) == 0x0, "ks_netif_filter.nf_link offset");
_Static_assert(offsetof(struct ks_netif_filter, nf_port) == 0x8, "ks_netif_filter.nf_port offset");
_Static_assert(offsetof(struct ks_netif_filter, nf_refcnt) == 0xC, "ks_netif_filter.nf_refcnt offset");
_Static_assert(offsetof(struct ks_netif_filter, nf_cb_arg) == 0x10, "ks_netif_filter.nf_cb_arg offset");
_Static_assert(offsetof(struct ks_netif_filter, nf_cb_func) == 0x18, "ks_netif_filter.nf_cb_func offset");
_Static_assert(sizeof(struct ks_netif_filter) == 0x20, "ks_netif_filter size");

/* refs: 1 */
struct ks_netif_filter_head {
    struct ks_netif_filter *stqh_first;
    struct ks_netif_filter **stqh_last;
};
_Static_assert(offsetof(struct ks_netif_filter_head, stqh_first) == 0x0, "ks_netif_filter_head.stqh_first offset");
_Static_assert(offsetof(struct ks_netif_filter_head, stqh_last) == 0x8, "ks_netif_filter_head.stqh_last offset");
_Static_assert(sizeof(struct ks_netif_filter_head) == 0x10, "ks_netif_filter_head size");

/* refs: 1 */
struct ks_netif_flow_desc {
    unsigned short fd_ethertype;
    struct ks_in6_addr fd_laddr;
    struct ks_in6_addr fd_raddr;
};
_Static_assert(offsetof(struct ks_netif_flow_desc, fd_ethertype) == 0x0, "ks_netif_flow_desc.fd_ethertype offset");
_Static_assert(offsetof(struct ks_netif_flow_desc, fd_laddr) == 0x4, "ks_netif_flow_desc.fd_laddr offset");
_Static_assert(offsetof(struct ks_netif_flow_desc, fd_raddr) == 0x14, "ks_netif_flow_desc.fd_raddr offset");
_Static_assert(sizeof(struct ks_netif_flow_desc) == 0x24, "ks_netif_flow_desc size");

/* refs: 4 */
struct ks_netif_flow {
    struct {
        struct ks_netif_flow *sle_next;
    } nf_link;
    struct {
        struct ks_netif_flow *sle_next;
    } nf_table_link;
    unsigned short nf_port;
    unsigned int nf_refcnt;
    struct ks_netif_flow_desc nf_desc;
    void *nf_cb_arg;
    int *nf_cb_func;
};
_Static_assert(offsetof(struct ks_netif_flow, nf_link) == 0x0, "ks_netif_flow.nf_link offset");
_Static_assert(offsetof(struct ks_netif_flow, nf_table_link) == 0x8, "ks_netif_flow.nf_table_link offset");
_Static_assert(offsetof(struct ks_netif_flow, nf_port) == 0x10, "ks_netif_flow.nf_port offset");
_Static_assert(offsetof(struct ks_netif_flow, nf_refcnt) == 0x14, "ks_netif_flow.nf_refcnt offset");
_Static_assert(offsetof(struct ks_netif_flow, nf_desc) == 0x18, "ks_netif_flow.nf_desc offset");
_Static_assert(offsetof(struct ks_netif_flow, nf_cb_arg) == 0x40, "ks_netif_flow.nf_cb_arg offset");
_Static_assert(offsetof(struct ks_netif_flow, nf_cb_func) == 0x48, "ks_netif_flow.nf_cb_func offset");
_Static_assert(sizeof(struct ks_netif_flow) == 0x50, "ks_netif_flow size");

/* refs: 1 */
struct ks_netif_flow_head {
    struct ks_netif_flow *slh_first;
};
_Static_assert(offsetof(struct ks_netif_flow_head, slh_first) == 0x0, "ks_netif_flow_head.slh_first offset");
_Static_assert(sizeof(struct ks_netif_flow_head) == 0x8, "ks_netif_flow_head size");

/* refs: 1 */
struct ks_netif_flowtable {
    struct ks_netif_flowtable_ops *ft_ops;
    void *ft_internal;
};
_Static_assert(offsetof(struct ks_netif_flowtable, ft_ops) == 0x0, "ks_netif_flowtable.ft_ops offset");
_Static_assert(offsetof(struct ks_netif_flowtable, ft_internal) == 0x8, "ks_netif_flowtable.ft_internal offset");
_Static_assert(sizeof(struct ks_netif_flowtable) == 0x10, "ks_netif_flowtable size");

/* refs: 4 */
struct ks_netif_llink {
    struct ks_nx_netif *nll_nif;
    struct {
        struct ks_netif_llink *stqe_next;
    } nll_link;
    struct {
        struct ks_netif_qset *slh_first;
    } nll_qset_list;
    struct ks_netif_qset *nll_default_qset;
    struct ks_ifclassq *nll_ifcq;
    struct ks_os_refcnt nll_refcnt;
    unsigned long long nll_link_id;
    unsigned short nll_link_id_internal;
    unsigned short nll_qset_cnt;
    unsigned char nll_state;
    unsigned char nll_flags;
    void *nll_ctx;
};
_Static_assert(offsetof(struct ks_netif_llink, nll_nif) == 0x0, "ks_netif_llink.nll_nif offset");
_Static_assert(offsetof(struct ks_netif_llink, nll_link) == 0x8, "ks_netif_llink.nll_link offset");
_Static_assert(offsetof(struct ks_netif_llink, nll_qset_list) == 0x10, "ks_netif_llink.nll_qset_list offset");
_Static_assert(offsetof(struct ks_netif_llink, nll_default_qset) == 0x18, "ks_netif_llink.nll_default_qset offset");
_Static_assert(offsetof(struct ks_netif_llink, nll_ifcq) == 0x20, "ks_netif_llink.nll_ifcq offset");
_Static_assert(offsetof(struct ks_netif_llink, nll_refcnt) == 0x28, "ks_netif_llink.nll_refcnt offset");
_Static_assert(offsetof(struct ks_netif_llink, nll_link_id) == 0x30, "ks_netif_llink.nll_link_id offset");
_Static_assert(offsetof(struct ks_netif_llink, nll_link_id_internal) == 0x38, "ks_netif_llink.nll_link_id_internal offset");
_Static_assert(offsetof(struct ks_netif_llink, nll_qset_cnt) == 0x3A, "ks_netif_llink.nll_qset_cnt offset");
_Static_assert(offsetof(struct ks_netif_llink, nll_state) == 0x3C, "ks_netif_llink.nll_state offset");
_Static_assert(offsetof(struct ks_netif_llink, nll_flags) == 0x3D, "ks_netif_llink.nll_flags offset");
_Static_assert(offsetof(struct ks_netif_llink, nll_ctx) == 0x40, "ks_netif_llink.nll_ctx offset");
_Static_assert(sizeof(struct ks_netif_llink) == 0x48, "ks_netif_llink size");

/* refs: 2 */
struct ks_netif_nexus_advisory {
    unsigned long long nna_version;
    union {
        struct ks___kern_netif_intf_advisory __kern_intf_adv __attribute__((aligned(8)));
        unsigned char __nna_intf_adv[0x68];
    };
} __attribute__((aligned(8)));
_Static_assert(offsetof(struct ks_netif_nexus_advisory, nna_version) == 0x0, "ks_netif_nexus_advisory.nna_version offset");
_Static_assert(sizeof(struct ks_netif_nexus_advisory) == 0x70, "ks_netif_nexus_advisory size");

/* refs: 1 */
struct ks_netif_qset_extensions {
    int *qe_notify_steering_info;
    void *qe_prov_ctx;
};
_Static_assert(offsetof(struct ks_netif_qset_extensions, qe_notify_steering_info) == 0x0, "ks_netif_qset_extensions.qe_notify_steering_info offset");
_Static_assert(offsetof(struct ks_netif_qset_extensions, qe_prov_ctx) == 0x8, "ks_netif_qset_extensions.qe_prov_ctx offset");
_Static_assert(sizeof(struct ks_netif_qset_extensions) == 0x10, "ks_netif_qset_extensions size");

/* refs: 1 */
struct ks_netif_rx_flow_steering {
    int *config_fn;
    void *prov_ctx;
};
_Static_assert(offsetof(struct ks_netif_rx_flow_steering, config_fn) == 0x0, "ks_netif_rx_flow_steering.config_fn offset");
_Static_assert(offsetof(struct ks_netif_rx_flow_steering, prov_ctx) == 0x8, "ks_netif_rx_flow_steering.prov_ctx offset");
_Static_assert(sizeof(struct ks_netif_rx_flow_steering) == 0x10, "ks_netif_rx_flow_steering size");

/* refs: 1 */
struct ks_netif_stats {
    unsigned long long _arr[0x88];
} __attribute__((aligned(16)));
_Static_assert(offsetof(struct ks_netif_stats, _arr) == 0x0, "ks_netif_stats._arr offset");
_Static_assert(sizeof(struct ks_netif_stats) == 0x440, "ks_netif_stats size");

/* refs: 6 */
struct ks_nexus_adapter {
    unsigned int na_flags;
    unsigned int na_type;
    unsigned int na_md_type;
    unsigned int na_md_subtype;
    unsigned short na_nx_port;
    unsigned int na_channels;
    unsigned int na_num_rx_rings;
    unsigned int na_num_tx_rings;
    unsigned int na_num_allocator_ring_pairs;
    unsigned int na_num_event_rings;
    unsigned int na_num_large_buf_alloc_rings;
    unsigned int na_rx_rings_cnt;
    unsigned int na_tx_rings_cnt;
    unsigned int na_alloc_free_rings_cnt;
    unsigned int na_event_rings_cnt;
    unsigned int na_large_buf_alloc_rings_cnt;
    unsigned int na_slot_ctxs_cnt;
    unsigned int na_scratch_cnt;
    unsigned int na_all_rings_cnt;
    unsigned long long na_work_ts;
    struct ks___kern_channel_ring *na_tx_rings;
    struct ks___kern_channel_ring *na_rx_rings;
    struct ks___kern_channel_ring *na_all_rings;
    struct ks_kern_nexus *na_nx;
    unsigned int na_refcount;
    int na_si_users[6];
    struct ks_ch_selinfo na_si[6];
    struct ks_skmem_arena *na_arena;
    unsigned int na_num_tx_slots;
    unsigned int na_num_rx_slots;
    unsigned int na_num_allocator_slots;
    unsigned int na_num_event_slots;
    unsigned int na_num_large_buf_alloc_slots;
    unsigned int na_total_slots;
    unsigned int na_flowadv_max;
    unsigned int na_stats_type;
    struct ks___kern_channel_ring *na_alloc_rings;
    struct ks___kern_channel_ring *na_free_rings;
    struct ks___kern_channel_ring *na_event_rings;
    struct ks___kern_channel_ring *na_large_buf_alloc_rings;
    unsigned long long na_ch_mit_ival;
    struct ks_kern_nexus_domain_provider *na_nxdom_prov;
    struct ks_slot_ctx *na_slot_ctxs;
    unsigned long long *na_scratch;
    struct ks___kern_channel_ring *na_tail;
    void *na_private;
    struct ks_ifnet *na_ifp;
    unsigned char na_kring_svc_lut[10];
    unsigned int na_next_pipe;
    unsigned int na_max_pipes;
    struct ks_nexus_upipe_adapter **na_pipes;
    char na_name[0x40];
    unsigned char na_uuid[0x10];
    int *na_activate;
    int *na_special;
    int *na_txsync;
    int *na_rxsync;
    int *na_notify;
    int *na_channel_event_notify;
    int *na_config;
    int *na_krings_create;
    void *na_krings_delete;
    void *na_dtor;
    void *na_free;
    void *na_rx;
};
_Static_assert(offsetof(struct ks_nexus_adapter, na_flags) == 0x0, "ks_nexus_adapter.na_flags offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_type) == 0x4, "ks_nexus_adapter.na_type offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_md_type) == 0x8, "ks_nexus_adapter.na_md_type offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_md_subtype) == 0xC, "ks_nexus_adapter.na_md_subtype offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_nx_port) == 0x10, "ks_nexus_adapter.na_nx_port offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_channels) == 0x14, "ks_nexus_adapter.na_channels offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_num_rx_rings) == 0x18, "ks_nexus_adapter.na_num_rx_rings offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_num_tx_rings) == 0x1C, "ks_nexus_adapter.na_num_tx_rings offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_num_allocator_ring_pairs) == 0x20, "ks_nexus_adapter.na_num_allocator_ring_pairs offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_num_event_rings) == 0x24, "ks_nexus_adapter.na_num_event_rings offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_num_large_buf_alloc_rings) == 0x28, "ks_nexus_adapter.na_num_large_buf_alloc_rings offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_rx_rings_cnt) == 0x2C, "ks_nexus_adapter.na_rx_rings_cnt offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_tx_rings_cnt) == 0x30, "ks_nexus_adapter.na_tx_rings_cnt offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_alloc_free_rings_cnt) == 0x34, "ks_nexus_adapter.na_alloc_free_rings_cnt offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_event_rings_cnt) == 0x38, "ks_nexus_adapter.na_event_rings_cnt offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_large_buf_alloc_rings_cnt) == 0x3C, "ks_nexus_adapter.na_large_buf_alloc_rings_cnt offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_slot_ctxs_cnt) == 0x40, "ks_nexus_adapter.na_slot_ctxs_cnt offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_scratch_cnt) == 0x44, "ks_nexus_adapter.na_scratch_cnt offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_all_rings_cnt) == 0x48, "ks_nexus_adapter.na_all_rings_cnt offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_work_ts) == 0x50, "ks_nexus_adapter.na_work_ts offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_tx_rings) == 0x58, "ks_nexus_adapter.na_tx_rings offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_rx_rings) == 0x60, "ks_nexus_adapter.na_rx_rings offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_all_rings) == 0x68, "ks_nexus_adapter.na_all_rings offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_nx) == 0x70, "ks_nexus_adapter.na_nx offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_refcount) == 0x78, "ks_nexus_adapter.na_refcount offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_si_users) == 0x7C, "ks_nexus_adapter.na_si_users offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_si) == 0x98, "ks_nexus_adapter.na_si offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_arena) == 0x308, "ks_nexus_adapter.na_arena offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_num_tx_slots) == 0x310, "ks_nexus_adapter.na_num_tx_slots offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_num_rx_slots) == 0x314, "ks_nexus_adapter.na_num_rx_slots offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_num_allocator_slots) == 0x318, "ks_nexus_adapter.na_num_allocator_slots offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_num_event_slots) == 0x31C, "ks_nexus_adapter.na_num_event_slots offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_num_large_buf_alloc_slots) == 0x320, "ks_nexus_adapter.na_num_large_buf_alloc_slots offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_total_slots) == 0x324, "ks_nexus_adapter.na_total_slots offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_flowadv_max) == 0x328, "ks_nexus_adapter.na_flowadv_max offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_stats_type) == 0x32C, "ks_nexus_adapter.na_stats_type offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_alloc_rings) == 0x330, "ks_nexus_adapter.na_alloc_rings offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_free_rings) == 0x338, "ks_nexus_adapter.na_free_rings offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_event_rings) == 0x340, "ks_nexus_adapter.na_event_rings offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_large_buf_alloc_rings) == 0x348, "ks_nexus_adapter.na_large_buf_alloc_rings offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_ch_mit_ival) == 0x350, "ks_nexus_adapter.na_ch_mit_ival offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_nxdom_prov) == 0x358, "ks_nexus_adapter.na_nxdom_prov offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_slot_ctxs) == 0x360, "ks_nexus_adapter.na_slot_ctxs offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_scratch) == 0x368, "ks_nexus_adapter.na_scratch offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_tail) == 0x370, "ks_nexus_adapter.na_tail offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_private) == 0x378, "ks_nexus_adapter.na_private offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_ifp) == 0x380, "ks_nexus_adapter.na_ifp offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_kring_svc_lut) == 0x388, "ks_nexus_adapter.na_kring_svc_lut offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_next_pipe) == 0x394, "ks_nexus_adapter.na_next_pipe offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_max_pipes) == 0x398, "ks_nexus_adapter.na_max_pipes offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_pipes) == 0x3A0, "ks_nexus_adapter.na_pipes offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_name) == 0x3A8, "ks_nexus_adapter.na_name offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_uuid) == 0x3E8, "ks_nexus_adapter.na_uuid offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_activate) == 0x3F8, "ks_nexus_adapter.na_activate offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_special) == 0x400, "ks_nexus_adapter.na_special offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_txsync) == 0x408, "ks_nexus_adapter.na_txsync offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_rxsync) == 0x410, "ks_nexus_adapter.na_rxsync offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_notify) == 0x418, "ks_nexus_adapter.na_notify offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_channel_event_notify) == 0x420, "ks_nexus_adapter.na_channel_event_notify offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_config) == 0x428, "ks_nexus_adapter.na_config offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_krings_create) == 0x430, "ks_nexus_adapter.na_krings_create offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_krings_delete) == 0x438, "ks_nexus_adapter.na_krings_delete offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_dtor) == 0x440, "ks_nexus_adapter.na_dtor offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_free) == 0x448, "ks_nexus_adapter.na_free offset");
_Static_assert(offsetof(struct ks_nexus_adapter, na_rx) == 0x450, "ks_nexus_adapter.na_rx offset");
_Static_assert(sizeof(struct ks_nexus_adapter) == 0x458, "ks_nexus_adapter size");

/* refs: 1 */
struct ks_nexus_ifnet_ops {
    void *ni_finalize;
    void *ni_reap;
    int *ni_dequeue;
    int *ni_get_len;
};
_Static_assert(offsetof(struct ks_nexus_ifnet_ops, ni_finalize) == 0x0, "ks_nexus_ifnet_ops.ni_finalize offset");
_Static_assert(offsetof(struct ks_nexus_ifnet_ops, ni_reap) == 0x8, "ks_nexus_ifnet_ops.ni_reap offset");
_Static_assert(offsetof(struct ks_nexus_ifnet_ops, ni_dequeue) == 0x10, "ks_nexus_ifnet_ops.ni_dequeue offset");
_Static_assert(offsetof(struct ks_nexus_ifnet_ops, ni_get_len) == 0x18, "ks_nexus_ifnet_ops.ni_get_len offset");
_Static_assert(sizeof(struct ks_nexus_ifnet_ops) == 0x20, "ks_nexus_ifnet_ops size");

/* refs: 1 */
struct ks_nexus_netif_adapter {
    struct ks_nexus_adapter nifna_up;
    struct ks_nx_netif *nifna_netif;
    struct ks_nx_netif_mit *nifna_tx_mit;
    struct ks_nx_netif_mit *nifna_rx_mit;
    union {
        struct ks_netif_filter *nifna_filter;
        struct ks_netif_flow *nifna_flow;
    };
    unsigned short nifna_gencnt;
    unsigned int nifna_tx_mit_count;
    unsigned int nifna_rx_mit_count;
};
_Static_assert(offsetof(struct ks_nexus_netif_adapter, nifna_up) == 0x0, "ks_nexus_netif_adapter.nifna_up offset");
_Static_assert(offsetof(struct ks_nexus_netif_adapter, nifna_netif) == 0x458, "ks_nexus_netif_adapter.nifna_netif offset");
_Static_assert(offsetof(struct ks_nexus_netif_adapter, nifna_tx_mit) == 0x460, "ks_nexus_netif_adapter.nifna_tx_mit offset");
_Static_assert(offsetof(struct ks_nexus_netif_adapter, nifna_rx_mit) == 0x468, "ks_nexus_netif_adapter.nifna_rx_mit offset");
_Static_assert(offsetof(struct ks_nexus_netif_adapter, nifna_gencnt) == 0x478, "ks_nexus_netif_adapter.nifna_gencnt offset");
_Static_assert(offsetof(struct ks_nexus_netif_adapter, nifna_tx_mit_count) == 0x47C, "ks_nexus_netif_adapter.nifna_tx_mit_count offset");
_Static_assert(offsetof(struct ks_nexus_netif_adapter, nifna_rx_mit_count) == 0x480, "ks_nexus_netif_adapter.nifna_rx_mit_count offset");
_Static_assert(sizeof(struct ks_nexus_netif_adapter) == 0x488, "ks_nexus_netif_adapter size");

/* refs: 2 */
struct ks_nexus_upipe_adapter {
    struct ks_nexus_adapter pna_up;
    unsigned int pna_id;
    unsigned int pna_role;
    struct ks_nexus_adapter *pna_parent;
    struct ks_nexus_upipe_adapter *pna_peer;
    int pna_peer_ref;
    unsigned int pna_parent_slot;
};
_Static_assert(offsetof(struct ks_nexus_upipe_adapter, pna_up) == 0x0, "ks_nexus_upipe_adapter.pna_up offset");
_Static_assert(offsetof(struct ks_nexus_upipe_adapter, pna_id) == 0x458, "ks_nexus_upipe_adapter.pna_id offset");
_Static_assert(offsetof(struct ks_nexus_upipe_adapter, pna_role) == 0x45C, "ks_nexus_upipe_adapter.pna_role offset");
_Static_assert(offsetof(struct ks_nexus_upipe_adapter, pna_parent) == 0x460, "ks_nexus_upipe_adapter.pna_parent offset");
_Static_assert(offsetof(struct ks_nexus_upipe_adapter, pna_peer) == 0x468, "ks_nexus_upipe_adapter.pna_peer offset");
_Static_assert(offsetof(struct ks_nexus_upipe_adapter, pna_peer_ref) == 0x470, "ks_nexus_upipe_adapter.pna_peer_ref offset");
_Static_assert(offsetof(struct ks_nexus_upipe_adapter, pna_parent_slot) == 0x474, "ks_nexus_upipe_adapter.pna_parent_slot offset");
_Static_assert(sizeof(struct ks_nexus_upipe_adapter) == 0x478, "ks_nexus_upipe_adapter size");

/* refs: 1 */
struct ks_ns_flow_info {
    unsigned char nfi_flow_uuid[0x10] __attribute__((aligned(8)));
    struct ks_ifnet *nfi_ifp;
    union ks_sockaddr_in_4_6 nfi_laddr;
    union ks_sockaddr_in_4_6 nfi_faddr;
    unsigned char nfi_protocol;
    unsigned char nfi_pad[3];
    int nfi_owner_pid;
    int nfi_effective_pid;
    char nfi_owner_name[0x11];
    char nfi_effective_name[0x11];
};
_Static_assert(offsetof(struct ks_ns_flow_info, nfi_flow_uuid) == 0x0, "ks_ns_flow_info.nfi_flow_uuid offset");
_Static_assert(offsetof(struct ks_ns_flow_info, nfi_ifp) == 0x10, "ks_ns_flow_info.nfi_ifp offset");
_Static_assert(offsetof(struct ks_ns_flow_info, nfi_laddr) == 0x18, "ks_ns_flow_info.nfi_laddr offset");
_Static_assert(offsetof(struct ks_ns_flow_info, nfi_faddr) == 0x34, "ks_ns_flow_info.nfi_faddr offset");
_Static_assert(offsetof(struct ks_ns_flow_info, nfi_protocol) == 0x50, "ks_ns_flow_info.nfi_protocol offset");
_Static_assert(offsetof(struct ks_ns_flow_info, nfi_pad) == 0x51, "ks_ns_flow_info.nfi_pad offset");
_Static_assert(offsetof(struct ks_ns_flow_info, nfi_owner_pid) == 0x54, "ks_ns_flow_info.nfi_owner_pid offset");
_Static_assert(offsetof(struct ks_ns_flow_info, nfi_effective_pid) == 0x58, "ks_ns_flow_info.nfi_effective_pid offset");
_Static_assert(offsetof(struct ks_ns_flow_info, nfi_owner_name) == 0x5C, "ks_ns_flow_info.nfi_owner_name offset");
_Static_assert(offsetof(struct ks_ns_flow_info, nfi_effective_name) == 0x6D, "ks_ns_flow_info.nfi_effective_name offset");
_Static_assert(sizeof(struct ks_ns_flow_info) == 0x80, "ks_ns_flow_info size");

/* refs: 5 */
struct ks_ns_token {
    struct ks_ifnet *nt_ifp;
    struct {
        struct ks_ns_token *le_next;
        struct ks_ns_token **le_prev;
    } nt_ifp_link;
    struct {
        struct ks_ns_token *le_next;
        struct ks_ns_token **le_prev;
    } nt_all_link;
    unsigned int nt_state;
    union {
        unsigned int nt_addr[4];
        struct ks_in_addr nt_inaddr;
        struct ks_in6_addr nt_in6addr;
    };
    unsigned char nt_addr_len;
    unsigned char nt_proto;
    unsigned short nt_port;
    unsigned int nt_flags;
    struct ks_ns_flow_info *nt_flow_info;
};
_Static_assert(offsetof(struct ks_ns_token, nt_ifp) == 0x0, "ks_ns_token.nt_ifp offset");
_Static_assert(offsetof(struct ks_ns_token, nt_ifp_link) == 0x8, "ks_ns_token.nt_ifp_link offset");
_Static_assert(offsetof(struct ks_ns_token, nt_all_link) == 0x18, "ks_ns_token.nt_all_link offset");
_Static_assert(offsetof(struct ks_ns_token, nt_state) == 0x28, "ks_ns_token.nt_state offset");
_Static_assert(offsetof(struct ks_ns_token, nt_addr_len) == 0x3C, "ks_ns_token.nt_addr_len offset");
_Static_assert(offsetof(struct ks_ns_token, nt_proto) == 0x3D, "ks_ns_token.nt_proto offset");
_Static_assert(offsetof(struct ks_ns_token, nt_port) == 0x3E, "ks_ns_token.nt_port offset");
_Static_assert(offsetof(struct ks_ns_token, nt_flags) == 0x40, "ks_ns_token.nt_flags offset");
_Static_assert(offsetof(struct ks_ns_token, nt_flow_info) == 0x48, "ks_ns_token.nt_flow_info offset");
_Static_assert(sizeof(struct ks_ns_token) == 0x50, "ks_ns_token size");

/* refs: 1 */
struct ks_nstat_counts {
    unsigned long long nstat_rxpackets __attribute__((aligned(8)));
    unsigned long long nstat_rxbytes __attribute__((aligned(8)));
    unsigned long long nstat_txpackets __attribute__((aligned(8)));
    unsigned long long nstat_txbytes __attribute__((aligned(8)));
    unsigned long long nstat_cell_rxbytes __attribute__((aligned(8)));
    unsigned long long nstat_cell_txbytes __attribute__((aligned(8)));
    unsigned long long nstat_wifi_rxbytes __attribute__((aligned(8)));
    unsigned long long nstat_wifi_txbytes __attribute__((aligned(8)));
    unsigned long long nstat_wired_rxbytes __attribute__((aligned(8)));
    unsigned long long nstat_wired_txbytes __attribute__((aligned(8)));
    unsigned int nstat_rxduplicatebytes;
    unsigned int nstat_rxoutoforderbytes;
    unsigned int nstat_txretransmit;
    unsigned int nstat_connectattempts;
    unsigned int nstat_connectsuccesses;
    unsigned int nstat_min_rtt;
    unsigned int nstat_avg_rtt;
    unsigned int nstat_var_rtt;
};
_Static_assert(offsetof(struct ks_nstat_counts, nstat_rxpackets) == 0x0, "ks_nstat_counts.nstat_rxpackets offset");
_Static_assert(offsetof(struct ks_nstat_counts, nstat_rxbytes) == 0x8, "ks_nstat_counts.nstat_rxbytes offset");
_Static_assert(offsetof(struct ks_nstat_counts, nstat_txpackets) == 0x10, "ks_nstat_counts.nstat_txpackets offset");
_Static_assert(offsetof(struct ks_nstat_counts, nstat_txbytes) == 0x18, "ks_nstat_counts.nstat_txbytes offset");
_Static_assert(offsetof(struct ks_nstat_counts, nstat_cell_rxbytes) == 0x20, "ks_nstat_counts.nstat_cell_rxbytes offset");
_Static_assert(offsetof(struct ks_nstat_counts, nstat_cell_txbytes) == 0x28, "ks_nstat_counts.nstat_cell_txbytes offset");
_Static_assert(offsetof(struct ks_nstat_counts, nstat_wifi_rxbytes) == 0x30, "ks_nstat_counts.nstat_wifi_rxbytes offset");
_Static_assert(offsetof(struct ks_nstat_counts, nstat_wifi_txbytes) == 0x38, "ks_nstat_counts.nstat_wifi_txbytes offset");
_Static_assert(offsetof(struct ks_nstat_counts, nstat_wired_rxbytes) == 0x40, "ks_nstat_counts.nstat_wired_rxbytes offset");
_Static_assert(offsetof(struct ks_nstat_counts, nstat_wired_txbytes) == 0x48, "ks_nstat_counts.nstat_wired_txbytes offset");
_Static_assert(offsetof(struct ks_nstat_counts, nstat_rxduplicatebytes) == 0x50, "ks_nstat_counts.nstat_rxduplicatebytes offset");
_Static_assert(offsetof(struct ks_nstat_counts, nstat_rxoutoforderbytes) == 0x54, "ks_nstat_counts.nstat_rxoutoforderbytes offset");
_Static_assert(offsetof(struct ks_nstat_counts, nstat_txretransmit) == 0x58, "ks_nstat_counts.nstat_txretransmit offset");
_Static_assert(offsetof(struct ks_nstat_counts, nstat_connectattempts) == 0x5C, "ks_nstat_counts.nstat_connectattempts offset");
_Static_assert(offsetof(struct ks_nstat_counts, nstat_connectsuccesses) == 0x60, "ks_nstat_counts.nstat_connectsuccesses offset");
_Static_assert(offsetof(struct ks_nstat_counts, nstat_min_rtt) == 0x64, "ks_nstat_counts.nstat_min_rtt offset");
_Static_assert(offsetof(struct ks_nstat_counts, nstat_avg_rtt) == 0x68, "ks_nstat_counts.nstat_avg_rtt offset");
_Static_assert(offsetof(struct ks_nstat_counts, nstat_var_rtt) == 0x6C, "ks_nstat_counts.nstat_var_rtt offset");
_Static_assert(sizeof(struct ks_nstat_counts) == 0x70, "ks_nstat_counts size");

/* refs: 1 */
struct ks_skoid {
    struct ks_sysctl_oid_list sko_oid_list;
    struct ks_sysctl_oid sko_oid;
    char sko_name[0x20];
};
_Static_assert(offsetof(struct ks_skoid, sko_oid_list) == 0x0, "ks_skoid.sko_oid_list offset");
_Static_assert(offsetof(struct ks_skoid, sko_oid) == 0x8, "ks_skoid.sko_oid offset");
_Static_assert(offsetof(struct ks_skoid, sko_name) == 0x58, "ks_skoid.sko_name offset");
_Static_assert(sizeof(struct ks_skoid) == 0x78, "ks_skoid size");

/* refs: 1 */
struct ks_nx_flowswitch {
    struct ks_lck_rw_s fsw_lock;
    unsigned int fsw_tx_rings;
    unsigned int fsw_rx_rings;
    struct ks_kern_nexus *fsw_nx;
    unsigned int fsw_classq_enq_ptype;
    int fsw_classq_enabled;
    void *fsw_pkt_copy_from_pkt;
    void *fsw_pkt_copy_from_mbuf;
    void *fsw_pkt_copy_to_mbuf;
    unsigned char fsw_frame_headroom;
    unsigned int fsw_src_lla_gencnt;
    unsigned int fsw_pending_nonviable;
    unsigned int fsw_low_power_gencnt;
    struct ks_flow_mgr *fsw_flow_mgr;
    void *fsw_agent_session;
    unsigned char fsw_agent_uuid[0x10];
    struct ks_ifnet *fsw_ifp;
    struct ks_nexus_adapter *fsw_nifna;
    unsigned int fsw_state_flags;
    union {
        unsigned long long _buf[1];
        unsigned char _eth_src[6];
    } __fsw_slladdr __attribute__((aligned(8)));
    int *fsw_resolve;
    void *fsw_frame;
    unsigned char *fsw_demux;
    struct ks_fsw_stats fsw_stats __attribute__((aligned(16)));
    struct ks_lck_mtx_s fsw_detach_barrier_lock;
    unsigned int fsw_detach_flags;
    unsigned int fsw_detach_barriers;
    unsigned int fsw_detach_waiters;
    unsigned int fsw_ifp_dlt;
    unsigned int fsw_rx_largest_size;
    void *fsw_ctor;
    struct ks___nx_stats_fsw *fsw_closed_na_stats;
    struct ks_fsw_ip_frag_mgr *fsw_ipfm;
    struct ks_skoid fsw_skoid;
    struct ks_netem *fsw_input_netem;
    struct ks_kern_channel *fsw_dev_ch;
    struct ks_kern_channel *fsw_host_ch;
    struct ks_lck_mtx_s fsw_reap_lock;
    unsigned int fsw_reap_flags;
    unsigned int fsw_reap_requests;
    struct ks_thread *fsw_reap_thread;
    char fsw_reap_name[0x40];
    unsigned long long fsw_reap_last;
    unsigned long long fsw_drain_channel_chk_last;
    unsigned long long fsw_drain_netif_chk_last;
    unsigned long long fsw_rx_stall_chk_last;
    struct ks_lck_mtx_s fsw_linger_lock;
    struct ks_flow_entry_linger_head fsw_linger_head;
    unsigned int fsw_linger_cnt;
    unsigned int fsw_tso_mode;
    unsigned int fsw_tso_sw_mtu;
    unsigned int fsw_tso_hw_v4_mtu;
    unsigned int fsw_tso_hw_v6_mtu;
    struct ks_lck_mtx_s fsw_rxstrc_lock;
    struct ks_flow_entry_rxstrc_head fsw_rxstrc_head;
    unsigned int fsw_rxstrc_cnt;
};
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_lock) == 0x0, "ks_nx_flowswitch.fsw_lock offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_tx_rings) == 0x10, "ks_nx_flowswitch.fsw_tx_rings offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_rx_rings) == 0x14, "ks_nx_flowswitch.fsw_rx_rings offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_nx) == 0x18, "ks_nx_flowswitch.fsw_nx offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_classq_enq_ptype) == 0x20, "ks_nx_flowswitch.fsw_classq_enq_ptype offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_classq_enabled) == 0x24, "ks_nx_flowswitch.fsw_classq_enabled offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_pkt_copy_from_pkt) == 0x28, "ks_nx_flowswitch.fsw_pkt_copy_from_pkt offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_pkt_copy_from_mbuf) == 0x30, "ks_nx_flowswitch.fsw_pkt_copy_from_mbuf offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_pkt_copy_to_mbuf) == 0x38, "ks_nx_flowswitch.fsw_pkt_copy_to_mbuf offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_frame_headroom) == 0x40, "ks_nx_flowswitch.fsw_frame_headroom offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_src_lla_gencnt) == 0x44, "ks_nx_flowswitch.fsw_src_lla_gencnt offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_pending_nonviable) == 0x48, "ks_nx_flowswitch.fsw_pending_nonviable offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_low_power_gencnt) == 0x4C, "ks_nx_flowswitch.fsw_low_power_gencnt offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_flow_mgr) == 0x50, "ks_nx_flowswitch.fsw_flow_mgr offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_agent_session) == 0x58, "ks_nx_flowswitch.fsw_agent_session offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_agent_uuid) == 0x60, "ks_nx_flowswitch.fsw_agent_uuid offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_ifp) == 0x70, "ks_nx_flowswitch.fsw_ifp offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_nifna) == 0x78, "ks_nx_flowswitch.fsw_nifna offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_state_flags) == 0x80, "ks_nx_flowswitch.fsw_state_flags offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, __fsw_slladdr) == 0x88, "ks_nx_flowswitch.__fsw_slladdr offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_resolve) == 0x90, "ks_nx_flowswitch.fsw_resolve offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_frame) == 0x98, "ks_nx_flowswitch.fsw_frame offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_demux) == 0xA0, "ks_nx_flowswitch.fsw_demux offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_stats) == 0xB0, "ks_nx_flowswitch.fsw_stats offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_detach_barrier_lock) == 0x4A0, "ks_nx_flowswitch.fsw_detach_barrier_lock offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_detach_flags) == 0x4B0, "ks_nx_flowswitch.fsw_detach_flags offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_detach_barriers) == 0x4B4, "ks_nx_flowswitch.fsw_detach_barriers offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_detach_waiters) == 0x4B8, "ks_nx_flowswitch.fsw_detach_waiters offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_ifp_dlt) == 0x4BC, "ks_nx_flowswitch.fsw_ifp_dlt offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_rx_largest_size) == 0x4C0, "ks_nx_flowswitch.fsw_rx_largest_size offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_ctor) == 0x4C8, "ks_nx_flowswitch.fsw_ctor offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_closed_na_stats) == 0x4D0, "ks_nx_flowswitch.fsw_closed_na_stats offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_ipfm) == 0x4D8, "ks_nx_flowswitch.fsw_ipfm offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_skoid) == 0x4E0, "ks_nx_flowswitch.fsw_skoid offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_input_netem) == 0x558, "ks_nx_flowswitch.fsw_input_netem offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_dev_ch) == 0x560, "ks_nx_flowswitch.fsw_dev_ch offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_host_ch) == 0x568, "ks_nx_flowswitch.fsw_host_ch offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_reap_lock) == 0x570, "ks_nx_flowswitch.fsw_reap_lock offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_reap_flags) == 0x580, "ks_nx_flowswitch.fsw_reap_flags offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_reap_requests) == 0x584, "ks_nx_flowswitch.fsw_reap_requests offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_reap_thread) == 0x588, "ks_nx_flowswitch.fsw_reap_thread offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_reap_name) == 0x590, "ks_nx_flowswitch.fsw_reap_name offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_reap_last) == 0x5D0, "ks_nx_flowswitch.fsw_reap_last offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_drain_channel_chk_last) == 0x5D8, "ks_nx_flowswitch.fsw_drain_channel_chk_last offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_drain_netif_chk_last) == 0x5E0, "ks_nx_flowswitch.fsw_drain_netif_chk_last offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_rx_stall_chk_last) == 0x5E8, "ks_nx_flowswitch.fsw_rx_stall_chk_last offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_linger_lock) == 0x5F0, "ks_nx_flowswitch.fsw_linger_lock offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_linger_head) == 0x600, "ks_nx_flowswitch.fsw_linger_head offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_linger_cnt) == 0x610, "ks_nx_flowswitch.fsw_linger_cnt offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_tso_mode) == 0x614, "ks_nx_flowswitch.fsw_tso_mode offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_tso_sw_mtu) == 0x618, "ks_nx_flowswitch.fsw_tso_sw_mtu offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_tso_hw_v4_mtu) == 0x61C, "ks_nx_flowswitch.fsw_tso_hw_v4_mtu offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_tso_hw_v6_mtu) == 0x620, "ks_nx_flowswitch.fsw_tso_hw_v6_mtu offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_rxstrc_lock) == 0x628, "ks_nx_flowswitch.fsw_rxstrc_lock offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_rxstrc_head) == 0x638, "ks_nx_flowswitch.fsw_rxstrc_head offset");
_Static_assert(offsetof(struct ks_nx_flowswitch, fsw_rxstrc_cnt) == 0x648, "ks_nx_flowswitch.fsw_rxstrc_cnt offset");
_Static_assert(sizeof(struct ks_nx_flowswitch) == 0x650, "ks_nx_flowswitch size");

/* refs: 1 */
struct ks_nx_pktq {
    struct ks_lck_mtx_s nx_pktq_lock;
    struct ks__class_queue_ nx_pktq_q;
    struct ks__lck_grp_ *nx_pktq_grp;
    struct ks___kern_channel_ring *nx_pktq_kring;
};
_Static_assert(offsetof(struct ks_nx_pktq, nx_pktq_lock) == 0x0, "ks_nx_pktq.nx_pktq_lock offset");
_Static_assert(offsetof(struct ks_nx_pktq, nx_pktq_q) == 0x10, "ks_nx_pktq.nx_pktq_q offset");
_Static_assert(offsetof(struct ks_nx_pktq, nx_pktq_grp) == 0x48, "ks_nx_pktq.nx_pktq_grp offset");
_Static_assert(offsetof(struct ks_nx_pktq, nx_pktq_kring) == 0x50, "ks_nx_pktq.nx_pktq_kring offset");
_Static_assert(sizeof(struct ks_nx_pktq) == 0x58, "ks_nx_pktq size");

/* refs: 2 */
struct ks_nx_netif {
    struct ks_lck_rw_s nif_lock;
    struct ks_kern_nexus *nif_nx;
    struct ks_nxbind *nif_dev_nxb;
    struct ks_nxbind *nif_host_nxb;
    unsigned char nif_uuid[0x10];
    struct ks_netif_stats nif_stats __attribute__((aligned(16)));
    unsigned int nif_flags;
    struct ks_os_refcnt nif_refcnt;
    struct ks_lck_mtx_s nif_agent_lock;
    struct ks_netif_agent_flow_head nif_agent_flow_list;
    unsigned int nif_agent_flow_cnt;
    unsigned int nif_agent_flags;
    void *nif_agent_session;
    unsigned char nif_agent_uuid[0x10];
    unsigned int nif_hwassist;
    unsigned int nif_capabilities;
    unsigned int nif_capenable;
    unsigned long long nif_input_rate;
    struct ks_ifnet *nif_ifp;
    struct ks_nx_flowswitch *nif_fsw;
    struct ks_sk_nexusadv *nif_fsw_nxadv;
    struct ks_netif_nexus_advisory *nif_netif_nxadv;
    void *nif_pkt_copy_from_mbuf;
    void *nif_pkt_copy_to_mbuf;
    void *nif_pkt_copy_from_pkt;
    struct ks_lck_mtx_s nif_filter_lock;
    unsigned int nif_filter_flags;
    unsigned int nif_filter_vp_cnt;
    unsigned int nif_filter_cnt;
    struct ks_kern_pbufpool *nif_filter_pp;
    struct ks_netif_filter_head nif_filter_list;
    union {
        struct ks_nx_mbq nif_tx_processed_mbq[4];
        struct ks_nx_pktq nif_tx_processed_pktq[4];
    };
    struct ks_lck_mtx_s nif_flow_lock;
    unsigned int nif_vp_cnt;
    unsigned int nif_flow_flags;
    unsigned int nif_flow_cnt;
    struct ks_netif_flow_head nif_flow_list;
    struct ks_netif_flowtable *nif_flow_table;
    struct ks_kern_channel *nif_hw_ch;
    unsigned int nif_hw_ch_refcnt;
    struct ks_lck_rw_s nif_llink_lock __attribute__((aligned(8)));
    struct ks_kern_nexus_netif_llink_init *nif_default_llink_params;
    struct ks_netif_llink *nif_default_llink;
    struct {
        struct ks_netif_llink *stqh_first;
        struct ks_netif_llink **stqh_last;
    } nif_llink_list;
    unsigned short nif_llink_cnt;
    unsigned int nif_extended_capabilities;
    int *nif_intf_adv_config;
    void *nif_intf_adv_prov_ctx;
    struct ks_netif_qset_extensions nif_qset_extensions;
    struct ks_netif_rx_flow_steering nif_rx_flow_steering;
};
_Static_assert(offsetof(struct ks_nx_netif, nif_lock) == 0x0, "ks_nx_netif.nif_lock offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_nx) == 0x10, "ks_nx_netif.nif_nx offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_dev_nxb) == 0x18, "ks_nx_netif.nif_dev_nxb offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_host_nxb) == 0x20, "ks_nx_netif.nif_host_nxb offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_uuid) == 0x28, "ks_nx_netif.nif_uuid offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_stats) == 0x40, "ks_nx_netif.nif_stats offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_flags) == 0x480, "ks_nx_netif.nif_flags offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_refcnt) == 0x484, "ks_nx_netif.nif_refcnt offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_agent_lock) == 0x488, "ks_nx_netif.nif_agent_lock offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_agent_flow_list) == 0x498, "ks_nx_netif.nif_agent_flow_list offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_agent_flow_cnt) == 0x4A0, "ks_nx_netif.nif_agent_flow_cnt offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_agent_flags) == 0x4A4, "ks_nx_netif.nif_agent_flags offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_agent_session) == 0x4A8, "ks_nx_netif.nif_agent_session offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_agent_uuid) == 0x4B0, "ks_nx_netif.nif_agent_uuid offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_hwassist) == 0x4C0, "ks_nx_netif.nif_hwassist offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_capabilities) == 0x4C4, "ks_nx_netif.nif_capabilities offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_capenable) == 0x4C8, "ks_nx_netif.nif_capenable offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_input_rate) == 0x4D0, "ks_nx_netif.nif_input_rate offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_ifp) == 0x4D8, "ks_nx_netif.nif_ifp offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_fsw) == 0x4E0, "ks_nx_netif.nif_fsw offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_fsw_nxadv) == 0x4E8, "ks_nx_netif.nif_fsw_nxadv offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_netif_nxadv) == 0x4F0, "ks_nx_netif.nif_netif_nxadv offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_pkt_copy_from_mbuf) == 0x4F8, "ks_nx_netif.nif_pkt_copy_from_mbuf offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_pkt_copy_to_mbuf) == 0x500, "ks_nx_netif.nif_pkt_copy_to_mbuf offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_pkt_copy_from_pkt) == 0x508, "ks_nx_netif.nif_pkt_copy_from_pkt offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_filter_lock) == 0x510, "ks_nx_netif.nif_filter_lock offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_filter_flags) == 0x520, "ks_nx_netif.nif_filter_flags offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_filter_vp_cnt) == 0x524, "ks_nx_netif.nif_filter_vp_cnt offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_filter_cnt) == 0x528, "ks_nx_netif.nif_filter_cnt offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_filter_pp) == 0x530, "ks_nx_netif.nif_filter_pp offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_filter_list) == 0x538, "ks_nx_netif.nif_filter_list offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_flow_lock) == 0x6A8, "ks_nx_netif.nif_flow_lock offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_vp_cnt) == 0x6B8, "ks_nx_netif.nif_vp_cnt offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_flow_flags) == 0x6BC, "ks_nx_netif.nif_flow_flags offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_flow_cnt) == 0x6C0, "ks_nx_netif.nif_flow_cnt offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_flow_list) == 0x6C8, "ks_nx_netif.nif_flow_list offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_flow_table) == 0x6D0, "ks_nx_netif.nif_flow_table offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_hw_ch) == 0x6D8, "ks_nx_netif.nif_hw_ch offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_hw_ch_refcnt) == 0x6E0, "ks_nx_netif.nif_hw_ch_refcnt offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_llink_lock) == 0x6E8, "ks_nx_netif.nif_llink_lock offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_default_llink_params) == 0x6F8, "ks_nx_netif.nif_default_llink_params offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_default_llink) == 0x700, "ks_nx_netif.nif_default_llink offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_llink_list) == 0x708, "ks_nx_netif.nif_llink_list offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_llink_cnt) == 0x718, "ks_nx_netif.nif_llink_cnt offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_extended_capabilities) == 0x71C, "ks_nx_netif.nif_extended_capabilities offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_intf_adv_config) == 0x720, "ks_nx_netif.nif_intf_adv_config offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_intf_adv_prov_ctx) == 0x728, "ks_nx_netif.nif_intf_adv_prov_ctx offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_qset_extensions) == 0x730, "ks_nx_netif.nif_qset_extensions offset");
_Static_assert(offsetof(struct ks_nx_netif, nif_rx_flow_steering) == 0x740, "ks_nx_netif.nif_rx_flow_steering offset");
_Static_assert(sizeof(struct ks_nx_netif) == 0x750, "ks_nx_netif size");

/* refs: 5 */
struct ks_nx_netif_mit {
    struct ks_lck_spin_s mit_lock;
    volatile struct ks___kern_channel_ring *mit_ckr;
    unsigned int mit_flags;
    unsigned int mit_requests;
    unsigned int mit_interval;
    unsigned int mit_cfg_idx_max;
    unsigned int mit_cfg_idx;
    const struct ks_mit_cfg_tbl *mit_cfg;
    unsigned int mit_mode;
    unsigned int mit_packets_avg;
    unsigned int mit_packets_min;
    unsigned int mit_packets_max;
    unsigned int mit_bytes_avg;
    unsigned int mit_bytes_min;
    unsigned int mit_bytes_max;
    struct ks_pktcntr mit_sstats;
    struct ks_timespec mit_mode_holdtime;
    struct ks_timespec mit_mode_lasttime;
    struct ks_timespec mit_sample_time;
    struct ks_timespec mit_sample_lasttime;
    struct ks_timespec mit_start_time;
    struct ks_thread *mit_thread;
    char mit_name[0x40];
    const struct ks_ifnet *mit_netif_ifp;
    struct ks_mit_cfg_tbl mit_tbl[5];
};
_Static_assert(offsetof(struct ks_nx_netif_mit, mit_lock) == 0x0, "ks_nx_netif_mit.mit_lock offset");
_Static_assert(offsetof(struct ks_nx_netif_mit, mit_ckr) == 0x10, "ks_nx_netif_mit.mit_ckr offset");
_Static_assert(offsetof(struct ks_nx_netif_mit, mit_flags) == 0x18, "ks_nx_netif_mit.mit_flags offset");
_Static_assert(offsetof(struct ks_nx_netif_mit, mit_requests) == 0x1C, "ks_nx_netif_mit.mit_requests offset");
_Static_assert(offsetof(struct ks_nx_netif_mit, mit_interval) == 0x20, "ks_nx_netif_mit.mit_interval offset");
_Static_assert(offsetof(struct ks_nx_netif_mit, mit_cfg_idx_max) == 0x24, "ks_nx_netif_mit.mit_cfg_idx_max offset");
_Static_assert(offsetof(struct ks_nx_netif_mit, mit_cfg_idx) == 0x28, "ks_nx_netif_mit.mit_cfg_idx offset");
_Static_assert(offsetof(struct ks_nx_netif_mit, mit_cfg) == 0x30, "ks_nx_netif_mit.mit_cfg offset");
_Static_assert(offsetof(struct ks_nx_netif_mit, mit_mode) == 0x38, "ks_nx_netif_mit.mit_mode offset");
_Static_assert(offsetof(struct ks_nx_netif_mit, mit_packets_avg) == 0x3C, "ks_nx_netif_mit.mit_packets_avg offset");
_Static_assert(offsetof(struct ks_nx_netif_mit, mit_packets_min) == 0x40, "ks_nx_netif_mit.mit_packets_min offset");
_Static_assert(offsetof(struct ks_nx_netif_mit, mit_packets_max) == 0x44, "ks_nx_netif_mit.mit_packets_max offset");
_Static_assert(offsetof(struct ks_nx_netif_mit, mit_bytes_avg) == 0x48, "ks_nx_netif_mit.mit_bytes_avg offset");
_Static_assert(offsetof(struct ks_nx_netif_mit, mit_bytes_min) == 0x4C, "ks_nx_netif_mit.mit_bytes_min offset");
_Static_assert(offsetof(struct ks_nx_netif_mit, mit_bytes_max) == 0x50, "ks_nx_netif_mit.mit_bytes_max offset");
_Static_assert(offsetof(struct ks_nx_netif_mit, mit_sstats) == 0x58, "ks_nx_netif_mit.mit_sstats offset");
_Static_assert(offsetof(struct ks_nx_netif_mit, mit_mode_holdtime) == 0x68, "ks_nx_netif_mit.mit_mode_holdtime offset");
_Static_assert(offsetof(struct ks_nx_netif_mit, mit_mode_lasttime) == 0x78, "ks_nx_netif_mit.mit_mode_lasttime offset");
_Static_assert(offsetof(struct ks_nx_netif_mit, mit_sample_time) == 0x88, "ks_nx_netif_mit.mit_sample_time offset");
_Static_assert(offsetof(struct ks_nx_netif_mit, mit_sample_lasttime) == 0x98, "ks_nx_netif_mit.mit_sample_lasttime offset");
_Static_assert(offsetof(struct ks_nx_netif_mit, mit_start_time) == 0xA8, "ks_nx_netif_mit.mit_start_time offset");
_Static_assert(offsetof(struct ks_nx_netif_mit, mit_thread) == 0xB8, "ks_nx_netif_mit.mit_thread offset");
_Static_assert(offsetof(struct ks_nx_netif_mit, mit_name) == 0xC0, "ks_nx_netif_mit.mit_name offset");
_Static_assert(offsetof(struct ks_nx_netif_mit, mit_netif_ifp) == 0x100, "ks_nx_netif_mit.mit_netif_ifp offset");
_Static_assert(offsetof(struct ks_nx_netif_mit, mit_tbl) == 0x108, "ks_nx_netif_mit.mit_tbl offset");
_Static_assert(sizeof(struct ks_nx_netif_mit) == 0x170, "ks_nx_netif_mit size");

/* refs: 2 */
struct ks_nx_port_info {
    unsigned long npi_nah;
    struct ks_nxbind *npi_nxb;
    void *npi_info;
};
_Static_assert(offsetof(struct ks_nx_port_info, npi_nah) == 0x0, "ks_nx_port_info.npi_nah offset");
_Static_assert(offsetof(struct ks_nx_port_info, npi_nxb) == 0x8, "ks_nx_port_info.npi_nxb offset");
_Static_assert(offsetof(struct ks_nx_port_info, npi_info) == 0x10, "ks_nx_port_info.npi_info offset");
_Static_assert(sizeof(struct ks_nx_port_info) == 0x18, "ks_nx_port_info size");

/* refs: 3 */
struct ks_nxbind {
    unsigned int nxb_flags;
    int nxb_pid;
    unsigned long long nxb_uniqueid;
    unsigned char nxb_exec_uuid[0x10];
    unsigned int nxb_key_len;
    void *nxb_key;
};
_Static_assert(offsetof(struct ks_nxbind, nxb_flags) == 0x0, "ks_nxbind.nxb_flags offset");
_Static_assert(offsetof(struct ks_nxbind, nxb_pid) == 0x4, "ks_nxbind.nxb_pid offset");
_Static_assert(offsetof(struct ks_nxbind, nxb_uniqueid) == 0x8, "ks_nxbind.nxb_uniqueid offset");
_Static_assert(offsetof(struct ks_nxbind, nxb_exec_uuid) == 0x10, "ks_nxbind.nxb_exec_uuid offset");
_Static_assert(offsetof(struct ks_nxbind, nxb_key_len) == 0x20, "ks_nxbind.nxb_key_len offset");
_Static_assert(offsetof(struct ks_nxbind, nxb_key) == 0x28, "ks_nxbind.nxb_key offset");
_Static_assert(sizeof(struct ks_nxbind) == 0x30, "ks_nxbind size");

/* refs: 17 */
struct ks_nxp_bounds {
    unsigned int nb_def;
    unsigned int nb_min;
    unsigned int nb_max;
};
_Static_assert(offsetof(struct ks_nxp_bounds, nb_def) == 0x0, "ks_nxp_bounds.nb_def offset");
_Static_assert(offsetof(struct ks_nxp_bounds, nb_min) == 0x4, "ks_nxp_bounds.nb_min offset");
_Static_assert(offsetof(struct ks_nxp_bounds, nb_max) == 0x8, "ks_nxp_bounds.nb_max offset");
_Static_assert(sizeof(struct ks_nxp_bounds) == 0xC, "ks_nxp_bounds size");

/* refs: 2 */
struct ks_nxdom {
    struct {
        struct ks_nxdom *stqe_next;
    } nxdom_link;
    struct {
        struct ks_kern_nexus_domain_provider *stqh_first;
        struct ks_kern_nexus_domain_provider **stqh_last;
    } nxdom_prov_head;
    int nxdom_type;
    unsigned int nxdom_md_type;
    unsigned int nxdom_md_subtype;
    unsigned int nxdom_flags;
    struct ks_nxp_bounds nxdom_ports;
    struct ks_nxp_bounds nxdom_tx_rings;
    struct ks_nxp_bounds nxdom_rx_rings;
    struct ks_nxp_bounds nxdom_tx_slots;
    struct ks_nxp_bounds nxdom_rx_slots;
    struct ks_nxp_bounds nxdom_buf_size;
    struct ks_nxp_bounds nxdom_large_buf_size;
    struct ks_nxp_bounds nxdom_meta_size;
    struct ks_nxp_bounds nxdom_stats_size;
    struct ks_nxp_bounds nxdom_pipes;
    struct ks_nxp_bounds nxdom_extensions;
    struct ks_nxp_bounds nxdom_mhints;
    struct ks_nxp_bounds nxdom_flowadv_max;
    struct ks_nxp_bounds nxdom_nexusadv_size;
    struct ks_nxp_bounds nxdom_capabilities;
    struct ks_nxp_bounds nxdom_qmap;
    struct ks_nxp_bounds nxdom_max_frags;
    struct ks_skmem_region_params nxdom_region_params[0x1C];
    const char *nxdom_name;
    void *nxdom_init;
    void *nxdom_terminate;
    void *nxdom_fini;
    int *nxdom_find_port;
    int *nxdom_port_is_reserved;
    int *nxdom_bind_port;
    int *nxdom_unbind_port;
    int *nxdom_connect;
    void *nxdom_disconnect;
    void *nxdom_defunct;
    void *nxdom_defunct_finalize;
};
_Static_assert(offsetof(struct ks_nxdom, nxdom_link) == 0x0, "ks_nxdom.nxdom_link offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_prov_head) == 0x8, "ks_nxdom.nxdom_prov_head offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_type) == 0x18, "ks_nxdom.nxdom_type offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_md_type) == 0x1C, "ks_nxdom.nxdom_md_type offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_md_subtype) == 0x20, "ks_nxdom.nxdom_md_subtype offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_flags) == 0x24, "ks_nxdom.nxdom_flags offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_ports) == 0x28, "ks_nxdom.nxdom_ports offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_tx_rings) == 0x34, "ks_nxdom.nxdom_tx_rings offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_rx_rings) == 0x40, "ks_nxdom.nxdom_rx_rings offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_tx_slots) == 0x4C, "ks_nxdom.nxdom_tx_slots offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_rx_slots) == 0x58, "ks_nxdom.nxdom_rx_slots offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_buf_size) == 0x64, "ks_nxdom.nxdom_buf_size offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_large_buf_size) == 0x70, "ks_nxdom.nxdom_large_buf_size offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_meta_size) == 0x7C, "ks_nxdom.nxdom_meta_size offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_stats_size) == 0x88, "ks_nxdom.nxdom_stats_size offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_pipes) == 0x94, "ks_nxdom.nxdom_pipes offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_extensions) == 0xA0, "ks_nxdom.nxdom_extensions offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_mhints) == 0xAC, "ks_nxdom.nxdom_mhints offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_flowadv_max) == 0xB8, "ks_nxdom.nxdom_flowadv_max offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_nexusadv_size) == 0xC4, "ks_nxdom.nxdom_nexusadv_size offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_capabilities) == 0xD0, "ks_nxdom.nxdom_capabilities offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_qmap) == 0xDC, "ks_nxdom.nxdom_qmap offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_max_frags) == 0xE8, "ks_nxdom.nxdom_max_frags offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_region_params) == 0xF8, "ks_nxdom.nxdom_region_params offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_name) == 0x8D8, "ks_nxdom.nxdom_name offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_init) == 0x8E0, "ks_nxdom.nxdom_init offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_terminate) == 0x8E8, "ks_nxdom.nxdom_terminate offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_fini) == 0x8F0, "ks_nxdom.nxdom_fini offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_find_port) == 0x8F8, "ks_nxdom.nxdom_find_port offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_port_is_reserved) == 0x900, "ks_nxdom.nxdom_port_is_reserved offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_bind_port) == 0x908, "ks_nxdom.nxdom_bind_port offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_unbind_port) == 0x910, "ks_nxdom.nxdom_unbind_port offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_connect) == 0x918, "ks_nxdom.nxdom_connect offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_disconnect) == 0x920, "ks_nxdom.nxdom_disconnect offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_defunct) == 0x928, "ks_nxdom.nxdom_defunct offset");
_Static_assert(offsetof(struct ks_nxdom, nxdom_defunct_finalize) == 0x930, "ks_nxdom.nxdom_defunct_finalize offset");
_Static_assert(sizeof(struct ks_nxdom) == 0x938, "ks_nxdom size");

/* refs: 2 */
struct ks_os_reason {
    struct ks_lck_mtx_s osr_lock;
    struct ks_os_refcnt osr_refcount;
    unsigned int osr_namespace;
    unsigned long long osr_code;
    unsigned long long osr_flags;
    unsigned int osr_bufsize;
    struct ks_kcdata_descriptor osr_kcd_descriptor;
    char *osr_kcd_buf;
};
_Static_assert(offsetof(struct ks_os_reason, osr_lock) == 0x0, "ks_os_reason.osr_lock offset");
_Static_assert(offsetof(struct ks_os_reason, osr_refcount) == 0x10, "ks_os_reason.osr_refcount offset");
_Static_assert(offsetof(struct ks_os_reason, osr_namespace) == 0x14, "ks_os_reason.osr_namespace offset");
_Static_assert(offsetof(struct ks_os_reason, osr_code) == 0x18, "ks_os_reason.osr_code offset");
_Static_assert(offsetof(struct ks_os_reason, osr_flags) == 0x20, "ks_os_reason.osr_flags offset");
_Static_assert(offsetof(struct ks_os_reason, osr_bufsize) == 0x28, "ks_os_reason.osr_bufsize offset");
_Static_assert(offsetof(struct ks_os_reason, osr_kcd_descriptor) == 0x30, "ks_os_reason.osr_kcd_descriptor offset");
_Static_assert(offsetof(struct ks_os_reason, osr_kcd_buf) == 0x110, "ks_os_reason.osr_kcd_buf offset");
_Static_assert(sizeof(struct ks_os_reason) == 0x118, "ks_os_reason size");

/* refs: 1 */
struct ks_page_table_attr {
    const struct ks_page_table_level_info *pta_level_info;
    const struct ks_page_table_ops *pta_ops;
    unsigned long ap_ro;
    unsigned long ap_rw;
    unsigned long ap_rona;
    unsigned long ap_rwna;
    unsigned long ap_xn;
    unsigned long ap_x;
    const unsigned int pta_root_level;
    const unsigned int pta_commpage_level;
    const unsigned int pta_max_level;
    const _Bool stage2;
    unsigned long long pta_tcr_value;
    unsigned long long pta_page_size;
    unsigned long long pta_page_shift;
    unsigned char geometry_id;
    unsigned long long pta_va_valid_mask;
};
_Static_assert(offsetof(struct ks_page_table_attr, pta_level_info) == 0x0, "ks_page_table_attr.pta_level_info offset");
_Static_assert(offsetof(struct ks_page_table_attr, pta_ops) == 0x8, "ks_page_table_attr.pta_ops offset");
_Static_assert(offsetof(struct ks_page_table_attr, ap_ro) == 0x10, "ks_page_table_attr.ap_ro offset");
_Static_assert(offsetof(struct ks_page_table_attr, ap_rw) == 0x18, "ks_page_table_attr.ap_rw offset");
_Static_assert(offsetof(struct ks_page_table_attr, ap_rona) == 0x20, "ks_page_table_attr.ap_rona offset");
_Static_assert(offsetof(struct ks_page_table_attr, ap_rwna) == 0x28, "ks_page_table_attr.ap_rwna offset");
_Static_assert(offsetof(struct ks_page_table_attr, ap_xn) == 0x30, "ks_page_table_attr.ap_xn offset");
_Static_assert(offsetof(struct ks_page_table_attr, ap_x) == 0x38, "ks_page_table_attr.ap_x offset");
_Static_assert(offsetof(struct ks_page_table_attr, pta_root_level) == 0x40, "ks_page_table_attr.pta_root_level offset");
_Static_assert(offsetof(struct ks_page_table_attr, pta_commpage_level) == 0x44, "ks_page_table_attr.pta_commpage_level offset");
_Static_assert(offsetof(struct ks_page_table_attr, pta_max_level) == 0x48, "ks_page_table_attr.pta_max_level offset");
_Static_assert(offsetof(struct ks_page_table_attr, stage2) == 0x4C, "ks_page_table_attr.stage2 offset");
_Static_assert(offsetof(struct ks_page_table_attr, pta_tcr_value) == 0x50, "ks_page_table_attr.pta_tcr_value offset");
_Static_assert(offsetof(struct ks_page_table_attr, pta_page_size) == 0x58, "ks_page_table_attr.pta_page_size offset");
_Static_assert(offsetof(struct ks_page_table_attr, pta_page_shift) == 0x60, "ks_page_table_attr.pta_page_shift offset");
_Static_assert(offsetof(struct ks_page_table_attr, geometry_id) == 0x68, "ks_page_table_attr.geometry_id offset");
_Static_assert(offsetof(struct ks_page_table_attr, pta_va_valid_mask) == 0x70, "ks_page_table_attr.pta_va_valid_mask offset");
_Static_assert(sizeof(struct ks_page_table_attr) == 0x78, "ks_page_table_attr size");

/* refs: 1 */
struct ks_page_table_level_info {
    unsigned long long size;
    unsigned long long offmask;
    unsigned long long shift;
    unsigned long long index_mask;
    unsigned long long valid_mask;
    unsigned long long type_mask;
    unsigned long long type_block;
};
_Static_assert(offsetof(struct ks_page_table_level_info, size) == 0x0, "ks_page_table_level_info.size offset");
_Static_assert(offsetof(struct ks_page_table_level_info, offmask) == 0x8, "ks_page_table_level_info.offmask offset");
_Static_assert(offsetof(struct ks_page_table_level_info, shift) == 0x10, "ks_page_table_level_info.shift offset");
_Static_assert(offsetof(struct ks_page_table_level_info, index_mask) == 0x18, "ks_page_table_level_info.index_mask offset");
_Static_assert(offsetof(struct ks_page_table_level_info, valid_mask) == 0x20, "ks_page_table_level_info.valid_mask offset");
_Static_assert(offsetof(struct ks_page_table_level_info, type_mask) == 0x28, "ks_page_table_level_info.type_mask offset");
_Static_assert(offsetof(struct ks_page_table_level_info, type_block) == 0x30, "ks_page_table_level_info.type_block offset");
_Static_assert(sizeof(struct ks_page_table_level_info) == 0x38, "ks_page_table_level_info size");

/* refs: 1 */
struct ks_page_table_ops {
    _Bool *alloc_id;
    void *free_id;
    void *flush_tlb_region_async;
    void *flush_tlb_async;
    unsigned long long *wimg_to_pte;
};
_Static_assert(offsetof(struct ks_page_table_ops, alloc_id) == 0x0, "ks_page_table_ops.alloc_id offset");
_Static_assert(offsetof(struct ks_page_table_ops, free_id) == 0x8, "ks_page_table_ops.free_id offset");
_Static_assert(offsetof(struct ks_page_table_ops, flush_tlb_region_async) == 0x10, "ks_page_table_ops.flush_tlb_region_async offset");
_Static_assert(offsetof(struct ks_page_table_ops, flush_tlb_async) == 0x18, "ks_page_table_ops.flush_tlb_async offset");
_Static_assert(offsetof(struct ks_page_table_ops, wimg_to_pte) == 0x20, "ks_page_table_ops.wimg_to_pte offset");
_Static_assert(sizeof(struct ks_page_table_ops) == 0x28, "ks_page_table_ops size");

/* refs: 3 */
struct ks_persona {
    struct ks_os_refcnt pna_refcount;
    int pna_valid;
    unsigned int pna_id;
    int pna_type;
    char pna_login[0x100];
    char *pna_path;
    unsigned int pna_uid;
    struct {
        struct ks_persona *le_next;
        struct ks_persona **le_prev;
    } pna_list;
    struct {
        struct ks_proc *lh_first;
    } pna_members;
    struct ks_lck_mtx_s pna_lock;
};
_Static_assert(offsetof(struct ks_persona, pna_refcount) == 0x0, "ks_persona.pna_refcount offset");
_Static_assert(offsetof(struct ks_persona, pna_valid) == 0x4, "ks_persona.pna_valid offset");
_Static_assert(offsetof(struct ks_persona, pna_id) == 0x8, "ks_persona.pna_id offset");
_Static_assert(offsetof(struct ks_persona, pna_type) == 0xC, "ks_persona.pna_type offset");
_Static_assert(offsetof(struct ks_persona, pna_login) == 0x10, "ks_persona.pna_login offset");
_Static_assert(offsetof(struct ks_persona, pna_path) == 0x110, "ks_persona.pna_path offset");
_Static_assert(offsetof(struct ks_persona, pna_uid) == 0x118, "ks_persona.pna_uid offset");
_Static_assert(offsetof(struct ks_persona, pna_list) == 0x120, "ks_persona.pna_list offset");
_Static_assert(offsetof(struct ks_persona, pna_members) == 0x130, "ks_persona.pna_members offset");
_Static_assert(offsetof(struct ks_persona, pna_lock) == 0x138, "ks_persona.pna_lock offset");
_Static_assert(sizeof(struct ks_persona) == 0x148, "ks_persona size");

/* refs: 4 */
struct ks_pf_addr {
    union {
        struct ks_in_addr _v4addr;
        struct ks_in6_addr _v6addr;
        unsigned char _addr8[0x10];
        unsigned short _addr16[8];
        unsigned int _addr32[4];
    } pfa;
};
_Static_assert(offsetof(struct ks_pf_addr, pfa) == 0x0, "ks_pf_addr.pfa offset");
_Static_assert(sizeof(struct ks_pf_addr) == 0x10, "ks_pf_addr size");

/* refs: 4 */
struct ks_pfi_dynaddr {
    struct {
        struct ks_pfi_dynaddr *tqe_next;
        struct ks_pfi_dynaddr **tqe_prev;
    } entry;
    struct ks_pf_addr pfid_addr4;
    struct ks_pf_addr pfid_mask4;
    struct ks_pf_addr pfid_addr6;
    struct ks_pf_addr pfid_mask6;
    struct ks_pfr_ktable *pfid_kt;
    struct ks_pfi_kif *pfid_kif;
    void *pfid_hook_cookie;
    unsigned char pfid_net;
    int pfid_acnt4;
    int pfid_acnt6;
    unsigned char pfid_af;
    unsigned char pfid_iflags;
};
_Static_assert(offsetof(struct ks_pfi_dynaddr, entry) == 0x0, "ks_pfi_dynaddr.entry offset");
_Static_assert(offsetof(struct ks_pfi_dynaddr, pfid_addr4) == 0x10, "ks_pfi_dynaddr.pfid_addr4 offset");
_Static_assert(offsetof(struct ks_pfi_dynaddr, pfid_mask4) == 0x20, "ks_pfi_dynaddr.pfid_mask4 offset");
_Static_assert(offsetof(struct ks_pfi_dynaddr, pfid_addr6) == 0x30, "ks_pfi_dynaddr.pfid_addr6 offset");
_Static_assert(offsetof(struct ks_pfi_dynaddr, pfid_mask6) == 0x40, "ks_pfi_dynaddr.pfid_mask6 offset");
_Static_assert(offsetof(struct ks_pfi_dynaddr, pfid_kt) == 0x50, "ks_pfi_dynaddr.pfid_kt offset");
_Static_assert(offsetof(struct ks_pfi_dynaddr, pfid_kif) == 0x58, "ks_pfi_dynaddr.pfid_kif offset");
_Static_assert(offsetof(struct ks_pfi_dynaddr, pfid_hook_cookie) == 0x60, "ks_pfi_dynaddr.pfid_hook_cookie offset");
_Static_assert(offsetof(struct ks_pfi_dynaddr, pfid_net) == 0x68, "ks_pfi_dynaddr.pfid_net offset");
_Static_assert(offsetof(struct ks_pfi_dynaddr, pfid_acnt4) == 0x6C, "ks_pfi_dynaddr.pfid_acnt4 offset");
_Static_assert(offsetof(struct ks_pfi_dynaddr, pfid_acnt6) == 0x70, "ks_pfi_dynaddr.pfid_acnt6 offset");
_Static_assert(offsetof(struct ks_pfi_dynaddr, pfid_af) == 0x74, "ks_pfi_dynaddr.pfid_af offset");
_Static_assert(offsetof(struct ks_pfi_dynaddr, pfid_iflags) == 0x75, "ks_pfi_dynaddr.pfid_iflags offset");
_Static_assert(sizeof(struct ks_pfi_dynaddr) == 0x78, "ks_pfi_dynaddr size");

/* refs: 5 */
struct ks_pfi_kif {
    char pfik_name[0x10];
    struct {
        struct ks_pfi_kif *rbe_left;
        struct ks_pfi_kif *rbe_right;
        struct ks_pfi_kif *rbe_parent;
    } pfik_tree;
    unsigned long long pfik_packets[2][2][2];
    unsigned long long pfik_bytes[2][2][2];
    unsigned long long pfik_tzero;
    int pfik_flags;
    void *pfik_ah_cookie;
    struct ks_ifnet *pfik_ifp;
    int pfik_states;
    int pfik_rules;
    struct {
        struct ks_pfi_dynaddr *tqh_first;
        struct ks_pfi_dynaddr **tqh_last;
    } pfik_dynaddrs;
};
_Static_assert(offsetof(struct ks_pfi_kif, pfik_name) == 0x0, "ks_pfi_kif.pfik_name offset");
_Static_assert(offsetof(struct ks_pfi_kif, pfik_tree) == 0x10, "ks_pfi_kif.pfik_tree offset");
_Static_assert(offsetof(struct ks_pfi_kif, pfik_packets) == 0x28, "ks_pfi_kif.pfik_packets offset");
_Static_assert(offsetof(struct ks_pfi_kif, pfik_bytes) == 0x68, "ks_pfi_kif.pfik_bytes offset");
_Static_assert(offsetof(struct ks_pfi_kif, pfik_tzero) == 0xA8, "ks_pfi_kif.pfik_tzero offset");
_Static_assert(offsetof(struct ks_pfi_kif, pfik_flags) == 0xB0, "ks_pfi_kif.pfik_flags offset");
_Static_assert(offsetof(struct ks_pfi_kif, pfik_ah_cookie) == 0xB8, "ks_pfi_kif.pfik_ah_cookie offset");
_Static_assert(offsetof(struct ks_pfi_kif, pfik_ifp) == 0xC0, "ks_pfi_kif.pfik_ifp offset");
_Static_assert(offsetof(struct ks_pfi_kif, pfik_states) == 0xC8, "ks_pfi_kif.pfik_states offset");
_Static_assert(offsetof(struct ks_pfi_kif, pfik_rules) == 0xCC, "ks_pfi_kif.pfik_rules offset");
_Static_assert(offsetof(struct ks_pfi_kif, pfik_dynaddrs) == 0xD0, "ks_pfi_kif.pfik_dynaddrs offset");
_Static_assert(sizeof(struct ks_pfi_kif) == 0xE0, "ks_pfi_kif size");

/* refs: 1 */
struct ks_pfr_table {
    char pfrt_anchor[0x400];
    char pfrt_name[0x20];
    unsigned int pfrt_flags;
    unsigned char pfrt_fback;
};
_Static_assert(offsetof(struct ks_pfr_table, pfrt_anchor) == 0x0, "ks_pfr_table.pfrt_anchor offset");
_Static_assert(offsetof(struct ks_pfr_table, pfrt_name) == 0x400, "ks_pfr_table.pfrt_name offset");
_Static_assert(offsetof(struct ks_pfr_table, pfrt_flags) == 0x420, "ks_pfr_table.pfrt_flags offset");
_Static_assert(offsetof(struct ks_pfr_table, pfrt_fback) == 0x424, "ks_pfr_table.pfrt_fback offset");
_Static_assert(sizeof(struct ks_pfr_table) == 0x428, "ks_pfr_table size");

/* refs: 1 */
struct ks_pfr_tstats {
    struct ks_pfr_table pfrts_t;
    unsigned long long pfrts_packets[2][3];
    unsigned long long pfrts_bytes[2][3];
    unsigned long long pfrts_match;
    unsigned long long pfrts_nomatch;
    unsigned long long pfrts_tzero;
    int pfrts_cnt;
    int pfrts_refcnt[2];
};
_Static_assert(offsetof(struct ks_pfr_tstats, pfrts_t) == 0x0, "ks_pfr_tstats.pfrts_t offset");
_Static_assert(offsetof(struct ks_pfr_tstats, pfrts_packets) == 0x428, "ks_pfr_tstats.pfrts_packets offset");
_Static_assert(offsetof(struct ks_pfr_tstats, pfrts_bytes) == 0x458, "ks_pfr_tstats.pfrts_bytes offset");
_Static_assert(offsetof(struct ks_pfr_tstats, pfrts_match) == 0x488, "ks_pfr_tstats.pfrts_match offset");
_Static_assert(offsetof(struct ks_pfr_tstats, pfrts_nomatch) == 0x490, "ks_pfr_tstats.pfrts_nomatch offset");
_Static_assert(offsetof(struct ks_pfr_tstats, pfrts_tzero) == 0x498, "ks_pfr_tstats.pfrts_tzero offset");
_Static_assert(offsetof(struct ks_pfr_tstats, pfrts_cnt) == 0x4A0, "ks_pfr_tstats.pfrts_cnt offset");
_Static_assert(offsetof(struct ks_pfr_tstats, pfrts_refcnt) == 0x4A4, "ks_pfr_tstats.pfrts_refcnt offset");
_Static_assert(sizeof(struct ks_pfr_tstats) == 0x4B0, "ks_pfr_tstats size");

/* refs: 5 */
struct ks_pfr_ktable {
    struct ks_pfr_tstats pfrkt_ts;
    struct {
        struct ks_pfr_ktable *rbe_left;
        struct ks_pfr_ktable *rbe_right;
        struct ks_pfr_ktable *rbe_parent;
    } pfrkt_tree;
    struct {
        struct ks_pfr_ktable *sle_next;
    } pfrkt_workq;
    struct ks_radix_node_head *pfrkt_ip4;
    struct ks_radix_node_head *pfrkt_ip6;
    struct ks_pfr_ktable *pfrkt_shadow;
    struct ks_pfr_ktable *pfrkt_root;
    struct ks_pf_ruleset *pfrkt_rs;
    unsigned long long pfrkt_larg;
    unsigned int pfrkt_nflags;
};
_Static_assert(offsetof(struct ks_pfr_ktable, pfrkt_ts) == 0x0, "ks_pfr_ktable.pfrkt_ts offset");
_Static_assert(offsetof(struct ks_pfr_ktable, pfrkt_tree) == 0x4B0, "ks_pfr_ktable.pfrkt_tree offset");
_Static_assert(offsetof(struct ks_pfr_ktable, pfrkt_workq) == 0x4C8, "ks_pfr_ktable.pfrkt_workq offset");
_Static_assert(offsetof(struct ks_pfr_ktable, pfrkt_ip4) == 0x4D0, "ks_pfr_ktable.pfrkt_ip4 offset");
_Static_assert(offsetof(struct ks_pfr_ktable, pfrkt_ip6) == 0x4D8, "ks_pfr_ktable.pfrkt_ip6 offset");
_Static_assert(offsetof(struct ks_pfr_ktable, pfrkt_shadow) == 0x4E0, "ks_pfr_ktable.pfrkt_shadow offset");
_Static_assert(offsetof(struct ks_pfr_ktable, pfrkt_root) == 0x4E8, "ks_pfr_ktable.pfrkt_root offset");
_Static_assert(offsetof(struct ks_pfr_ktable, pfrkt_rs) == 0x4F0, "ks_pfr_ktable.pfrkt_rs offset");
_Static_assert(offsetof(struct ks_pfr_ktable, pfrkt_larg) == 0x4F8, "ks_pfr_ktable.pfrkt_larg offset");
_Static_assert(offsetof(struct ks_pfr_ktable, pfrkt_nflags) == 0x500, "ks_pfr_ktable.pfrkt_nflags offset");
_Static_assert(sizeof(struct ks_pfr_ktable) == 0x508, "ks_pfr_ktable size");

/* refs: 2 */
struct ks_pgrp {
    union {
        struct ks_lck_mtx_s pg_mlock;
        struct ks_smr_node pg_smr_node;
    };
    struct ks_smrq_slink pg_hash;
    struct {
        struct ks_proc *lh_first;
    } pg_members;
    struct ks_session *pg_session;
    int pg_id;
    int pg_jobc;
    unsigned int pg_refcount;
    unsigned int pg_hashref;
};
_Static_assert(offsetof(struct ks_pgrp, pg_hash) == 0x10, "ks_pgrp.pg_hash offset");
_Static_assert(offsetof(struct ks_pgrp, pg_members) == 0x18, "ks_pgrp.pg_members offset");
_Static_assert(offsetof(struct ks_pgrp, pg_session) == 0x20, "ks_pgrp.pg_session offset");
_Static_assert(offsetof(struct ks_pgrp, pg_id) == 0x28, "ks_pgrp.pg_id offset");
_Static_assert(offsetof(struct ks_pgrp, pg_jobc) == 0x2C, "ks_pgrp.pg_jobc offset");
_Static_assert(offsetof(struct ks_pgrp, pg_refcount) == 0x30, "ks_pgrp.pg_refcount offset");
_Static_assert(offsetof(struct ks_pgrp, pg_hashref) == 0x34, "ks_pgrp.pg_hashref offset");
_Static_assert(sizeof(struct ks_pgrp) == 0x38, "ks_pgrp size");

/* refs: 3 */
struct ks_pktsched_ops {
    unsigned char ps_id;
    unsigned char ps_ops_flags;
    int *ps_setup;
    void *ps_teardown;
    int *ps_enq;
    int *ps_deq;
    int *ps_deq_sc;
    int *ps_req;
    int *ps_stats;
    int *ps_allow_dequeue;
    struct {
        struct ks_pktsched_ops *le_next;
        struct ks_pktsched_ops **le_prev;
    } ps_ops_link;
};
_Static_assert(offsetof(struct ks_pktsched_ops, ps_id) == 0x0, "ks_pktsched_ops.ps_id offset");
_Static_assert(offsetof(struct ks_pktsched_ops, ps_ops_flags) == 0x1, "ks_pktsched_ops.ps_ops_flags offset");
_Static_assert(offsetof(struct ks_pktsched_ops, ps_setup) == 0x8, "ks_pktsched_ops.ps_setup offset");
_Static_assert(offsetof(struct ks_pktsched_ops, ps_teardown) == 0x10, "ks_pktsched_ops.ps_teardown offset");
_Static_assert(offsetof(struct ks_pktsched_ops, ps_enq) == 0x18, "ks_pktsched_ops.ps_enq offset");
_Static_assert(offsetof(struct ks_pktsched_ops, ps_deq) == 0x20, "ks_pktsched_ops.ps_deq offset");
_Static_assert(offsetof(struct ks_pktsched_ops, ps_deq_sc) == 0x28, "ks_pktsched_ops.ps_deq_sc offset");
_Static_assert(offsetof(struct ks_pktsched_ops, ps_req) == 0x30, "ks_pktsched_ops.ps_req offset");
_Static_assert(offsetof(struct ks_pktsched_ops, ps_stats) == 0x38, "ks_pktsched_ops.ps_stats offset");
_Static_assert(offsetof(struct ks_pktsched_ops, ps_allow_dequeue) == 0x40, "ks_pktsched_ops.ps_allow_dequeue offset");
_Static_assert(offsetof(struct ks_pktsched_ops, ps_ops_link) == 0x48, "ks_pktsched_ops.ps_ops_link offset");
_Static_assert(sizeof(struct ks_pktsched_ops) == 0x58, "ks_pktsched_ops size");

/* refs: 1 */
struct ks_rlimit {
    unsigned long long rlim_cur;
    unsigned long long rlim_max;
};
_Static_assert(offsetof(struct ks_rlimit, rlim_cur) == 0x0, "ks_rlimit.rlim_cur offset");
_Static_assert(offsetof(struct ks_rlimit, rlim_max) == 0x8, "ks_rlimit.rlim_max offset");
_Static_assert(sizeof(struct ks_rlimit) == 0x10, "ks_rlimit size");

/* refs: 1 */
struct ks_plimit {
    struct ks_smr_node pl_node;
    struct ks_rlimit pl_rlimit[9];
    struct ks_os_refcnt pl_refcnt;
};
_Static_assert(offsetof(struct ks_plimit, pl_node) == 0x0, "ks_plimit.pl_node offset");
_Static_assert(offsetof(struct ks_plimit, pl_rlimit) == 0x10, "ks_plimit.pl_rlimit offset");
_Static_assert(offsetof(struct ks_plimit, pl_refcnt) == 0xA0, "ks_plimit.pl_refcnt offset");
_Static_assert(sizeof(struct ks_plimit) == 0xA8, "ks_plimit size");

/* refs: 3 */
struct ks_pmap {
    unsigned long long *tte;
    unsigned long long ttep;
    unsigned long long min;
    unsigned long long max;
    const struct ks_page_table_attr *pmap_pt_attr;
    struct ks_ledger *ledger;
    struct ks_lck_rw_s rwlock;
    struct ks_queue_entry pmaps;
    unsigned long long nested_region_addr;
    unsigned long long nested_region_size;
    unsigned long long nested_region_true_start;
    unsigned long long nested_region_true_end;
    union {
        struct ks_pmap *nested_pmap;
        unsigned long long *nested_region_unnested_table_bitmap;
    };
    unsigned int ref_count;
    unsigned short asid;
    _Bool xprr_jit_enabled;
    _Bool pmap_vm_map_cs_enforced;
    _Bool is_x86_64;
    _Bool is_rosetta;
    _Bool nx_enabled;
    _Bool is_64bit;
    _Bool disable_jop;
    _Bool xprr_tpro_enabled;
    unsigned char type;
    struct ks_lck_rw_s txm_lck;
    struct ks__TXMAddressSpace *txm_addr_space;
    unsigned char txm_trust_level;
    const void *associated_vm_map_serial_id;
};
_Static_assert(offsetof(struct ks_pmap, tte) == 0x0, "ks_pmap.tte offset");
_Static_assert(offsetof(struct ks_pmap, ttep) == 0x8, "ks_pmap.ttep offset");
_Static_assert(offsetof(struct ks_pmap, min) == 0x10, "ks_pmap.min offset");
_Static_assert(offsetof(struct ks_pmap, max) == 0x18, "ks_pmap.max offset");
_Static_assert(offsetof(struct ks_pmap, pmap_pt_attr) == 0x20, "ks_pmap.pmap_pt_attr offset");
_Static_assert(offsetof(struct ks_pmap, ledger) == 0x28, "ks_pmap.ledger offset");
_Static_assert(offsetof(struct ks_pmap, rwlock) == 0x30, "ks_pmap.rwlock offset");
_Static_assert(offsetof(struct ks_pmap, pmaps) == 0x40, "ks_pmap.pmaps offset");
_Static_assert(offsetof(struct ks_pmap, nested_region_addr) == 0x50, "ks_pmap.nested_region_addr offset");
_Static_assert(offsetof(struct ks_pmap, nested_region_size) == 0x58, "ks_pmap.nested_region_size offset");
_Static_assert(offsetof(struct ks_pmap, nested_region_true_start) == 0x60, "ks_pmap.nested_region_true_start offset");
_Static_assert(offsetof(struct ks_pmap, nested_region_true_end) == 0x68, "ks_pmap.nested_region_true_end offset");
_Static_assert(offsetof(struct ks_pmap, ref_count) == 0x78, "ks_pmap.ref_count offset");
_Static_assert(offsetof(struct ks_pmap, asid) == 0x7C, "ks_pmap.asid offset");
_Static_assert(offsetof(struct ks_pmap, xprr_jit_enabled) == 0x7E, "ks_pmap.xprr_jit_enabled offset");
_Static_assert(offsetof(struct ks_pmap, pmap_vm_map_cs_enforced) == 0x7F, "ks_pmap.pmap_vm_map_cs_enforced offset");
_Static_assert(offsetof(struct ks_pmap, is_x86_64) == 0x80, "ks_pmap.is_x86_64 offset");
_Static_assert(offsetof(struct ks_pmap, is_rosetta) == 0x81, "ks_pmap.is_rosetta offset");
_Static_assert(offsetof(struct ks_pmap, nx_enabled) == 0x82, "ks_pmap.nx_enabled offset");
_Static_assert(offsetof(struct ks_pmap, is_64bit) == 0x83, "ks_pmap.is_64bit offset");
_Static_assert(offsetof(struct ks_pmap, disable_jop) == 0x84, "ks_pmap.disable_jop offset");
_Static_assert(offsetof(struct ks_pmap, xprr_tpro_enabled) == 0x85, "ks_pmap.xprr_tpro_enabled offset");
_Static_assert(offsetof(struct ks_pmap, type) == 0x86, "ks_pmap.type offset");
_Static_assert(offsetof(struct ks_pmap, txm_lck) == 0x88, "ks_pmap.txm_lck offset");
_Static_assert(offsetof(struct ks_pmap, txm_addr_space) == 0x98, "ks_pmap.txm_addr_space offset");
_Static_assert(offsetof(struct ks_pmap, txm_trust_level) == 0xA0, "ks_pmap.txm_trust_level offset");
_Static_assert(offsetof(struct ks_pmap, associated_vm_map_serial_id) == 0xA8, "ks_pmap.associated_vm_map_serial_id offset");
_Static_assert(sizeof(struct ks_pmap) == 0xB0, "ks_pmap size");

/* refs: 1 */
struct ks_pollfd {
    int fd;
    short events;
    short revents;
};
_Static_assert(offsetof(struct ks_pollfd, fd) == 0x0, "ks_pollfd.fd offset");
_Static_assert(offsetof(struct ks_pollfd, events) == 0x4, "ks_pollfd.events offset");
_Static_assert(offsetof(struct ks_pollfd, revents) == 0x6, "ks_pollfd.revents offset");
_Static_assert(sizeof(struct ks_pollfd) == 0x8, "ks_pollfd size");

/* refs: 1 */
struct ks_posix_cred {
    unsigned int cr_uid;
    unsigned int cr_ruid;
    unsigned int cr_svuid;
    unsigned short cr_ngroups;
    unsigned short __cr_padding;
    unsigned int cr_groups[0x10];
    unsigned int cr_rgid;
    unsigned int cr_svgid;
    unsigned int cr_gmuid;
    int cr_flags;
};
_Static_assert(offsetof(struct ks_posix_cred, cr_uid) == 0x0, "ks_posix_cred.cr_uid offset");
_Static_assert(offsetof(struct ks_posix_cred, cr_ruid) == 0x4, "ks_posix_cred.cr_ruid offset");
_Static_assert(offsetof(struct ks_posix_cred, cr_svuid) == 0x8, "ks_posix_cred.cr_svuid offset");
_Static_assert(offsetof(struct ks_posix_cred, cr_ngroups) == 0xC, "ks_posix_cred.cr_ngroups offset");
_Static_assert(offsetof(struct ks_posix_cred, __cr_padding) == 0xE, "ks_posix_cred.__cr_padding offset");
_Static_assert(offsetof(struct ks_posix_cred, cr_groups) == 0x10, "ks_posix_cred.cr_groups offset");
_Static_assert(offsetof(struct ks_posix_cred, cr_rgid) == 0x50, "ks_posix_cred.cr_rgid offset");
_Static_assert(offsetof(struct ks_posix_cred, cr_svgid) == 0x54, "ks_posix_cred.cr_svgid offset");
_Static_assert(offsetof(struct ks_posix_cred, cr_gmuid) == 0x58, "ks_posix_cred.cr_gmuid offset");
_Static_assert(offsetof(struct ks_posix_cred, cr_flags) == 0x5C, "ks_posix_cred.cr_flags offset");
_Static_assert(sizeof(struct ks_posix_cred) == 0x60, "ks_posix_cred size");

/* refs: 1 */
struct ks_pr_usrreqs {
    unsigned int pru_flags;
    int *pru_abort;
    int *pru_accept;
    int *pru_attach;
    int *pru_bind;
    int *pru_connect;
    int *pru_connect2;
    int *pru_connectx;
    int *pru_control;
    int *pru_detach;
    int *pru_disconnect;
    int *pru_disconnectx;
    int *pru_listen;
    int *pru_peeraddr;
    int *pru_rcvd;
    int *pru_rcvoob;
    int *pru_send;
    int *pru_send_list;
    int *pru_sense;
    int *pru_shutdown;
    int *pru_sockaddr;
    int *pru_sopoll;
    int *pru_soreceive;
    int *pru_sosend;
    int *pru_sosend_list;
    int *pru_socheckopt;
    int *pru_preconnect;
    int *pru_defunct;
};
_Static_assert(offsetof(struct ks_pr_usrreqs, pru_flags) == 0x0, "ks_pr_usrreqs.pru_flags offset");
_Static_assert(offsetof(struct ks_pr_usrreqs, pru_abort) == 0x8, "ks_pr_usrreqs.pru_abort offset");
_Static_assert(offsetof(struct ks_pr_usrreqs, pru_accept) == 0x10, "ks_pr_usrreqs.pru_accept offset");
_Static_assert(offsetof(struct ks_pr_usrreqs, pru_attach) == 0x18, "ks_pr_usrreqs.pru_attach offset");
_Static_assert(offsetof(struct ks_pr_usrreqs, pru_bind) == 0x20, "ks_pr_usrreqs.pru_bind offset");
_Static_assert(offsetof(struct ks_pr_usrreqs, pru_connect) == 0x28, "ks_pr_usrreqs.pru_connect offset");
_Static_assert(offsetof(struct ks_pr_usrreqs, pru_connect2) == 0x30, "ks_pr_usrreqs.pru_connect2 offset");
_Static_assert(offsetof(struct ks_pr_usrreqs, pru_connectx) == 0x38, "ks_pr_usrreqs.pru_connectx offset");
_Static_assert(offsetof(struct ks_pr_usrreqs, pru_control) == 0x40, "ks_pr_usrreqs.pru_control offset");
_Static_assert(offsetof(struct ks_pr_usrreqs, pru_detach) == 0x48, "ks_pr_usrreqs.pru_detach offset");
_Static_assert(offsetof(struct ks_pr_usrreqs, pru_disconnect) == 0x50, "ks_pr_usrreqs.pru_disconnect offset");
_Static_assert(offsetof(struct ks_pr_usrreqs, pru_disconnectx) == 0x58, "ks_pr_usrreqs.pru_disconnectx offset");
_Static_assert(offsetof(struct ks_pr_usrreqs, pru_listen) == 0x60, "ks_pr_usrreqs.pru_listen offset");
_Static_assert(offsetof(struct ks_pr_usrreqs, pru_peeraddr) == 0x68, "ks_pr_usrreqs.pru_peeraddr offset");
_Static_assert(offsetof(struct ks_pr_usrreqs, pru_rcvd) == 0x70, "ks_pr_usrreqs.pru_rcvd offset");
_Static_assert(offsetof(struct ks_pr_usrreqs, pru_rcvoob) == 0x78, "ks_pr_usrreqs.pru_rcvoob offset");
_Static_assert(offsetof(struct ks_pr_usrreqs, pru_send) == 0x80, "ks_pr_usrreqs.pru_send offset");
_Static_assert(offsetof(struct ks_pr_usrreqs, pru_send_list) == 0x88, "ks_pr_usrreqs.pru_send_list offset");
_Static_assert(offsetof(struct ks_pr_usrreqs, pru_sense) == 0x90, "ks_pr_usrreqs.pru_sense offset");
_Static_assert(offsetof(struct ks_pr_usrreqs, pru_shutdown) == 0x98, "ks_pr_usrreqs.pru_shutdown offset");
_Static_assert(offsetof(struct ks_pr_usrreqs, pru_sockaddr) == 0xA0, "ks_pr_usrreqs.pru_sockaddr offset");
_Static_assert(offsetof(struct ks_pr_usrreqs, pru_sopoll) == 0xA8, "ks_pr_usrreqs.pru_sopoll offset");
_Static_assert(offsetof(struct ks_pr_usrreqs, pru_soreceive) == 0xB0, "ks_pr_usrreqs.pru_soreceive offset");
_Static_assert(offsetof(struct ks_pr_usrreqs, pru_sosend) == 0xB8, "ks_pr_usrreqs.pru_sosend offset");
_Static_assert(offsetof(struct ks_pr_usrreqs, pru_sosend_list) == 0xC0, "ks_pr_usrreqs.pru_sosend_list offset");
_Static_assert(offsetof(struct ks_pr_usrreqs, pru_socheckopt) == 0xC8, "ks_pr_usrreqs.pru_socheckopt offset");
_Static_assert(offsetof(struct ks_pr_usrreqs, pru_preconnect) == 0xD0, "ks_pr_usrreqs.pru_preconnect offset");
_Static_assert(offsetof(struct ks_pr_usrreqs, pru_defunct) == 0xD8, "ks_pr_usrreqs.pru_defunct offset");
_Static_assert(sizeof(struct ks_pr_usrreqs) == 0xE0, "ks_pr_usrreqs size");

/* refs: 1 */
struct ks_pr_usrreqs_old {
    int *pru_abort;
    int *pru_accept;
    int *pru_attach;
    int *pru_bind;
    int *pru_connect;
    int *pru_connect2;
    int *pru_control;
    int *pru_detach;
    int *pru_disconnect;
    int *pru_listen;
    int *pru_peeraddr;
    int *pru_rcvd;
    int *pru_rcvoob;
    int *pru_send;
    int *pru_sense;
    int *pru_shutdown;
    int *pru_sockaddr;
    int *pru_sosend;
    int *pru_soreceive;
    int *pru_sopoll;
};
_Static_assert(offsetof(struct ks_pr_usrreqs_old, pru_abort) == 0x0, "ks_pr_usrreqs_old.pru_abort offset");
_Static_assert(offsetof(struct ks_pr_usrreqs_old, pru_accept) == 0x8, "ks_pr_usrreqs_old.pru_accept offset");
_Static_assert(offsetof(struct ks_pr_usrreqs_old, pru_attach) == 0x10, "ks_pr_usrreqs_old.pru_attach offset");
_Static_assert(offsetof(struct ks_pr_usrreqs_old, pru_bind) == 0x18, "ks_pr_usrreqs_old.pru_bind offset");
_Static_assert(offsetof(struct ks_pr_usrreqs_old, pru_connect) == 0x20, "ks_pr_usrreqs_old.pru_connect offset");
_Static_assert(offsetof(struct ks_pr_usrreqs_old, pru_connect2) == 0x28, "ks_pr_usrreqs_old.pru_connect2 offset");
_Static_assert(offsetof(struct ks_pr_usrreqs_old, pru_control) == 0x30, "ks_pr_usrreqs_old.pru_control offset");
_Static_assert(offsetof(struct ks_pr_usrreqs_old, pru_detach) == 0x38, "ks_pr_usrreqs_old.pru_detach offset");
_Static_assert(offsetof(struct ks_pr_usrreqs_old, pru_disconnect) == 0x40, "ks_pr_usrreqs_old.pru_disconnect offset");
_Static_assert(offsetof(struct ks_pr_usrreqs_old, pru_listen) == 0x48, "ks_pr_usrreqs_old.pru_listen offset");
_Static_assert(offsetof(struct ks_pr_usrreqs_old, pru_peeraddr) == 0x50, "ks_pr_usrreqs_old.pru_peeraddr offset");
_Static_assert(offsetof(struct ks_pr_usrreqs_old, pru_rcvd) == 0x58, "ks_pr_usrreqs_old.pru_rcvd offset");
_Static_assert(offsetof(struct ks_pr_usrreqs_old, pru_rcvoob) == 0x60, "ks_pr_usrreqs_old.pru_rcvoob offset");
_Static_assert(offsetof(struct ks_pr_usrreqs_old, pru_send) == 0x68, "ks_pr_usrreqs_old.pru_send offset");
_Static_assert(offsetof(struct ks_pr_usrreqs_old, pru_sense) == 0x70, "ks_pr_usrreqs_old.pru_sense offset");
_Static_assert(offsetof(struct ks_pr_usrreqs_old, pru_shutdown) == 0x78, "ks_pr_usrreqs_old.pru_shutdown offset");
_Static_assert(offsetof(struct ks_pr_usrreqs_old, pru_sockaddr) == 0x80, "ks_pr_usrreqs_old.pru_sockaddr offset");
_Static_assert(offsetof(struct ks_pr_usrreqs_old, pru_sosend) == 0x88, "ks_pr_usrreqs_old.pru_sosend offset");
_Static_assert(offsetof(struct ks_pr_usrreqs_old, pru_soreceive) == 0x90, "ks_pr_usrreqs_old.pru_soreceive offset");
_Static_assert(offsetof(struct ks_pr_usrreqs_old, pru_sopoll) == 0x98, "ks_pr_usrreqs_old.pru_sopoll offset");
_Static_assert(sizeof(struct ks_pr_usrreqs_old) == 0xA0, "ks_pr_usrreqs_old size");

/* refs: 2 */
struct ks_priority_queue_deadline_min {
    struct ks_priority_queue_entry_deadline *pq_root;
};
_Static_assert(offsetof(struct ks_priority_queue_deadline_min, pq_root) == 0x0, "ks_priority_queue_deadline_min.pq_root offset");
_Static_assert(sizeof(struct ks_priority_queue_deadline_min) == 0x8, "ks_priority_queue_deadline_min size");

/* refs: 2 */
struct ks_priority_queue_entry_stable {
    struct ks_priority_queue_entry_stable *next;
    struct ks_priority_queue_entry_stable *prev;
    long key : 16; /* bit offset 128 */
    long child : 48; /* bit offset 144 */
    unsigned long long stamp;
};
_Static_assert(offsetof(struct ks_priority_queue_entry_stable, next) == 0x0, "ks_priority_queue_entry_stable.next offset");
_Static_assert(offsetof(struct ks_priority_queue_entry_stable, prev) == 0x8, "ks_priority_queue_entry_stable.prev offset");
_Static_assert(offsetof(struct ks_priority_queue_entry_stable, stamp) == 0x18, "ks_priority_queue_entry_stable.stamp offset");
_Static_assert(sizeof(struct ks_priority_queue_entry_stable) == 0x20, "ks_priority_queue_entry_stable size");

/* refs: 1 */
struct ks_priority_queue_sched_stable_max {
    struct ks_priority_queue_entry_stable *pq_root;
};
_Static_assert(offsetof(struct ks_priority_queue_sched_stable_max, pq_root) == 0x0, "ks_priority_queue_sched_stable_max.pq_root offset");
_Static_assert(sizeof(struct ks_priority_queue_sched_stable_max) == 0x8, "ks_priority_queue_sched_stable_max size");

/* refs: 1 */
struct ks_proc_forkcopy_data {
    unsigned int p_argslen;
    int p_argc;
    unsigned long long user_stack;
    struct ks_vnode *p_textvp;
    long long p_textoff;
    unsigned int p_sigmask;
    unsigned int p_sigignore;
    unsigned int p_sigcatch;
    unsigned int p_workq_allow_sigmask;
    unsigned char p_priority;
    unsigned char p_resv0;
    char p_nice;
    unsigned char p_resv1;
    char p_comm[0x11];
    char p_name[0x21];
    unsigned char p_xhighbits;
    int p_contproc;
    unsigned int p_pcaction;
    unsigned char p_uuid[0x10];
    unsigned char p_responsible_uuid[0x10];
    int p_cputype;
    int p_cpusubtype;
};
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_argslen) == 0x0, "ks_proc_forkcopy_data.p_argslen offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_argc) == 0x4, "ks_proc_forkcopy_data.p_argc offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, user_stack) == 0x8, "ks_proc_forkcopy_data.user_stack offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_textvp) == 0x10, "ks_proc_forkcopy_data.p_textvp offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_textoff) == 0x18, "ks_proc_forkcopy_data.p_textoff offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_sigmask) == 0x20, "ks_proc_forkcopy_data.p_sigmask offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_sigignore) == 0x24, "ks_proc_forkcopy_data.p_sigignore offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_sigcatch) == 0x28, "ks_proc_forkcopy_data.p_sigcatch offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_workq_allow_sigmask) == 0x2C, "ks_proc_forkcopy_data.p_workq_allow_sigmask offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_priority) == 0x30, "ks_proc_forkcopy_data.p_priority offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_resv0) == 0x31, "ks_proc_forkcopy_data.p_resv0 offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_nice) == 0x32, "ks_proc_forkcopy_data.p_nice offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_resv1) == 0x33, "ks_proc_forkcopy_data.p_resv1 offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_comm) == 0x34, "ks_proc_forkcopy_data.p_comm offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_name) == 0x45, "ks_proc_forkcopy_data.p_name offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_xhighbits) == 0x66, "ks_proc_forkcopy_data.p_xhighbits offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_contproc) == 0x68, "ks_proc_forkcopy_data.p_contproc offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_pcaction) == 0x6C, "ks_proc_forkcopy_data.p_pcaction offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_uuid) == 0x70, "ks_proc_forkcopy_data.p_uuid offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_responsible_uuid) == 0x80, "ks_proc_forkcopy_data.p_responsible_uuid offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_cputype) == 0x90, "ks_proc_forkcopy_data.p_cputype offset");
_Static_assert(offsetof(struct ks_proc_forkcopy_data, p_cpusubtype) == 0x94, "ks_proc_forkcopy_data.p_cpusubtype offset");
_Static_assert(sizeof(struct ks_proc_forkcopy_data) == 0x98, "ks_proc_forkcopy_data size");

/* refs: 1 */
struct ks_sigacts {
    unsigned long long ps_sigact[0x20];
    unsigned long long ps_trampact[0x20];
    unsigned int ps_catchmask[0x20];
    unsigned int ps_sigonstack;
    unsigned int ps_sigintr;
    unsigned int ps_sigreset;
    unsigned int ps_signodefer;
    unsigned int ps_siginfo;
    unsigned int ps_oldmask;
    unsigned int ps_sigreturn_validation;
    int ps_flags;
    int ps_sig;
    int ps_code;
    int ps_addr;
};
_Static_assert(offsetof(struct ks_sigacts, ps_sigact) == 0x0, "ks_sigacts.ps_sigact offset");
_Static_assert(offsetof(struct ks_sigacts, ps_trampact) == 0x100, "ks_sigacts.ps_trampact offset");
_Static_assert(offsetof(struct ks_sigacts, ps_catchmask) == 0x200, "ks_sigacts.ps_catchmask offset");
_Static_assert(offsetof(struct ks_sigacts, ps_sigonstack) == 0x280, "ks_sigacts.ps_sigonstack offset");
_Static_assert(offsetof(struct ks_sigacts, ps_sigintr) == 0x284, "ks_sigacts.ps_sigintr offset");
_Static_assert(offsetof(struct ks_sigacts, ps_sigreset) == 0x288, "ks_sigacts.ps_sigreset offset");
_Static_assert(offsetof(struct ks_sigacts, ps_signodefer) == 0x28C, "ks_sigacts.ps_signodefer offset");
_Static_assert(offsetof(struct ks_sigacts, ps_siginfo) == 0x290, "ks_sigacts.ps_siginfo offset");
_Static_assert(offsetof(struct ks_sigacts, ps_oldmask) == 0x294, "ks_sigacts.ps_oldmask offset");
_Static_assert(offsetof(struct ks_sigacts, ps_sigreturn_validation) == 0x298, "ks_sigacts.ps_sigreturn_validation offset");
_Static_assert(offsetof(struct ks_sigacts, ps_flags) == 0x29C, "ks_sigacts.ps_flags offset");
_Static_assert(offsetof(struct ks_sigacts, ps_sig) == 0x2A0, "ks_sigacts.ps_sig offset");
_Static_assert(offsetof(struct ks_sigacts, ps_code) == 0x2A4, "ks_sigacts.ps_code offset");
_Static_assert(offsetof(struct ks_sigacts, ps_addr) == 0x2A8, "ks_sigacts.ps_addr offset");
_Static_assert(sizeof(struct ks_sigacts) == 0x2B0, "ks_sigacts size");

/* refs: 24 */
struct ks_proc {
    union {
        struct {
            struct ks_proc *le_next;
            struct ks_proc **le_prev;
        } p_list;
        struct ks_smr_node p_smr_node;
    };
    struct ks_proc *p_pptr;
    struct ks_proc_ro *p_proc_ro;
    int p_ppid;
    int p_pgrpid;
    unsigned int p_uid;
    unsigned int p_gid;
    unsigned int p_ruid;
    unsigned int p_rgid;
    unsigned int p_svuid;
    unsigned int p_svgid;
    int p_sessionid;
    unsigned long long p_puniqueid;
    struct ks_lck_mtx_s p_mlock;
    int p_pid;
    char p_stat;
    char p_shutdownstate;
    char p_kdebug;
    char p_btrace;
    struct {
        struct ks_proc *le_next;
        struct ks_proc **le_prev;
    } p_pglist;
    struct {
        struct ks_proc *le_next;
        struct ks_proc **le_prev;
    } p_sibling;
    struct {
        struct ks_proc *lh_first;
    } p_children;
    struct {
        struct ks_uthread *tqh_first;
        struct ks_uthread **tqh_last;
    } p_uthlist;
    struct ks_smrq_slink p_hash;
    struct ks_persona *p_persona;
    struct {
        struct ks_proc *le_next;
        struct ks_proc **le_prev;
    } p_persona_list;
    struct ks_lck_mtx_s p_ucred_mlock;
    struct ks_lck_mtx_s p_audit_mlock;
    struct ks_filedesc p_fd;
    struct ks_pstats *p_stats;
    struct {
        volatile struct ks_plimit *__smr_ptr;
    } p_limit;
    struct {
        volatile struct ks_pgrp *__smr_ptr;
    } p_pgrp;
    struct ks_sigacts p_sigacts;
    struct ks_lck_spin_s p_slock;
    int p_siglist;
    unsigned int p_flag;
    unsigned int p_lflag;
    unsigned int p_listflag;
    unsigned int p_ladvflag;
    unsigned int p_refcount;
    unsigned int p_waitref;
    int p_childrencnt;
    int p_parentref;
    int p_oppid;
    unsigned int p_xstat;
    int p_aio_total_count;
    struct ks_itimerval p_realtimer;
    struct ks_timeval p_rtime;
    struct ks_itimerval p_vtimer_user;
    struct ks_itimerval p_vtimer_prof;
    struct ks_timeval p_rlim_cpu;
    int p_debugger;
    int sigwait;
    void *sigwait_thread;
    void *exit_thread;
    int si_pid;
    unsigned int si_status;
    unsigned int si_code;
    unsigned int si_uid;
    void *vm_shm;
    int p_ractive;
    int p_responsible_pid;
    int p_dtrace_probes;
    unsigned int p_dtrace_count;
    unsigned char p_dtrace_stop;
    unsigned long long p_dtrace_argv;
    unsigned long long p_dtrace_envp;
    struct ks_lck_mtx_s p_dtrace_sprlock;
    struct ks_dtrace_ptss_page *p_dtrace_ptss_pages;
    struct ks_dtrace_ptss_page_entry *p_dtrace_ptss_free_list;
    struct ks_dtrace_helpers *p_dtrace_helpers;
    struct ks_dof_ioctl_data *p_dtrace_lazy_dofs;
    struct ks_proc_forkcopy_data p_forkcopy;
    struct {
        struct ks_aio_workq_entry *tqh_first;
        struct ks_aio_workq_entry **tqh_last;
    } p_aio_activeq;
    struct {
        struct ks_aio_workq_entry *tqh_first;
        struct ks_aio_workq_entry **tqh_last;
    } p_aio_doneq;
    struct ks_klist p_klist;
    struct ks_rusage_superset *p_ru;
    struct ks_thread *p_signalholder;
    struct ks_thread *p_transholder;
    int p_sigwaitcnt;
    unsigned short p_acflag;
    unsigned short p_vfs_iopolicy;
    unsigned long long p_threadstart;
    unsigned long long p_wqthread;
    int p_pthsize;
    unsigned int p_pth_tsd_offset;
    unsigned long long p_stack_addr_hint;
    struct ks_workqueue * _Atomic p_wqptr;
    struct ks_workq_aio_s * _Atomic p_aio_wqptr;
    struct ks_timeval p_start;
    void *p_rcall;
    void *p_pthhash;
    unsigned long long was_throttled __attribute__((aligned(8)));
    unsigned long long did_throttle __attribute__((aligned(8)));
    unsigned long long p_dispatchqueue_offset;
    unsigned long long p_dispatchqueue_serialno_offset;
    unsigned long long p_dispatchqueue_label_offset;
    unsigned long long p_return_to_kernel_offset;
    unsigned long long p_mach_thread_self_offset;
    unsigned long long p_pthread_wq_quantum_offset;
    struct ks_timeval vm_pressure_last_notify_tstamp;
    unsigned char p_crash_behavior;
    _Bool p_posix_spawn_failed;
    _Bool p_disallow_map_with_linking;
    unsigned int p_memstat_state;
    int p_memstat_effectivepriority;
    int p_memstat_requestedpriority;
    int p_memstat_assertionpriority;
    unsigned int p_memstat_dirty;
    struct {
        struct ks_proc *tqe_next;
        struct ks_proc **tqe_prev;
    } p_memstat_list;
    unsigned long long p_memstat_userdata;
    unsigned long long p_memstat_idledeadline;
    unsigned long long p_memstat_prio_start;
    unsigned long long p_memstat_idle_delta;
    int p_memstat_memlimit;
    int p_memstat_memlimit_active;
    int p_memstat_memlimit_inactive;
    int p_memstat_relaunch_flags;
    unsigned int p_user_faults;
    unsigned int p_memlimit_increase;
    unsigned long long p_crash_behavior_deadline;
    unsigned int p_crash_count;
    unsigned int p_throttle_timeout;
    struct ks_os_reason *p_exit_reason;
    unsigned long long p_user_data;
    char *p_subsystem_root_path;
};
_Static_assert(offsetof(struct ks_proc, p_pptr) == 0x10, "ks_proc.p_pptr offset");
_Static_assert(offsetof(struct ks_proc, p_proc_ro) == 0x18, "ks_proc.p_proc_ro offset");
_Static_assert(offsetof(struct ks_proc, p_ppid) == 0x20, "ks_proc.p_ppid offset");
_Static_assert(offsetof(struct ks_proc, p_pgrpid) == 0x24, "ks_proc.p_pgrpid offset");
_Static_assert(offsetof(struct ks_proc, p_uid) == 0x28, "ks_proc.p_uid offset");
_Static_assert(offsetof(struct ks_proc, p_gid) == 0x2C, "ks_proc.p_gid offset");
_Static_assert(offsetof(struct ks_proc, p_ruid) == 0x30, "ks_proc.p_ruid offset");
_Static_assert(offsetof(struct ks_proc, p_rgid) == 0x34, "ks_proc.p_rgid offset");
_Static_assert(offsetof(struct ks_proc, p_svuid) == 0x38, "ks_proc.p_svuid offset");
_Static_assert(offsetof(struct ks_proc, p_svgid) == 0x3C, "ks_proc.p_svgid offset");
_Static_assert(offsetof(struct ks_proc, p_sessionid) == 0x40, "ks_proc.p_sessionid offset");
_Static_assert(offsetof(struct ks_proc, p_puniqueid) == 0x48, "ks_proc.p_puniqueid offset");
_Static_assert(offsetof(struct ks_proc, p_mlock) == 0x50, "ks_proc.p_mlock offset");
_Static_assert(offsetof(struct ks_proc, p_pid) == 0x60, "ks_proc.p_pid offset");
_Static_assert(offsetof(struct ks_proc, p_stat) == 0x64, "ks_proc.p_stat offset");
_Static_assert(offsetof(struct ks_proc, p_shutdownstate) == 0x65, "ks_proc.p_shutdownstate offset");
_Static_assert(offsetof(struct ks_proc, p_kdebug) == 0x66, "ks_proc.p_kdebug offset");
_Static_assert(offsetof(struct ks_proc, p_btrace) == 0x67, "ks_proc.p_btrace offset");
_Static_assert(offsetof(struct ks_proc, p_pglist) == 0x68, "ks_proc.p_pglist offset");
_Static_assert(offsetof(struct ks_proc, p_sibling) == 0x78, "ks_proc.p_sibling offset");
_Static_assert(offsetof(struct ks_proc, p_children) == 0x88, "ks_proc.p_children offset");
_Static_assert(offsetof(struct ks_proc, p_uthlist) == 0x90, "ks_proc.p_uthlist offset");
_Static_assert(offsetof(struct ks_proc, p_hash) == 0xA0, "ks_proc.p_hash offset");
_Static_assert(offsetof(struct ks_proc, p_persona) == 0xA8, "ks_proc.p_persona offset");
_Static_assert(offsetof(struct ks_proc, p_persona_list) == 0xB0, "ks_proc.p_persona_list offset");
_Static_assert(offsetof(struct ks_proc, p_ucred_mlock) == 0xC0, "ks_proc.p_ucred_mlock offset");
_Static_assert(offsetof(struct ks_proc, p_audit_mlock) == 0xD0, "ks_proc.p_audit_mlock offset");
_Static_assert(offsetof(struct ks_proc, p_fd) == 0xE0, "ks_proc.p_fd offset");
_Static_assert(offsetof(struct ks_proc, p_stats) == 0x188, "ks_proc.p_stats offset");
_Static_assert(offsetof(struct ks_proc, p_limit) == 0x190, "ks_proc.p_limit offset");
_Static_assert(offsetof(struct ks_proc, p_pgrp) == 0x198, "ks_proc.p_pgrp offset");
_Static_assert(offsetof(struct ks_proc, p_sigacts) == 0x1A0, "ks_proc.p_sigacts offset");
_Static_assert(offsetof(struct ks_proc, p_slock) == 0x450, "ks_proc.p_slock offset");
_Static_assert(offsetof(struct ks_proc, p_siglist) == 0x460, "ks_proc.p_siglist offset");
_Static_assert(offsetof(struct ks_proc, p_flag) == 0x464, "ks_proc.p_flag offset");
_Static_assert(offsetof(struct ks_proc, p_lflag) == 0x468, "ks_proc.p_lflag offset");
_Static_assert(offsetof(struct ks_proc, p_listflag) == 0x46C, "ks_proc.p_listflag offset");
_Static_assert(offsetof(struct ks_proc, p_ladvflag) == 0x470, "ks_proc.p_ladvflag offset");
_Static_assert(offsetof(struct ks_proc, p_refcount) == 0x474, "ks_proc.p_refcount offset");
_Static_assert(offsetof(struct ks_proc, p_waitref) == 0x478, "ks_proc.p_waitref offset");
_Static_assert(offsetof(struct ks_proc, p_childrencnt) == 0x47C, "ks_proc.p_childrencnt offset");
_Static_assert(offsetof(struct ks_proc, p_parentref) == 0x480, "ks_proc.p_parentref offset");
_Static_assert(offsetof(struct ks_proc, p_oppid) == 0x484, "ks_proc.p_oppid offset");
_Static_assert(offsetof(struct ks_proc, p_xstat) == 0x488, "ks_proc.p_xstat offset");
_Static_assert(offsetof(struct ks_proc, p_aio_total_count) == 0x48C, "ks_proc.p_aio_total_count offset");
_Static_assert(offsetof(struct ks_proc, p_realtimer) == 0x490, "ks_proc.p_realtimer offset");
_Static_assert(offsetof(struct ks_proc, p_rtime) == 0x4B0, "ks_proc.p_rtime offset");
_Static_assert(offsetof(struct ks_proc, p_vtimer_user) == 0x4C0, "ks_proc.p_vtimer_user offset");
_Static_assert(offsetof(struct ks_proc, p_vtimer_prof) == 0x4E0, "ks_proc.p_vtimer_prof offset");
_Static_assert(offsetof(struct ks_proc, p_rlim_cpu) == 0x500, "ks_proc.p_rlim_cpu offset");
_Static_assert(offsetof(struct ks_proc, p_debugger) == 0x510, "ks_proc.p_debugger offset");
_Static_assert(offsetof(struct ks_proc, sigwait) == 0x514, "ks_proc.sigwait offset");
_Static_assert(offsetof(struct ks_proc, sigwait_thread) == 0x518, "ks_proc.sigwait_thread offset");
_Static_assert(offsetof(struct ks_proc, exit_thread) == 0x520, "ks_proc.exit_thread offset");
_Static_assert(offsetof(struct ks_proc, si_pid) == 0x528, "ks_proc.si_pid offset");
_Static_assert(offsetof(struct ks_proc, si_status) == 0x52C, "ks_proc.si_status offset");
_Static_assert(offsetof(struct ks_proc, si_code) == 0x530, "ks_proc.si_code offset");
_Static_assert(offsetof(struct ks_proc, si_uid) == 0x534, "ks_proc.si_uid offset");
_Static_assert(offsetof(struct ks_proc, vm_shm) == 0x538, "ks_proc.vm_shm offset");
_Static_assert(offsetof(struct ks_proc, p_ractive) == 0x540, "ks_proc.p_ractive offset");
_Static_assert(offsetof(struct ks_proc, p_responsible_pid) == 0x544, "ks_proc.p_responsible_pid offset");
_Static_assert(offsetof(struct ks_proc, p_dtrace_probes) == 0x548, "ks_proc.p_dtrace_probes offset");
_Static_assert(offsetof(struct ks_proc, p_dtrace_count) == 0x54C, "ks_proc.p_dtrace_count offset");
_Static_assert(offsetof(struct ks_proc, p_dtrace_stop) == 0x550, "ks_proc.p_dtrace_stop offset");
_Static_assert(offsetof(struct ks_proc, p_dtrace_argv) == 0x558, "ks_proc.p_dtrace_argv offset");
_Static_assert(offsetof(struct ks_proc, p_dtrace_envp) == 0x560, "ks_proc.p_dtrace_envp offset");
_Static_assert(offsetof(struct ks_proc, p_dtrace_sprlock) == 0x568, "ks_proc.p_dtrace_sprlock offset");
_Static_assert(offsetof(struct ks_proc, p_dtrace_ptss_pages) == 0x578, "ks_proc.p_dtrace_ptss_pages offset");
_Static_assert(offsetof(struct ks_proc, p_dtrace_ptss_free_list) == 0x580, "ks_proc.p_dtrace_ptss_free_list offset");
_Static_assert(offsetof(struct ks_proc, p_dtrace_helpers) == 0x588, "ks_proc.p_dtrace_helpers offset");
_Static_assert(offsetof(struct ks_proc, p_dtrace_lazy_dofs) == 0x590, "ks_proc.p_dtrace_lazy_dofs offset");
_Static_assert(offsetof(struct ks_proc, p_forkcopy) == 0x598, "ks_proc.p_forkcopy offset");
_Static_assert(offsetof(struct ks_proc, p_aio_activeq) == 0x630, "ks_proc.p_aio_activeq offset");
_Static_assert(offsetof(struct ks_proc, p_aio_doneq) == 0x640, "ks_proc.p_aio_doneq offset");
_Static_assert(offsetof(struct ks_proc, p_klist) == 0x650, "ks_proc.p_klist offset");
_Static_assert(offsetof(struct ks_proc, p_ru) == 0x658, "ks_proc.p_ru offset");
_Static_assert(offsetof(struct ks_proc, p_signalholder) == 0x660, "ks_proc.p_signalholder offset");
_Static_assert(offsetof(struct ks_proc, p_transholder) == 0x668, "ks_proc.p_transholder offset");
_Static_assert(offsetof(struct ks_proc, p_sigwaitcnt) == 0x670, "ks_proc.p_sigwaitcnt offset");
_Static_assert(offsetof(struct ks_proc, p_acflag) == 0x674, "ks_proc.p_acflag offset");
_Static_assert(offsetof(struct ks_proc, p_vfs_iopolicy) == 0x676, "ks_proc.p_vfs_iopolicy offset");
_Static_assert(offsetof(struct ks_proc, p_threadstart) == 0x678, "ks_proc.p_threadstart offset");
_Static_assert(offsetof(struct ks_proc, p_wqthread) == 0x680, "ks_proc.p_wqthread offset");
_Static_assert(offsetof(struct ks_proc, p_pthsize) == 0x688, "ks_proc.p_pthsize offset");
_Static_assert(offsetof(struct ks_proc, p_pth_tsd_offset) == 0x68C, "ks_proc.p_pth_tsd_offset offset");
_Static_assert(offsetof(struct ks_proc, p_stack_addr_hint) == 0x690, "ks_proc.p_stack_addr_hint offset");
_Static_assert(offsetof(struct ks_proc, p_wqptr) == 0x698, "ks_proc.p_wqptr offset");
_Static_assert(offsetof(struct ks_proc, p_aio_wqptr) == 0x6A0, "ks_proc.p_aio_wqptr offset");
_Static_assert(offsetof(struct ks_proc, p_start) == 0x6A8, "ks_proc.p_start offset");
_Static_assert(offsetof(struct ks_proc, p_rcall) == 0x6B8, "ks_proc.p_rcall offset");
_Static_assert(offsetof(struct ks_proc, p_pthhash) == 0x6C0, "ks_proc.p_pthhash offset");
_Static_assert(offsetof(struct ks_proc, was_throttled) == 0x6C8, "ks_proc.was_throttled offset");
_Static_assert(offsetof(struct ks_proc, did_throttle) == 0x6D0, "ks_proc.did_throttle offset");
_Static_assert(offsetof(struct ks_proc, p_dispatchqueue_offset) == 0x6D8, "ks_proc.p_dispatchqueue_offset offset");
_Static_assert(offsetof(struct ks_proc, p_dispatchqueue_serialno_offset) == 0x6E0, "ks_proc.p_dispatchqueue_serialno_offset offset");
_Static_assert(offsetof(struct ks_proc, p_dispatchqueue_label_offset) == 0x6E8, "ks_proc.p_dispatchqueue_label_offset offset");
_Static_assert(offsetof(struct ks_proc, p_return_to_kernel_offset) == 0x6F0, "ks_proc.p_return_to_kernel_offset offset");
_Static_assert(offsetof(struct ks_proc, p_mach_thread_self_offset) == 0x6F8, "ks_proc.p_mach_thread_self_offset offset");
_Static_assert(offsetof(struct ks_proc, p_pthread_wq_quantum_offset) == 0x700, "ks_proc.p_pthread_wq_quantum_offset offset");
_Static_assert(offsetof(struct ks_proc, vm_pressure_last_notify_tstamp) == 0x708, "ks_proc.vm_pressure_last_notify_tstamp offset");
_Static_assert(offsetof(struct ks_proc, p_crash_behavior) == 0x718, "ks_proc.p_crash_behavior offset");
_Static_assert(offsetof(struct ks_proc, p_posix_spawn_failed) == 0x719, "ks_proc.p_posix_spawn_failed offset");
_Static_assert(offsetof(struct ks_proc, p_disallow_map_with_linking) == 0x71A, "ks_proc.p_disallow_map_with_linking offset");
_Static_assert(offsetof(struct ks_proc, p_memstat_state) == 0x71C, "ks_proc.p_memstat_state offset");
_Static_assert(offsetof(struct ks_proc, p_memstat_effectivepriority) == 0x720, "ks_proc.p_memstat_effectivepriority offset");
_Static_assert(offsetof(struct ks_proc, p_memstat_requestedpriority) == 0x724, "ks_proc.p_memstat_requestedpriority offset");
_Static_assert(offsetof(struct ks_proc, p_memstat_assertionpriority) == 0x728, "ks_proc.p_memstat_assertionpriority offset");
_Static_assert(offsetof(struct ks_proc, p_memstat_dirty) == 0x72C, "ks_proc.p_memstat_dirty offset");
_Static_assert(offsetof(struct ks_proc, p_memstat_list) == 0x730, "ks_proc.p_memstat_list offset");
_Static_assert(offsetof(struct ks_proc, p_memstat_userdata) == 0x740, "ks_proc.p_memstat_userdata offset");
_Static_assert(offsetof(struct ks_proc, p_memstat_idledeadline) == 0x748, "ks_proc.p_memstat_idledeadline offset");
_Static_assert(offsetof(struct ks_proc, p_memstat_prio_start) == 0x750, "ks_proc.p_memstat_prio_start offset");
_Static_assert(offsetof(struct ks_proc, p_memstat_idle_delta) == 0x758, "ks_proc.p_memstat_idle_delta offset");
_Static_assert(offsetof(struct ks_proc, p_memstat_memlimit) == 0x760, "ks_proc.p_memstat_memlimit offset");
_Static_assert(offsetof(struct ks_proc, p_memstat_memlimit_active) == 0x764, "ks_proc.p_memstat_memlimit_active offset");
_Static_assert(offsetof(struct ks_proc, p_memstat_memlimit_inactive) == 0x768, "ks_proc.p_memstat_memlimit_inactive offset");
_Static_assert(offsetof(struct ks_proc, p_memstat_relaunch_flags) == 0x76C, "ks_proc.p_memstat_relaunch_flags offset");
_Static_assert(offsetof(struct ks_proc, p_user_faults) == 0x770, "ks_proc.p_user_faults offset");
_Static_assert(offsetof(struct ks_proc, p_memlimit_increase) == 0x774, "ks_proc.p_memlimit_increase offset");
_Static_assert(offsetof(struct ks_proc, p_crash_behavior_deadline) == 0x778, "ks_proc.p_crash_behavior_deadline offset");
_Static_assert(offsetof(struct ks_proc, p_crash_count) == 0x780, "ks_proc.p_crash_count offset");
_Static_assert(offsetof(struct ks_proc, p_throttle_timeout) == 0x784, "ks_proc.p_throttle_timeout offset");
_Static_assert(offsetof(struct ks_proc, p_exit_reason) == 0x788, "ks_proc.p_exit_reason offset");
_Static_assert(offsetof(struct ks_proc, p_user_data) == 0x790, "ks_proc.p_user_data offset");
_Static_assert(offsetof(struct ks_proc, p_subsystem_root_path) == 0x798, "ks_proc.p_subsystem_root_path offset");
_Static_assert(sizeof(struct ks_proc) == 0x7A0, "ks_proc size");

/* refs: 1 */
struct ks_proc_platform_ro_data {
    unsigned int p_platform;
    unsigned int p_min_sdk;
    unsigned int p_sdk;
};
_Static_assert(offsetof(struct ks_proc_platform_ro_data, p_platform) == 0x0, "ks_proc_platform_ro_data.p_platform offset");
_Static_assert(offsetof(struct ks_proc_platform_ro_data, p_min_sdk) == 0x4, "ks_proc_platform_ro_data.p_min_sdk offset");
_Static_assert(offsetof(struct ks_proc_platform_ro_data, p_sdk) == 0x8, "ks_proc_platform_ro_data.p_sdk offset");
_Static_assert(sizeof(struct ks_proc_platform_ro_data) == 0xC, "ks_proc_platform_ro_data size");

/* refs: 1 */
struct ks_proc_ro_data {
    unsigned long long p_uniqueid;
    int p_idversion;
    int p_orig_ppid;
    int p_orig_ppidversion;
    unsigned int p_csflags;
    struct {
        volatile struct ks_ucred *__smr_ptr;
    } p_ucred;
    unsigned char *syscall_filter_mask;
    struct ks_proc_platform_ro_data p_platform_data;
};
_Static_assert(offsetof(struct ks_proc_ro_data, p_uniqueid) == 0x0, "ks_proc_ro_data.p_uniqueid offset");
_Static_assert(offsetof(struct ks_proc_ro_data, p_idversion) == 0x8, "ks_proc_ro_data.p_idversion offset");
_Static_assert(offsetof(struct ks_proc_ro_data, p_orig_ppid) == 0xC, "ks_proc_ro_data.p_orig_ppid offset");
_Static_assert(offsetof(struct ks_proc_ro_data, p_orig_ppidversion) == 0x10, "ks_proc_ro_data.p_orig_ppidversion offset");
_Static_assert(offsetof(struct ks_proc_ro_data, p_csflags) == 0x14, "ks_proc_ro_data.p_csflags offset");
_Static_assert(offsetof(struct ks_proc_ro_data, p_ucred) == 0x18, "ks_proc_ro_data.p_ucred offset");
_Static_assert(offsetof(struct ks_proc_ro_data, syscall_filter_mask) == 0x20, "ks_proc_ro_data.syscall_filter_mask offset");
_Static_assert(offsetof(struct ks_proc_ro_data, p_platform_data) == 0x28, "ks_proc_ro_data.p_platform_data offset");
_Static_assert(sizeof(struct ks_proc_ro_data) == 0x38, "ks_proc_ro_data size");

/* refs: 1 */
struct ks_task_filter_ro_data {
    unsigned char *mach_trap_filter_mask;
    unsigned char *mach_kobj_filter_mask;
};
_Static_assert(offsetof(struct ks_task_filter_ro_data, mach_trap_filter_mask) == 0x0, "ks_task_filter_ro_data.mach_trap_filter_mask offset");
_Static_assert(offsetof(struct ks_task_filter_ro_data, mach_kobj_filter_mask) == 0x8, "ks_task_filter_ro_data.mach_kobj_filter_mask offset");
_Static_assert(sizeof(struct ks_task_filter_ro_data) == 0x10, "ks_task_filter_ro_data size");

/* refs: 2 */
struct ks_security_token_t {
    unsigned int val[2];
} __attribute__((aligned(4)));
_Static_assert(offsetof(struct ks_security_token_t, val) == 0x0, "ks_security_token_t.val offset");
_Static_assert(sizeof(struct ks_security_token_t) == 0x8, "ks_security_token_t size");

/* refs: 1 */
struct ks_task_token_ro_data {
    struct ks_security_token_t sec_token __attribute__((aligned(4)));
    struct ks_audit_token_t audit_token __attribute__((aligned(4)));
};
_Static_assert(offsetof(struct ks_task_token_ro_data, sec_token) == 0x0, "ks_task_token_ro_data.sec_token offset");
_Static_assert(offsetof(struct ks_task_token_ro_data, audit_token) == 0x8, "ks_task_token_ro_data.audit_token offset");
_Static_assert(sizeof(struct ks_task_token_ro_data) == 0x28, "ks_task_token_ro_data size");

/* refs: 1 */
struct ks_task_ro_data {
    struct ks_task_token_ro_data task_tokens;
    struct ks_task_filter_ro_data task_filters;
    unsigned int t_flags_ro;
    unsigned char task_control_port_options;
};
_Static_assert(offsetof(struct ks_task_ro_data, task_tokens) == 0x0, "ks_task_ro_data.task_tokens offset");
_Static_assert(offsetof(struct ks_task_ro_data, task_filters) == 0x28, "ks_task_ro_data.task_filters offset");
_Static_assert(offsetof(struct ks_task_ro_data, t_flags_ro) == 0x38, "ks_task_ro_data.t_flags_ro offset");
_Static_assert(offsetof(struct ks_task_ro_data, task_control_port_options) == 0x3C, "ks_task_ro_data.task_control_port_options offset");
_Static_assert(sizeof(struct ks_task_ro_data) == 0x40, "ks_task_ro_data size");

/* refs: 3 */
struct ks_proc_ro {
    struct ks_proc *pr_proc;
    struct ks_task *pr_task;
    struct ks_proc_ro_data proc_data;
    struct ks_task_ro_data task_data;
};
_Static_assert(offsetof(struct ks_proc_ro, pr_proc) == 0x0, "ks_proc_ro.pr_proc offset");
_Static_assert(offsetof(struct ks_proc_ro, pr_task) == 0x8, "ks_proc_ro.pr_task offset");
_Static_assert(offsetof(struct ks_proc_ro, proc_data) == 0x10, "ks_proc_ro.proc_data offset");
_Static_assert(offsetof(struct ks_proc_ro, task_data) == 0x48, "ks_proc_ro.task_data offset");
_Static_assert(sizeof(struct ks_proc_ro) == 0x88, "ks_proc_ro size");

/* refs: 2 */
struct ks_rt_queue_pri_t {
    struct ks_queue_entry pri_queue;
    unsigned long long pri_earliest_deadline;
    int pri_count;
    unsigned int pri_constraint;
};
_Static_assert(offsetof(struct ks_rt_queue_pri_t, pri_queue) == 0x0, "ks_rt_queue_pri_t.pri_queue offset");
_Static_assert(offsetof(struct ks_rt_queue_pri_t, pri_earliest_deadline) == 0x10, "ks_rt_queue_pri_t.pri_earliest_deadline offset");
_Static_assert(offsetof(struct ks_rt_queue_pri_t, pri_count) == 0x18, "ks_rt_queue_pri_t.pri_count offset");
_Static_assert(offsetof(struct ks_rt_queue_pri_t, pri_constraint) == 0x1C, "ks_rt_queue_pri_t.pri_constraint offset");
_Static_assert(sizeof(struct ks_rt_queue_pri_t) == 0x20, "ks_rt_queue_pri_t size");

/* refs: 2 */
struct ks_runq_stats {
    unsigned long long count_sum;
    unsigned long long last_change_timestamp;
};
_Static_assert(offsetof(struct ks_runq_stats, count_sum) == 0x0, "ks_runq_stats.count_sum offset");
_Static_assert(offsetof(struct ks_runq_stats, last_change_timestamp) == 0x8, "ks_runq_stats.last_change_timestamp offset");
_Static_assert(sizeof(struct ks_runq_stats) == 0x10, "ks_runq_stats size");

/* refs: 1 */
struct ks_rt_queue {
    unsigned long long earliest_deadline;
    _Atomic int count;
    unsigned int constraint;
    _Atomic int ed_index;
    unsigned long long bitmap[1];
    struct ks_rt_queue_pri_t rt_queue_pri[0x1F];
    struct ks_runq_stats runq_stats;
};
_Static_assert(offsetof(struct ks_rt_queue, earliest_deadline) == 0x0, "ks_rt_queue.earliest_deadline offset");
_Static_assert(offsetof(struct ks_rt_queue, count) == 0x8, "ks_rt_queue.count offset");
_Static_assert(offsetof(struct ks_rt_queue, constraint) == 0xC, "ks_rt_queue.constraint offset");
_Static_assert(offsetof(struct ks_rt_queue, ed_index) == 0x10, "ks_rt_queue.ed_index offset");
_Static_assert(offsetof(struct ks_rt_queue, bitmap) == 0x18, "ks_rt_queue.bitmap offset");
_Static_assert(offsetof(struct ks_rt_queue, rt_queue_pri) == 0x20, "ks_rt_queue.rt_queue_pri offset");
_Static_assert(offsetof(struct ks_rt_queue, runq_stats) == 0x400, "ks_rt_queue.runq_stats offset");
_Static_assert(sizeof(struct ks_rt_queue) == 0x410, "ks_rt_queue size");

/* refs: 2 */
struct ks_run_queue {
    int highq;
    unsigned long long bitmap[2];
    int count;
    int urgency;
    struct ks_circle_queue_head queues[0x60];
    struct ks_runq_stats runq_stats;
};
_Static_assert(offsetof(struct ks_run_queue, highq) == 0x0, "ks_run_queue.highq offset");
_Static_assert(offsetof(struct ks_run_queue, bitmap) == 0x8, "ks_run_queue.bitmap offset");
_Static_assert(offsetof(struct ks_run_queue, count) == 0x18, "ks_run_queue.count offset");
_Static_assert(offsetof(struct ks_run_queue, urgency) == 0x1C, "ks_run_queue.urgency offset");
_Static_assert(offsetof(struct ks_run_queue, queues) == 0x20, "ks_run_queue.queues offset");
_Static_assert(offsetof(struct ks_run_queue, runq_stats) == 0x320, "ks_run_queue.runq_stats offset");
_Static_assert(sizeof(struct ks_run_queue) == 0x330, "ks_run_queue size");

/* refs: 1 */
struct ks_sched_clutch_bucket_runq {
    int scbrq_highq;
    int scbrq_count;
    unsigned long long scbrq_bitmap[2];
    struct ks_circle_queue_head scbrq_queues[0x80];
};
_Static_assert(offsetof(struct ks_sched_clutch_bucket_runq, scbrq_highq) == 0x0, "ks_sched_clutch_bucket_runq.scbrq_highq offset");
_Static_assert(offsetof(struct ks_sched_clutch_bucket_runq, scbrq_count) == 0x4, "ks_sched_clutch_bucket_runq.scbrq_count offset");
_Static_assert(offsetof(struct ks_sched_clutch_bucket_runq, scbrq_bitmap) == 0x8, "ks_sched_clutch_bucket_runq.scbrq_bitmap offset");
_Static_assert(offsetof(struct ks_sched_clutch_bucket_runq, scbrq_queues) == 0x18, "ks_sched_clutch_bucket_runq.scbrq_queues offset");
_Static_assert(sizeof(struct ks_sched_clutch_bucket_runq) == 0x418, "ks_sched_clutch_bucket_runq size");

/* refs: 2 */
struct ks_sched_clutch_root_bucket {
    unsigned char scrb_bucket;
    _Bool scrb_bound;
    _Bool scrb_starvation_avoidance;
    union {
        struct ks_sched_clutch_bucket_runq scrb_clutch_buckets;
        struct ks_run_queue scrb_bound_thread_runq;
    };
    struct ks_priority_queue_entry_deadline scrb_pqlink;
    unsigned long long scrb_warped_deadline;
    unsigned long long scrb_warp_remaining;
    unsigned long long scrb_starvation_ts;
};
_Static_assert(offsetof(struct ks_sched_clutch_root_bucket, scrb_bucket) == 0x0, "ks_sched_clutch_root_bucket.scrb_bucket offset");
_Static_assert(offsetof(struct ks_sched_clutch_root_bucket, scrb_bound) == 0x1, "ks_sched_clutch_root_bucket.scrb_bound offset");
_Static_assert(offsetof(struct ks_sched_clutch_root_bucket, scrb_starvation_avoidance) == 0x2, "ks_sched_clutch_root_bucket.scrb_starvation_avoidance offset");
_Static_assert(offsetof(struct ks_sched_clutch_root_bucket, scrb_pqlink) == 0x420, "ks_sched_clutch_root_bucket.scrb_pqlink offset");
_Static_assert(offsetof(struct ks_sched_clutch_root_bucket, scrb_warped_deadline) == 0x440, "ks_sched_clutch_root_bucket.scrb_warped_deadline offset");
_Static_assert(offsetof(struct ks_sched_clutch_root_bucket, scrb_warp_remaining) == 0x448, "ks_sched_clutch_root_bucket.scrb_warp_remaining offset");
_Static_assert(offsetof(struct ks_sched_clutch_root_bucket, scrb_starvation_ts) == 0x450, "ks_sched_clutch_root_bucket.scrb_starvation_ts offset");
_Static_assert(sizeof(struct ks_sched_clutch_root_bucket) == 0x458, "ks_sched_clutch_root_bucket size");

/* refs: 2 */
struct ks_sched_clutch_root {
    short scr_priority;
    unsigned short scr_thr_count;
    short scr_urgency;
    unsigned short scr_shared_rsrc_load_runnable[2];
    unsigned int scr_cluster_id;
    struct ks_processor_set *scr_pset;
    struct ks_queue_entry scr_clutch_buckets;
    struct ks_priority_queue_sched_max scr_foreign_buckets;
    unsigned long long scr_unbound_runnable_bitmap[1];
    unsigned long long scr_unbound_warp_available[1];
    unsigned long long scr_bound_runnable_bitmap[1];
    unsigned long long scr_bound_warp_available[1];
    struct ks_priority_queue_deadline_min scr_unbound_root_buckets;
    struct ks_priority_queue_deadline_min scr_bound_root_buckets;
    unsigned short scr_cumulative_run_count[6];
    struct ks_sched_clutch_root_bucket scr_unbound_buckets[6];
    struct ks_sched_clutch_root_bucket scr_bound_buckets[6];
};
_Static_assert(offsetof(struct ks_sched_clutch_root, scr_priority) == 0x0, "ks_sched_clutch_root.scr_priority offset");
_Static_assert(offsetof(struct ks_sched_clutch_root, scr_thr_count) == 0x2, "ks_sched_clutch_root.scr_thr_count offset");
_Static_assert(offsetof(struct ks_sched_clutch_root, scr_urgency) == 0x4, "ks_sched_clutch_root.scr_urgency offset");
_Static_assert(offsetof(struct ks_sched_clutch_root, scr_shared_rsrc_load_runnable) == 0x6, "ks_sched_clutch_root.scr_shared_rsrc_load_runnable offset");
_Static_assert(offsetof(struct ks_sched_clutch_root, scr_cluster_id) == 0xC, "ks_sched_clutch_root.scr_cluster_id offset");
_Static_assert(offsetof(struct ks_sched_clutch_root, scr_pset) == 0x10, "ks_sched_clutch_root.scr_pset offset");
_Static_assert(offsetof(struct ks_sched_clutch_root, scr_clutch_buckets) == 0x18, "ks_sched_clutch_root.scr_clutch_buckets offset");
_Static_assert(offsetof(struct ks_sched_clutch_root, scr_foreign_buckets) == 0x28, "ks_sched_clutch_root.scr_foreign_buckets offset");
_Static_assert(offsetof(struct ks_sched_clutch_root, scr_unbound_runnable_bitmap) == 0x30, "ks_sched_clutch_root.scr_unbound_runnable_bitmap offset");
_Static_assert(offsetof(struct ks_sched_clutch_root, scr_unbound_warp_available) == 0x38, "ks_sched_clutch_root.scr_unbound_warp_available offset");
_Static_assert(offsetof(struct ks_sched_clutch_root, scr_bound_runnable_bitmap) == 0x40, "ks_sched_clutch_root.scr_bound_runnable_bitmap offset");
_Static_assert(offsetof(struct ks_sched_clutch_root, scr_bound_warp_available) == 0x48, "ks_sched_clutch_root.scr_bound_warp_available offset");
_Static_assert(offsetof(struct ks_sched_clutch_root, scr_unbound_root_buckets) == 0x50, "ks_sched_clutch_root.scr_unbound_root_buckets offset");
_Static_assert(offsetof(struct ks_sched_clutch_root, scr_bound_root_buckets) == 0x58, "ks_sched_clutch_root.scr_bound_root_buckets offset");
_Static_assert(offsetof(struct ks_sched_clutch_root, scr_cumulative_run_count) == 0x60, "ks_sched_clutch_root.scr_cumulative_run_count offset");
_Static_assert(offsetof(struct ks_sched_clutch_root, scr_unbound_buckets) == 0x70, "ks_sched_clutch_root.scr_unbound_buckets offset");
_Static_assert(offsetof(struct ks_sched_clutch_root, scr_bound_buckets) == 0x1A80, "ks_sched_clutch_root.scr_bound_buckets offset");
_Static_assert(sizeof(struct ks_sched_clutch_root) == 0x3490, "ks_sched_clutch_root size");

/* refs: 2 */
union ks_pset_execution_time_t {
    struct {
        unsigned long long pset_avg_thread_execution_time;
        unsigned long long pset_execution_time_last_update;
    };
    unsigned __int128 pset_execution_time_packed;
};
_Static_assert(offsetof(union ks_pset_execution_time_t, pset_execution_time_packed) == 0x0, "ks_pset_execution_time_t.pset_execution_time_packed offset");

/* refs: 3 */
union ks_sched_clutch_edge {
    struct {
        unsigned int sce_migration_allowed : 1; /* bit offset 0 */
        unsigned int sce_steal_allowed : 1; /* bit offset 1 */
        unsigned int _reserved : 30; /* bit offset 2 */
        unsigned int sce_migration_weight;
    };
    unsigned long long sce_edge_packed;
};
_Static_assert(offsetof(union ks_sched_clutch_edge, sce_edge_packed) == 0x0, "ks_sched_clutch_edge.sce_edge_packed offset");

/* refs: 4 */
union ks_sched_pset_search_order_t {
    unsigned char spso_search_order[1];
    unsigned __int128 spso_packed;
};
_Static_assert(offsetof(union ks_sched_pset_search_order_t, spso_search_order) == 0x0, "ks_sched_pset_search_order_t.spso_search_order offset");
_Static_assert(offsetof(union ks_sched_pset_search_order_t, spso_packed) == 0x0, "ks_sched_pset_search_order_t.spso_packed offset");

/* refs: 4 */
struct ks_processor_set {
    int pset_id;
    int online_processor_count;
    int cpu_set_low;
    int cpu_set_hi;
    int cpu_set_count;
    int last_chosen;
    unsigned long long pset_load_average[6];
    unsigned int pset_runnable_depth[6];
    unsigned long long pset_load_last_update;
    unsigned long long cpu_bitmask;
    unsigned long long recommended_bitmask;
    unsigned long long cpu_state_map[7];
    unsigned long long realtime_map;
    unsigned long long cpu_available_map;
    struct ks_lck_ticket_s sched_lock __attribute__((aligned(128)));
    struct ks_run_queue pset_runq;
    struct ks_rt_queue rt_runq;
    unsigned long long stealable_rt_threads_earliest_deadline;
    struct ks_sched_clutch_root pset_clutch_root;
    unsigned long long pending_AST_URGENT_cpu_mask;
    unsigned long long pending_AST_PREEMPT_cpu_mask;
    unsigned long long pending_deferred_AST_cpu_mask;
    unsigned long long pending_spill_cpu_mask;
    unsigned long long rt_pending_spill_cpu_mask;
    struct ks_ipc_port *pset_self;
    struct ks_ipc_port *pset_name_self;
    struct ks_processor_set *pset_list;
    struct ks_pset_node *node;
    unsigned int pset_cluster_id;
    unsigned int pset_cluster_type;
    int pset_type;
    unsigned long long cpu_running_foreign;
    unsigned long long cpu_running_cluster_shared_rsrc_thread[2];
    unsigned int cpu_running_buckets[8];
    unsigned long long foreign_psets[1];
    unsigned long long native_psets[1];
    unsigned long long local_psets[1];
    unsigned long long remote_psets[1];
    union ks_pset_execution_time_t pset_execution_time[6];
    unsigned long long pset_cluster_shared_rsrc_load[2];
    union ks_sched_clutch_edge sched_edges[2][6];
    union ks_sched_pset_search_order_t spill_search_order[6];
    unsigned char max_parallel_cores[6];
    unsigned char max_parallel_clusters[6];
    union ks_sched_clutch_edge sched_rt_edges[2];
    union ks_sched_pset_search_order_t sched_rt_spill_search_order;
    union ks_sched_pset_search_order_t sched_rt_steal_search_order;
    unsigned long long perfcontrol_cpu_preferred_bitmask;
    unsigned long long perfcontrol_cpu_migration_bitmask;
    int cpu_preferred_last_chosen;
};
_Static_assert(offsetof(struct ks_processor_set, pset_id) == 0x0, "ks_processor_set.pset_id offset");
_Static_assert(offsetof(struct ks_processor_set, online_processor_count) == 0x4, "ks_processor_set.online_processor_count offset");
_Static_assert(offsetof(struct ks_processor_set, cpu_set_low) == 0x8, "ks_processor_set.cpu_set_low offset");
_Static_assert(offsetof(struct ks_processor_set, cpu_set_hi) == 0xC, "ks_processor_set.cpu_set_hi offset");
_Static_assert(offsetof(struct ks_processor_set, cpu_set_count) == 0x10, "ks_processor_set.cpu_set_count offset");
_Static_assert(offsetof(struct ks_processor_set, last_chosen) == 0x14, "ks_processor_set.last_chosen offset");
_Static_assert(offsetof(struct ks_processor_set, pset_load_average) == 0x18, "ks_processor_set.pset_load_average offset");
_Static_assert(offsetof(struct ks_processor_set, pset_runnable_depth) == 0x48, "ks_processor_set.pset_runnable_depth offset");
_Static_assert(offsetof(struct ks_processor_set, pset_load_last_update) == 0x60, "ks_processor_set.pset_load_last_update offset");
_Static_assert(offsetof(struct ks_processor_set, cpu_bitmask) == 0x68, "ks_processor_set.cpu_bitmask offset");
_Static_assert(offsetof(struct ks_processor_set, recommended_bitmask) == 0x70, "ks_processor_set.recommended_bitmask offset");
_Static_assert(offsetof(struct ks_processor_set, cpu_state_map) == 0x78, "ks_processor_set.cpu_state_map offset");
_Static_assert(offsetof(struct ks_processor_set, realtime_map) == 0xB0, "ks_processor_set.realtime_map offset");
_Static_assert(offsetof(struct ks_processor_set, cpu_available_map) == 0xB8, "ks_processor_set.cpu_available_map offset");
_Static_assert(offsetof(struct ks_processor_set, sched_lock) == 0x100, "ks_processor_set.sched_lock offset");
_Static_assert(offsetof(struct ks_processor_set, pset_runq) == 0x110, "ks_processor_set.pset_runq offset");
_Static_assert(offsetof(struct ks_processor_set, rt_runq) == 0x440, "ks_processor_set.rt_runq offset");
_Static_assert(offsetof(struct ks_processor_set, stealable_rt_threads_earliest_deadline) == 0x850, "ks_processor_set.stealable_rt_threads_earliest_deadline offset");
_Static_assert(offsetof(struct ks_processor_set, pset_clutch_root) == 0x858, "ks_processor_set.pset_clutch_root offset");
_Static_assert(offsetof(struct ks_processor_set, pending_AST_URGENT_cpu_mask) == 0x3CE8, "ks_processor_set.pending_AST_URGENT_cpu_mask offset");
_Static_assert(offsetof(struct ks_processor_set, pending_AST_PREEMPT_cpu_mask) == 0x3CF0, "ks_processor_set.pending_AST_PREEMPT_cpu_mask offset");
_Static_assert(offsetof(struct ks_processor_set, pending_deferred_AST_cpu_mask) == 0x3CF8, "ks_processor_set.pending_deferred_AST_cpu_mask offset");
_Static_assert(offsetof(struct ks_processor_set, pending_spill_cpu_mask) == 0x3D00, "ks_processor_set.pending_spill_cpu_mask offset");
_Static_assert(offsetof(struct ks_processor_set, rt_pending_spill_cpu_mask) == 0x3D08, "ks_processor_set.rt_pending_spill_cpu_mask offset");
_Static_assert(offsetof(struct ks_processor_set, pset_self) == 0x3D10, "ks_processor_set.pset_self offset");
_Static_assert(offsetof(struct ks_processor_set, pset_name_self) == 0x3D18, "ks_processor_set.pset_name_self offset");
_Static_assert(offsetof(struct ks_processor_set, pset_list) == 0x3D20, "ks_processor_set.pset_list offset");
_Static_assert(offsetof(struct ks_processor_set, node) == 0x3D28, "ks_processor_set.node offset");
_Static_assert(offsetof(struct ks_processor_set, pset_cluster_id) == 0x3D30, "ks_processor_set.pset_cluster_id offset");
_Static_assert(offsetof(struct ks_processor_set, pset_cluster_type) == 0x3D34, "ks_processor_set.pset_cluster_type offset");
_Static_assert(offsetof(struct ks_processor_set, pset_type) == 0x3D38, "ks_processor_set.pset_type offset");
_Static_assert(offsetof(struct ks_processor_set, cpu_running_foreign) == 0x3D40, "ks_processor_set.cpu_running_foreign offset");
_Static_assert(offsetof(struct ks_processor_set, cpu_running_cluster_shared_rsrc_thread) == 0x3D48, "ks_processor_set.cpu_running_cluster_shared_rsrc_thread offset");
_Static_assert(offsetof(struct ks_processor_set, cpu_running_buckets) == 0x3D58, "ks_processor_set.cpu_running_buckets offset");
_Static_assert(offsetof(struct ks_processor_set, foreign_psets) == 0x3D78, "ks_processor_set.foreign_psets offset");
_Static_assert(offsetof(struct ks_processor_set, native_psets) == 0x3D80, "ks_processor_set.native_psets offset");
_Static_assert(offsetof(struct ks_processor_set, local_psets) == 0x3D88, "ks_processor_set.local_psets offset");
_Static_assert(offsetof(struct ks_processor_set, remote_psets) == 0x3D90, "ks_processor_set.remote_psets offset");
_Static_assert(offsetof(struct ks_processor_set, pset_execution_time) == 0x3DA0, "ks_processor_set.pset_execution_time offset");
_Static_assert(offsetof(struct ks_processor_set, pset_cluster_shared_rsrc_load) == 0x3E00, "ks_processor_set.pset_cluster_shared_rsrc_load offset");
_Static_assert(offsetof(struct ks_processor_set, sched_edges) == 0x3E10, "ks_processor_set.sched_edges offset");
_Static_assert(offsetof(struct ks_processor_set, spill_search_order) == 0x3E70, "ks_processor_set.spill_search_order offset");
_Static_assert(offsetof(struct ks_processor_set, max_parallel_cores) == 0x3ED0, "ks_processor_set.max_parallel_cores offset");
_Static_assert(offsetof(struct ks_processor_set, max_parallel_clusters) == 0x3ED6, "ks_processor_set.max_parallel_clusters offset");
_Static_assert(offsetof(struct ks_processor_set, sched_rt_edges) == 0x3EE0, "ks_processor_set.sched_rt_edges offset");
_Static_assert(offsetof(struct ks_processor_set, sched_rt_spill_search_order) == 0x3EF0, "ks_processor_set.sched_rt_spill_search_order offset");
_Static_assert(offsetof(struct ks_processor_set, sched_rt_steal_search_order) == 0x3F00, "ks_processor_set.sched_rt_steal_search_order offset");
_Static_assert(offsetof(struct ks_processor_set, perfcontrol_cpu_preferred_bitmask) == 0x3F10, "ks_processor_set.perfcontrol_cpu_preferred_bitmask offset");
_Static_assert(offsetof(struct ks_processor_set, perfcontrol_cpu_migration_bitmask) == 0x3F18, "ks_processor_set.perfcontrol_cpu_migration_bitmask offset");
_Static_assert(offsetof(struct ks_processor_set, cpu_preferred_last_chosen) == 0x3F20, "ks_processor_set.cpu_preferred_last_chosen offset");
_Static_assert(sizeof(struct ks_processor_set) == 0x3F80, "ks_processor_set size");

/* refs: 1 */
struct ks_proto_hash_entry {
    struct ks_if_proto *slh_first;
};
_Static_assert(offsetof(struct ks_proto_hash_entry, slh_first) == 0x0, "ks_proto_hash_entry.slh_first offset");
_Static_assert(sizeof(struct ks_proto_hash_entry) == 0x8, "ks_proto_hash_entry size");

/* refs: 6 */
struct ks_protosw {
    struct {
        struct ks_protosw *tqe_next;
        struct ks_protosw **tqe_prev;
    } pr_entry;
    struct ks_domain *pr_domain;
    struct ks_protosw *pr_protosw;
    unsigned short pr_type;
    unsigned short pr_protocol;
    unsigned int pr_flags;
    void *pr_input;
    int *pr_output;
    void *pr_ctlinput;
    int *pr_ctloutput;
    struct ks_pr_usrreqs *pr_usrreqs;
    void *pr_init;
    void *pr_drain;
    int *pr_lock;
    int *pr_unlock;
    struct ks_lck_mtx_s **pr_getlock;
    struct {
        struct ks_socket_filter *tqh_first;
        struct ks_socket_filter **tqh_last;
    } pr_filter_head;
    struct ks_protosw_old *pr_old;
    void *pr_update_last_owner;
    void *pr_copy_last_owner;
    struct ks_mem_acct *pr_mem_acct;
};
_Static_assert(offsetof(struct ks_protosw, pr_entry) == 0x0, "ks_protosw.pr_entry offset");
_Static_assert(offsetof(struct ks_protosw, pr_domain) == 0x10, "ks_protosw.pr_domain offset");
_Static_assert(offsetof(struct ks_protosw, pr_protosw) == 0x18, "ks_protosw.pr_protosw offset");
_Static_assert(offsetof(struct ks_protosw, pr_type) == 0x20, "ks_protosw.pr_type offset");
_Static_assert(offsetof(struct ks_protosw, pr_protocol) == 0x22, "ks_protosw.pr_protocol offset");
_Static_assert(offsetof(struct ks_protosw, pr_flags) == 0x24, "ks_protosw.pr_flags offset");
_Static_assert(offsetof(struct ks_protosw, pr_input) == 0x28, "ks_protosw.pr_input offset");
_Static_assert(offsetof(struct ks_protosw, pr_output) == 0x30, "ks_protosw.pr_output offset");
_Static_assert(offsetof(struct ks_protosw, pr_ctlinput) == 0x38, "ks_protosw.pr_ctlinput offset");
_Static_assert(offsetof(struct ks_protosw, pr_ctloutput) == 0x40, "ks_protosw.pr_ctloutput offset");
_Static_assert(offsetof(struct ks_protosw, pr_usrreqs) == 0x48, "ks_protosw.pr_usrreqs offset");
_Static_assert(offsetof(struct ks_protosw, pr_init) == 0x50, "ks_protosw.pr_init offset");
_Static_assert(offsetof(struct ks_protosw, pr_drain) == 0x58, "ks_protosw.pr_drain offset");
_Static_assert(offsetof(struct ks_protosw, pr_lock) == 0x60, "ks_protosw.pr_lock offset");
_Static_assert(offsetof(struct ks_protosw, pr_unlock) == 0x68, "ks_protosw.pr_unlock offset");
_Static_assert(offsetof(struct ks_protosw, pr_getlock) == 0x70, "ks_protosw.pr_getlock offset");
_Static_assert(offsetof(struct ks_protosw, pr_filter_head) == 0x78, "ks_protosw.pr_filter_head offset");
_Static_assert(offsetof(struct ks_protosw, pr_old) == 0x88, "ks_protosw.pr_old offset");
_Static_assert(offsetof(struct ks_protosw, pr_update_last_owner) == 0x90, "ks_protosw.pr_update_last_owner offset");
_Static_assert(offsetof(struct ks_protosw, pr_copy_last_owner) == 0x98, "ks_protosw.pr_copy_last_owner offset");
_Static_assert(offsetof(struct ks_protosw, pr_mem_acct) == 0xA0, "ks_protosw.pr_mem_acct offset");
_Static_assert(sizeof(struct ks_protosw) == 0xA8, "ks_protosw size");

/* refs: 2 */
#pragma pack(push, 4)
struct ks_protosw_old {
    short pr_type;
    struct ks_domain *pr_domain;
    short pr_protocol;
    unsigned int pr_flags;
    void *pr_input;
    int *pr_output;
    void *pr_ctlinput;
    int *pr_ctloutput;
    void *pr_ousrreq;
    void *pr_init;
    void *pr_unused;
    void *pr_unused2;
    void *pr_drain;
    int *pr_sysctl;
    struct ks_pr_usrreqs_old *pr_usrreqs;
    int *pr_lock;
    int *pr_unlock;
    struct ks_lck_mtx_s **pr_getlock;
    struct {
        struct ks_socket_filter *tqh_first;
        struct ks_socket_filter **tqh_last;
    } pr_filter_head __attribute__((aligned(4)));
    struct ks_protosw_old *pr_next;
    unsigned int reserved[1];
};
#pragma pack(pop)
_Static_assert(offsetof(struct ks_protosw_old, pr_type) == 0x0, "ks_protosw_old.pr_type offset");
_Static_assert(offsetof(struct ks_protosw_old, pr_domain) == 0x4, "ks_protosw_old.pr_domain offset");
_Static_assert(offsetof(struct ks_protosw_old, pr_protocol) == 0xC, "ks_protosw_old.pr_protocol offset");
_Static_assert(offsetof(struct ks_protosw_old, pr_flags) == 0x10, "ks_protosw_old.pr_flags offset");
_Static_assert(offsetof(struct ks_protosw_old, pr_input) == 0x14, "ks_protosw_old.pr_input offset");
_Static_assert(offsetof(struct ks_protosw_old, pr_output) == 0x1C, "ks_protosw_old.pr_output offset");
_Static_assert(offsetof(struct ks_protosw_old, pr_ctlinput) == 0x24, "ks_protosw_old.pr_ctlinput offset");
_Static_assert(offsetof(struct ks_protosw_old, pr_ctloutput) == 0x2C, "ks_protosw_old.pr_ctloutput offset");
_Static_assert(offsetof(struct ks_protosw_old, pr_ousrreq) == 0x34, "ks_protosw_old.pr_ousrreq offset");
_Static_assert(offsetof(struct ks_protosw_old, pr_init) == 0x3C, "ks_protosw_old.pr_init offset");
_Static_assert(offsetof(struct ks_protosw_old, pr_unused) == 0x44, "ks_protosw_old.pr_unused offset");
_Static_assert(offsetof(struct ks_protosw_old, pr_unused2) == 0x4C, "ks_protosw_old.pr_unused2 offset");
_Static_assert(offsetof(struct ks_protosw_old, pr_drain) == 0x54, "ks_protosw_old.pr_drain offset");
_Static_assert(offsetof(struct ks_protosw_old, pr_sysctl) == 0x5C, "ks_protosw_old.pr_sysctl offset");
_Static_assert(offsetof(struct ks_protosw_old, pr_usrreqs) == 0x64, "ks_protosw_old.pr_usrreqs offset");
_Static_assert(offsetof(struct ks_protosw_old, pr_lock) == 0x6C, "ks_protosw_old.pr_lock offset");
_Static_assert(offsetof(struct ks_protosw_old, pr_unlock) == 0x74, "ks_protosw_old.pr_unlock offset");
_Static_assert(offsetof(struct ks_protosw_old, pr_getlock) == 0x7C, "ks_protosw_old.pr_getlock offset");
_Static_assert(offsetof(struct ks_protosw_old, pr_filter_head) == 0x84, "ks_protosw_old.pr_filter_head offset");
_Static_assert(offsetof(struct ks_protosw_old, pr_next) == 0x94, "ks_protosw_old.pr_next offset");
_Static_assert(offsetof(struct ks_protosw_old, reserved) == 0x9C, "ks_protosw_old.reserved offset");
_Static_assert(sizeof(struct ks_protosw_old) == 0xA0, "ks_protosw_old size");

/* refs: 2 */
struct ks_pset_node {
    struct ks_processor_set *psets;
    struct ks_pset_node *node_list;
    unsigned int pset_cluster_type;
    unsigned long long pset_map;
    unsigned long long pset_idle_map;
    unsigned long long pset_non_rt_map;
    unsigned long long pset_recommended_map;
};
_Static_assert(offsetof(struct ks_pset_node, psets) == 0x0, "ks_pset_node.psets offset");
_Static_assert(offsetof(struct ks_pset_node, node_list) == 0x8, "ks_pset_node.node_list offset");
_Static_assert(offsetof(struct ks_pset_node, pset_cluster_type) == 0x10, "ks_pset_node.pset_cluster_type offset");
_Static_assert(offsetof(struct ks_pset_node, pset_map) == 0x18, "ks_pset_node.pset_map offset");
_Static_assert(offsetof(struct ks_pset_node, pset_idle_map) == 0x20, "ks_pset_node.pset_idle_map offset");
_Static_assert(offsetof(struct ks_pset_node, pset_non_rt_map) == 0x28, "ks_pset_node.pset_non_rt_map offset");
_Static_assert(offsetof(struct ks_pset_node, pset_recommended_map) == 0x30, "ks_pset_node.pset_recommended_map offset");
_Static_assert(sizeof(struct ks_pset_node) == 0x38, "ks_pset_node size");

/* refs: 3 */
struct ks_rusage {
    struct ks_timeval ru_utime;
    struct ks_timeval ru_stime;
    long ru_maxrss;
    long ru_ixrss;
    long ru_idrss;
    long ru_isrss;
    long ru_minflt;
    long ru_majflt;
    long ru_nswap;
    long ru_inblock;
    long ru_oublock;
    long ru_msgsnd;
    long ru_msgrcv;
    long ru_nsignals;
    long ru_nvcsw;
    long ru_nivcsw;
};
_Static_assert(offsetof(struct ks_rusage, ru_utime) == 0x0, "ks_rusage.ru_utime offset");
_Static_assert(offsetof(struct ks_rusage, ru_stime) == 0x10, "ks_rusage.ru_stime offset");
_Static_assert(offsetof(struct ks_rusage, ru_maxrss) == 0x20, "ks_rusage.ru_maxrss offset");
_Static_assert(offsetof(struct ks_rusage, ru_ixrss) == 0x28, "ks_rusage.ru_ixrss offset");
_Static_assert(offsetof(struct ks_rusage, ru_idrss) == 0x30, "ks_rusage.ru_idrss offset");
_Static_assert(offsetof(struct ks_rusage, ru_isrss) == 0x38, "ks_rusage.ru_isrss offset");
_Static_assert(offsetof(struct ks_rusage, ru_minflt) == 0x40, "ks_rusage.ru_minflt offset");
_Static_assert(offsetof(struct ks_rusage, ru_majflt) == 0x48, "ks_rusage.ru_majflt offset");
_Static_assert(offsetof(struct ks_rusage, ru_nswap) == 0x50, "ks_rusage.ru_nswap offset");
_Static_assert(offsetof(struct ks_rusage, ru_inblock) == 0x58, "ks_rusage.ru_inblock offset");
_Static_assert(offsetof(struct ks_rusage, ru_oublock) == 0x60, "ks_rusage.ru_oublock offset");
_Static_assert(offsetof(struct ks_rusage, ru_msgsnd) == 0x68, "ks_rusage.ru_msgsnd offset");
_Static_assert(offsetof(struct ks_rusage, ru_msgrcv) == 0x70, "ks_rusage.ru_msgrcv offset");
_Static_assert(offsetof(struct ks_rusage, ru_nsignals) == 0x78, "ks_rusage.ru_nsignals offset");
_Static_assert(offsetof(struct ks_rusage, ru_nvcsw) == 0x80, "ks_rusage.ru_nvcsw offset");
_Static_assert(offsetof(struct ks_rusage, ru_nivcsw) == 0x88, "ks_rusage.ru_nivcsw offset");
_Static_assert(sizeof(struct ks_rusage) == 0x90, "ks_rusage size");

/* refs: 1 */
struct ks_rusage_info_child {
    unsigned long long ri_child_user_time;
    unsigned long long ri_child_system_time;
    unsigned long long ri_child_pkg_idle_wkups;
    unsigned long long ri_child_interrupt_wkups;
    unsigned long long ri_child_pageins;
    unsigned long long ri_child_elapsed_abstime;
};
_Static_assert(offsetof(struct ks_rusage_info_child, ri_child_user_time) == 0x0, "ks_rusage_info_child.ri_child_user_time offset");
_Static_assert(offsetof(struct ks_rusage_info_child, ri_child_system_time) == 0x8, "ks_rusage_info_child.ri_child_system_time offset");
_Static_assert(offsetof(struct ks_rusage_info_child, ri_child_pkg_idle_wkups) == 0x10, "ks_rusage_info_child.ri_child_pkg_idle_wkups offset");
_Static_assert(offsetof(struct ks_rusage_info_child, ri_child_interrupt_wkups) == 0x18, "ks_rusage_info_child.ri_child_interrupt_wkups offset");
_Static_assert(offsetof(struct ks_rusage_info_child, ri_child_pageins) == 0x20, "ks_rusage_info_child.ri_child_pageins offset");
_Static_assert(offsetof(struct ks_rusage_info_child, ri_child_elapsed_abstime) == 0x28, "ks_rusage_info_child.ri_child_elapsed_abstime offset");
_Static_assert(sizeof(struct ks_rusage_info_child) == 0x30, "ks_rusage_info_child size");

/* refs: 1 */
struct ks_uprof {
    struct ks_uprof *pr_next;
    char *pr_base;
    unsigned int pr_size;
    unsigned int pr_off;
    unsigned int pr_scale;
    unsigned int pr_addr;
    unsigned int pr_ticks;
};
_Static_assert(offsetof(struct ks_uprof, pr_next) == 0x0, "ks_uprof.pr_next offset");
_Static_assert(offsetof(struct ks_uprof, pr_base) == 0x8, "ks_uprof.pr_base offset");
_Static_assert(offsetof(struct ks_uprof, pr_size) == 0x10, "ks_uprof.pr_size offset");
_Static_assert(offsetof(struct ks_uprof, pr_off) == 0x14, "ks_uprof.pr_off offset");
_Static_assert(offsetof(struct ks_uprof, pr_scale) == 0x18, "ks_uprof.pr_scale offset");
_Static_assert(offsetof(struct ks_uprof, pr_addr) == 0x1C, "ks_uprof.pr_addr offset");
_Static_assert(offsetof(struct ks_uprof, pr_ticks) == 0x20, "ks_uprof.pr_ticks offset");
_Static_assert(sizeof(struct ks_uprof) == 0x28, "ks_uprof size");

/* refs: 1 */
struct ks_user_uprof {
    struct ks_user_uprof *pr_next;
    unsigned long long pr_base;
    unsigned long long pr_size;
    unsigned long long pr_off;
    unsigned long long pr_scale;
    unsigned long long pr_addr;
    unsigned long long pr_ticks;
};
_Static_assert(offsetof(struct ks_user_uprof, pr_next) == 0x0, "ks_user_uprof.pr_next offset");
_Static_assert(offsetof(struct ks_user_uprof, pr_base) == 0x8, "ks_user_uprof.pr_base offset");
_Static_assert(offsetof(struct ks_user_uprof, pr_size) == 0x10, "ks_user_uprof.pr_size offset");
_Static_assert(offsetof(struct ks_user_uprof, pr_off) == 0x18, "ks_user_uprof.pr_off offset");
_Static_assert(offsetof(struct ks_user_uprof, pr_scale) == 0x20, "ks_user_uprof.pr_scale offset");
_Static_assert(offsetof(struct ks_user_uprof, pr_addr) == 0x28, "ks_user_uprof.pr_addr offset");
_Static_assert(offsetof(struct ks_user_uprof, pr_ticks) == 0x30, "ks_user_uprof.pr_ticks offset");
_Static_assert(sizeof(struct ks_user_uprof) == 0x38, "ks_user_uprof size");

/* refs: 1 */
struct ks_pstats {
    struct ks_rusage p_ru;
    struct ks_rusage p_cru;
    struct ks_uprof p_prof;
    unsigned long long ps_start;
    struct ks_rusage_info_child ri_child;
    struct ks_user_uprof user_p_prof;
};
_Static_assert(offsetof(struct ks_pstats, p_ru) == 0x0, "ks_pstats.p_ru offset");
_Static_assert(offsetof(struct ks_pstats, p_cru) == 0x90, "ks_pstats.p_cru offset");
_Static_assert(offsetof(struct ks_pstats, p_prof) == 0x120, "ks_pstats.p_prof offset");
_Static_assert(offsetof(struct ks_pstats, ps_start) == 0x148, "ks_pstats.ps_start offset");
_Static_assert(offsetof(struct ks_pstats, ri_child) == 0x150, "ks_pstats.ri_child offset");
_Static_assert(offsetof(struct ks_pstats, user_p_prof) == 0x180, "ks_pstats.user_p_prof offset");
_Static_assert(sizeof(struct ks_pstats) == 0x1B8, "ks_pstats size");

/* refs: 1 */
struct ks_radix_mask {
    short rm_bit;
    char rm_unused;
    unsigned char rm_flags;
    unsigned char __rm_masklen;
    unsigned char pad[3];
    struct ks_radix_mask *rm_mklist;
    union {
        char *__rm_mask;
        struct ks_radix_node *rm_leaf;
    };
    int rm_refs;
};
_Static_assert(offsetof(struct ks_radix_mask, rm_bit) == 0x0, "ks_radix_mask.rm_bit offset");
_Static_assert(offsetof(struct ks_radix_mask, rm_unused) == 0x2, "ks_radix_mask.rm_unused offset");
_Static_assert(offsetof(struct ks_radix_mask, rm_flags) == 0x3, "ks_radix_mask.rm_flags offset");
_Static_assert(offsetof(struct ks_radix_mask, __rm_masklen) == 0x4, "ks_radix_mask.__rm_masklen offset");
_Static_assert(offsetof(struct ks_radix_mask, pad) == 0x5, "ks_radix_mask.pad offset");
_Static_assert(offsetof(struct ks_radix_mask, rm_mklist) == 0x8, "ks_radix_mask.rm_mklist offset");
_Static_assert(offsetof(struct ks_radix_mask, rm_refs) == 0x18, "ks_radix_mask.rm_refs offset");
_Static_assert(sizeof(struct ks_radix_mask) == 0x20, "ks_radix_mask size");

/* refs: 5 */
struct ks_radix_node {
    struct ks_radix_mask *rn_mklist;
    struct ks_radix_node *rn_parent;
    short rn_bit;
    char rn_bmask;
    unsigned char rn_flags;
    unsigned char __rn_keylen;
    unsigned char __rn_masklen;
    short pad2;
    union {
        struct {
            char *rn_Key;
            char *rn_Mask;
            struct ks_radix_node *rn_Dupedkey;
        } rn_leaf;
        struct {
            int rn_Off;
            struct ks_radix_node *rn_L;
            struct ks_radix_node *rn_R;
        } rn_node;
    } rn_u;
};
_Static_assert(offsetof(struct ks_radix_node, rn_mklist) == 0x0, "ks_radix_node.rn_mklist offset");
_Static_assert(offsetof(struct ks_radix_node, rn_parent) == 0x8, "ks_radix_node.rn_parent offset");
_Static_assert(offsetof(struct ks_radix_node, rn_bit) == 0x10, "ks_radix_node.rn_bit offset");
_Static_assert(offsetof(struct ks_radix_node, rn_bmask) == 0x12, "ks_radix_node.rn_bmask offset");
_Static_assert(offsetof(struct ks_radix_node, rn_flags) == 0x13, "ks_radix_node.rn_flags offset");
_Static_assert(offsetof(struct ks_radix_node, __rn_keylen) == 0x14, "ks_radix_node.__rn_keylen offset");
_Static_assert(offsetof(struct ks_radix_node, __rn_masklen) == 0x15, "ks_radix_node.__rn_masklen offset");
_Static_assert(offsetof(struct ks_radix_node, pad2) == 0x16, "ks_radix_node.pad2 offset");
_Static_assert(offsetof(struct ks_radix_node, rn_u) == 0x18, "ks_radix_node.rn_u offset");
_Static_assert(sizeof(struct ks_radix_node) == 0x30, "ks_radix_node size");

/* refs: 1 */
struct ks_recount_metrics {
    unsigned long long rm_time_mach;
    unsigned long long rm_instructions;
    unsigned long long rm_cycles;
};
_Static_assert(offsetof(struct ks_recount_metrics, rm_time_mach) == 0x0, "ks_recount_metrics.rm_time_mach offset");
_Static_assert(offsetof(struct ks_recount_metrics, rm_instructions) == 0x8, "ks_recount_metrics.rm_instructions offset");
_Static_assert(offsetof(struct ks_recount_metrics, rm_cycles) == 0x10, "ks_recount_metrics.rm_cycles offset");
_Static_assert(sizeof(struct ks_recount_metrics) == 0x18, "ks_recount_metrics size");

/* refs: 1 */
struct ks_recount_task {
    struct ks_recount_track *rtk_lifetime;
    struct ks_recount_usage *rtk_terminated;
};
_Static_assert(offsetof(struct ks_recount_task, rtk_lifetime) == 0x0, "ks_recount_task.rtk_lifetime offset");
_Static_assert(offsetof(struct ks_recount_task, rtk_terminated) == 0x8, "ks_recount_task.rtk_terminated offset");
_Static_assert(sizeof(struct ks_recount_task) == 0x10, "ks_recount_task size");

/* refs: 1 */
struct ks_recount_thread {
    struct ks_recount_track *rth_lifetime;
    unsigned long long rth_interrupt_duration_mach;
    unsigned int rth_current_level;
};
_Static_assert(offsetof(struct ks_recount_thread, rth_lifetime) == 0x0, "ks_recount_thread.rth_lifetime offset");
_Static_assert(offsetof(struct ks_recount_thread, rth_interrupt_duration_mach) == 0x8, "ks_recount_thread.rth_interrupt_duration_mach offset");
_Static_assert(offsetof(struct ks_recount_thread, rth_current_level) == 0x10, "ks_recount_thread.rth_current_level offset");
_Static_assert(sizeof(struct ks_recount_thread) == 0x18, "ks_recount_thread size");

/* refs: 3 */
struct ks_recount_usage {
    struct ks_recount_metrics ru_metrics[3];
    unsigned long long ru_energy_nj;
};
_Static_assert(offsetof(struct ks_recount_usage, ru_metrics) == 0x0, "ks_recount_usage.ru_metrics offset");
_Static_assert(offsetof(struct ks_recount_usage, ru_energy_nj) == 0x48, "ks_recount_usage.ru_energy_nj offset");
_Static_assert(sizeof(struct ks_recount_usage) == 0x50, "ks_recount_usage size");

/* refs: 3 */
struct ks_recount_track {
    unsigned int rt_pad;
    unsigned int rt_sync;
    struct ks_recount_usage rt_usage;
};
_Static_assert(offsetof(struct ks_recount_track, rt_pad) == 0x0, "ks_recount_track.rt_pad offset");
_Static_assert(offsetof(struct ks_recount_track, rt_sync) == 0x4, "ks_recount_track.rt_sync offset");
_Static_assert(offsetof(struct ks_recount_track, rt_usage) == 0x8, "ks_recount_track.rt_usage offset");
_Static_assert(sizeof(struct ks_recount_track) == 0x58, "ks_recount_track size");

/* refs: 1 */
struct ks_recount_work_interval {
    struct ks_recount_track *rwi_current_instance;
};
_Static_assert(offsetof(struct ks_recount_work_interval, rwi_current_instance) == 0x0, "ks_recount_work_interval.rwi_current_instance offset");
_Static_assert(sizeof(struct ks_recount_work_interval) == 0x8, "ks_recount_work_interval size");

/* refs: 2 */
struct ks_task_restartable_range_t {
    unsigned long long location;
    unsigned short length;
    unsigned short recovery_offs;
    unsigned int flags;
};
_Static_assert(offsetof(struct ks_task_restartable_range_t, location) == 0x0, "ks_task_restartable_range_t.location offset");
_Static_assert(offsetof(struct ks_task_restartable_range_t, length) == 0x8, "ks_task_restartable_range_t.length offset");
_Static_assert(offsetof(struct ks_task_restartable_range_t, recovery_offs) == 0xA, "ks_task_restartable_range_t.recovery_offs offset");
_Static_assert(offsetof(struct ks_task_restartable_range_t, flags) == 0xC, "ks_task_restartable_range_t.flags offset");
_Static_assert(sizeof(struct ks_task_restartable_range_t) == 0x10, "ks_task_restartable_range_t size");

/* refs: 1 */
struct ks_restartable_ranges {
    struct ks_queue_entry rr_link;
    struct ks_os_refcnt rr_ref;
    unsigned int rr_count;
    unsigned int rr_hash;
    struct ks_task_restartable_range_t rr_ranges[0x40];
};
_Static_assert(offsetof(struct ks_restartable_ranges, rr_link) == 0x0, "ks_restartable_ranges.rr_link offset");
_Static_assert(offsetof(struct ks_restartable_ranges, rr_ref) == 0x10, "ks_restartable_ranges.rr_ref offset");
_Static_assert(offsetof(struct ks_restartable_ranges, rr_count) == 0x14, "ks_restartable_ranges.rr_count offset");
_Static_assert(offsetof(struct ks_restartable_ranges, rr_hash) == 0x18, "ks_restartable_ranges.rr_hash offset");
_Static_assert(offsetof(struct ks_restartable_ranges, rr_ranges) == 0x20, "ks_restartable_ranges.rr_ranges offset");
_Static_assert(sizeof(struct ks_restartable_ranges) == 0x420, "ks_restartable_ranges size");

/* refs: 1 */
struct ks_rt_metrics {
    unsigned int rmx_locks;
    unsigned int rmx_mtu;
    unsigned int rmx_hopcount;
    int rmx_expire;
    unsigned int rmx_recvpipe;
    unsigned int rmx_sendpipe;
    unsigned int rmx_ssthresh;
    unsigned int rmx_rtt;
    unsigned int rmx_rttvar;
    unsigned int rmx_pksent;
    unsigned int rmx_filler[4];
};
_Static_assert(offsetof(struct ks_rt_metrics, rmx_locks) == 0x0, "ks_rt_metrics.rmx_locks offset");
_Static_assert(offsetof(struct ks_rt_metrics, rmx_mtu) == 0x4, "ks_rt_metrics.rmx_mtu offset");
_Static_assert(offsetof(struct ks_rt_metrics, rmx_hopcount) == 0x8, "ks_rt_metrics.rmx_hopcount offset");
_Static_assert(offsetof(struct ks_rt_metrics, rmx_expire) == 0xC, "ks_rt_metrics.rmx_expire offset");
_Static_assert(offsetof(struct ks_rt_metrics, rmx_recvpipe) == 0x10, "ks_rt_metrics.rmx_recvpipe offset");
_Static_assert(offsetof(struct ks_rt_metrics, rmx_sendpipe) == 0x14, "ks_rt_metrics.rmx_sendpipe offset");
_Static_assert(offsetof(struct ks_rt_metrics, rmx_ssthresh) == 0x18, "ks_rt_metrics.rmx_ssthresh offset");
_Static_assert(offsetof(struct ks_rt_metrics, rmx_rtt) == 0x1C, "ks_rt_metrics.rmx_rtt offset");
_Static_assert(offsetof(struct ks_rt_metrics, rmx_rttvar) == 0x20, "ks_rt_metrics.rmx_rttvar offset");
_Static_assert(offsetof(struct ks_rt_metrics, rmx_pksent) == 0x24, "ks_rt_metrics.rmx_pksent offset");
_Static_assert(offsetof(struct ks_rt_metrics, rmx_filler) == 0x28, "ks_rt_metrics.rmx_filler offset");
_Static_assert(sizeof(struct ks_rt_metrics) == 0x38, "ks_rt_metrics size");

/* refs: 2 */
struct ks_rtentry {
    struct ks_radix_node rt_nodes[2];
    struct ks_lck_mtx_s rt_lock;
    unsigned int rt_refcnt;
    unsigned int rt_flags;
    unsigned int rt_genid;
    struct ks_sockaddr *rt_gateway;
    struct ks_ifnet *rt_ifp;
    struct ks_ifaddr *rt_ifa;
    struct ks_sockaddr *rt_genmask;
    void *rt_llinfo;
    void *rt_llinfo_get_ri;
    void *rt_llinfo_get_iflri;
    void *rt_llinfo_purge;
    void *rt_llinfo_free;
    void *rt_llinfo_refresh;
    struct ks_rt_metrics rt_rmx;
    struct ks_rtentry *rt_gwroute;
    struct ks_rtentry *rt_parent;
    struct ks_nstat_counts *rt_stats;
    void *rt_if_ref_fn;
    unsigned int *rt_tree_genid;
    unsigned long long rt_expire;
    unsigned long long base_calendartime;
    unsigned long long base_uptime;
    unsigned int rtt_hist[10];
    unsigned int rtt_min;
    unsigned int rtt_expire_ts;
    unsigned char rtt_index;
    unsigned long long rt_qset_id;
    unsigned int rt_tr_genid;
    struct ks_eventhandler_lists_ctxt rt_evhdlr_ctxt;
};
_Static_assert(offsetof(struct ks_rtentry, rt_nodes) == 0x0, "ks_rtentry.rt_nodes offset");
_Static_assert(offsetof(struct ks_rtentry, rt_lock) == 0x60, "ks_rtentry.rt_lock offset");
_Static_assert(offsetof(struct ks_rtentry, rt_refcnt) == 0x70, "ks_rtentry.rt_refcnt offset");
_Static_assert(offsetof(struct ks_rtentry, rt_flags) == 0x74, "ks_rtentry.rt_flags offset");
_Static_assert(offsetof(struct ks_rtentry, rt_genid) == 0x78, "ks_rtentry.rt_genid offset");
_Static_assert(offsetof(struct ks_rtentry, rt_gateway) == 0x80, "ks_rtentry.rt_gateway offset");
_Static_assert(offsetof(struct ks_rtentry, rt_ifp) == 0x88, "ks_rtentry.rt_ifp offset");
_Static_assert(offsetof(struct ks_rtentry, rt_ifa) == 0x90, "ks_rtentry.rt_ifa offset");
_Static_assert(offsetof(struct ks_rtentry, rt_genmask) == 0x98, "ks_rtentry.rt_genmask offset");
_Static_assert(offsetof(struct ks_rtentry, rt_llinfo) == 0xA0, "ks_rtentry.rt_llinfo offset");
_Static_assert(offsetof(struct ks_rtentry, rt_llinfo_get_ri) == 0xA8, "ks_rtentry.rt_llinfo_get_ri offset");
_Static_assert(offsetof(struct ks_rtentry, rt_llinfo_get_iflri) == 0xB0, "ks_rtentry.rt_llinfo_get_iflri offset");
_Static_assert(offsetof(struct ks_rtentry, rt_llinfo_purge) == 0xB8, "ks_rtentry.rt_llinfo_purge offset");
_Static_assert(offsetof(struct ks_rtentry, rt_llinfo_free) == 0xC0, "ks_rtentry.rt_llinfo_free offset");
_Static_assert(offsetof(struct ks_rtentry, rt_llinfo_refresh) == 0xC8, "ks_rtentry.rt_llinfo_refresh offset");
_Static_assert(offsetof(struct ks_rtentry, rt_rmx) == 0xD0, "ks_rtentry.rt_rmx offset");
_Static_assert(offsetof(struct ks_rtentry, rt_gwroute) == 0x108, "ks_rtentry.rt_gwroute offset");
_Static_assert(offsetof(struct ks_rtentry, rt_parent) == 0x110, "ks_rtentry.rt_parent offset");
_Static_assert(offsetof(struct ks_rtentry, rt_stats) == 0x118, "ks_rtentry.rt_stats offset");
_Static_assert(offsetof(struct ks_rtentry, rt_if_ref_fn) == 0x120, "ks_rtentry.rt_if_ref_fn offset");
_Static_assert(offsetof(struct ks_rtentry, rt_tree_genid) == 0x128, "ks_rtentry.rt_tree_genid offset");
_Static_assert(offsetof(struct ks_rtentry, rt_expire) == 0x130, "ks_rtentry.rt_expire offset");
_Static_assert(offsetof(struct ks_rtentry, base_calendartime) == 0x138, "ks_rtentry.base_calendartime offset");
_Static_assert(offsetof(struct ks_rtentry, base_uptime) == 0x140, "ks_rtentry.base_uptime offset");
_Static_assert(offsetof(struct ks_rtentry, rtt_hist) == 0x148, "ks_rtentry.rtt_hist offset");
_Static_assert(offsetof(struct ks_rtentry, rtt_min) == 0x170, "ks_rtentry.rtt_min offset");
_Static_assert(offsetof(struct ks_rtentry, rtt_expire_ts) == 0x174, "ks_rtentry.rtt_expire_ts offset");
_Static_assert(offsetof(struct ks_rtentry, rtt_index) == 0x178, "ks_rtentry.rtt_index offset");
_Static_assert(offsetof(struct ks_rtentry, rt_qset_id) == 0x180, "ks_rtentry.rt_qset_id offset");
_Static_assert(offsetof(struct ks_rtentry, rt_tr_genid) == 0x188, "ks_rtentry.rt_tr_genid offset");
_Static_assert(offsetof(struct ks_rtentry, rt_evhdlr_ctxt) == 0x190, "ks_rtentry.rt_evhdlr_ctxt offset");
_Static_assert(sizeof(struct ks_rtentry) == 0x1B8, "ks_rtentry size");

/* refs: 2 */
struct ks_rusage_info_v6 {
    unsigned char ri_uuid[0x10];
    unsigned long long ri_user_time;
    unsigned long long ri_system_time;
    unsigned long long ri_pkg_idle_wkups;
    unsigned long long ri_interrupt_wkups;
    unsigned long long ri_pageins;
    unsigned long long ri_wired_size;
    unsigned long long ri_resident_size;
    unsigned long long ri_phys_footprint;
    unsigned long long ri_proc_start_abstime;
    unsigned long long ri_proc_exit_abstime;
    unsigned long long ri_child_user_time;
    unsigned long long ri_child_system_time;
    unsigned long long ri_child_pkg_idle_wkups;
    unsigned long long ri_child_interrupt_wkups;
    unsigned long long ri_child_pageins;
    unsigned long long ri_child_elapsed_abstime;
    unsigned long long ri_diskio_bytesread;
    unsigned long long ri_diskio_byteswritten;
    unsigned long long ri_cpu_time_qos_default;
    unsigned long long ri_cpu_time_qos_maintenance;
    unsigned long long ri_cpu_time_qos_background;
    unsigned long long ri_cpu_time_qos_utility;
    unsigned long long ri_cpu_time_qos_legacy;
    unsigned long long ri_cpu_time_qos_user_initiated;
    unsigned long long ri_cpu_time_qos_user_interactive;
    unsigned long long ri_billed_system_time;
    unsigned long long ri_serviced_system_time;
    unsigned long long ri_logical_writes;
    unsigned long long ri_lifetime_max_phys_footprint;
    unsigned long long ri_instructions;
    unsigned long long ri_cycles;
    unsigned long long ri_billed_energy;
    unsigned long long ri_serviced_energy;
    unsigned long long ri_interval_max_phys_footprint;
    unsigned long long ri_runnable_time;
    unsigned long long ri_flags;
    unsigned long long ri_user_ptime;
    unsigned long long ri_system_ptime;
    unsigned long long ri_pinstructions;
    unsigned long long ri_pcycles;
    unsigned long long ri_energy_nj;
    unsigned long long ri_penergy_nj;
    unsigned long long ri_secure_time_in_system;
    unsigned long long ri_secure_ptime_in_system;
    unsigned long long ri_neural_footprint;
    unsigned long long ri_lifetime_max_neural_footprint;
    unsigned long long ri_interval_max_neural_footprint;
    unsigned long long ri_reserved[9];
};
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_uuid) == 0x0, "ks_rusage_info_v6.ri_uuid offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_user_time) == 0x10, "ks_rusage_info_v6.ri_user_time offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_system_time) == 0x18, "ks_rusage_info_v6.ri_system_time offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_pkg_idle_wkups) == 0x20, "ks_rusage_info_v6.ri_pkg_idle_wkups offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_interrupt_wkups) == 0x28, "ks_rusage_info_v6.ri_interrupt_wkups offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_pageins) == 0x30, "ks_rusage_info_v6.ri_pageins offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_wired_size) == 0x38, "ks_rusage_info_v6.ri_wired_size offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_resident_size) == 0x40, "ks_rusage_info_v6.ri_resident_size offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_phys_footprint) == 0x48, "ks_rusage_info_v6.ri_phys_footprint offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_proc_start_abstime) == 0x50, "ks_rusage_info_v6.ri_proc_start_abstime offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_proc_exit_abstime) == 0x58, "ks_rusage_info_v6.ri_proc_exit_abstime offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_child_user_time) == 0x60, "ks_rusage_info_v6.ri_child_user_time offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_child_system_time) == 0x68, "ks_rusage_info_v6.ri_child_system_time offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_child_pkg_idle_wkups) == 0x70, "ks_rusage_info_v6.ri_child_pkg_idle_wkups offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_child_interrupt_wkups) == 0x78, "ks_rusage_info_v6.ri_child_interrupt_wkups offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_child_pageins) == 0x80, "ks_rusage_info_v6.ri_child_pageins offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_child_elapsed_abstime) == 0x88, "ks_rusage_info_v6.ri_child_elapsed_abstime offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_diskio_bytesread) == 0x90, "ks_rusage_info_v6.ri_diskio_bytesread offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_diskio_byteswritten) == 0x98, "ks_rusage_info_v6.ri_diskio_byteswritten offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_cpu_time_qos_default) == 0xA0, "ks_rusage_info_v6.ri_cpu_time_qos_default offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_cpu_time_qos_maintenance) == 0xA8, "ks_rusage_info_v6.ri_cpu_time_qos_maintenance offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_cpu_time_qos_background) == 0xB0, "ks_rusage_info_v6.ri_cpu_time_qos_background offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_cpu_time_qos_utility) == 0xB8, "ks_rusage_info_v6.ri_cpu_time_qos_utility offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_cpu_time_qos_legacy) == 0xC0, "ks_rusage_info_v6.ri_cpu_time_qos_legacy offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_cpu_time_qos_user_initiated) == 0xC8, "ks_rusage_info_v6.ri_cpu_time_qos_user_initiated offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_cpu_time_qos_user_interactive) == 0xD0, "ks_rusage_info_v6.ri_cpu_time_qos_user_interactive offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_billed_system_time) == 0xD8, "ks_rusage_info_v6.ri_billed_system_time offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_serviced_system_time) == 0xE0, "ks_rusage_info_v6.ri_serviced_system_time offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_logical_writes) == 0xE8, "ks_rusage_info_v6.ri_logical_writes offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_lifetime_max_phys_footprint) == 0xF0, "ks_rusage_info_v6.ri_lifetime_max_phys_footprint offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_instructions) == 0xF8, "ks_rusage_info_v6.ri_instructions offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_cycles) == 0x100, "ks_rusage_info_v6.ri_cycles offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_billed_energy) == 0x108, "ks_rusage_info_v6.ri_billed_energy offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_serviced_energy) == 0x110, "ks_rusage_info_v6.ri_serviced_energy offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_interval_max_phys_footprint) == 0x118, "ks_rusage_info_v6.ri_interval_max_phys_footprint offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_runnable_time) == 0x120, "ks_rusage_info_v6.ri_runnable_time offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_flags) == 0x128, "ks_rusage_info_v6.ri_flags offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_user_ptime) == 0x130, "ks_rusage_info_v6.ri_user_ptime offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_system_ptime) == 0x138, "ks_rusage_info_v6.ri_system_ptime offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_pinstructions) == 0x140, "ks_rusage_info_v6.ri_pinstructions offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_pcycles) == 0x148, "ks_rusage_info_v6.ri_pcycles offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_energy_nj) == 0x150, "ks_rusage_info_v6.ri_energy_nj offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_penergy_nj) == 0x158, "ks_rusage_info_v6.ri_penergy_nj offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_secure_time_in_system) == 0x160, "ks_rusage_info_v6.ri_secure_time_in_system offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_secure_ptime_in_system) == 0x168, "ks_rusage_info_v6.ri_secure_ptime_in_system offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_neural_footprint) == 0x170, "ks_rusage_info_v6.ri_neural_footprint offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_lifetime_max_neural_footprint) == 0x178, "ks_rusage_info_v6.ri_lifetime_max_neural_footprint offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_interval_max_neural_footprint) == 0x180, "ks_rusage_info_v6.ri_interval_max_neural_footprint offset");
_Static_assert(offsetof(struct ks_rusage_info_v6, ri_reserved) == 0x188, "ks_rusage_info_v6.ri_reserved offset");
_Static_assert(sizeof(struct ks_rusage_info_v6) == 0x1D0, "ks_rusage_info_v6 size");

/* refs: 1 */
struct ks_rusage_superset {
    struct ks_rusage ru;
    struct ks_rusage_info_v6 ri;
};
_Static_assert(offsetof(struct ks_rusage_superset, ru) == 0x0, "ks_rusage_superset.ru offset");
_Static_assert(offsetof(struct ks_rusage_superset, ri) == 0x90, "ks_rusage_superset.ri offset");
_Static_assert(sizeof(struct ks_rusage_superset) == 0x260, "ks_rusage_superset size");

/* refs: 2 */
union ks_sched_clutch_bucket_cpu_data {
    struct {
        unsigned long long scbcd_cpu_used;
        unsigned long long scbcd_cpu_blocked;
    } cpu_data;
    unsigned __int128 scbcd_cpu_data_packed;
};
_Static_assert(offsetof(union ks_sched_clutch_bucket_cpu_data, cpu_data) == 0x0, "ks_sched_clutch_bucket_cpu_data.cpu_data offset");
_Static_assert(offsetof(union ks_sched_clutch_bucket_cpu_data, scbcd_cpu_data_packed) == 0x0, "ks_sched_clutch_bucket_cpu_data.scbcd_cpu_data_packed offset");

/* refs: 4 */
union ks_sched_clutch_counter_time {
    struct {
        unsigned long long scct_count;
        unsigned long long scct_timestamp;
    };
    unsigned __int128 scct_packed;
} __attribute__((aligned(16)));
_Static_assert(offsetof(union ks_sched_clutch_counter_time, scct_packed) == 0x0, "ks_sched_clutch_counter_time.scct_packed offset");

/* refs: 2 */
struct ks_sched_clutch_bucket_group {
    unsigned char scbg_bucket;
    unsigned int scbg_timeshare_tick;
    unsigned int scbg_pri_shift;
    unsigned int scbg_preferred_cluster;
    struct ks_sched_clutch *scbg_clutch;
    union ks_sched_clutch_counter_time scbg_blocked_data __attribute__((aligned(16)));
    union ks_sched_clutch_counter_time scbg_pending_data __attribute__((aligned(16)));
    union ks_sched_clutch_counter_time scbg_interactivity_data __attribute__((aligned(16)));
    union ks_sched_clutch_bucket_cpu_data scbg_cpu_data;
    struct ks_sched_clutch_bucket *scbg_clutch_buckets;
};
_Static_assert(offsetof(struct ks_sched_clutch_bucket_group, scbg_bucket) == 0x0, "ks_sched_clutch_bucket_group.scbg_bucket offset");
_Static_assert(offsetof(struct ks_sched_clutch_bucket_group, scbg_timeshare_tick) == 0x4, "ks_sched_clutch_bucket_group.scbg_timeshare_tick offset");
_Static_assert(offsetof(struct ks_sched_clutch_bucket_group, scbg_pri_shift) == 0x8, "ks_sched_clutch_bucket_group.scbg_pri_shift offset");
_Static_assert(offsetof(struct ks_sched_clutch_bucket_group, scbg_preferred_cluster) == 0xC, "ks_sched_clutch_bucket_group.scbg_preferred_cluster offset");
_Static_assert(offsetof(struct ks_sched_clutch_bucket_group, scbg_clutch) == 0x10, "ks_sched_clutch_bucket_group.scbg_clutch offset");
_Static_assert(offsetof(struct ks_sched_clutch_bucket_group, scbg_blocked_data) == 0x20, "ks_sched_clutch_bucket_group.scbg_blocked_data offset");
_Static_assert(offsetof(struct ks_sched_clutch_bucket_group, scbg_pending_data) == 0x30, "ks_sched_clutch_bucket_group.scbg_pending_data offset");
_Static_assert(offsetof(struct ks_sched_clutch_bucket_group, scbg_interactivity_data) == 0x40, "ks_sched_clutch_bucket_group.scbg_interactivity_data offset");
_Static_assert(offsetof(struct ks_sched_clutch_bucket_group, scbg_cpu_data) == 0x50, "ks_sched_clutch_bucket_group.scbg_cpu_data offset");
_Static_assert(offsetof(struct ks_sched_clutch_bucket_group, scbg_clutch_buckets) == 0x60, "ks_sched_clutch_bucket_group.scbg_clutch_buckets offset");
_Static_assert(sizeof(struct ks_sched_clutch_bucket_group) == 0x70, "ks_sched_clutch_bucket_group size");

/* refs: 2 */
struct ks_sched_clutch {
    unsigned short sc_thr_count;
    struct ks_thread_group *sc_tg;
    struct ks_sched_clutch_bucket_group sc_clutch_groups[6];
};
_Static_assert(offsetof(struct ks_sched_clutch, sc_thr_count) == 0x0, "ks_sched_clutch.sc_thr_count offset");
_Static_assert(offsetof(struct ks_sched_clutch, sc_tg) == 0x8, "ks_sched_clutch.sc_tg offset");
_Static_assert(offsetof(struct ks_sched_clutch, sc_clutch_groups) == 0x10, "ks_sched_clutch.sc_clutch_groups offset");
_Static_assert(sizeof(struct ks_sched_clutch) == 0x2B0, "ks_sched_clutch size");

/* refs: 1 */
struct ks_sched_clutch_bucket {
    _Bool scb_foreign;
    unsigned char scb_bucket;
    unsigned char scb_priority;
    unsigned short scb_thr_count;
    struct ks_sched_clutch_bucket_group *scb_group;
    struct ks_sched_clutch_root *scb_root;
    struct ks_priority_queue_sched_max scb_clutchpri_prioq;
    struct ks_priority_queue_sched_stable_max scb_thread_runq;
    struct ks_queue_entry scb_listlink;
    struct ks_queue_entry scb_runqlink;
    struct ks_queue_entry scb_thread_timeshare_queue;
    struct ks_priority_queue_entry_sched scb_foreignlink;
};
_Static_assert(offsetof(struct ks_sched_clutch_bucket, scb_foreign) == 0x0, "ks_sched_clutch_bucket.scb_foreign offset");
_Static_assert(offsetof(struct ks_sched_clutch_bucket, scb_bucket) == 0x1, "ks_sched_clutch_bucket.scb_bucket offset");
_Static_assert(offsetof(struct ks_sched_clutch_bucket, scb_priority) == 0x2, "ks_sched_clutch_bucket.scb_priority offset");
_Static_assert(offsetof(struct ks_sched_clutch_bucket, scb_thr_count) == 0x4, "ks_sched_clutch_bucket.scb_thr_count offset");
_Static_assert(offsetof(struct ks_sched_clutch_bucket, scb_group) == 0x8, "ks_sched_clutch_bucket.scb_group offset");
_Static_assert(offsetof(struct ks_sched_clutch_bucket, scb_root) == 0x10, "ks_sched_clutch_bucket.scb_root offset");
_Static_assert(offsetof(struct ks_sched_clutch_bucket, scb_clutchpri_prioq) == 0x18, "ks_sched_clutch_bucket.scb_clutchpri_prioq offset");
_Static_assert(offsetof(struct ks_sched_clutch_bucket, scb_thread_runq) == 0x20, "ks_sched_clutch_bucket.scb_thread_runq offset");
_Static_assert(offsetof(struct ks_sched_clutch_bucket, scb_listlink) == 0x28, "ks_sched_clutch_bucket.scb_listlink offset");
_Static_assert(offsetof(struct ks_sched_clutch_bucket, scb_runqlink) == 0x38, "ks_sched_clutch_bucket.scb_runqlink offset");
_Static_assert(offsetof(struct ks_sched_clutch_bucket, scb_thread_timeshare_queue) == 0x48, "ks_sched_clutch_bucket.scb_thread_timeshare_queue offset");
_Static_assert(offsetof(struct ks_sched_clutch_bucket, scb_foreignlink) == 0x58, "ks_sched_clutch_bucket.scb_foreignlink offset");
_Static_assert(sizeof(struct ks_sched_clutch_bucket) == 0x70, "ks_sched_clutch_bucket size");

/* refs: 1 */
struct ks_segfreehead {
    struct ks_sksegment *tqh_first;
    struct ks_sksegment **tqh_last;
};
_Static_assert(offsetof(struct ks_segfreehead, tqh_first) == 0x0, "ks_segfreehead.tqh_first offset");
_Static_assert(offsetof(struct ks_segfreehead, tqh_last) == 0x8, "ks_segfreehead.tqh_last offset");
_Static_assert(sizeof(struct ks_segfreehead) == 0x10, "ks_segfreehead size");

/* refs: 1 */
struct ks_segtfreehead {
    struct ks_sksegment *rbh_root;
};
_Static_assert(offsetof(struct ks_segtfreehead, rbh_root) == 0x0, "ks_segtfreehead.rbh_root offset");
_Static_assert(sizeof(struct ks_segtfreehead) == 0x8, "ks_segtfreehead size");

/* refs: 1 */
struct ks_select_nocancel_args {
    char nd_l_[0];
    int nd;
    char nd_r_[4];
    char in_l_[0];
    unsigned long long in;
    char in_r_[0];
    char ou_l_[0];
    unsigned long long ou;
    char ou_r_[0];
    char ex_l_[0];
    unsigned long long ex;
    char ex_r_[0];
    char tv_l_[0];
    unsigned long long tv;
    char tv_r_[0];
};
_Static_assert(offsetof(struct ks_select_nocancel_args, nd_l_) == 0x0, "ks_select_nocancel_args.nd_l_ offset");
_Static_assert(offsetof(struct ks_select_nocancel_args, nd) == 0x0, "ks_select_nocancel_args.nd offset");
_Static_assert(offsetof(struct ks_select_nocancel_args, nd_r_) == 0x4, "ks_select_nocancel_args.nd_r_ offset");
_Static_assert(offsetof(struct ks_select_nocancel_args, in_l_) == 0x8, "ks_select_nocancel_args.in_l_ offset");
_Static_assert(offsetof(struct ks_select_nocancel_args, in) == 0x8, "ks_select_nocancel_args.in offset");
_Static_assert(offsetof(struct ks_select_nocancel_args, in_r_) == 0x10, "ks_select_nocancel_args.in_r_ offset");
_Static_assert(offsetof(struct ks_select_nocancel_args, ou_l_) == 0x10, "ks_select_nocancel_args.ou_l_ offset");
_Static_assert(offsetof(struct ks_select_nocancel_args, ou) == 0x10, "ks_select_nocancel_args.ou offset");
_Static_assert(offsetof(struct ks_select_nocancel_args, ou_r_) == 0x18, "ks_select_nocancel_args.ou_r_ offset");
_Static_assert(offsetof(struct ks_select_nocancel_args, ex_l_) == 0x18, "ks_select_nocancel_args.ex_l_ offset");
_Static_assert(offsetof(struct ks_select_nocancel_args, ex) == 0x18, "ks_select_nocancel_args.ex offset");
_Static_assert(offsetof(struct ks_select_nocancel_args, ex_r_) == 0x20, "ks_select_nocancel_args.ex_r_ offset");
_Static_assert(offsetof(struct ks_select_nocancel_args, tv_l_) == 0x20, "ks_select_nocancel_args.tv_l_ offset");
_Static_assert(offsetof(struct ks_select_nocancel_args, tv) == 0x20, "ks_select_nocancel_args.tv offset");
_Static_assert(offsetof(struct ks_select_nocancel_args, tv_r_) == 0x28, "ks_select_nocancel_args.tv_r_ offset");
_Static_assert(sizeof(struct ks_select_nocancel_args) == 0x28, "ks_select_nocancel_args size");

/* refs: 4 */
struct ks_select_set {
    struct {
        unsigned int selset_type : 3; /* bit offset 0 */
        unsigned int selset_fifo : 1; /* bit offset 3 */
        unsigned int selset_preposted : 1; /* bit offset 4 */
        unsigned int selset_conflict : 1; /* bit offset 5 */
    };
    union ks_hw_lck_ticket_s selset_interlock;
    unsigned char selset_padding[0];
    union {
        struct ks_circle_queue_head selset_queue;
        struct ks_priority_queue_sched_max selset_prio_queue;
        struct ks_turnstile *selset_ts;
    };
    union {
        struct ks_circle_queue_head selset_links;
        struct ks_waitq_link_list_entry selset_sellinks;
        void *selset_inheritor;
        struct ks_mpsc_queue_chain selset_defer;
    };
    unsigned long long selset_id;
};
_Static_assert(offsetof(struct ks_select_set, selset_interlock) == 0x4, "ks_select_set.selset_interlock offset");
_Static_assert(offsetof(struct ks_select_set, selset_padding) == 0x8, "ks_select_set.selset_padding offset");
_Static_assert(offsetof(struct ks_select_set, selset_id) == 0x18, "ks_select_set.selset_id offset");
_Static_assert(sizeof(struct ks_select_set) == 0x20, "ks_select_set size");

/* refs: 4 */
struct ks_session {
    struct ks_lck_mtx_s s_mlock;
    struct {
        struct ks_session *le_next;
        struct ks_session **le_prev;
    } s_hash;
    struct ks_proc *s_leader;
    struct ks_vnode *s_ttyvp;
    struct ks_tty *s_ttyp;
    unsigned int s_ttyvid;
    int s_ttypgrpid;
    int s_ttydev;
    int s_sid;
    unsigned int s_refcount;
    char s_login[0xFF];
};
_Static_assert(offsetof(struct ks_session, s_mlock) == 0x0, "ks_session.s_mlock offset");
_Static_assert(offsetof(struct ks_session, s_hash) == 0x10, "ks_session.s_hash offset");
_Static_assert(offsetof(struct ks_session, s_leader) == 0x20, "ks_session.s_leader offset");
_Static_assert(offsetof(struct ks_session, s_ttyvp) == 0x28, "ks_session.s_ttyvp offset");
_Static_assert(offsetof(struct ks_session, s_ttyp) == 0x30, "ks_session.s_ttyp offset");
_Static_assert(offsetof(struct ks_session, s_ttyvid) == 0x38, "ks_session.s_ttyvid offset");
_Static_assert(offsetof(struct ks_session, s_ttypgrpid) == 0x3C, "ks_session.s_ttypgrpid offset");
_Static_assert(offsetof(struct ks_session, s_ttydev) == 0x40, "ks_session.s_ttydev offset");
_Static_assert(offsetof(struct ks_session, s_sid) == 0x44, "ks_session.s_sid offset");
_Static_assert(offsetof(struct ks_session, s_refcount) == 0x48, "ks_session.s_refcount offset");
_Static_assert(offsetof(struct ks_session, s_login) == 0x4C, "ks_session.s_login offset");
_Static_assert(sizeof(struct ks_session) == 0x150, "ks_session size");

/* refs: 1 */
struct ks_sflt_filter_ext {
    unsigned int sf_ext_len;
    int *sf_ext_accept;
    void *sf_ext_rsvd[5];
};
_Static_assert(offsetof(struct ks_sflt_filter_ext, sf_ext_len) == 0x0, "ks_sflt_filter_ext.sf_ext_len offset");
_Static_assert(offsetof(struct ks_sflt_filter_ext, sf_ext_accept) == 0x8, "ks_sflt_filter_ext.sf_ext_accept offset");
_Static_assert(offsetof(struct ks_sflt_filter_ext, sf_ext_rsvd) == 0x10, "ks_sflt_filter_ext.sf_ext_rsvd offset");
_Static_assert(sizeof(struct ks_sflt_filter_ext) == 0x38, "ks_sflt_filter_ext size");

/* refs: 1 */
struct ks_sflt_filter {
    unsigned int sf_handle;
    int sf_flags;
    char *sf_name;
    void *sf_unregistered;
    int *sf_attach;
    void *sf_detach;
    void *sf_notify;
    int *sf_getpeername;
    int *sf_getsockname;
    int *sf_data_in;
    int *sf_data_out;
    int *sf_connect_in;
    int *sf_connect_out;
    int *sf_bind;
    int *sf_setoption;
    int *sf_getoption;
    int *sf_listen;
    int *sf_ioctl;
    struct ks_sflt_filter_ext sf_ext;
};
_Static_assert(offsetof(struct ks_sflt_filter, sf_handle) == 0x0, "ks_sflt_filter.sf_handle offset");
_Static_assert(offsetof(struct ks_sflt_filter, sf_flags) == 0x4, "ks_sflt_filter.sf_flags offset");
_Static_assert(offsetof(struct ks_sflt_filter, sf_name) == 0x8, "ks_sflt_filter.sf_name offset");
_Static_assert(offsetof(struct ks_sflt_filter, sf_unregistered) == 0x10, "ks_sflt_filter.sf_unregistered offset");
_Static_assert(offsetof(struct ks_sflt_filter, sf_attach) == 0x18, "ks_sflt_filter.sf_attach offset");
_Static_assert(offsetof(struct ks_sflt_filter, sf_detach) == 0x20, "ks_sflt_filter.sf_detach offset");
_Static_assert(offsetof(struct ks_sflt_filter, sf_notify) == 0x28, "ks_sflt_filter.sf_notify offset");
_Static_assert(offsetof(struct ks_sflt_filter, sf_getpeername) == 0x30, "ks_sflt_filter.sf_getpeername offset");
_Static_assert(offsetof(struct ks_sflt_filter, sf_getsockname) == 0x38, "ks_sflt_filter.sf_getsockname offset");
_Static_assert(offsetof(struct ks_sflt_filter, sf_data_in) == 0x40, "ks_sflt_filter.sf_data_in offset");
_Static_assert(offsetof(struct ks_sflt_filter, sf_data_out) == 0x48, "ks_sflt_filter.sf_data_out offset");
_Static_assert(offsetof(struct ks_sflt_filter, sf_connect_in) == 0x50, "ks_sflt_filter.sf_connect_in offset");
_Static_assert(offsetof(struct ks_sflt_filter, sf_connect_out) == 0x58, "ks_sflt_filter.sf_connect_out offset");
_Static_assert(offsetof(struct ks_sflt_filter, sf_bind) == 0x60, "ks_sflt_filter.sf_bind offset");
_Static_assert(offsetof(struct ks_sflt_filter, sf_setoption) == 0x68, "ks_sflt_filter.sf_setoption offset");
_Static_assert(offsetof(struct ks_sflt_filter, sf_getoption) == 0x70, "ks_sflt_filter.sf_getoption offset");
_Static_assert(offsetof(struct ks_sflt_filter, sf_listen) == 0x78, "ks_sflt_filter.sf_listen offset");
_Static_assert(offsetof(struct ks_sflt_filter, sf_ioctl) == 0x80, "ks_sflt_filter.sf_ioctl offset");
_Static_assert(offsetof(struct ks_sflt_filter, sf_ext) == 0x88, "ks_sflt_filter.sf_ext offset");
_Static_assert(sizeof(struct ks_sflt_filter) == 0xC0, "ks_sflt_filter size");

/* refs: 2 */
struct ks_sk_nexusadv {
    unsigned long long nxadv_ver;
    unsigned long long nxadv_fg_sendts;
    unsigned long long nxadv_rt_sendts;
    union {
        struct ks___kern_netif_intf_advisory _nxadv_intf_adv __attribute__((aligned(8)));
        unsigned char _nxadv_reserved[0x68];
    };
} __attribute__((aligned(8)));
_Static_assert(offsetof(struct ks_sk_nexusadv, nxadv_ver) == 0x0, "ks_sk_nexusadv.nxadv_ver offset");
_Static_assert(offsetof(struct ks_sk_nexusadv, nxadv_fg_sendts) == 0x8, "ks_sk_nexusadv.nxadv_fg_sendts offset");
_Static_assert(offsetof(struct ks_sk_nexusadv, nxadv_rt_sendts) == 0x10, "ks_sk_nexusadv.nxadv_rt_sendts offset");
_Static_assert(sizeof(struct ks_sk_nexusadv) == 0x80, "ks_sk_nexusadv size");

/* refs: 4 */
struct ks_skmem_arena {
    struct ks_lck_mtx_s ar_lock;
    unsigned int ar_refcnt;
    struct {
        struct ks_skmem_arena *tqe_next;
        struct ks_skmem_arena **tqe_prev;
    } ar_link;
    char ar_name[0x40];
    unsigned int ar_type;
    unsigned int ar_flags;
    unsigned long ar_zsize;
    struct ks_IOSKArena *ar_ar;
    struct ks_skmem_region *ar_regions[0x1C];
    unsigned long long ar_mapsize;
    unsigned int ar_mapcnt;
    unsigned int ar_maprdrcnt;
    struct {
        struct ks_skmem_arena_mmap_info *slh_first;
    } ar_map_head;
};
_Static_assert(offsetof(struct ks_skmem_arena, ar_lock) == 0x0, "ks_skmem_arena.ar_lock offset");
_Static_assert(offsetof(struct ks_skmem_arena, ar_refcnt) == 0x10, "ks_skmem_arena.ar_refcnt offset");
_Static_assert(offsetof(struct ks_skmem_arena, ar_link) == 0x18, "ks_skmem_arena.ar_link offset");
_Static_assert(offsetof(struct ks_skmem_arena, ar_name) == 0x28, "ks_skmem_arena.ar_name offset");
_Static_assert(offsetof(struct ks_skmem_arena, ar_type) == 0x68, "ks_skmem_arena.ar_type offset");
_Static_assert(offsetof(struct ks_skmem_arena, ar_flags) == 0x6C, "ks_skmem_arena.ar_flags offset");
_Static_assert(offsetof(struct ks_skmem_arena, ar_zsize) == 0x70, "ks_skmem_arena.ar_zsize offset");
_Static_assert(offsetof(struct ks_skmem_arena, ar_ar) == 0x78, "ks_skmem_arena.ar_ar offset");
_Static_assert(offsetof(struct ks_skmem_arena, ar_regions) == 0x80, "ks_skmem_arena.ar_regions offset");
_Static_assert(offsetof(struct ks_skmem_arena, ar_mapsize) == 0x160, "ks_skmem_arena.ar_mapsize offset");
_Static_assert(offsetof(struct ks_skmem_arena, ar_mapcnt) == 0x168, "ks_skmem_arena.ar_mapcnt offset");
_Static_assert(offsetof(struct ks_skmem_arena, ar_maprdrcnt) == 0x16C, "ks_skmem_arena.ar_maprdrcnt offset");
_Static_assert(offsetof(struct ks_skmem_arena, ar_map_head) == 0x170, "ks_skmem_arena.ar_map_head offset");
_Static_assert(sizeof(struct ks_skmem_arena) == 0x178, "ks_skmem_arena size");

/* refs: 2 */
struct ks_skmem_bufctl {
    struct {
        struct ks_skmem_bufctl *sle_next;
    } bc_link;
    void *bc_addr;
    void *bc_addrm;
    struct ks_skmem_slab *bc_slab;
    unsigned int bc_lim;
    unsigned int bc_flags;
    unsigned int bc_idx;
    unsigned int bc_usecnt;
};
_Static_assert(offsetof(struct ks_skmem_bufctl, bc_link) == 0x0, "ks_skmem_bufctl.bc_link offset");
_Static_assert(offsetof(struct ks_skmem_bufctl, bc_addr) == 0x8, "ks_skmem_bufctl.bc_addr offset");
_Static_assert(offsetof(struct ks_skmem_bufctl, bc_addrm) == 0x10, "ks_skmem_bufctl.bc_addrm offset");
_Static_assert(offsetof(struct ks_skmem_bufctl, bc_slab) == 0x18, "ks_skmem_bufctl.bc_slab offset");
_Static_assert(offsetof(struct ks_skmem_bufctl, bc_lim) == 0x20, "ks_skmem_bufctl.bc_lim offset");
_Static_assert(offsetof(struct ks_skmem_bufctl, bc_flags) == 0x24, "ks_skmem_bufctl.bc_flags offset");
_Static_assert(offsetof(struct ks_skmem_bufctl, bc_idx) == 0x28, "ks_skmem_bufctl.bc_idx offset");
_Static_assert(offsetof(struct ks_skmem_bufctl, bc_usecnt) == 0x2C, "ks_skmem_bufctl.bc_usecnt offset");
_Static_assert(sizeof(struct ks_skmem_bufctl) == 0x30, "ks_skmem_bufctl size");

/* refs: 2 */
struct ks_skmem_cpu_cache {
    struct ks_lck_mtx_s cp_lock;
    struct ks_skmem_mag *cp_loaded;
    struct ks_skmem_mag *cp_ploaded;
    unsigned long long cp_alloc;
    unsigned long long cp_free;
    int cp_rounds;
    int cp_prounds;
    int cp_magsize;
} __attribute__((aligned(128)));
_Static_assert(offsetof(struct ks_skmem_cpu_cache, cp_lock) == 0x0, "ks_skmem_cpu_cache.cp_lock offset");
_Static_assert(offsetof(struct ks_skmem_cpu_cache, cp_loaded) == 0x10, "ks_skmem_cpu_cache.cp_loaded offset");
_Static_assert(offsetof(struct ks_skmem_cpu_cache, cp_ploaded) == 0x18, "ks_skmem_cpu_cache.cp_ploaded offset");
_Static_assert(offsetof(struct ks_skmem_cpu_cache, cp_alloc) == 0x20, "ks_skmem_cpu_cache.cp_alloc offset");
_Static_assert(offsetof(struct ks_skmem_cpu_cache, cp_free) == 0x28, "ks_skmem_cpu_cache.cp_free offset");
_Static_assert(offsetof(struct ks_skmem_cpu_cache, cp_rounds) == 0x30, "ks_skmem_cpu_cache.cp_rounds offset");
_Static_assert(offsetof(struct ks_skmem_cpu_cache, cp_prounds) == 0x34, "ks_skmem_cpu_cache.cp_prounds offset");
_Static_assert(offsetof(struct ks_skmem_cpu_cache, cp_magsize) == 0x38, "ks_skmem_cpu_cache.cp_magsize offset");
_Static_assert(sizeof(struct ks_skmem_cpu_cache) == 0x80, "ks_skmem_cpu_cache size");

/* refs: 2 */
struct ks_skmem_maglist {
    struct {
        struct ks_skmem_mag *slh_first;
    } ml_list;
    unsigned int ml_total;
    unsigned int ml_min;
    unsigned int ml_reaplimit;
    unsigned long long ml_alloc;
};
_Static_assert(offsetof(struct ks_skmem_maglist, ml_list) == 0x0, "ks_skmem_maglist.ml_list offset");
_Static_assert(offsetof(struct ks_skmem_maglist, ml_total) == 0x8, "ks_skmem_maglist.ml_total offset");
_Static_assert(offsetof(struct ks_skmem_maglist, ml_min) == 0xC, "ks_skmem_maglist.ml_min offset");
_Static_assert(offsetof(struct ks_skmem_maglist, ml_reaplimit) == 0x10, "ks_skmem_maglist.ml_reaplimit offset");
_Static_assert(offsetof(struct ks_skmem_maglist, ml_alloc) == 0x18, "ks_skmem_maglist.ml_alloc offset");
_Static_assert(sizeof(struct ks_skmem_maglist) == 0x20, "ks_skmem_maglist size");

/* refs: 7 */
struct ks_skmem_cache {
    unsigned int skm_mode;
    int *skm_ctor;
    void *skm_dtor;
    void *skm_reclaim;
    void *skm_private;
    struct ks_lck_mtx_s skm_dp_lock;
    struct ks_skmem_magtype *skm_magtype;
    struct ks_skmem_maglist skm_full;
    struct ks_skmem_maglist skm_empty;
    struct ks_lck_mtx_s skm_sl_lock;
    int *skm_slab_alloc;
    void *skm_slab_free;
    unsigned long skm_chunksize;
    unsigned long skm_objsize;
    unsigned long skm_slabsize;
    unsigned long skm_hash_initial;
    unsigned long skm_hash_limit;
    unsigned long skm_hash_shift;
    unsigned long skm_hash_mask;
    unsigned long skm_hash_size;
    struct ks_skmem_bufctl_bkt *skm_hash_table;
    struct {
        struct ks_skmem_slab *tqh_first;
        struct ks_skmem_slab **tqh_last;
    } skm_sl_partial_list;
    struct {
        struct ks_skmem_slab *tqh_first;
        struct ks_skmem_slab **tqh_last;
    } skm_sl_empty_list;
    struct ks_skmem_region *skm_region;
    unsigned int skm_cpu_mag_size;
    unsigned int skm_cpu_mag_resize;
    unsigned int skm_cpu_mag_purge;
    unsigned int skm_cpu_mag_reap;
    unsigned long long skm_depot_contention;
    unsigned long long skm_depot_contention_prev;
    unsigned int skm_depot_full;
    unsigned int skm_depot_empty;
    unsigned int skm_depot_ws_zero;
    unsigned int skm_sl_rescale;
    unsigned int skm_sl_create;
    unsigned int skm_sl_destroy;
    unsigned int skm_sl_alloc;
    unsigned int skm_sl_free;
    unsigned int skm_sl_partial;
    unsigned int skm_sl_empty;
    unsigned long long skm_sl_alloc_fail;
    unsigned long long skm_sl_bufinuse;
    unsigned long long skm_sl_bufmax;
    struct {
        struct ks_skmem_cache *tqe_next;
        struct ks_skmem_cache **tqe_prev;
    } skm_link;
    char skm_name[0x40];
    unsigned char skm_uuid[0x10];
    unsigned long skm_bufsize;
    unsigned long skm_bufalign;
    unsigned long skm_objalign;
    struct ks_lck_mtx_s skm_rs_lock;
    struct ks_thread *skm_rs_owner;
    unsigned int skm_rs_busy;
    unsigned int skm_rs_want;
    unsigned long skm_cpu_cache_count;
    struct ks_skmem_cpu_cache skm_cpu_cache[] __attribute__((aligned(128)));
};
_Static_assert(offsetof(struct ks_skmem_cache, skm_mode) == 0x0, "ks_skmem_cache.skm_mode offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_ctor) == 0x8, "ks_skmem_cache.skm_ctor offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_dtor) == 0x10, "ks_skmem_cache.skm_dtor offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_reclaim) == 0x18, "ks_skmem_cache.skm_reclaim offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_private) == 0x20, "ks_skmem_cache.skm_private offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_dp_lock) == 0x28, "ks_skmem_cache.skm_dp_lock offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_magtype) == 0x38, "ks_skmem_cache.skm_magtype offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_full) == 0x40, "ks_skmem_cache.skm_full offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_empty) == 0x60, "ks_skmem_cache.skm_empty offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_sl_lock) == 0x80, "ks_skmem_cache.skm_sl_lock offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_slab_alloc) == 0x90, "ks_skmem_cache.skm_slab_alloc offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_slab_free) == 0x98, "ks_skmem_cache.skm_slab_free offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_chunksize) == 0xA0, "ks_skmem_cache.skm_chunksize offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_objsize) == 0xA8, "ks_skmem_cache.skm_objsize offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_slabsize) == 0xB0, "ks_skmem_cache.skm_slabsize offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_hash_initial) == 0xB8, "ks_skmem_cache.skm_hash_initial offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_hash_limit) == 0xC0, "ks_skmem_cache.skm_hash_limit offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_hash_shift) == 0xC8, "ks_skmem_cache.skm_hash_shift offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_hash_mask) == 0xD0, "ks_skmem_cache.skm_hash_mask offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_hash_size) == 0xD8, "ks_skmem_cache.skm_hash_size offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_hash_table) == 0xE0, "ks_skmem_cache.skm_hash_table offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_sl_partial_list) == 0xE8, "ks_skmem_cache.skm_sl_partial_list offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_sl_empty_list) == 0xF8, "ks_skmem_cache.skm_sl_empty_list offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_region) == 0x108, "ks_skmem_cache.skm_region offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_cpu_mag_size) == 0x110, "ks_skmem_cache.skm_cpu_mag_size offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_cpu_mag_resize) == 0x114, "ks_skmem_cache.skm_cpu_mag_resize offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_cpu_mag_purge) == 0x118, "ks_skmem_cache.skm_cpu_mag_purge offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_cpu_mag_reap) == 0x11C, "ks_skmem_cache.skm_cpu_mag_reap offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_depot_contention) == 0x120, "ks_skmem_cache.skm_depot_contention offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_depot_contention_prev) == 0x128, "ks_skmem_cache.skm_depot_contention_prev offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_depot_full) == 0x130, "ks_skmem_cache.skm_depot_full offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_depot_empty) == 0x134, "ks_skmem_cache.skm_depot_empty offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_depot_ws_zero) == 0x138, "ks_skmem_cache.skm_depot_ws_zero offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_sl_rescale) == 0x13C, "ks_skmem_cache.skm_sl_rescale offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_sl_create) == 0x140, "ks_skmem_cache.skm_sl_create offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_sl_destroy) == 0x144, "ks_skmem_cache.skm_sl_destroy offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_sl_alloc) == 0x148, "ks_skmem_cache.skm_sl_alloc offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_sl_free) == 0x14C, "ks_skmem_cache.skm_sl_free offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_sl_partial) == 0x150, "ks_skmem_cache.skm_sl_partial offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_sl_empty) == 0x154, "ks_skmem_cache.skm_sl_empty offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_sl_alloc_fail) == 0x158, "ks_skmem_cache.skm_sl_alloc_fail offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_sl_bufinuse) == 0x160, "ks_skmem_cache.skm_sl_bufinuse offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_sl_bufmax) == 0x168, "ks_skmem_cache.skm_sl_bufmax offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_link) == 0x170, "ks_skmem_cache.skm_link offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_name) == 0x180, "ks_skmem_cache.skm_name offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_uuid) == 0x1C0, "ks_skmem_cache.skm_uuid offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_bufsize) == 0x1D0, "ks_skmem_cache.skm_bufsize offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_bufalign) == 0x1D8, "ks_skmem_cache.skm_bufalign offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_objalign) == 0x1E0, "ks_skmem_cache.skm_objalign offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_rs_lock) == 0x1E8, "ks_skmem_cache.skm_rs_lock offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_rs_owner) == 0x1F8, "ks_skmem_cache.skm_rs_owner offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_rs_busy) == 0x200, "ks_skmem_cache.skm_rs_busy offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_rs_want) == 0x204, "ks_skmem_cache.skm_rs_want offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_cpu_cache_count) == 0x208, "ks_skmem_cache.skm_cpu_cache_count offset");
_Static_assert(offsetof(struct ks_skmem_cache, skm_cpu_cache) == 0x280, "ks_skmem_cache.skm_cpu_cache offset");
_Static_assert(sizeof(struct ks_skmem_cache) == 0x280, "ks_skmem_cache size");

/* refs: 10 */
struct ks_skmem_region {
    struct ks_lck_mtx_s skr_lock;
    unsigned long long skr_meminuse;
    unsigned long long skr_w_meminuse;
    unsigned long long skr_memtotal;
    unsigned long long skr_alloc;
    unsigned long long skr_free;
    unsigned int skr_seginuse;
    unsigned int skr_rescale;
    struct ks_skmem_region_params skr_params;
    struct {
        struct ks_skmem_region *tqe_next;
        struct ks_skmem_region **tqe_prev;
    } skr_link;
    char skr_name[0x40];
    unsigned char skr_uuid[0x10];
    unsigned int skr_mode;
    unsigned int skr_size;
    struct ks_IOSKMemoryBufferSpec skr_bufspec;
    struct ks_IOSKRegionSpec skr_regspec;
    struct ks_IOSKRegion *skr_reg;
    struct ks_zone *skr_zreg;
    void *skr_private;
    struct ks_skmem_cache *skr_cache[2];
    int *skr_seg_ctor;
    void *skr_seg_dtor;
    unsigned int skr_seg_objs;
    unsigned int skr_seg_bmap_len;
    unsigned long skr_seg_bmap_size;
    unsigned long long *skr_seg_bmap;
    unsigned int skr_seg_free_cnt;
    unsigned int skr_hash_initial;
    unsigned int skr_hash_limit;
    unsigned int skr_hash_shift;
    unsigned int skr_hash_mask;
    unsigned long skr_hash_size;
    struct ks_sksegment_bkt *skr_hash_table;
    struct ks_segfreehead skr_seg_free;
    struct ks_segtfreehead skr_seg_tfree;
    unsigned int skr_seg_waiters;
    unsigned int skr_refcnt;
    struct ks_skmem_region *skr_mirror;
};
_Static_assert(offsetof(struct ks_skmem_region, skr_lock) == 0x0, "ks_skmem_region.skr_lock offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_meminuse) == 0x10, "ks_skmem_region.skr_meminuse offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_w_meminuse) == 0x18, "ks_skmem_region.skr_w_meminuse offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_memtotal) == 0x20, "ks_skmem_region.skr_memtotal offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_alloc) == 0x28, "ks_skmem_region.skr_alloc offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_free) == 0x30, "ks_skmem_region.skr_free offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_seginuse) == 0x38, "ks_skmem_region.skr_seginuse offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_rescale) == 0x3C, "ks_skmem_region.skr_rescale offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_params) == 0x40, "ks_skmem_region.skr_params offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_link) == 0x88, "ks_skmem_region.skr_link offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_name) == 0x98, "ks_skmem_region.skr_name offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_uuid) == 0xD8, "ks_skmem_region.skr_uuid offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_mode) == 0xE8, "ks_skmem_region.skr_mode offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_size) == 0xEC, "ks_skmem_region.skr_size offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_bufspec) == 0xF0, "ks_skmem_region.skr_bufspec offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_regspec) == 0x118, "ks_skmem_region.skr_regspec offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_reg) == 0x120, "ks_skmem_region.skr_reg offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_zreg) == 0x128, "ks_skmem_region.skr_zreg offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_private) == 0x130, "ks_skmem_region.skr_private offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_cache) == 0x138, "ks_skmem_region.skr_cache offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_seg_ctor) == 0x148, "ks_skmem_region.skr_seg_ctor offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_seg_dtor) == 0x150, "ks_skmem_region.skr_seg_dtor offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_seg_objs) == 0x158, "ks_skmem_region.skr_seg_objs offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_seg_bmap_len) == 0x15C, "ks_skmem_region.skr_seg_bmap_len offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_seg_bmap_size) == 0x160, "ks_skmem_region.skr_seg_bmap_size offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_seg_bmap) == 0x168, "ks_skmem_region.skr_seg_bmap offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_seg_free_cnt) == 0x170, "ks_skmem_region.skr_seg_free_cnt offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_hash_initial) == 0x174, "ks_skmem_region.skr_hash_initial offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_hash_limit) == 0x178, "ks_skmem_region.skr_hash_limit offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_hash_shift) == 0x17C, "ks_skmem_region.skr_hash_shift offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_hash_mask) == 0x180, "ks_skmem_region.skr_hash_mask offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_hash_size) == 0x188, "ks_skmem_region.skr_hash_size offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_hash_table) == 0x190, "ks_skmem_region.skr_hash_table offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_seg_free) == 0x198, "ks_skmem_region.skr_seg_free offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_seg_tfree) == 0x1A8, "ks_skmem_region.skr_seg_tfree offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_seg_waiters) == 0x1B0, "ks_skmem_region.skr_seg_waiters offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_refcnt) == 0x1B4, "ks_skmem_region.skr_refcnt offset");
_Static_assert(offsetof(struct ks_skmem_region, skr_mirror) == 0x1B8, "ks_skmem_region.skr_mirror offset");
_Static_assert(sizeof(struct ks_skmem_region) == 0x1C0, "ks_skmem_region size");

/* refs: 4 */
struct ks_slot_ctx {
    void *slot_ctx_arg;
};
_Static_assert(offsetof(struct ks_slot_ctx, slot_ctx_arg) == 0x0, "ks_slot_ctx.slot_ctx_arg offset");
_Static_assert(sizeof(struct ks_slot_ctx) == 0x8, "ks_slot_ctx size");

/* refs: 2 */
struct ks_smr_clock_t {
    unsigned long s_rd_seq;
    unsigned long s_wr_seq;
};
_Static_assert(offsetof(struct ks_smr_clock_t, s_rd_seq) == 0x0, "ks_smr_clock_t.s_rd_seq offset");
_Static_assert(offsetof(struct ks_smr_clock_t, s_wr_seq) == 0x8, "ks_smr_clock_t.s_wr_seq offset");
_Static_assert(sizeof(struct ks_smr_clock_t) == 0x10, "ks_smr_clock_t size");

/* refs: 2 */
struct ks_smr {
    struct ks_smr_clock_t smr_clock;
    struct ks_smr_pcpu *smr_pcpu;
    unsigned long smr_flags;
    unsigned long smr_early;
    char smr_name[0x18];
} __attribute__((aligned(64)));
_Static_assert(offsetof(struct ks_smr, smr_clock) == 0x0, "ks_smr.smr_clock offset");
_Static_assert(offsetof(struct ks_smr, smr_pcpu) == 0x10, "ks_smr.smr_pcpu offset");
_Static_assert(offsetof(struct ks_smr, smr_flags) == 0x18, "ks_smr.smr_flags offset");
_Static_assert(offsetof(struct ks_smr, smr_early) == 0x20, "ks_smr.smr_early offset");
_Static_assert(offsetof(struct ks_smr, smr_name) == 0x28, "ks_smr.smr_name offset");
_Static_assert(sizeof(struct ks_smr) == 0x40, "ks_smr size");

/* refs: 1 */
struct ks_smrq_slist_head {
    struct ks___smrq_slink_t first;
};
_Static_assert(offsetof(struct ks_smrq_slist_head, first) == 0x0, "ks_smrq_slist_head.first offset");
_Static_assert(sizeof(struct ks_smrq_slist_head) == 0x8, "ks_smrq_slist_head size");

/* refs: 2 */
struct ks_sockbuf {
    unsigned int sb_cc;
    unsigned int sb_hiwat;
    unsigned int sb_mbcnt;
    unsigned int sb_mbmax;
    unsigned int sb_ctl;
    unsigned int sb_lowat;
    struct ks_mbuf *sb_mb;
    struct ks_mbuf *sb_mbtail;
    struct ks_mbuf *sb_lastrecord;
    struct ks_socket *sb_so;
    struct ks_selinfo sb_sel;
    struct ks_timeval sb_timeo;
    unsigned int sb_flags;
    unsigned int sb_idealsize;
    void *sb_upcall;
    void *sb_upcallarg;
    unsigned int sb_wantlock;
    unsigned int sb_waiters;
    struct ks_thread *sb_cfil_thread;
    unsigned int sb_cfil_refs;
    unsigned int sb_preconn_hiwat;
    struct ks_mbuf *sb_sendhead;
    int sb_sendoff;
};
_Static_assert(offsetof(struct ks_sockbuf, sb_cc) == 0x0, "ks_sockbuf.sb_cc offset");
_Static_assert(offsetof(struct ks_sockbuf, sb_hiwat) == 0x4, "ks_sockbuf.sb_hiwat offset");
_Static_assert(offsetof(struct ks_sockbuf, sb_mbcnt) == 0x8, "ks_sockbuf.sb_mbcnt offset");
_Static_assert(offsetof(struct ks_sockbuf, sb_mbmax) == 0xC, "ks_sockbuf.sb_mbmax offset");
_Static_assert(offsetof(struct ks_sockbuf, sb_ctl) == 0x10, "ks_sockbuf.sb_ctl offset");
_Static_assert(offsetof(struct ks_sockbuf, sb_lowat) == 0x14, "ks_sockbuf.sb_lowat offset");
_Static_assert(offsetof(struct ks_sockbuf, sb_mb) == 0x18, "ks_sockbuf.sb_mb offset");
_Static_assert(offsetof(struct ks_sockbuf, sb_mbtail) == 0x20, "ks_sockbuf.sb_mbtail offset");
_Static_assert(offsetof(struct ks_sockbuf, sb_lastrecord) == 0x28, "ks_sockbuf.sb_lastrecord offset");
_Static_assert(offsetof(struct ks_sockbuf, sb_so) == 0x30, "ks_sockbuf.sb_so offset");
_Static_assert(offsetof(struct ks_sockbuf, sb_sel) == 0x38, "ks_sockbuf.sb_sel offset");
_Static_assert(offsetof(struct ks_sockbuf, sb_timeo) == 0x70, "ks_sockbuf.sb_timeo offset");
_Static_assert(offsetof(struct ks_sockbuf, sb_flags) == 0x80, "ks_sockbuf.sb_flags offset");
_Static_assert(offsetof(struct ks_sockbuf, sb_idealsize) == 0x84, "ks_sockbuf.sb_idealsize offset");
_Static_assert(offsetof(struct ks_sockbuf, sb_upcall) == 0x88, "ks_sockbuf.sb_upcall offset");
_Static_assert(offsetof(struct ks_sockbuf, sb_upcallarg) == 0x90, "ks_sockbuf.sb_upcallarg offset");
_Static_assert(offsetof(struct ks_sockbuf, sb_wantlock) == 0x98, "ks_sockbuf.sb_wantlock offset");
_Static_assert(offsetof(struct ks_sockbuf, sb_waiters) == 0x9C, "ks_sockbuf.sb_waiters offset");
_Static_assert(offsetof(struct ks_sockbuf, sb_cfil_thread) == 0xA0, "ks_sockbuf.sb_cfil_thread offset");
_Static_assert(offsetof(struct ks_sockbuf, sb_cfil_refs) == 0xA8, "ks_sockbuf.sb_cfil_refs offset");
_Static_assert(offsetof(struct ks_sockbuf, sb_preconn_hiwat) == 0xAC, "ks_sockbuf.sb_preconn_hiwat offset");
_Static_assert(offsetof(struct ks_sockbuf, sb_sendhead) == 0xB0, "ks_sockbuf.sb_sendhead offset");
_Static_assert(offsetof(struct ks_sockbuf, sb_sendoff) == 0xB8, "ks_sockbuf.sb_sendoff offset");
_Static_assert(sizeof(struct ks_sockbuf) == 0xC0, "ks_sockbuf size");

/* refs: 14 */
struct ks_socket {
    int so_zone;
    short so_type;
    unsigned short so_protocol;
    int so_family;
    unsigned short so_error;
    unsigned int so_options;
    short so_linger;
    short so_state;
    void *so_pcb;
    struct ks_protosw *so_proto;
    struct ks_socket *so_head;
    struct {
        struct ks_socket *tqh_first;
        struct ks_socket **tqh_last;
    } so_incomp;
    struct {
        struct ks_socket *tqh_first;
        struct ks_socket **tqh_last;
    } so_comp;
    struct {
        struct ks_socket *tqe_next;
        struct ks_socket **tqe_prev;
    } so_list;
    short so_qlen;
    short so_incqlen;
    short so_qlimit;
    short so_timeo;
    int so_pgid;
    unsigned int so_oobmark;
    struct ks_sockbuf so_rcv;
    struct ks_sockbuf so_snd;
    char *so_tpcb;
    void *so_event;
    void *so_eventarg;
    struct ks_ucred *so_cred;
    unsigned long long so_gencnt;
    unsigned int so_eventmask;
    int last_pid;
    unsigned long long last_upid;
    struct ks_socket_filter_entry *so_filt;
    unsigned int so_flags;
    unsigned int so_flags1;
    unsigned int so_upcallusecount;
    int so_usecount;
    int so_retaincnt;
    unsigned short so_traffic_class;
    signed char so_netsvctype;
    unsigned char so_restrictions;
    struct ks_thread *so_send_filt_thread;
    void *lock_lr[4];
    void *unlock_lr[4];
    unsigned char next_lock_lr;
    unsigned char next_unlock_lr;
    unsigned short so_pktheadroom;
    unsigned int so_ifdenied_notifies;
    struct ks_thread *so_background_thread;
    struct ks_data_stats so_tc_stats[4];
    struct ks_klist so_klist;
    struct ks_flow_divert_pcb *so_fd_pcb;
    struct ks_soflow_db *so_flow_db;
    struct ks_cfil_info *so_cfil;
    unsigned int so_state_change_cnt;
    int e_pid;
    unsigned long long e_upid;
    int so_rpid;
    unsigned char last_uuid[0x10];
    unsigned char e_uuid[0x10];
    unsigned char so_vuuid[0x10];
    unsigned char so_ruuid[0x10];
    unsigned int so_persona_id;
    int so_policy_gencnt;
    unsigned long long so_extended_bk_start;
    unsigned char so_fallback_mode;
    unsigned char so_log_seqn;
    unsigned char so_mpkl_send_proto;
    unsigned char so_mpkl_send_uuid[0x10];
};
_Static_assert(offsetof(struct ks_socket, so_zone) == 0x0, "ks_socket.so_zone offset");
_Static_assert(offsetof(struct ks_socket, so_type) == 0x4, "ks_socket.so_type offset");
_Static_assert(offsetof(struct ks_socket, so_protocol) == 0x6, "ks_socket.so_protocol offset");
_Static_assert(offsetof(struct ks_socket, so_family) == 0x8, "ks_socket.so_family offset");
_Static_assert(offsetof(struct ks_socket, so_error) == 0xC, "ks_socket.so_error offset");
_Static_assert(offsetof(struct ks_socket, so_options) == 0x10, "ks_socket.so_options offset");
_Static_assert(offsetof(struct ks_socket, so_linger) == 0x14, "ks_socket.so_linger offset");
_Static_assert(offsetof(struct ks_socket, so_state) == 0x16, "ks_socket.so_state offset");
_Static_assert(offsetof(struct ks_socket, so_pcb) == 0x18, "ks_socket.so_pcb offset");
_Static_assert(offsetof(struct ks_socket, so_proto) == 0x20, "ks_socket.so_proto offset");
_Static_assert(offsetof(struct ks_socket, so_head) == 0x28, "ks_socket.so_head offset");
_Static_assert(offsetof(struct ks_socket, so_incomp) == 0x30, "ks_socket.so_incomp offset");
_Static_assert(offsetof(struct ks_socket, so_comp) == 0x40, "ks_socket.so_comp offset");
_Static_assert(offsetof(struct ks_socket, so_list) == 0x50, "ks_socket.so_list offset");
_Static_assert(offsetof(struct ks_socket, so_qlen) == 0x60, "ks_socket.so_qlen offset");
_Static_assert(offsetof(struct ks_socket, so_incqlen) == 0x62, "ks_socket.so_incqlen offset");
_Static_assert(offsetof(struct ks_socket, so_qlimit) == 0x64, "ks_socket.so_qlimit offset");
_Static_assert(offsetof(struct ks_socket, so_timeo) == 0x66, "ks_socket.so_timeo offset");
_Static_assert(offsetof(struct ks_socket, so_pgid) == 0x68, "ks_socket.so_pgid offset");
_Static_assert(offsetof(struct ks_socket, so_oobmark) == 0x6C, "ks_socket.so_oobmark offset");
_Static_assert(offsetof(struct ks_socket, so_rcv) == 0x70, "ks_socket.so_rcv offset");
_Static_assert(offsetof(struct ks_socket, so_snd) == 0x130, "ks_socket.so_snd offset");
_Static_assert(offsetof(struct ks_socket, so_tpcb) == 0x1F0, "ks_socket.so_tpcb offset");
_Static_assert(offsetof(struct ks_socket, so_event) == 0x1F8, "ks_socket.so_event offset");
_Static_assert(offsetof(struct ks_socket, so_eventarg) == 0x200, "ks_socket.so_eventarg offset");
_Static_assert(offsetof(struct ks_socket, so_cred) == 0x208, "ks_socket.so_cred offset");
_Static_assert(offsetof(struct ks_socket, so_gencnt) == 0x210, "ks_socket.so_gencnt offset");
_Static_assert(offsetof(struct ks_socket, so_eventmask) == 0x218, "ks_socket.so_eventmask offset");
_Static_assert(offsetof(struct ks_socket, last_pid) == 0x21C, "ks_socket.last_pid offset");
_Static_assert(offsetof(struct ks_socket, last_upid) == 0x220, "ks_socket.last_upid offset");
_Static_assert(offsetof(struct ks_socket, so_filt) == 0x228, "ks_socket.so_filt offset");
_Static_assert(offsetof(struct ks_socket, so_flags) == 0x230, "ks_socket.so_flags offset");
_Static_assert(offsetof(struct ks_socket, so_flags1) == 0x234, "ks_socket.so_flags1 offset");
_Static_assert(offsetof(struct ks_socket, so_upcallusecount) == 0x238, "ks_socket.so_upcallusecount offset");
_Static_assert(offsetof(struct ks_socket, so_usecount) == 0x23C, "ks_socket.so_usecount offset");
_Static_assert(offsetof(struct ks_socket, so_retaincnt) == 0x240, "ks_socket.so_retaincnt offset");
_Static_assert(offsetof(struct ks_socket, so_traffic_class) == 0x244, "ks_socket.so_traffic_class offset");
_Static_assert(offsetof(struct ks_socket, so_netsvctype) == 0x246, "ks_socket.so_netsvctype offset");
_Static_assert(offsetof(struct ks_socket, so_restrictions) == 0x247, "ks_socket.so_restrictions offset");
_Static_assert(offsetof(struct ks_socket, so_send_filt_thread) == 0x248, "ks_socket.so_send_filt_thread offset");
_Static_assert(offsetof(struct ks_socket, lock_lr) == 0x250, "ks_socket.lock_lr offset");
_Static_assert(offsetof(struct ks_socket, unlock_lr) == 0x270, "ks_socket.unlock_lr offset");
_Static_assert(offsetof(struct ks_socket, next_lock_lr) == 0x290, "ks_socket.next_lock_lr offset");
_Static_assert(offsetof(struct ks_socket, next_unlock_lr) == 0x291, "ks_socket.next_unlock_lr offset");
_Static_assert(offsetof(struct ks_socket, so_pktheadroom) == 0x292, "ks_socket.so_pktheadroom offset");
_Static_assert(offsetof(struct ks_socket, so_ifdenied_notifies) == 0x294, "ks_socket.so_ifdenied_notifies offset");
_Static_assert(offsetof(struct ks_socket, so_background_thread) == 0x298, "ks_socket.so_background_thread offset");
_Static_assert(offsetof(struct ks_socket, so_tc_stats) == 0x2A0, "ks_socket.so_tc_stats offset");
_Static_assert(offsetof(struct ks_socket, so_klist) == 0x320, "ks_socket.so_klist offset");
_Static_assert(offsetof(struct ks_socket, so_fd_pcb) == 0x328, "ks_socket.so_fd_pcb offset");
_Static_assert(offsetof(struct ks_socket, so_flow_db) == 0x330, "ks_socket.so_flow_db offset");
_Static_assert(offsetof(struct ks_socket, so_cfil) == 0x338, "ks_socket.so_cfil offset");
_Static_assert(offsetof(struct ks_socket, so_state_change_cnt) == 0x340, "ks_socket.so_state_change_cnt offset");
_Static_assert(offsetof(struct ks_socket, e_pid) == 0x344, "ks_socket.e_pid offset");
_Static_assert(offsetof(struct ks_socket, e_upid) == 0x348, "ks_socket.e_upid offset");
_Static_assert(offsetof(struct ks_socket, so_rpid) == 0x350, "ks_socket.so_rpid offset");
_Static_assert(offsetof(struct ks_socket, last_uuid) == 0x354, "ks_socket.last_uuid offset");
_Static_assert(offsetof(struct ks_socket, e_uuid) == 0x364, "ks_socket.e_uuid offset");
_Static_assert(offsetof(struct ks_socket, so_vuuid) == 0x374, "ks_socket.so_vuuid offset");
_Static_assert(offsetof(struct ks_socket, so_ruuid) == 0x384, "ks_socket.so_ruuid offset");
_Static_assert(offsetof(struct ks_socket, so_persona_id) == 0x394, "ks_socket.so_persona_id offset");
_Static_assert(offsetof(struct ks_socket, so_policy_gencnt) == 0x398, "ks_socket.so_policy_gencnt offset");
_Static_assert(offsetof(struct ks_socket, so_extended_bk_start) == 0x3A0, "ks_socket.so_extended_bk_start offset");
_Static_assert(offsetof(struct ks_socket, so_fallback_mode) == 0x3A8, "ks_socket.so_fallback_mode offset");
_Static_assert(offsetof(struct ks_socket, so_log_seqn) == 0x3A9, "ks_socket.so_log_seqn offset");
_Static_assert(offsetof(struct ks_socket, so_mpkl_send_proto) == 0x3AA, "ks_socket.so_mpkl_send_proto offset");
_Static_assert(offsetof(struct ks_socket, so_mpkl_send_uuid) == 0x3AB, "ks_socket.so_mpkl_send_uuid offset");
_Static_assert(sizeof(struct ks_socket) == 0x3C0, "ks_socket size");

/* refs: 9 */
struct ks_socket_filter {
    struct {
        struct ks_socket_filter *tqe_next;
        struct ks_socket_filter **tqe_prev;
    } sf_protosw_next;
    struct {
        struct ks_socket_filter *tqe_next;
        struct ks_socket_filter **tqe_prev;
    } sf_global_next;
    struct ks_socket_filter_entry *sf_entry_head;
    struct ks_protosw *sf_proto;
    struct ks_sflt_filter sf_filter;
    struct ks_os_refcnt sf_refcount;
    unsigned int sf_flags;
};
_Static_assert(offsetof(struct ks_socket_filter, sf_protosw_next) == 0x0, "ks_socket_filter.sf_protosw_next offset");
_Static_assert(offsetof(struct ks_socket_filter, sf_global_next) == 0x10, "ks_socket_filter.sf_global_next offset");
_Static_assert(offsetof(struct ks_socket_filter, sf_entry_head) == 0x20, "ks_socket_filter.sf_entry_head offset");
_Static_assert(offsetof(struct ks_socket_filter, sf_proto) == 0x28, "ks_socket_filter.sf_proto offset");
_Static_assert(offsetof(struct ks_socket_filter, sf_filter) == 0x30, "ks_socket_filter.sf_filter offset");
_Static_assert(offsetof(struct ks_socket_filter, sf_refcount) == 0xF0, "ks_socket_filter.sf_refcount offset");
_Static_assert(offsetof(struct ks_socket_filter, sf_flags) == 0xF4, "ks_socket_filter.sf_flags offset");
_Static_assert(sizeof(struct ks_socket_filter) == 0xF8, "ks_socket_filter size");

/* refs: 2 */
struct ks_socket_filter_entry {
    struct ks_socket_filter_entry *sfe_next_onsocket;
    struct ks_socket_filter_entry *sfe_next_onfilter;
    struct ks_socket_filter_entry *sfe_next_oncleanup;
    struct ks_socket_filter *sfe_filter;
    struct ks_socket *sfe_socket;
    void *sfe_cookie;
    unsigned int sfe_flags;
    struct ks_os_refcnt sfe_refcount;
};
_Static_assert(offsetof(struct ks_socket_filter_entry, sfe_next_onsocket) == 0x0, "ks_socket_filter_entry.sfe_next_onsocket offset");
_Static_assert(offsetof(struct ks_socket_filter_entry, sfe_next_onfilter) == 0x8, "ks_socket_filter_entry.sfe_next_onfilter offset");
_Static_assert(offsetof(struct ks_socket_filter_entry, sfe_next_oncleanup) == 0x10, "ks_socket_filter_entry.sfe_next_oncleanup offset");
_Static_assert(offsetof(struct ks_socket_filter_entry, sfe_filter) == 0x18, "ks_socket_filter_entry.sfe_filter offset");
_Static_assert(offsetof(struct ks_socket_filter_entry, sfe_socket) == 0x20, "ks_socket_filter_entry.sfe_socket offset");
_Static_assert(offsetof(struct ks_socket_filter_entry, sfe_cookie) == 0x28, "ks_socket_filter_entry.sfe_cookie offset");
_Static_assert(offsetof(struct ks_socket_filter_entry, sfe_flags) == 0x30, "ks_socket_filter_entry.sfe_flags offset");
_Static_assert(offsetof(struct ks_socket_filter_entry, sfe_refcount) == 0x34, "ks_socket_filter_entry.sfe_refcount offset");
_Static_assert(sizeof(struct ks_socket_filter_entry) == 0x38, "ks_socket_filter_entry size");

/* refs: 2 */
struct ks_soflow_db {
    struct ks_os_refcnt soflow_db_ref_count;
    struct ks_socket *soflow_db_so;
    unsigned int soflow_db_count;
    struct ks_soflow_hash_head *soflow_db_hashbase;
    unsigned long soflow_db_hashmask;
    struct ks_soflow_hash_entry *soflow_db_only_entry;
    unsigned char soflow_db_debug : 1; /* bit offset 384 */
    unsigned char soflow_db_reserved : 7; /* bit offset 385 */
    unsigned long long soflow_db_flags;
};
_Static_assert(offsetof(struct ks_soflow_db, soflow_db_ref_count) == 0x0, "ks_soflow_db.soflow_db_ref_count offset");
_Static_assert(offsetof(struct ks_soflow_db, soflow_db_so) == 0x8, "ks_soflow_db.soflow_db_so offset");
_Static_assert(offsetof(struct ks_soflow_db, soflow_db_count) == 0x10, "ks_soflow_db.soflow_db_count offset");
_Static_assert(offsetof(struct ks_soflow_db, soflow_db_hashbase) == 0x18, "ks_soflow_db.soflow_db_hashbase offset");
_Static_assert(offsetof(struct ks_soflow_db, soflow_db_hashmask) == 0x20, "ks_soflow_db.soflow_db_hashmask offset");
_Static_assert(offsetof(struct ks_soflow_db, soflow_db_only_entry) == 0x28, "ks_soflow_db.soflow_db_only_entry offset");
_Static_assert(offsetof(struct ks_soflow_db, soflow_db_flags) == 0x38, "ks_soflow_db.soflow_db_flags offset");
_Static_assert(sizeof(struct ks_soflow_db) == 0x40, "ks_soflow_db size");

/* refs: 7 */
struct ks_soflow_hash_entry {
    struct {
        struct ks_soflow_hash_entry *le_next;
        struct ks_soflow_hash_entry **le_prev;
    } soflow_entry_link;
    struct {
        struct ks_soflow_hash_entry *tqe_next;
        struct ks_soflow_hash_entry **tqe_prev;
    } soflow_entry_list_link;
    struct ks_os_refcnt soflow_ref_count;
    struct ks_soflow_db *soflow_db;
    unsigned short soflow_outifindex;
    unsigned short soflow_fport;
    unsigned short soflow_lport;
    unsigned char soflow_family;
    unsigned int soflow_flowhash;
    unsigned long long soflow_lastused;
    unsigned int soflow_faddr6_ifscope;
    unsigned int soflow_laddr6_ifscope;
    union {
        struct ks_in_addr_4in6 addr46;
        struct ks_in6_addr addr6;
    } soflow_faddr;
    union {
        struct ks_in_addr_4in6 addr46;
        struct ks_in6_addr addr6;
    } soflow_laddr;
    unsigned char soflow_outgoing : 1; /* bit offset 896 */
    unsigned char soflow_laddr_updated : 1; /* bit offset 897 */
    unsigned char soflow_lport_updated : 1; /* bit offset 898 */
    unsigned char soflow_gc : 1; /* bit offset 899 */
    unsigned char soflow_feat_gc : 1; /* bit offset 900 */
    unsigned char soflow_debug : 1; /* bit offset 901 */
    unsigned char soflow_reserved : 2; /* bit offset 902 */
    unsigned long long soflow_rxpackets;
    unsigned long long soflow_rxbytes;
    unsigned long long soflow_txpackets;
    unsigned long long soflow_txbytes;
    unsigned long long soflow_feat_ctxt_id;
    void *soflow_feat_ctxt;
    unsigned int soflow_filter_control_unit;
    int soflow_policies_gencount;
    struct ks_timeval soflow_timestamp;
};
_Static_assert(offsetof(struct ks_soflow_hash_entry, soflow_entry_link) == 0x0, "ks_soflow_hash_entry.soflow_entry_link offset");
_Static_assert(offsetof(struct ks_soflow_hash_entry, soflow_entry_list_link) == 0x10, "ks_soflow_hash_entry.soflow_entry_list_link offset");
_Static_assert(offsetof(struct ks_soflow_hash_entry, soflow_ref_count) == 0x20, "ks_soflow_hash_entry.soflow_ref_count offset");
_Static_assert(offsetof(struct ks_soflow_hash_entry, soflow_db) == 0x28, "ks_soflow_hash_entry.soflow_db offset");
_Static_assert(offsetof(struct ks_soflow_hash_entry, soflow_outifindex) == 0x30, "ks_soflow_hash_entry.soflow_outifindex offset");
_Static_assert(offsetof(struct ks_soflow_hash_entry, soflow_fport) == 0x32, "ks_soflow_hash_entry.soflow_fport offset");
_Static_assert(offsetof(struct ks_soflow_hash_entry, soflow_lport) == 0x34, "ks_soflow_hash_entry.soflow_lport offset");
_Static_assert(offsetof(struct ks_soflow_hash_entry, soflow_family) == 0x36, "ks_soflow_hash_entry.soflow_family offset");
_Static_assert(offsetof(struct ks_soflow_hash_entry, soflow_flowhash) == 0x38, "ks_soflow_hash_entry.soflow_flowhash offset");
_Static_assert(offsetof(struct ks_soflow_hash_entry, soflow_lastused) == 0x40, "ks_soflow_hash_entry.soflow_lastused offset");
_Static_assert(offsetof(struct ks_soflow_hash_entry, soflow_faddr6_ifscope) == 0x48, "ks_soflow_hash_entry.soflow_faddr6_ifscope offset");
_Static_assert(offsetof(struct ks_soflow_hash_entry, soflow_laddr6_ifscope) == 0x4C, "ks_soflow_hash_entry.soflow_laddr6_ifscope offset");
_Static_assert(offsetof(struct ks_soflow_hash_entry, soflow_faddr) == 0x50, "ks_soflow_hash_entry.soflow_faddr offset");
_Static_assert(offsetof(struct ks_soflow_hash_entry, soflow_laddr) == 0x60, "ks_soflow_hash_entry.soflow_laddr offset");
_Static_assert(offsetof(struct ks_soflow_hash_entry, soflow_rxpackets) == 0x78, "ks_soflow_hash_entry.soflow_rxpackets offset");
_Static_assert(offsetof(struct ks_soflow_hash_entry, soflow_rxbytes) == 0x80, "ks_soflow_hash_entry.soflow_rxbytes offset");
_Static_assert(offsetof(struct ks_soflow_hash_entry, soflow_txpackets) == 0x88, "ks_soflow_hash_entry.soflow_txpackets offset");
_Static_assert(offsetof(struct ks_soflow_hash_entry, soflow_txbytes) == 0x90, "ks_soflow_hash_entry.soflow_txbytes offset");
_Static_assert(offsetof(struct ks_soflow_hash_entry, soflow_feat_ctxt_id) == 0x98, "ks_soflow_hash_entry.soflow_feat_ctxt_id offset");
_Static_assert(offsetof(struct ks_soflow_hash_entry, soflow_feat_ctxt) == 0xA0, "ks_soflow_hash_entry.soflow_feat_ctxt offset");
_Static_assert(offsetof(struct ks_soflow_hash_entry, soflow_filter_control_unit) == 0xA8, "ks_soflow_hash_entry.soflow_filter_control_unit offset");
_Static_assert(offsetof(struct ks_soflow_hash_entry, soflow_policies_gencount) == 0xAC, "ks_soflow_hash_entry.soflow_policies_gencount offset");
_Static_assert(offsetof(struct ks_soflow_hash_entry, soflow_timestamp) == 0xB0, "ks_soflow_hash_entry.soflow_timestamp offset");
_Static_assert(sizeof(struct ks_soflow_hash_entry) == 0xC0, "ks_soflow_hash_entry size");

/* refs: 2 */
struct ks_soflow_hash_head {
    struct ks_soflow_hash_entry *lh_first;
};
_Static_assert(offsetof(struct ks_soflow_hash_head, lh_first) == 0x0, "ks_soflow_hash_head.lh_first offset");
_Static_assert(sizeof(struct ks_soflow_hash_head) == 0x8, "ks_soflow_hash_head size");

/* refs: 1 */
struct ks_specinfo {
    struct ks_vnode **si_hashchain;
    struct ks_vnode *si_specnext;
    long si_flags;
    int si_rdev;
    int si_opencount;
    int si_size;
    long long si_lastr;
    unsigned long long si_devsize;
    unsigned char si_initted;
    unsigned char si_throttleable;
    unsigned short si_isssd;
    unsigned int si_devbsdunit;
    unsigned long long si_throttle_mask;
    struct ks_thread *si_mountingowner;
};
_Static_assert(offsetof(struct ks_specinfo, si_hashchain) == 0x0, "ks_specinfo.si_hashchain offset");
_Static_assert(offsetof(struct ks_specinfo, si_specnext) == 0x8, "ks_specinfo.si_specnext offset");
_Static_assert(offsetof(struct ks_specinfo, si_flags) == 0x10, "ks_specinfo.si_flags offset");
_Static_assert(offsetof(struct ks_specinfo, si_rdev) == 0x18, "ks_specinfo.si_rdev offset");
_Static_assert(offsetof(struct ks_specinfo, si_opencount) == 0x1C, "ks_specinfo.si_opencount offset");
_Static_assert(offsetof(struct ks_specinfo, si_size) == 0x20, "ks_specinfo.si_size offset");
_Static_assert(offsetof(struct ks_specinfo, si_lastr) == 0x28, "ks_specinfo.si_lastr offset");
_Static_assert(offsetof(struct ks_specinfo, si_devsize) == 0x30, "ks_specinfo.si_devsize offset");
_Static_assert(offsetof(struct ks_specinfo, si_initted) == 0x38, "ks_specinfo.si_initted offset");
_Static_assert(offsetof(struct ks_specinfo, si_throttleable) == 0x39, "ks_specinfo.si_throttleable offset");
_Static_assert(offsetof(struct ks_specinfo, si_isssd) == 0x3A, "ks_specinfo.si_isssd offset");
_Static_assert(offsetof(struct ks_specinfo, si_devbsdunit) == 0x3C, "ks_specinfo.si_devbsdunit offset");
_Static_assert(offsetof(struct ks_specinfo, si_throttle_mask) == 0x40, "ks_specinfo.si_throttle_mask offset");
_Static_assert(offsetof(struct ks_specinfo, si_mountingowner) == 0x48, "ks_specinfo.si_mountingowner offset");
_Static_assert(sizeof(struct ks_specinfo) == 0x50, "ks_specinfo size");

/* refs: 1 */
struct ks_task_effective_policy {
    unsigned long long tep_darwinbg : 1; /* bit offset 0 */
    unsigned long long tep_lowpri_cpu : 1; /* bit offset 1 */
    unsigned long long tep_io_tier : 2; /* bit offset 2 */
    unsigned long long tep_io_passive : 1; /* bit offset 4 */
    unsigned long long tep_all_sockets_bg : 1; /* bit offset 5 */
    unsigned long long tep_new_sockets_bg : 1; /* bit offset 6 */
    unsigned long long tep_bg_iotier : 2; /* bit offset 7 */
    unsigned long long tep_terminated : 1; /* bit offset 9 */
    unsigned long long tep_qos_ui_is_urgent : 1; /* bit offset 10 */
    unsigned long long tep_latency_qos : 3; /* bit offset 11 */
    unsigned long long tep_through_qos : 3; /* bit offset 14 */
    unsigned long long tep_tal_engaged : 1; /* bit offset 17 */
    unsigned long long tep_watchers_bg : 1; /* bit offset 18 */
    unsigned long long tep_sup_active : 1; /* bit offset 19 */
    unsigned long long tep_role : 4; /* bit offset 20 */
    unsigned long long tep_suppressed_cpu : 1; /* bit offset 24 */
    unsigned long long tep_sfi_managed : 1; /* bit offset 25 */
    unsigned long long tep_live_donor : 1; /* bit offset 26 */
    unsigned long long tep_qos_clamp : 3; /* bit offset 27 */
    unsigned long long tep_qos_ceiling : 3; /* bit offset 30 */
    unsigned long long tep_promote_above_task : 1; /* bit offset 33 */
    unsigned long long tep_coalition_bg : 1; /* bit offset 34 */
    unsigned long long tep_runaway_mitigation : 1; /* bit offset 35 */
    unsigned long long tep_reserved : 28; /* bit offset 36 */
};
_Static_assert(sizeof(struct ks_task_effective_policy) == 0x8, "ks_task_effective_policy size");

/* refs: 1 */
struct ks_task_pend_token {
    union {
        struct {
            unsigned int tpt_update_sockets : 1; /* bit offset 0 */
            unsigned int tpt_update_timers : 1; /* bit offset 1 */
            unsigned int tpt_update_watchers : 1; /* bit offset 2 */
            unsigned int tpt_update_live_donor : 1; /* bit offset 3 */
            unsigned int tpt_update_coal_sfi : 1; /* bit offset 4 */
            unsigned int tpt_update_throttle : 1; /* bit offset 5 */
            unsigned int tpt_update_thread_sfi : 1; /* bit offset 6 */
            unsigned int tpt_force_recompute_pri : 1; /* bit offset 7 */
            unsigned int tpt_update_tg_ui_flag : 1; /* bit offset 8 */
            unsigned int tpt_update_turnstile : 1; /* bit offset 9 */
            unsigned int tpt_update_tg_app_flag : 1; /* bit offset 10 */
            unsigned int tpt_update_game_mode : 1; /* bit offset 11 */
            unsigned int tpt_update_carplay_mode : 1; /* bit offset 12 */
            unsigned int tpt_update_appnap : 1; /* bit offset 13 */
        };
        unsigned int tpt_value;
    };
};
_Static_assert(sizeof(struct ks_task_pend_token) == 0x4, "ks_task_pend_token size");

/* refs: 1 */
struct ks_task_requested_policy {
    unsigned long long trp_int_darwinbg : 1; /* bit offset 0 */
    unsigned long long trp_ext_darwinbg : 1; /* bit offset 1 */
    unsigned long long trp_int_iotier : 2; /* bit offset 2 */
    unsigned long long trp_ext_iotier : 2; /* bit offset 4 */
    unsigned long long trp_int_iopassive : 1; /* bit offset 6 */
    unsigned long long trp_ext_iopassive : 1; /* bit offset 7 */
    unsigned long long trp_bg_iotier : 2; /* bit offset 8 */
    unsigned long long trp_terminated : 1; /* bit offset 10 */
    unsigned long long trp_base_latency_qos : 3; /* bit offset 11 */
    unsigned long long trp_base_through_qos : 3; /* bit offset 14 */
    unsigned long long trp_apptype : 3; /* bit offset 17 */
    unsigned long long trp_boosted : 1; /* bit offset 20 */
    unsigned long long trp_role : 5; /* bit offset 21 */
    unsigned long long trp_over_latency_qos : 3; /* bit offset 26 */
    unsigned long long trp_over_through_qos : 3; /* bit offset 29 */
    unsigned long long trp_sfi_managed : 1; /* bit offset 32 */
    unsigned long long trp_qos_clamp : 3; /* bit offset 33 */
    unsigned long long trp_sup_active : 1; /* bit offset 36 */
    unsigned long long trp_sup_lowpri_cpu : 1; /* bit offset 37 */
    unsigned long long trp_sup_timer : 3; /* bit offset 38 */
    unsigned long long trp_sup_disk : 1; /* bit offset 41 */
    unsigned long long trp_sup_throughput : 3; /* bit offset 42 */
    unsigned long long trp_sup_cpu : 1; /* bit offset 45 */
    unsigned long long trp_sup_bg_sockets : 1; /* bit offset 46 */
    unsigned long long trp_runaway_mitigation : 1; /* bit offset 47 */
    unsigned long long trp_reserved : 16; /* bit offset 48 */
};
_Static_assert(sizeof(struct ks_task_requested_policy) == 0x8, "ks_task_requested_policy size");

/* refs: 2 */
struct ks_task_security_config {
    union {
        struct {
            unsigned short hardened_heap : 1; /* bit offset 0 */
            unsigned short tpro : 1; /* bit offset 1 */
            unsigned short reserved : 1; /* bit offset 2 */
            unsigned short platform_restrictions_version : 3; /* bit offset 3 */
            unsigned short script_restrictions : 1; /* bit offset 6 */
            unsigned short ipc_containment_vessel : 1; /* bit offset 7 */
            unsigned short guard_objects : 1; /* bit offset 8 */
            unsigned char hardened_process_version;
        };
        unsigned int value;
    };
};
_Static_assert(sizeof(struct ks_task_security_config) == 0x4, "ks_task_security_config size");

/* refs: 2 */
struct ks_task_writes_counters {
    unsigned long long task_immediate_writes;
    unsigned long long task_deferred_writes;
    unsigned long long task_invalidated_writes;
    unsigned long long task_metadata_writes;
};
_Static_assert(offsetof(struct ks_task_writes_counters, task_immediate_writes) == 0x0, "ks_task_writes_counters.task_immediate_writes offset");
_Static_assert(offsetof(struct ks_task_writes_counters, task_deferred_writes) == 0x8, "ks_task_writes_counters.task_deferred_writes offset");
_Static_assert(offsetof(struct ks_task_writes_counters, task_invalidated_writes) == 0x10, "ks_task_writes_counters.task_invalidated_writes offset");
_Static_assert(offsetof(struct ks_task_writes_counters, task_metadata_writes) == 0x18, "ks_task_writes_counters.task_metadata_writes offset");
_Static_assert(sizeof(struct ks_task_writes_counters) == 0x20, "ks_task_writes_counters size");

/* refs: 2 */
struct ks_vm_extmod_statistics {
    long long task_for_pid_count;
    long long task_for_pid_caller_count;
    long long thread_creation_count;
    long long thread_creation_caller_count;
    long long thread_set_state_count;
    long long thread_set_state_caller_count;
} __attribute__((aligned(8)));
_Static_assert(offsetof(struct ks_vm_extmod_statistics, task_for_pid_count) == 0x0, "ks_vm_extmod_statistics.task_for_pid_count offset");
_Static_assert(offsetof(struct ks_vm_extmod_statistics, task_for_pid_caller_count) == 0x8, "ks_vm_extmod_statistics.task_for_pid_caller_count offset");
_Static_assert(offsetof(struct ks_vm_extmod_statistics, thread_creation_count) == 0x10, "ks_vm_extmod_statistics.thread_creation_count offset");
_Static_assert(offsetof(struct ks_vm_extmod_statistics, thread_creation_caller_count) == 0x18, "ks_vm_extmod_statistics.thread_creation_caller_count offset");
_Static_assert(offsetof(struct ks_vm_extmod_statistics, thread_set_state_count) == 0x20, "ks_vm_extmod_statistics.thread_set_state_count offset");
_Static_assert(offsetof(struct ks_vm_extmod_statistics, thread_set_state_caller_count) == 0x28, "ks_vm_extmod_statistics.thread_set_state_caller_count offset");
_Static_assert(sizeof(struct ks_vm_extmod_statistics) == 0x30, "ks_vm_extmod_statistics size");

/* refs: 13 */
struct ks_task {
    struct ks_lck_mtx_s lock;
    struct ks_os_refcnt ref_count;
    _Bool active;
    _Bool ipc_active;
    _Bool halting;
    _Bool message_app_suspended;
    unsigned int vtimers;
    unsigned int loadTag;
    unsigned long long task_uniqueid;
    struct ks__vm_map *map;
    struct ks_queue_entry tasks;
    struct ks_task_watchports *watchports;
    void *returnwait_inheritor;
    struct ks_queue_entry threads;
    struct ks_restartable_ranges *t_rr_ranges;
    struct ks_processor_set *pset_hint;
    struct ks_affinity_space *affinity_space;
    int thread_count;
    unsigned int active_thread_count;
    int suspend_count;
    int user_stop_count;
    int legacy_stop_count;
    short priority;
    short max_priority;
    int importance;
    unsigned long long total_runnable_time;
    struct ks_recount_task tk_recount;
    struct ks_lck_mtx_s itk_lock_data;
    struct ks_ipc_port *itk_task_ports[4];
    struct ks_ipc_port *itk_settable_self;
    struct ks_exception_action exc_actions[14];
    struct ks_hardened_exception_action hardened_exception_action;
    struct ks_ipc_port *itk_host;
    struct ks_ipc_port *itk_bootstrap;
    struct ks_ipc_port *itk_debug_control;
    struct ks_ipc_port *itk_task_access;
    struct ks_ipc_port *itk_resume;
    struct ks_ipc_port *itk_registered[3];
    struct ks_ipc_port **itk_dyld_notify;
    struct ks_ipc_space *itk_space;
    struct ks_ledger *ledger;
    struct ks_queue_entry semaphore_list;
    int semaphores_owned;
    unsigned int priv_flags;
    void *task_debug;
    unsigned long long rop_pid;
    unsigned long long jop_pid;
    unsigned char disable_user_jop;
    unsigned char has_jitbox;
    unsigned long long jitbox_version;
    unsigned long long jitbox_start;
    unsigned long long jitbox_size;
    int jitbox_enabled;
    struct ks_arm64_uexc_region_t uexc;
    _Bool preserve_x18;
    _Bool uses_1ghz_timebase;
    unsigned long long *faults;
    unsigned long long *pageins;
    unsigned long long *cow_faults;
    unsigned long long *messages_sent;
    unsigned long long *messages_received;
    unsigned int decompressions;
    unsigned int syscalls_mach;
    unsigned int syscalls_unix;
    unsigned int c_switch;
    unsigned int p_switch;
    unsigned int ps_switch;
    struct ks_proc_ro *bsd_info_ro;
    struct ks_kcdata_descriptor *corpse_info;
    unsigned long long crashed_thread_id;
    struct ks_queue_entry corpse_tasks;
    struct ks_label *crash_label;
    unsigned int t_flags;
    unsigned int t_procflags;
    unsigned long long all_image_info_addr;
    unsigned long long all_image_info_size;
    unsigned int t_kpc;
    unsigned char t_gpu_role;
    _Bool pidsuspended;
    _Bool frozen;
    _Bool changing_freeze_state;
    _Bool is_large_corpse;
    unsigned short policy_ru_cpu : 4; /* bit offset 8648 */
    unsigned short policy_ru_cpu_ext : 4; /* bit offset 8652 */
    unsigned short applied_ru_cpu : 4; /* bit offset 8656 */
    unsigned short applied_ru_cpu_ext : 4; /* bit offset 8660 */
    unsigned char rusage_cpu_flags;
    unsigned char rusage_cpu_percentage;
    unsigned char rusage_cpu_perthr_percentage;
    unsigned char t_returnwaitflags;
    _Bool shared_region_auth_remapped;
    char *shared_region_id;
    struct ks_vm_shared_region *shared_region;
    unsigned long long rusage_cpu_interval;
    unsigned long long rusage_cpu_perthr_interval;
    unsigned long long rusage_cpu_deadline;
    struct ks_thread_call *rusage_cpu_callt;
    struct ks_queue_entry task_watchers;
    int num_taskwatchers;
    int watchapplying;
    struct ks_bank_task *bank_context;
    struct ks_ipc_importance_task *task_imp_base;
    struct ks_vm_extmod_statistics extmod_statistics __attribute__((aligned(8)));
    struct ks_task_requested_policy requested_policy;
    struct ks_task_effective_policy effective_policy;
    struct ks_task_pend_token pended_coalition_changes;
    unsigned int low_mem_notified_warn : 1; /* bit offset 9952 */
    unsigned int low_mem_notified_critical : 1; /* bit offset 9953 */
    unsigned int purged_memory_warn : 1; /* bit offset 9954 */
    unsigned int purged_memory_critical : 1; /* bit offset 9955 */
    unsigned int low_mem_privileged_listener : 1; /* bit offset 9956 */
    unsigned int mem_notify_reserved : 27; /* bit offset 9957 */
    unsigned int memlimit_flags;
    struct ks_io_stat_info *task_io_stats;
    struct ks_task_writes_counters task_writes_counters_internal;
    struct ks_task_writes_counters task_writes_counters_external;
    struct ks__cpu_time_qos_stats cpu_time_eqos_stats;
    struct ks__cpu_time_qos_stats cpu_time_rqos_stats;
    unsigned int task_timer_wakeups_bin_1;
    unsigned int task_timer_wakeups_bin_2;
    unsigned long long task_gpu_ns;
    unsigned char task_can_transfer_memory_ownership;
    unsigned char task_objects_disowning;
    unsigned char task_objects_disowned;
    int task_volatile_objects;
    int task_nonvolatile_objects;
    int task_owned_objects;
    struct ks_queue_entry task_objq;
    struct ks_lck_mtx_s task_objq_lock;
    unsigned int task_thread_limit : 16; /* bit offset 12032 */
    unsigned int task_legacy_footprint : 1; /* bit offset 12048 */
    unsigned int task_extra_footprint_limit : 1; /* bit offset 12049 */
    unsigned int task_ios13extended_footprint_limit : 1; /* bit offset 12050 */
    unsigned int task_region_footprint : 1; /* bit offset 12051 */
    unsigned int task_region_info_flags : 1; /* bit offset 12052 */
    unsigned int task_has_crossed_thread_limit : 1; /* bit offset 12053 */
    unsigned int task_rr_in_flight : 1; /* bit offset 12054 */
    unsigned int task_jetsam_realtime_audio : 1; /* bit offset 12055 */
    struct ks_coalition *coalition[2];
    struct ks_queue_entry task_coalition[2];
    unsigned long long dispatchqueue_offset;
    void *hv_task_target;
    unsigned int task_exc_guard;
    unsigned long long mach_header_vm_address;
    struct ks_queue_entry io_user_clients;
    int donates_own_pages;
    unsigned int task_shared_region_slide;
    unsigned long long task_fs_metadata_writes;
    unsigned char task_shared_region_uuid[0x10];
    unsigned long long memstat_dirty_start;
    struct ks__vmobject_list_output_ *corpse_vmobject_list;
    unsigned long long corpse_vmobject_list_size;
    struct ks_vm_deferred_reclamation_metadata_s *deferred_reclamation_metadata;
    unsigned long long task_cs_auxiliary_info;
    struct ks_task_security_config security_config;
};
_Static_assert(offsetof(struct ks_task, lock) == 0x0, "ks_task.lock offset");
_Static_assert(offsetof(struct ks_task, ref_count) == 0x10, "ks_task.ref_count offset");
_Static_assert(offsetof(struct ks_task, active) == 0x14, "ks_task.active offset");
_Static_assert(offsetof(struct ks_task, ipc_active) == 0x15, "ks_task.ipc_active offset");
_Static_assert(offsetof(struct ks_task, halting) == 0x16, "ks_task.halting offset");
_Static_assert(offsetof(struct ks_task, message_app_suspended) == 0x17, "ks_task.message_app_suspended offset");
_Static_assert(offsetof(struct ks_task, vtimers) == 0x18, "ks_task.vtimers offset");
_Static_assert(offsetof(struct ks_task, loadTag) == 0x1C, "ks_task.loadTag offset");
_Static_assert(offsetof(struct ks_task, task_uniqueid) == 0x20, "ks_task.task_uniqueid offset");
_Static_assert(offsetof(struct ks_task, map) == 0x28, "ks_task.map offset");
_Static_assert(offsetof(struct ks_task, tasks) == 0x30, "ks_task.tasks offset");
_Static_assert(offsetof(struct ks_task, watchports) == 0x40, "ks_task.watchports offset");
_Static_assert(offsetof(struct ks_task, returnwait_inheritor) == 0x48, "ks_task.returnwait_inheritor offset");
_Static_assert(offsetof(struct ks_task, threads) == 0x50, "ks_task.threads offset");
_Static_assert(offsetof(struct ks_task, t_rr_ranges) == 0x60, "ks_task.t_rr_ranges offset");
_Static_assert(offsetof(struct ks_task, pset_hint) == 0x68, "ks_task.pset_hint offset");
_Static_assert(offsetof(struct ks_task, affinity_space) == 0x70, "ks_task.affinity_space offset");
_Static_assert(offsetof(struct ks_task, thread_count) == 0x78, "ks_task.thread_count offset");
_Static_assert(offsetof(struct ks_task, active_thread_count) == 0x7C, "ks_task.active_thread_count offset");
_Static_assert(offsetof(struct ks_task, suspend_count) == 0x80, "ks_task.suspend_count offset");
_Static_assert(offsetof(struct ks_task, user_stop_count) == 0x84, "ks_task.user_stop_count offset");
_Static_assert(offsetof(struct ks_task, legacy_stop_count) == 0x88, "ks_task.legacy_stop_count offset");
_Static_assert(offsetof(struct ks_task, priority) == 0x8C, "ks_task.priority offset");
_Static_assert(offsetof(struct ks_task, max_priority) == 0x8E, "ks_task.max_priority offset");
_Static_assert(offsetof(struct ks_task, importance) == 0x90, "ks_task.importance offset");
_Static_assert(offsetof(struct ks_task, total_runnable_time) == 0x98, "ks_task.total_runnable_time offset");
_Static_assert(offsetof(struct ks_task, tk_recount) == 0xA0, "ks_task.tk_recount offset");
_Static_assert(offsetof(struct ks_task, itk_lock_data) == 0xB0, "ks_task.itk_lock_data offset");
_Static_assert(offsetof(struct ks_task, itk_task_ports) == 0xC0, "ks_task.itk_task_ports offset");
_Static_assert(offsetof(struct ks_task, itk_settable_self) == 0xE0, "ks_task.itk_settable_self offset");
_Static_assert(offsetof(struct ks_task, exc_actions) == 0xE8, "ks_task.exc_actions offset");
_Static_assert(offsetof(struct ks_task, hardened_exception_action) == 0x2A8, "ks_task.hardened_exception_action offset");
_Static_assert(offsetof(struct ks_task, itk_host) == 0x2D0, "ks_task.itk_host offset");
_Static_assert(offsetof(struct ks_task, itk_bootstrap) == 0x2D8, "ks_task.itk_bootstrap offset");
_Static_assert(offsetof(struct ks_task, itk_debug_control) == 0x2E0, "ks_task.itk_debug_control offset");
_Static_assert(offsetof(struct ks_task, itk_task_access) == 0x2E8, "ks_task.itk_task_access offset");
_Static_assert(offsetof(struct ks_task, itk_resume) == 0x2F0, "ks_task.itk_resume offset");
_Static_assert(offsetof(struct ks_task, itk_registered) == 0x2F8, "ks_task.itk_registered offset");
_Static_assert(offsetof(struct ks_task, itk_dyld_notify) == 0x310, "ks_task.itk_dyld_notify offset");
_Static_assert(offsetof(struct ks_task, itk_space) == 0x318, "ks_task.itk_space offset");
_Static_assert(offsetof(struct ks_task, ledger) == 0x320, "ks_task.ledger offset");
_Static_assert(offsetof(struct ks_task, semaphore_list) == 0x328, "ks_task.semaphore_list offset");
_Static_assert(offsetof(struct ks_task, semaphores_owned) == 0x338, "ks_task.semaphores_owned offset");
_Static_assert(offsetof(struct ks_task, priv_flags) == 0x33C, "ks_task.priv_flags offset");
_Static_assert(offsetof(struct ks_task, task_debug) == 0x340, "ks_task.task_debug offset");
_Static_assert(offsetof(struct ks_task, rop_pid) == 0x348, "ks_task.rop_pid offset");
_Static_assert(offsetof(struct ks_task, jop_pid) == 0x350, "ks_task.jop_pid offset");
_Static_assert(offsetof(struct ks_task, disable_user_jop) == 0x358, "ks_task.disable_user_jop offset");
_Static_assert(offsetof(struct ks_task, has_jitbox) == 0x359, "ks_task.has_jitbox offset");
_Static_assert(offsetof(struct ks_task, jitbox_version) == 0x360, "ks_task.jitbox_version offset");
_Static_assert(offsetof(struct ks_task, jitbox_start) == 0x368, "ks_task.jitbox_start offset");
_Static_assert(offsetof(struct ks_task, jitbox_size) == 0x370, "ks_task.jitbox_size offset");
_Static_assert(offsetof(struct ks_task, jitbox_enabled) == 0x378, "ks_task.jitbox_enabled offset");
_Static_assert(offsetof(struct ks_task, uexc) == 0x380, "ks_task.uexc offset");
_Static_assert(offsetof(struct ks_task, preserve_x18) == 0x3A0, "ks_task.preserve_x18 offset");
_Static_assert(offsetof(struct ks_task, uses_1ghz_timebase) == 0x3A1, "ks_task.uses_1ghz_timebase offset");
_Static_assert(offsetof(struct ks_task, faults) == 0x3A8, "ks_task.faults offset");
_Static_assert(offsetof(struct ks_task, pageins) == 0x3B0, "ks_task.pageins offset");
_Static_assert(offsetof(struct ks_task, cow_faults) == 0x3B8, "ks_task.cow_faults offset");
_Static_assert(offsetof(struct ks_task, messages_sent) == 0x3C0, "ks_task.messages_sent offset");
_Static_assert(offsetof(struct ks_task, messages_received) == 0x3C8, "ks_task.messages_received offset");
_Static_assert(offsetof(struct ks_task, decompressions) == 0x3D0, "ks_task.decompressions offset");
_Static_assert(offsetof(struct ks_task, syscalls_mach) == 0x3D4, "ks_task.syscalls_mach offset");
_Static_assert(offsetof(struct ks_task, syscalls_unix) == 0x3D8, "ks_task.syscalls_unix offset");
_Static_assert(offsetof(struct ks_task, c_switch) == 0x3DC, "ks_task.c_switch offset");
_Static_assert(offsetof(struct ks_task, p_switch) == 0x3E0, "ks_task.p_switch offset");
_Static_assert(offsetof(struct ks_task, ps_switch) == 0x3E4, "ks_task.ps_switch offset");
_Static_assert(offsetof(struct ks_task, bsd_info_ro) == 0x3E8, "ks_task.bsd_info_ro offset");
_Static_assert(offsetof(struct ks_task, corpse_info) == 0x3F0, "ks_task.corpse_info offset");
_Static_assert(offsetof(struct ks_task, crashed_thread_id) == 0x3F8, "ks_task.crashed_thread_id offset");
_Static_assert(offsetof(struct ks_task, corpse_tasks) == 0x400, "ks_task.corpse_tasks offset");
_Static_assert(offsetof(struct ks_task, crash_label) == 0x410, "ks_task.crash_label offset");
_Static_assert(offsetof(struct ks_task, t_flags) == 0x418, "ks_task.t_flags offset");
_Static_assert(offsetof(struct ks_task, t_procflags) == 0x41C, "ks_task.t_procflags offset");
_Static_assert(offsetof(struct ks_task, all_image_info_addr) == 0x420, "ks_task.all_image_info_addr offset");
_Static_assert(offsetof(struct ks_task, all_image_info_size) == 0x428, "ks_task.all_image_info_size offset");
_Static_assert(offsetof(struct ks_task, t_kpc) == 0x430, "ks_task.t_kpc offset");
_Static_assert(offsetof(struct ks_task, t_gpu_role) == 0x434, "ks_task.t_gpu_role offset");
_Static_assert(offsetof(struct ks_task, pidsuspended) == 0x435, "ks_task.pidsuspended offset");
_Static_assert(offsetof(struct ks_task, frozen) == 0x436, "ks_task.frozen offset");
_Static_assert(offsetof(struct ks_task, changing_freeze_state) == 0x437, "ks_task.changing_freeze_state offset");
_Static_assert(offsetof(struct ks_task, is_large_corpse) == 0x438, "ks_task.is_large_corpse offset");
_Static_assert(offsetof(struct ks_task, rusage_cpu_flags) == 0x43B, "ks_task.rusage_cpu_flags offset");
_Static_assert(offsetof(struct ks_task, rusage_cpu_percentage) == 0x43C, "ks_task.rusage_cpu_percentage offset");
_Static_assert(offsetof(struct ks_task, rusage_cpu_perthr_percentage) == 0x43D, "ks_task.rusage_cpu_perthr_percentage offset");
_Static_assert(offsetof(struct ks_task, t_returnwaitflags) == 0x43E, "ks_task.t_returnwaitflags offset");
_Static_assert(offsetof(struct ks_task, shared_region_auth_remapped) == 0x43F, "ks_task.shared_region_auth_remapped offset");
_Static_assert(offsetof(struct ks_task, shared_region_id) == 0x440, "ks_task.shared_region_id offset");
_Static_assert(offsetof(struct ks_task, shared_region) == 0x448, "ks_task.shared_region offset");
_Static_assert(offsetof(struct ks_task, rusage_cpu_interval) == 0x450, "ks_task.rusage_cpu_interval offset");
_Static_assert(offsetof(struct ks_task, rusage_cpu_perthr_interval) == 0x458, "ks_task.rusage_cpu_perthr_interval offset");
_Static_assert(offsetof(struct ks_task, rusage_cpu_deadline) == 0x460, "ks_task.rusage_cpu_deadline offset");
_Static_assert(offsetof(struct ks_task, rusage_cpu_callt) == 0x468, "ks_task.rusage_cpu_callt offset");
_Static_assert(offsetof(struct ks_task, task_watchers) == 0x470, "ks_task.task_watchers offset");
_Static_assert(offsetof(struct ks_task, num_taskwatchers) == 0x480, "ks_task.num_taskwatchers offset");
_Static_assert(offsetof(struct ks_task, watchapplying) == 0x484, "ks_task.watchapplying offset");
_Static_assert(offsetof(struct ks_task, bank_context) == 0x488, "ks_task.bank_context offset");
_Static_assert(offsetof(struct ks_task, task_imp_base) == 0x490, "ks_task.task_imp_base offset");
_Static_assert(offsetof(struct ks_task, extmod_statistics) == 0x498, "ks_task.extmod_statistics offset");
_Static_assert(offsetof(struct ks_task, requested_policy) == 0x4C8, "ks_task.requested_policy offset");
_Static_assert(offsetof(struct ks_task, effective_policy) == 0x4D0, "ks_task.effective_policy offset");
_Static_assert(offsetof(struct ks_task, pended_coalition_changes) == 0x4D8, "ks_task.pended_coalition_changes offset");
_Static_assert(offsetof(struct ks_task, memlimit_flags) == 0x4E0, "ks_task.memlimit_flags offset");
_Static_assert(offsetof(struct ks_task, task_io_stats) == 0x4E8, "ks_task.task_io_stats offset");
_Static_assert(offsetof(struct ks_task, task_writes_counters_internal) == 0x4F0, "ks_task.task_writes_counters_internal offset");
_Static_assert(offsetof(struct ks_task, task_writes_counters_external) == 0x510, "ks_task.task_writes_counters_external offset");
_Static_assert(offsetof(struct ks_task, cpu_time_eqos_stats) == 0x530, "ks_task.cpu_time_eqos_stats offset");
_Static_assert(offsetof(struct ks_task, cpu_time_rqos_stats) == 0x568, "ks_task.cpu_time_rqos_stats offset");
_Static_assert(offsetof(struct ks_task, task_timer_wakeups_bin_1) == 0x5A0, "ks_task.task_timer_wakeups_bin_1 offset");
_Static_assert(offsetof(struct ks_task, task_timer_wakeups_bin_2) == 0x5A4, "ks_task.task_timer_wakeups_bin_2 offset");
_Static_assert(offsetof(struct ks_task, task_gpu_ns) == 0x5A8, "ks_task.task_gpu_ns offset");
_Static_assert(offsetof(struct ks_task, task_can_transfer_memory_ownership) == 0x5B0, "ks_task.task_can_transfer_memory_ownership offset");
_Static_assert(offsetof(struct ks_task, task_objects_disowning) == 0x5B1, "ks_task.task_objects_disowning offset");
_Static_assert(offsetof(struct ks_task, task_objects_disowned) == 0x5B2, "ks_task.task_objects_disowned offset");
_Static_assert(offsetof(struct ks_task, task_volatile_objects) == 0x5B4, "ks_task.task_volatile_objects offset");
_Static_assert(offsetof(struct ks_task, task_nonvolatile_objects) == 0x5B8, "ks_task.task_nonvolatile_objects offset");
_Static_assert(offsetof(struct ks_task, task_owned_objects) == 0x5BC, "ks_task.task_owned_objects offset");
_Static_assert(offsetof(struct ks_task, task_objq) == 0x5C0, "ks_task.task_objq offset");
_Static_assert(offsetof(struct ks_task, task_objq_lock) == 0x5D0, "ks_task.task_objq_lock offset");
_Static_assert(offsetof(struct ks_task, coalition) == 0x5E8, "ks_task.coalition offset");
_Static_assert(offsetof(struct ks_task, task_coalition) == 0x5F8, "ks_task.task_coalition offset");
_Static_assert(offsetof(struct ks_task, dispatchqueue_offset) == 0x618, "ks_task.dispatchqueue_offset offset");
_Static_assert(offsetof(struct ks_task, hv_task_target) == 0x620, "ks_task.hv_task_target offset");
_Static_assert(offsetof(struct ks_task, task_exc_guard) == 0x628, "ks_task.task_exc_guard offset");
_Static_assert(offsetof(struct ks_task, mach_header_vm_address) == 0x630, "ks_task.mach_header_vm_address offset");
_Static_assert(offsetof(struct ks_task, io_user_clients) == 0x638, "ks_task.io_user_clients offset");
_Static_assert(offsetof(struct ks_task, donates_own_pages) == 0x648, "ks_task.donates_own_pages offset");
_Static_assert(offsetof(struct ks_task, task_shared_region_slide) == 0x64C, "ks_task.task_shared_region_slide offset");
_Static_assert(offsetof(struct ks_task, task_fs_metadata_writes) == 0x650, "ks_task.task_fs_metadata_writes offset");
_Static_assert(offsetof(struct ks_task, task_shared_region_uuid) == 0x658, "ks_task.task_shared_region_uuid offset");
_Static_assert(offsetof(struct ks_task, memstat_dirty_start) == 0x668, "ks_task.memstat_dirty_start offset");
_Static_assert(offsetof(struct ks_task, corpse_vmobject_list) == 0x670, "ks_task.corpse_vmobject_list offset");
_Static_assert(offsetof(struct ks_task, corpse_vmobject_list_size) == 0x678, "ks_task.corpse_vmobject_list_size offset");
_Static_assert(offsetof(struct ks_task, deferred_reclamation_metadata) == 0x680, "ks_task.deferred_reclamation_metadata offset");
_Static_assert(offsetof(struct ks_task, task_cs_auxiliary_info) == 0x688, "ks_task.task_cs_auxiliary_info offset");
_Static_assert(offsetof(struct ks_task, security_config) == 0x690, "ks_task.security_config offset");
_Static_assert(sizeof(struct ks_task) == 0x698, "ks_task size");

/* refs: 2 */
struct ks_task_watchport_elem {
    struct ks_task *twe_task;
    struct ks_ipc_port *twe_port;
    struct ks_ipc_port *twe_pdrequest;
};
_Static_assert(offsetof(struct ks_task_watchport_elem, twe_task) == 0x0, "ks_task_watchport_elem.twe_task offset");
_Static_assert(offsetof(struct ks_task_watchport_elem, twe_port) == 0x8, "ks_task_watchport_elem.twe_port offset");
_Static_assert(offsetof(struct ks_task_watchport_elem, twe_pdrequest) == 0x10, "ks_task_watchport_elem.twe_pdrequest offset");
_Static_assert(sizeof(struct ks_task_watchport_elem) == 0x18, "ks_task_watchport_elem size");

/* refs: 1 */
struct ks_task_watchports {
    struct ks_os_refcnt tw_refcount;
    struct ks_task *tw_task;
    struct ks_thread *tw_thread;
    unsigned int tw_elem_array_count;
    struct ks_task_watchport_elem tw_elem[];
};
_Static_assert(offsetof(struct ks_task_watchports, tw_refcount) == 0x0, "ks_task_watchports.tw_refcount offset");
_Static_assert(offsetof(struct ks_task_watchports, tw_task) == 0x8, "ks_task_watchports.tw_task offset");
_Static_assert(offsetof(struct ks_task_watchports, tw_thread) == 0x10, "ks_task_watchports.tw_thread offset");
_Static_assert(offsetof(struct ks_task_watchports, tw_elem_array_count) == 0x18, "ks_task_watchports.tw_elem_array_count offset");
_Static_assert(offsetof(struct ks_task_watchports, tw_elem) == 0x20, "ks_task_watchports.tw_elem offset");
_Static_assert(sizeof(struct ks_task_watchports) == 0x20, "ks_task_watchports size");

/* refs: 1 */
struct ks_tcpstat_local {
    unsigned long long badformat;
    unsigned long long unspecv6;
    unsigned long long synfin;
    unsigned long long badformatipsec;
    unsigned long long noconnnolist;
    unsigned long long noconnlist;
    unsigned long long listbadsyn;
    unsigned long long icmp6unreach;
    unsigned long long deprecate6;
    unsigned long long ooopacket;
    unsigned long long rstinsynrcv;
    unsigned long long dospacket;
    unsigned long long cleanup;
    unsigned long long synwindow;
    unsigned long long linkheur_stealthdrop;
    unsigned long long linkheur_noackpri;
    unsigned long long linkheur_comprxmt;
    unsigned long long linkheur_synrxmt;
    unsigned long long linkheur_rxmtfloor;
};
_Static_assert(offsetof(struct ks_tcpstat_local, badformat) == 0x0, "ks_tcpstat_local.badformat offset");
_Static_assert(offsetof(struct ks_tcpstat_local, unspecv6) == 0x8, "ks_tcpstat_local.unspecv6 offset");
_Static_assert(offsetof(struct ks_tcpstat_local, synfin) == 0x10, "ks_tcpstat_local.synfin offset");
_Static_assert(offsetof(struct ks_tcpstat_local, badformatipsec) == 0x18, "ks_tcpstat_local.badformatipsec offset");
_Static_assert(offsetof(struct ks_tcpstat_local, noconnnolist) == 0x20, "ks_tcpstat_local.noconnnolist offset");
_Static_assert(offsetof(struct ks_tcpstat_local, noconnlist) == 0x28, "ks_tcpstat_local.noconnlist offset");
_Static_assert(offsetof(struct ks_tcpstat_local, listbadsyn) == 0x30, "ks_tcpstat_local.listbadsyn offset");
_Static_assert(offsetof(struct ks_tcpstat_local, icmp6unreach) == 0x38, "ks_tcpstat_local.icmp6unreach offset");
_Static_assert(offsetof(struct ks_tcpstat_local, deprecate6) == 0x40, "ks_tcpstat_local.deprecate6 offset");
_Static_assert(offsetof(struct ks_tcpstat_local, ooopacket) == 0x48, "ks_tcpstat_local.ooopacket offset");
_Static_assert(offsetof(struct ks_tcpstat_local, rstinsynrcv) == 0x50, "ks_tcpstat_local.rstinsynrcv offset");
_Static_assert(offsetof(struct ks_tcpstat_local, dospacket) == 0x58, "ks_tcpstat_local.dospacket offset");
_Static_assert(offsetof(struct ks_tcpstat_local, cleanup) == 0x60, "ks_tcpstat_local.cleanup offset");
_Static_assert(offsetof(struct ks_tcpstat_local, synwindow) == 0x68, "ks_tcpstat_local.synwindow offset");
_Static_assert(offsetof(struct ks_tcpstat_local, linkheur_stealthdrop) == 0x70, "ks_tcpstat_local.linkheur_stealthdrop offset");
_Static_assert(offsetof(struct ks_tcpstat_local, linkheur_noackpri) == 0x78, "ks_tcpstat_local.linkheur_noackpri offset");
_Static_assert(offsetof(struct ks_tcpstat_local, linkheur_comprxmt) == 0x80, "ks_tcpstat_local.linkheur_comprxmt offset");
_Static_assert(offsetof(struct ks_tcpstat_local, linkheur_synrxmt) == 0x88, "ks_tcpstat_local.linkheur_synrxmt offset");
_Static_assert(offsetof(struct ks_tcpstat_local, linkheur_rxmtfloor) == 0x90, "ks_tcpstat_local.linkheur_rxmtfloor offset");
_Static_assert(sizeof(struct ks_tcpstat_local) == 0x98, "ks_tcpstat_local size");

/* refs: 1 */
struct ks_termios {
    unsigned long c_iflag;
    unsigned long c_oflag;
    unsigned long c_cflag;
    unsigned long c_lflag;
    unsigned char c_cc[0x14];
    unsigned long c_ispeed;
    unsigned long c_ospeed;
};
_Static_assert(offsetof(struct ks_termios, c_iflag) == 0x0, "ks_termios.c_iflag offset");
_Static_assert(offsetof(struct ks_termios, c_oflag) == 0x8, "ks_termios.c_oflag offset");
_Static_assert(offsetof(struct ks_termios, c_cflag) == 0x10, "ks_termios.c_cflag offset");
_Static_assert(offsetof(struct ks_termios, c_lflag) == 0x18, "ks_termios.c_lflag offset");
_Static_assert(offsetof(struct ks_termios, c_cc) == 0x20, "ks_termios.c_cc offset");
_Static_assert(offsetof(struct ks_termios, c_ispeed) == 0x38, "ks_termios.c_ispeed offset");
_Static_assert(offsetof(struct ks_termios, c_ospeed) == 0x40, "ks_termios.c_ospeed offset");
_Static_assert(sizeof(struct ks_termios) == 0x48, "ks_termios size");

/* refs: 1 */
struct ks_thread_effective_policy {
    unsigned long long thep_darwinbg : 1; /* bit offset 0 */
    unsigned long long thep_io_tier : 2; /* bit offset 1 */
    unsigned long long thep_io_passive : 1; /* bit offset 3 */
    unsigned long long thep_all_sockets_bg : 1; /* bit offset 4 */
    unsigned long long thep_new_sockets_bg : 1; /* bit offset 5 */
    unsigned long long thep_terminated : 1; /* bit offset 6 */
    unsigned long long thep_qos_ui_is_urgent : 1; /* bit offset 7 */
    unsigned long long thep_latency_qos : 3; /* bit offset 8 */
    unsigned long long thep_through_qos : 3; /* bit offset 11 */
    unsigned long long thep_qos : 3; /* bit offset 14 */
    unsigned long long thep_qos_relprio : 4; /* bit offset 17 */
    unsigned long long thep_qos_promote : 3; /* bit offset 21 */
    unsigned long long thep_promote_above_task : 1; /* bit offset 24 */
    unsigned long long thep_wi_driven : 1; /* bit offset 25 */
    unsigned long long thep_reserved : 38; /* bit offset 26 */
};
_Static_assert(sizeof(struct ks_thread_effective_policy) == 0x8, "ks_thread_effective_policy size");

/* refs: 1 */
struct ks_thread_requested_policy {
    unsigned long long thrp_int_darwinbg : 1; /* bit offset 0 */
    unsigned long long thrp_ext_darwinbg : 1; /* bit offset 1 */
    unsigned long long thrp_int_iotier : 2; /* bit offset 2 */
    unsigned long long thrp_ext_iotier : 2; /* bit offset 4 */
    unsigned long long thrp_int_iopassive : 1; /* bit offset 6 */
    unsigned long long thrp_ext_iopassive : 1; /* bit offset 7 */
    unsigned long long thrp_latency_qos : 3; /* bit offset 8 */
    unsigned long long thrp_through_qos : 3; /* bit offset 11 */
    unsigned long long thrp_pidbind_bg : 1; /* bit offset 14 */
    unsigned long long thrp_qos : 3; /* bit offset 15 */
    unsigned long long thrp_qos_relprio : 4; /* bit offset 18 */
    unsigned long long thrp_qos_override : 3; /* bit offset 22 */
    unsigned long long thrp_qos_promote : 3; /* bit offset 25 */
    unsigned long long thrp_qos_kevent_override : 3; /* bit offset 28 */
    unsigned long long thrp_terminated : 1; /* bit offset 31 */
    unsigned long long thrp_qos_workq_override : 3; /* bit offset 32 */
    unsigned long long thrp_qos_wlsvc_override : 3; /* bit offset 35 */
    unsigned long long thrp_iotier_kevent_override : 2; /* bit offset 38 */
    unsigned long long thrp_wi_driven : 1; /* bit offset 40 */
    unsigned long long thrp_reserved : 23; /* bit offset 41 */
};
_Static_assert(sizeof(struct ks_thread_requested_policy) == 0x8, "ks_thread_requested_policy size");

/* refs: 2 */
struct ks_timer {
    unsigned long long tstamp;
    unsigned long long all_bits;
};
_Static_assert(offsetof(struct ks_timer, tstamp) == 0x0, "ks_timer.tstamp offset");
_Static_assert(offsetof(struct ks_timer, all_bits) == 0x8, "ks_timer.all_bits offset");
_Static_assert(sizeof(struct ks_timer) == 0x10, "ks_timer size");

/* refs: 2 */
union ks_thread_rr_state {
    unsigned int trr_value;
    struct {
        unsigned char trr_fault_state;
        unsigned char trr_sync_waiting;
        unsigned short trr_ipi_ack_pending;
    };
};
_Static_assert(offsetof(union ks_thread_rr_state, trr_value) == 0x0, "ks_thread_rr_state.trr_value offset");

/* refs: 2 */
union ks_waitq_t {
    struct ks_waitq *wq_q;
    struct ks_waitq_set *wqs_set;
    struct ks_select_set *wqs_sel;
};
_Static_assert(offsetof(union ks_waitq_t, wq_q) == 0x0, "ks_waitq_t.wq_q offset");
_Static_assert(offsetof(union ks_waitq_t, wqs_set) == 0x0, "ks_waitq_t.wqs_set offset");
_Static_assert(offsetof(union ks_waitq_t, wqs_sel) == 0x0, "ks_waitq_t.wqs_sel offset");

/* refs: 36 */
struct ks_thread {
    union {
        struct ks_queue_entry runq_links;
        struct ks_queue_entry wait_links;
        struct ks_mpsc_queue_chain mpsc_links;
        struct ks_priority_queue_entry_sched wait_prioq_links;
    };
    unsigned long long wait_event;
    struct {
        struct ks_processor *runq;
    } __runq;
    union ks_waitq_t waitq;
    struct ks_turnstile *turnstile;
    void *inheritor;
    struct ks_priority_queue_sched_max sched_inheritor_queue;
    struct ks_priority_queue_sched_max base_inheritor_queue;
    _Bool th_bound_cluster_enqueued;
    _Bool th_shared_rsrc_enqueued[2];
    _Bool th_shared_rsrc_heavy_user[2];
    _Bool th_shared_rsrc_heavy_perf_control[2];
    unsigned char th_expired_quantum_on_lower_core : 1; /* bit offset 696 */
    unsigned char th_expired_quantum_on_higher_core : 1; /* bit offset 697 */
    struct ks_priority_queue_entry_stable th_clutch_runq_link;
    struct ks_priority_queue_entry_sched th_clutch_pri_link;
    struct ks_queue_entry th_clutch_timeshare_link;
    struct ks_lck_spin_s sched_lock;
    struct ks_lck_spin_s wake_lock;
    unsigned short options;
    _Bool wake_active;
    _Bool at_safe_point;
    unsigned char sched_saved_run_weight;
    unsigned int reason;
    unsigned int quantum_remaining;
    int wait_result;
    union ks_thread_rr_state t_rr_state;
    void *continuation;
    void *parameter;
    unsigned long kernel_stack;
    unsigned long reserved_stack;
    struct ks_machine_thread machine;
    int state;
    unsigned int sched_mode;
    unsigned int saved_mode;
    unsigned int th_sched_bucket;
    unsigned int sfi_class;
    unsigned int sfi_wait_class;
    unsigned int sched_flags;
    short sched_pri;
    short base_pri;
    short req_base_pri;
    short max_priority;
    short task_priority;
    unsigned short priority_floor_count;
    short suspend_count;
    int iotier_override;
    unsigned int ref_count;
    unsigned int rwlock_count;
    struct ks_smrq_slist_head smr_stack;
    int importance;
    int depress_timer_active;
    struct ks_timer_call *depress_timer;
    struct {
        unsigned int period;
        unsigned int computation;
        unsigned int constraint;
        _Bool preemptible;
        unsigned char priority_offset;
        unsigned long long deadline;
    } realtime;
    unsigned long long last_run_time;
    unsigned long long last_made_runnable_time;
    unsigned long long last_basepri_change_time;
    unsigned long long same_pri_latency;
    unsigned long long workq_quantum_deadline;
    struct ks_thread_group *thread_group;
    struct ks_processor *bound_processor;
    struct ks_processor *last_processor;
    struct ks_processor *chosen_processor;
    unsigned long long computation_metered;
    unsigned long long computation_epoch;
    unsigned long long computation_interrupt_epoch;
    unsigned long long safe_release;
    void *sched_call;
    unsigned int sched_stamp;
    unsigned int sched_usage;
    unsigned int pri_shift;
    unsigned int cpu_usage;
    unsigned int cpu_delta;
    unsigned int c_switch;
    unsigned int p_switch;
    unsigned int ps_switch;
    unsigned long long sched_time_save;
    unsigned long long vtimer_user_save;
    unsigned long long vtimer_prof_save;
    unsigned long long vtimer_rlim_save;
    unsigned long long vtimer_qos_save;
    struct ks_timer runnable_timer;
    struct ks_recount_thread th_recount;
    unsigned long long wait_sfi_begin_time;
    struct ks_queue_entry affinity_threads;
    struct ks_affinity_set *affinity_set;
    struct ks_task_watcher *taskwatch;
    union {
        struct {
            struct ks_mach_msg_recv_bufs_t recv_bufs;
            unsigned long long option;
            struct ks_ipc_object *object;
            int state;
            unsigned int seqno;
            unsigned int msize;
            unsigned int asize;
            unsigned int receiver_name;
            struct ks_ipc_kmsg *kmsg;
        } receive;
        struct {
            struct ks_semaphore *waitsemaphore;
            struct ks_semaphore *signalsemaphore;
            int options;
            int result;
            void *continuation;
        } sema;
        struct {
            void *tls[8];
        } iokit;
    } saved;
    union {
        struct ks_thread_call_thread_state *thc_state;
        struct {
            int os_reason;
            int exception_type;
            long long code;
            long long subcode;
        } mach_exc_info;
    };
    int user_stop_count;
    unsigned int ith_assertions;
    struct ks_circle_queue_head ith_messages;
    struct ks_ipc_port *ith_kernel_reply_port;
    _Bool th_vm_faults_disabled;
    _Bool recover;
    struct ks_queue_entry threads;
    struct ks_queue_entry task_threads;
    struct ks_thread_ro *t_tro;
    struct ks__vm_map *map;
    struct ks_thread *handoff_thread;
    struct ks_timer_call *wait_timer;
    unsigned short wait_timer_active;
    _Bool wait_timer_armed;
    unsigned int active : 1; /* bit offset 8344 */
    unsigned int ipc_active : 1; /* bit offset 8345 */
    unsigned int started : 1; /* bit offset 8346 */
    unsigned int static_param : 1; /* bit offset 8347 */
    unsigned int inspection : 1; /* bit offset 8348 */
    unsigned int policy_reset : 1; /* bit offset 8349 */
    unsigned int suspend_parked : 1; /* bit offset 8350 */
    unsigned int corpse_dup : 1; /* bit offset 8351 */
    unsigned int ast;
    struct ks_lck_mtx_s mutex;
    struct ks_ipc_port *ith_special_reply_port;
    unsigned short t_dtrace_flags;
    unsigned short t_dtrace_inprobe;
    unsigned int t_dtrace_predcache;
    long long t_dtrace_tracing;
    long long t_dtrace_vtime;
    unsigned long t_page_creation_time;
    unsigned int t_page_creation_count;
    unsigned int t_page_creation_throttled;
    int t_pagein_error;
    unsigned int ith_voucher_name;
    struct ks_ipc_voucher *ith_voucher;
    unsigned int kperf_ast;
    unsigned int kperf_pet_gen;
    unsigned int kperf_c_switch;
    unsigned int kperf_pet_cnt;
    unsigned long long *kpc_buf;
    void *hv_thread_target;
    unsigned int syscalls_unix;
    unsigned int syscalls_mach;
    struct ks_ledger *t_ledger;
    struct ks_ledger *t_threadledger;
    struct ks_ledger *t_bankledger;
    unsigned long long t_deduct_bank_ledger_time;
    unsigned long long t_deduct_bank_ledger_energy;
    unsigned long long thread_id;
    unsigned int ctid;
    unsigned int ctsid;
    struct ks_thread_requested_policy requested_policy;
    struct ks_thread_effective_policy effective_policy;
    struct ks_thread_qos_override *overrides;
    unsigned int kevent_overrides;
    unsigned char user_promotion_basepri;
    unsigned char kern_promotion_schedpri;
    unsigned short kevent_ast_bits;
    struct ks_io_stat_info *thread_io_stats;
    unsigned int thread_callout_interrupt_wakeups;
    unsigned int thread_callout_platform_idle_wakeups;
    unsigned int thread_timer_wakeups_bin_1;
    unsigned int thread_timer_wakeups_bin_2;
    unsigned short thread_tag;
    unsigned short callout_woken_from_icontext : 1; /* bit offset 10256 */
    unsigned short callout_woken_from_platform_idle : 1; /* bit offset 10257 */
    unsigned short callout_woke_thread : 1; /* bit offset 10258 */
    unsigned short mach_exc_fatal : 1; /* bit offset 10259 */
    unsigned short mach_exc_ktriage : 1; /* bit offset 10260 */
    unsigned short thread_bitfield_unused : 11; /* bit offset 10261 */
    unsigned int th_bound_cluster_id;
    struct ks_thread_group *preadopt_thread_group;
    struct ks_thread_group *old_preadopt_thread_group;
    struct ks_thread_group *bank_thread_group;
    struct ks_thread_group *auto_join_thread_group;
    struct ks_work_interval *th_work_interval;
    unsigned int th_work_interval_flags;
    unsigned char inheritor_flags;
    unsigned char pending_block_hint;
    unsigned char block_hint;
    unsigned int decompressions;
    int thread_region_page_shift;
    void *decmp_upl;
    struct ks_knote *ith_knote;
    unsigned long txm_thread_stack;
};
_Static_assert(offsetof(struct ks_thread, wait_event) == 0x18, "ks_thread.wait_event offset");
_Static_assert(offsetof(struct ks_thread, __runq) == 0x20, "ks_thread.__runq offset");
_Static_assert(offsetof(struct ks_thread, waitq) == 0x28, "ks_thread.waitq offset");
_Static_assert(offsetof(struct ks_thread, turnstile) == 0x30, "ks_thread.turnstile offset");
_Static_assert(offsetof(struct ks_thread, inheritor) == 0x38, "ks_thread.inheritor offset");
_Static_assert(offsetof(struct ks_thread, sched_inheritor_queue) == 0x40, "ks_thread.sched_inheritor_queue offset");
_Static_assert(offsetof(struct ks_thread, base_inheritor_queue) == 0x48, "ks_thread.base_inheritor_queue offset");
_Static_assert(offsetof(struct ks_thread, th_bound_cluster_enqueued) == 0x50, "ks_thread.th_bound_cluster_enqueued offset");
_Static_assert(offsetof(struct ks_thread, th_shared_rsrc_enqueued) == 0x51, "ks_thread.th_shared_rsrc_enqueued offset");
_Static_assert(offsetof(struct ks_thread, th_shared_rsrc_heavy_user) == 0x53, "ks_thread.th_shared_rsrc_heavy_user offset");
_Static_assert(offsetof(struct ks_thread, th_shared_rsrc_heavy_perf_control) == 0x55, "ks_thread.th_shared_rsrc_heavy_perf_control offset");
_Static_assert(offsetof(struct ks_thread, th_clutch_runq_link) == 0x58, "ks_thread.th_clutch_runq_link offset");
_Static_assert(offsetof(struct ks_thread, th_clutch_pri_link) == 0x78, "ks_thread.th_clutch_pri_link offset");
_Static_assert(offsetof(struct ks_thread, th_clutch_timeshare_link) == 0x90, "ks_thread.th_clutch_timeshare_link offset");
_Static_assert(offsetof(struct ks_thread, sched_lock) == 0xA0, "ks_thread.sched_lock offset");
_Static_assert(offsetof(struct ks_thread, wake_lock) == 0xB0, "ks_thread.wake_lock offset");
_Static_assert(offsetof(struct ks_thread, options) == 0xC0, "ks_thread.options offset");
_Static_assert(offsetof(struct ks_thread, wake_active) == 0xC2, "ks_thread.wake_active offset");
_Static_assert(offsetof(struct ks_thread, at_safe_point) == 0xC3, "ks_thread.at_safe_point offset");
_Static_assert(offsetof(struct ks_thread, sched_saved_run_weight) == 0xC4, "ks_thread.sched_saved_run_weight offset");
_Static_assert(offsetof(struct ks_thread, reason) == 0xC8, "ks_thread.reason offset");
_Static_assert(offsetof(struct ks_thread, quantum_remaining) == 0xCC, "ks_thread.quantum_remaining offset");
_Static_assert(offsetof(struct ks_thread, wait_result) == 0xD0, "ks_thread.wait_result offset");
_Static_assert(offsetof(struct ks_thread, t_rr_state) == 0xD4, "ks_thread.t_rr_state offset");
_Static_assert(offsetof(struct ks_thread, continuation) == 0xD8, "ks_thread.continuation offset");
_Static_assert(offsetof(struct ks_thread, parameter) == 0xE0, "ks_thread.parameter offset");
_Static_assert(offsetof(struct ks_thread, kernel_stack) == 0xE8, "ks_thread.kernel_stack offset");
_Static_assert(offsetof(struct ks_thread, reserved_stack) == 0xF0, "ks_thread.reserved_stack offset");
_Static_assert(offsetof(struct ks_thread, machine) == 0xF8, "ks_thread.machine offset");
_Static_assert(offsetof(struct ks_thread, state) == 0x1E0, "ks_thread.state offset");
_Static_assert(offsetof(struct ks_thread, sched_mode) == 0x1E4, "ks_thread.sched_mode offset");
_Static_assert(offsetof(struct ks_thread, saved_mode) == 0x1E8, "ks_thread.saved_mode offset");
_Static_assert(offsetof(struct ks_thread, th_sched_bucket) == 0x1EC, "ks_thread.th_sched_bucket offset");
_Static_assert(offsetof(struct ks_thread, sfi_class) == 0x1F0, "ks_thread.sfi_class offset");
_Static_assert(offsetof(struct ks_thread, sfi_wait_class) == 0x1F4, "ks_thread.sfi_wait_class offset");
_Static_assert(offsetof(struct ks_thread, sched_flags) == 0x1F8, "ks_thread.sched_flags offset");
_Static_assert(offsetof(struct ks_thread, sched_pri) == 0x1FC, "ks_thread.sched_pri offset");
_Static_assert(offsetof(struct ks_thread, base_pri) == 0x1FE, "ks_thread.base_pri offset");
_Static_assert(offsetof(struct ks_thread, req_base_pri) == 0x200, "ks_thread.req_base_pri offset");
_Static_assert(offsetof(struct ks_thread, max_priority) == 0x202, "ks_thread.max_priority offset");
_Static_assert(offsetof(struct ks_thread, task_priority) == 0x204, "ks_thread.task_priority offset");
_Static_assert(offsetof(struct ks_thread, priority_floor_count) == 0x206, "ks_thread.priority_floor_count offset");
_Static_assert(offsetof(struct ks_thread, suspend_count) == 0x208, "ks_thread.suspend_count offset");
_Static_assert(offsetof(struct ks_thread, iotier_override) == 0x20C, "ks_thread.iotier_override offset");
_Static_assert(offsetof(struct ks_thread, ref_count) == 0x210, "ks_thread.ref_count offset");
_Static_assert(offsetof(struct ks_thread, rwlock_count) == 0x214, "ks_thread.rwlock_count offset");
_Static_assert(offsetof(struct ks_thread, smr_stack) == 0x218, "ks_thread.smr_stack offset");
_Static_assert(offsetof(struct ks_thread, importance) == 0x220, "ks_thread.importance offset");
_Static_assert(offsetof(struct ks_thread, depress_timer_active) == 0x224, "ks_thread.depress_timer_active offset");
_Static_assert(offsetof(struct ks_thread, depress_timer) == 0x228, "ks_thread.depress_timer offset");
_Static_assert(offsetof(struct ks_thread, realtime) == 0x230, "ks_thread.realtime offset");
_Static_assert(offsetof(struct ks_thread, last_run_time) == 0x248, "ks_thread.last_run_time offset");
_Static_assert(offsetof(struct ks_thread, last_made_runnable_time) == 0x250, "ks_thread.last_made_runnable_time offset");
_Static_assert(offsetof(struct ks_thread, last_basepri_change_time) == 0x258, "ks_thread.last_basepri_change_time offset");
_Static_assert(offsetof(struct ks_thread, same_pri_latency) == 0x260, "ks_thread.same_pri_latency offset");
_Static_assert(offsetof(struct ks_thread, workq_quantum_deadline) == 0x268, "ks_thread.workq_quantum_deadline offset");
_Static_assert(offsetof(struct ks_thread, thread_group) == 0x270, "ks_thread.thread_group offset");
_Static_assert(offsetof(struct ks_thread, bound_processor) == 0x278, "ks_thread.bound_processor offset");
_Static_assert(offsetof(struct ks_thread, last_processor) == 0x280, "ks_thread.last_processor offset");
_Static_assert(offsetof(struct ks_thread, chosen_processor) == 0x288, "ks_thread.chosen_processor offset");
_Static_assert(offsetof(struct ks_thread, computation_metered) == 0x290, "ks_thread.computation_metered offset");
_Static_assert(offsetof(struct ks_thread, computation_epoch) == 0x298, "ks_thread.computation_epoch offset");
_Static_assert(offsetof(struct ks_thread, computation_interrupt_epoch) == 0x2A0, "ks_thread.computation_interrupt_epoch offset");
_Static_assert(offsetof(struct ks_thread, safe_release) == 0x2A8, "ks_thread.safe_release offset");
_Static_assert(offsetof(struct ks_thread, sched_call) == 0x2B0, "ks_thread.sched_call offset");
_Static_assert(offsetof(struct ks_thread, sched_stamp) == 0x2B8, "ks_thread.sched_stamp offset");
_Static_assert(offsetof(struct ks_thread, sched_usage) == 0x2BC, "ks_thread.sched_usage offset");
_Static_assert(offsetof(struct ks_thread, pri_shift) == 0x2C0, "ks_thread.pri_shift offset");
_Static_assert(offsetof(struct ks_thread, cpu_usage) == 0x2C4, "ks_thread.cpu_usage offset");
_Static_assert(offsetof(struct ks_thread, cpu_delta) == 0x2C8, "ks_thread.cpu_delta offset");
_Static_assert(offsetof(struct ks_thread, c_switch) == 0x2CC, "ks_thread.c_switch offset");
_Static_assert(offsetof(struct ks_thread, p_switch) == 0x2D0, "ks_thread.p_switch offset");
_Static_assert(offsetof(struct ks_thread, ps_switch) == 0x2D4, "ks_thread.ps_switch offset");
_Static_assert(offsetof(struct ks_thread, sched_time_save) == 0x2D8, "ks_thread.sched_time_save offset");
_Static_assert(offsetof(struct ks_thread, vtimer_user_save) == 0x2E0, "ks_thread.vtimer_user_save offset");
_Static_assert(offsetof(struct ks_thread, vtimer_prof_save) == 0x2E8, "ks_thread.vtimer_prof_save offset");
_Static_assert(offsetof(struct ks_thread, vtimer_rlim_save) == 0x2F0, "ks_thread.vtimer_rlim_save offset");
_Static_assert(offsetof(struct ks_thread, vtimer_qos_save) == 0x2F8, "ks_thread.vtimer_qos_save offset");
_Static_assert(offsetof(struct ks_thread, runnable_timer) == 0x300, "ks_thread.runnable_timer offset");
_Static_assert(offsetof(struct ks_thread, th_recount) == 0x310, "ks_thread.th_recount offset");
_Static_assert(offsetof(struct ks_thread, wait_sfi_begin_time) == 0x328, "ks_thread.wait_sfi_begin_time offset");
_Static_assert(offsetof(struct ks_thread, affinity_threads) == 0x330, "ks_thread.affinity_threads offset");
_Static_assert(offsetof(struct ks_thread, affinity_set) == 0x340, "ks_thread.affinity_set offset");
_Static_assert(offsetof(struct ks_thread, taskwatch) == 0x348, "ks_thread.taskwatch offset");
_Static_assert(offsetof(struct ks_thread, saved) == 0x350, "ks_thread.saved offset");
_Static_assert(offsetof(struct ks_thread, user_stop_count) == 0x3B0, "ks_thread.user_stop_count offset");
_Static_assert(offsetof(struct ks_thread, ith_assertions) == 0x3B4, "ks_thread.ith_assertions offset");
_Static_assert(offsetof(struct ks_thread, ith_messages) == 0x3B8, "ks_thread.ith_messages offset");
_Static_assert(offsetof(struct ks_thread, ith_kernel_reply_port) == 0x3C0, "ks_thread.ith_kernel_reply_port offset");
_Static_assert(offsetof(struct ks_thread, th_vm_faults_disabled) == 0x3C8, "ks_thread.th_vm_faults_disabled offset");
_Static_assert(offsetof(struct ks_thread, recover) == 0x3C9, "ks_thread.recover offset");
_Static_assert(offsetof(struct ks_thread, threads) == 0x3D0, "ks_thread.threads offset");
_Static_assert(offsetof(struct ks_thread, task_threads) == 0x3E0, "ks_thread.task_threads offset");
_Static_assert(offsetof(struct ks_thread, t_tro) == 0x3F0, "ks_thread.t_tro offset");
_Static_assert(offsetof(struct ks_thread, map) == 0x3F8, "ks_thread.map offset");
_Static_assert(offsetof(struct ks_thread, handoff_thread) == 0x400, "ks_thread.handoff_thread offset");
_Static_assert(offsetof(struct ks_thread, wait_timer) == 0x408, "ks_thread.wait_timer offset");
_Static_assert(offsetof(struct ks_thread, wait_timer_active) == 0x410, "ks_thread.wait_timer_active offset");
_Static_assert(offsetof(struct ks_thread, wait_timer_armed) == 0x412, "ks_thread.wait_timer_armed offset");
_Static_assert(offsetof(struct ks_thread, ast) == 0x414, "ks_thread.ast offset");
_Static_assert(offsetof(struct ks_thread, mutex) == 0x418, "ks_thread.mutex offset");
_Static_assert(offsetof(struct ks_thread, ith_special_reply_port) == 0x428, "ks_thread.ith_special_reply_port offset");
_Static_assert(offsetof(struct ks_thread, t_dtrace_flags) == 0x430, "ks_thread.t_dtrace_flags offset");
_Static_assert(offsetof(struct ks_thread, t_dtrace_inprobe) == 0x432, "ks_thread.t_dtrace_inprobe offset");
_Static_assert(offsetof(struct ks_thread, t_dtrace_predcache) == 0x434, "ks_thread.t_dtrace_predcache offset");
_Static_assert(offsetof(struct ks_thread, t_dtrace_tracing) == 0x438, "ks_thread.t_dtrace_tracing offset");
_Static_assert(offsetof(struct ks_thread, t_dtrace_vtime) == 0x440, "ks_thread.t_dtrace_vtime offset");
_Static_assert(offsetof(struct ks_thread, t_page_creation_time) == 0x448, "ks_thread.t_page_creation_time offset");
_Static_assert(offsetof(struct ks_thread, t_page_creation_count) == 0x450, "ks_thread.t_page_creation_count offset");
_Static_assert(offsetof(struct ks_thread, t_page_creation_throttled) == 0x454, "ks_thread.t_page_creation_throttled offset");
_Static_assert(offsetof(struct ks_thread, t_pagein_error) == 0x458, "ks_thread.t_pagein_error offset");
_Static_assert(offsetof(struct ks_thread, ith_voucher_name) == 0x45C, "ks_thread.ith_voucher_name offset");
_Static_assert(offsetof(struct ks_thread, ith_voucher) == 0x460, "ks_thread.ith_voucher offset");
_Static_assert(offsetof(struct ks_thread, kperf_ast) == 0x468, "ks_thread.kperf_ast offset");
_Static_assert(offsetof(struct ks_thread, kperf_pet_gen) == 0x46C, "ks_thread.kperf_pet_gen offset");
_Static_assert(offsetof(struct ks_thread, kperf_c_switch) == 0x470, "ks_thread.kperf_c_switch offset");
_Static_assert(offsetof(struct ks_thread, kperf_pet_cnt) == 0x474, "ks_thread.kperf_pet_cnt offset");
_Static_assert(offsetof(struct ks_thread, kpc_buf) == 0x478, "ks_thread.kpc_buf offset");
_Static_assert(offsetof(struct ks_thread, hv_thread_target) == 0x480, "ks_thread.hv_thread_target offset");
_Static_assert(offsetof(struct ks_thread, syscalls_unix) == 0x488, "ks_thread.syscalls_unix offset");
_Static_assert(offsetof(struct ks_thread, syscalls_mach) == 0x48C, "ks_thread.syscalls_mach offset");
_Static_assert(offsetof(struct ks_thread, t_ledger) == 0x490, "ks_thread.t_ledger offset");
_Static_assert(offsetof(struct ks_thread, t_threadledger) == 0x498, "ks_thread.t_threadledger offset");
_Static_assert(offsetof(struct ks_thread, t_bankledger) == 0x4A0, "ks_thread.t_bankledger offset");
_Static_assert(offsetof(struct ks_thread, t_deduct_bank_ledger_time) == 0x4A8, "ks_thread.t_deduct_bank_ledger_time offset");
_Static_assert(offsetof(struct ks_thread, t_deduct_bank_ledger_energy) == 0x4B0, "ks_thread.t_deduct_bank_ledger_energy offset");
_Static_assert(offsetof(struct ks_thread, thread_id) == 0x4B8, "ks_thread.thread_id offset");
_Static_assert(offsetof(struct ks_thread, ctid) == 0x4C0, "ks_thread.ctid offset");
_Static_assert(offsetof(struct ks_thread, ctsid) == 0x4C4, "ks_thread.ctsid offset");
_Static_assert(offsetof(struct ks_thread, requested_policy) == 0x4C8, "ks_thread.requested_policy offset");
_Static_assert(offsetof(struct ks_thread, effective_policy) == 0x4D0, "ks_thread.effective_policy offset");
_Static_assert(offsetof(struct ks_thread, overrides) == 0x4D8, "ks_thread.overrides offset");
_Static_assert(offsetof(struct ks_thread, kevent_overrides) == 0x4E0, "ks_thread.kevent_overrides offset");
_Static_assert(offsetof(struct ks_thread, user_promotion_basepri) == 0x4E4, "ks_thread.user_promotion_basepri offset");
_Static_assert(offsetof(struct ks_thread, kern_promotion_schedpri) == 0x4E5, "ks_thread.kern_promotion_schedpri offset");
_Static_assert(offsetof(struct ks_thread, kevent_ast_bits) == 0x4E6, "ks_thread.kevent_ast_bits offset");
_Static_assert(offsetof(struct ks_thread, thread_io_stats) == 0x4E8, "ks_thread.thread_io_stats offset");
_Static_assert(offsetof(struct ks_thread, thread_callout_interrupt_wakeups) == 0x4F0, "ks_thread.thread_callout_interrupt_wakeups offset");
_Static_assert(offsetof(struct ks_thread, thread_callout_platform_idle_wakeups) == 0x4F4, "ks_thread.thread_callout_platform_idle_wakeups offset");
_Static_assert(offsetof(struct ks_thread, thread_timer_wakeups_bin_1) == 0x4F8, "ks_thread.thread_timer_wakeups_bin_1 offset");
_Static_assert(offsetof(struct ks_thread, thread_timer_wakeups_bin_2) == 0x4FC, "ks_thread.thread_timer_wakeups_bin_2 offset");
_Static_assert(offsetof(struct ks_thread, thread_tag) == 0x500, "ks_thread.thread_tag offset");
_Static_assert(offsetof(struct ks_thread, th_bound_cluster_id) == 0x504, "ks_thread.th_bound_cluster_id offset");
_Static_assert(offsetof(struct ks_thread, preadopt_thread_group) == 0x508, "ks_thread.preadopt_thread_group offset");
_Static_assert(offsetof(struct ks_thread, old_preadopt_thread_group) == 0x510, "ks_thread.old_preadopt_thread_group offset");
_Static_assert(offsetof(struct ks_thread, bank_thread_group) == 0x518, "ks_thread.bank_thread_group offset");
_Static_assert(offsetof(struct ks_thread, auto_join_thread_group) == 0x520, "ks_thread.auto_join_thread_group offset");
_Static_assert(offsetof(struct ks_thread, th_work_interval) == 0x528, "ks_thread.th_work_interval offset");
_Static_assert(offsetof(struct ks_thread, th_work_interval_flags) == 0x530, "ks_thread.th_work_interval_flags offset");
_Static_assert(offsetof(struct ks_thread, inheritor_flags) == 0x534, "ks_thread.inheritor_flags offset");
_Static_assert(offsetof(struct ks_thread, pending_block_hint) == 0x535, "ks_thread.pending_block_hint offset");
_Static_assert(offsetof(struct ks_thread, block_hint) == 0x536, "ks_thread.block_hint offset");
_Static_assert(offsetof(struct ks_thread, decompressions) == 0x538, "ks_thread.decompressions offset");
_Static_assert(offsetof(struct ks_thread, thread_region_page_shift) == 0x53C, "ks_thread.thread_region_page_shift offset");
_Static_assert(offsetof(struct ks_thread, decmp_upl) == 0x540, "ks_thread.decmp_upl offset");
_Static_assert(offsetof(struct ks_thread, ith_knote) == 0x548, "ks_thread.ith_knote offset");
_Static_assert(offsetof(struct ks_thread, txm_thread_stack) == 0x550, "ks_thread.txm_thread_stack offset");
_Static_assert(sizeof(struct ks_thread) == 0x558, "ks_thread size");

/* refs: 11 */
struct ks_thread_group {
    unsigned long long tg_id;
    char tg_name[0x20];
    struct ks_os_refcnt tg_refcount;
    struct {
        unsigned int tg_flags;
        int tg_recommendation;
    };
    struct ks_mpsc_queue_chain tg_destroy_link;
    struct ks_queue_entry tg_queue_chain;
    struct ks_sched_clutch tg_sched_clutch;
    unsigned char tg_machine_data[] __attribute__((aligned(16)));
} __attribute__((aligned(16)));
_Static_assert(offsetof(struct ks_thread_group, tg_id) == 0x0, "ks_thread_group.tg_id offset");
_Static_assert(offsetof(struct ks_thread_group, tg_name) == 0x8, "ks_thread_group.tg_name offset");
_Static_assert(offsetof(struct ks_thread_group, tg_refcount) == 0x28, "ks_thread_group.tg_refcount offset");
_Static_assert(offsetof(struct ks_thread_group, tg_destroy_link) == 0x38, "ks_thread_group.tg_destroy_link offset");
_Static_assert(offsetof(struct ks_thread_group, tg_queue_chain) == 0x40, "ks_thread_group.tg_queue_chain offset");
_Static_assert(offsetof(struct ks_thread_group, tg_sched_clutch) == 0x50, "ks_thread_group.tg_sched_clutch offset");
_Static_assert(offsetof(struct ks_thread_group, tg_machine_data) == 0x300, "ks_thread_group.tg_machine_data offset");
_Static_assert(sizeof(struct ks_thread_group) == 0x300, "ks_thread_group size");

/* refs: 1 */
struct ks_winsize {
    unsigned short ws_row;
    unsigned short ws_col;
    unsigned short ws_xpixel;
    unsigned short ws_ypixel;
};
_Static_assert(offsetof(struct ks_winsize, ws_row) == 0x0, "ks_winsize.ws_row offset");
_Static_assert(offsetof(struct ks_winsize, ws_col) == 0x2, "ks_winsize.ws_col offset");
_Static_assert(offsetof(struct ks_winsize, ws_xpixel) == 0x4, "ks_winsize.ws_xpixel offset");
_Static_assert(offsetof(struct ks_winsize, ws_ypixel) == 0x6, "ks_winsize.ws_ypixel offset");
_Static_assert(sizeof(struct ks_winsize) == 0x8, "ks_winsize size");

/* refs: 1 */
struct ks_tty {
    struct ks_lck_mtx_s t_lock;
    struct ks_clist t_rawq;
    long t_rawcc;
    struct ks_clist t_canq;
    long t_cancc;
    struct ks_clist t_outq;
    long t_outcc;
    int t_line;
    int t_dev;
    int t_state;
    int t_flags;
    int t_timeout;
    struct ks_pgrp *t_pgrp;
    struct ks_session *t_session;
    struct ks_selinfo t_rsel;
    struct ks_selinfo t_wsel;
    struct ks_termios t_termios;
    struct ks_winsize t_winsize;
    void *t_oproc;
    void *t_stop;
    int *t_param;
    void *t_sc;
    int t_column;
    int t_rocount;
    int t_rocol;
    int t_hiwat;
    int t_lowat;
    int t_gen;
    void *t_iokit;
    unsigned int t_refcnt;
    struct ks_thread *t_locked_thread;
};
_Static_assert(offsetof(struct ks_tty, t_lock) == 0x0, "ks_tty.t_lock offset");
_Static_assert(offsetof(struct ks_tty, t_rawq) == 0x10, "ks_tty.t_rawq offset");
_Static_assert(offsetof(struct ks_tty, t_rawcc) == 0x40, "ks_tty.t_rawcc offset");
_Static_assert(offsetof(struct ks_tty, t_canq) == 0x48, "ks_tty.t_canq offset");
_Static_assert(offsetof(struct ks_tty, t_cancc) == 0x78, "ks_tty.t_cancc offset");
_Static_assert(offsetof(struct ks_tty, t_outq) == 0x80, "ks_tty.t_outq offset");
_Static_assert(offsetof(struct ks_tty, t_outcc) == 0xB0, "ks_tty.t_outcc offset");
_Static_assert(offsetof(struct ks_tty, t_line) == 0xB8, "ks_tty.t_line offset");
_Static_assert(offsetof(struct ks_tty, t_dev) == 0xBC, "ks_tty.t_dev offset");
_Static_assert(offsetof(struct ks_tty, t_state) == 0xC0, "ks_tty.t_state offset");
_Static_assert(offsetof(struct ks_tty, t_flags) == 0xC4, "ks_tty.t_flags offset");
_Static_assert(offsetof(struct ks_tty, t_timeout) == 0xC8, "ks_tty.t_timeout offset");
_Static_assert(offsetof(struct ks_tty, t_pgrp) == 0xD0, "ks_tty.t_pgrp offset");
_Static_assert(offsetof(struct ks_tty, t_session) == 0xD8, "ks_tty.t_session offset");
_Static_assert(offsetof(struct ks_tty, t_rsel) == 0xE0, "ks_tty.t_rsel offset");
_Static_assert(offsetof(struct ks_tty, t_wsel) == 0x118, "ks_tty.t_wsel offset");
_Static_assert(offsetof(struct ks_tty, t_termios) == 0x150, "ks_tty.t_termios offset");
_Static_assert(offsetof(struct ks_tty, t_winsize) == 0x198, "ks_tty.t_winsize offset");
_Static_assert(offsetof(struct ks_tty, t_oproc) == 0x1A0, "ks_tty.t_oproc offset");
_Static_assert(offsetof(struct ks_tty, t_stop) == 0x1A8, "ks_tty.t_stop offset");
_Static_assert(offsetof(struct ks_tty, t_param) == 0x1B0, "ks_tty.t_param offset");
_Static_assert(offsetof(struct ks_tty, t_sc) == 0x1B8, "ks_tty.t_sc offset");
_Static_assert(offsetof(struct ks_tty, t_column) == 0x1C0, "ks_tty.t_column offset");
_Static_assert(offsetof(struct ks_tty, t_rocount) == 0x1C4, "ks_tty.t_rocount offset");
_Static_assert(offsetof(struct ks_tty, t_rocol) == 0x1C8, "ks_tty.t_rocol offset");
_Static_assert(offsetof(struct ks_tty, t_hiwat) == 0x1CC, "ks_tty.t_hiwat offset");
_Static_assert(offsetof(struct ks_tty, t_lowat) == 0x1D0, "ks_tty.t_lowat offset");
_Static_assert(offsetof(struct ks_tty, t_gen) == 0x1D4, "ks_tty.t_gen offset");
_Static_assert(offsetof(struct ks_tty, t_iokit) == 0x1D8, "ks_tty.t_iokit offset");
_Static_assert(offsetof(struct ks_tty, t_refcnt) == 0x1E0, "ks_tty.t_refcnt offset");
_Static_assert(offsetof(struct ks_tty, t_locked_thread) == 0x1E8, "ks_tty.t_locked_thread offset");
_Static_assert(sizeof(struct ks_tty) == 0x1F0, "ks_tty size");

/* refs: 1 */
struct ks_turnstile_list {
    struct ks_turnstile *slh_first;
};
_Static_assert(offsetof(struct ks_turnstile_list, slh_first) == 0x0, "ks_turnstile_list.slh_first offset");
_Static_assert(sizeof(struct ks_turnstile_list) == 0x8, "ks_turnstile_list size");

/* refs: 13 */
struct ks_turnstile {
    union {
        struct {
            unsigned int ts_waitq_type : 3; /* bit offset 0 */
            unsigned int ts_waitq_fifo : 1; /* bit offset 3 */
            unsigned int ts_waitq_preposted : 1; /* bit offset 4 */
            unsigned int __ts_unused_bits : 7; /* bit offset 5 */
            unsigned int ts_compact_id : 20; /* bit offset 12 */
        };
        struct ks_waitq ts_waitq __attribute__((aligned(8)));
    };
    struct ks_turnstile_list ts_free_turnstiles;
    struct ks_priority_queue_sched_max ts_inheritor_queue;
    struct ks_priority_queue_entry_sched ts_inheritor_links;
    struct {
        struct ks_turnstile *sle_next;
    } ts_htable_link;
    unsigned long ts_proprietor;
    unsigned int ts_refcount;
    unsigned int ts_type_gencount;
    unsigned int ts_prim_count;
    unsigned char ts_inheritor_flags;
    unsigned char ts_priority;
};
_Static_assert(offsetof(struct ks_turnstile, ts_free_turnstiles) == 0x18, "ks_turnstile.ts_free_turnstiles offset");
_Static_assert(offsetof(struct ks_turnstile, ts_inheritor_queue) == 0x20, "ks_turnstile.ts_inheritor_queue offset");
_Static_assert(offsetof(struct ks_turnstile, ts_inheritor_links) == 0x28, "ks_turnstile.ts_inheritor_links offset");
_Static_assert(offsetof(struct ks_turnstile, ts_htable_link) == 0x40, "ks_turnstile.ts_htable_link offset");
_Static_assert(offsetof(struct ks_turnstile, ts_proprietor) == 0x48, "ks_turnstile.ts_proprietor offset");
_Static_assert(offsetof(struct ks_turnstile, ts_refcount) == 0x50, "ks_turnstile.ts_refcount offset");
_Static_assert(offsetof(struct ks_turnstile, ts_type_gencount) == 0x54, "ks_turnstile.ts_type_gencount offset");
_Static_assert(offsetof(struct ks_turnstile, ts_prim_count) == 0x58, "ks_turnstile.ts_prim_count offset");
_Static_assert(offsetof(struct ks_turnstile, ts_inheritor_flags) == 0x5C, "ks_turnstile.ts_inheritor_flags offset");
_Static_assert(offsetof(struct ks_turnstile, ts_priority) == 0x5D, "ks_turnstile.ts_priority offset");
_Static_assert(sizeof(struct ks_turnstile) == 0x60, "ks_turnstile size");

/* refs: 1 */
struct ks_ubc_info {
    struct ks_memory_object *ui_pager;
    struct ks_vm_object *ui_control;
    struct ks_vnode *ui_vnode;
    struct ks_ucred *ui_ucred;
    long long ui_size;
    unsigned int ui_flags;
    unsigned int cs_add_gen;
    struct ks_cl_readahead *cl_rahead;
    struct ks_cl_writebehind *cl_wbehind;
    struct ks_timespec cs_mtime;
    struct ks_cs_blob *cs_blobs;
    struct ks_cs_blob *cs_blob_supplement;
};
_Static_assert(offsetof(struct ks_ubc_info, ui_pager) == 0x0, "ks_ubc_info.ui_pager offset");
_Static_assert(offsetof(struct ks_ubc_info, ui_control) == 0x8, "ks_ubc_info.ui_control offset");
_Static_assert(offsetof(struct ks_ubc_info, ui_vnode) == 0x10, "ks_ubc_info.ui_vnode offset");
_Static_assert(offsetof(struct ks_ubc_info, ui_ucred) == 0x18, "ks_ubc_info.ui_ucred offset");
_Static_assert(offsetof(struct ks_ubc_info, ui_size) == 0x20, "ks_ubc_info.ui_size offset");
_Static_assert(offsetof(struct ks_ubc_info, ui_flags) == 0x28, "ks_ubc_info.ui_flags offset");
_Static_assert(offsetof(struct ks_ubc_info, cs_add_gen) == 0x2C, "ks_ubc_info.cs_add_gen offset");
_Static_assert(offsetof(struct ks_ubc_info, cl_rahead) == 0x30, "ks_ubc_info.cl_rahead offset");
_Static_assert(offsetof(struct ks_ubc_info, cl_wbehind) == 0x38, "ks_ubc_info.cl_wbehind offset");
_Static_assert(offsetof(struct ks_ubc_info, cs_mtime) == 0x40, "ks_ubc_info.cs_mtime offset");
_Static_assert(offsetof(struct ks_ubc_info, cs_blobs) == 0x50, "ks_ubc_info.cs_blobs offset");
_Static_assert(offsetof(struct ks_ubc_info, cs_blob_supplement) == 0x58, "ks_ubc_info.cs_blob_supplement offset");
_Static_assert(sizeof(struct ks_ubc_info) == 0x60, "ks_ubc_info size");

/* refs: 12 */
struct ks_ucred {
    struct ks_ucred_rw *cr_rw;
    void *cr_unused;
    unsigned long cr_ref;
    struct ks_posix_cred cr_posix;
    struct ks_label *cr_label;
    struct ks_au_session cr_audit;
};
_Static_assert(offsetof(struct ks_ucred, cr_rw) == 0x0, "ks_ucred.cr_rw offset");
_Static_assert(offsetof(struct ks_ucred, cr_unused) == 0x8, "ks_ucred.cr_unused offset");
_Static_assert(offsetof(struct ks_ucred, cr_ref) == 0x10, "ks_ucred.cr_ref offset");
_Static_assert(offsetof(struct ks_ucred, cr_posix) == 0x18, "ks_ucred.cr_posix offset");
_Static_assert(offsetof(struct ks_ucred, cr_label) == 0x78, "ks_ucred.cr_label offset");
_Static_assert(offsetof(struct ks_ucred, cr_audit) == 0x80, "ks_ucred.cr_audit offset");
_Static_assert(sizeof(struct ks_ucred) == 0x90, "ks_ucred size");

/* refs: 1 */
struct ks_ucred_rw {
    unsigned int crw_weak_ref;
    struct ks_ucred *crw_cred;
    struct ks_smrq_slink crw_link;
    struct ks_smr_node crw_node;
};
_Static_assert(offsetof(struct ks_ucred_rw, crw_weak_ref) == 0x0, "ks_ucred_rw.crw_weak_ref offset");
_Static_assert(offsetof(struct ks_ucred_rw, crw_cred) == 0x8, "ks_ucred_rw.crw_cred offset");
_Static_assert(offsetof(struct ks_ucred_rw, crw_link) == 0x10, "ks_ucred_rw.crw_link offset");
_Static_assert(offsetof(struct ks_ucred_rw, crw_node) == 0x18, "ks_ucred_rw.crw_node offset");
_Static_assert(sizeof(struct ks_ucred_rw) == 0x28, "ks_ucred_rw size");

/* refs: 1 */
struct ks_udpstat_local {
    unsigned long long port_unreach;
    unsigned long long faithprefix;
    unsigned long long port0;
    unsigned long long badlength;
    unsigned long long badchksum;
    unsigned long long badmcast;
    unsigned long long cleanup;
    unsigned long long badipsec;
    unsigned long long linkheur_stealthdrop;
};
_Static_assert(offsetof(struct ks_udpstat_local, port_unreach) == 0x0, "ks_udpstat_local.port_unreach offset");
_Static_assert(offsetof(struct ks_udpstat_local, faithprefix) == 0x8, "ks_udpstat_local.faithprefix offset");
_Static_assert(offsetof(struct ks_udpstat_local, port0) == 0x10, "ks_udpstat_local.port0 offset");
_Static_assert(offsetof(struct ks_udpstat_local, badlength) == 0x18, "ks_udpstat_local.badlength offset");
_Static_assert(offsetof(struct ks_udpstat_local, badchksum) == 0x20, "ks_udpstat_local.badchksum offset");
_Static_assert(offsetof(struct ks_udpstat_local, badmcast) == 0x28, "ks_udpstat_local.badmcast offset");
_Static_assert(offsetof(struct ks_udpstat_local, cleanup) == 0x30, "ks_udpstat_local.cleanup offset");
_Static_assert(offsetof(struct ks_udpstat_local, badipsec) == 0x38, "ks_udpstat_local.badipsec offset");
_Static_assert(offsetof(struct ks_udpstat_local, linkheur_stealthdrop) == 0x40, "ks_udpstat_local.linkheur_stealthdrop offset");
_Static_assert(sizeof(struct ks_udpstat_local) == 0x48, "ks_udpstat_local size");

/* refs: 2 */
struct ks_ulk_t {
    union {
        struct {
            unsigned long long ulk_addr;
            struct ks_task *ulk_task;
        };
        struct {
            unsigned long long ulk_object;
            unsigned long long ulk_offset;
        };
    };
    unsigned int ulk_key_type;
} __attribute__((packed));
_Static_assert(offsetof(struct ks_ulk_t, ulk_key_type) == 0x10, "ks_ulk_t.ulk_key_type offset");
_Static_assert(sizeof(struct ks_ulk_t) == 0x14, "ks_ulk_t size");

/* refs: 1 */
struct ks_ull {
    struct ks_thread *ull_owner;
    struct ks_ulk_t ull_key;
    struct ks_lck_spin_s ull_lock;
    unsigned int ull_bucket_index;
    int ull_nwaiters;
    int ull_refcount;
    unsigned char ull_opcode;
    struct ks_turnstile *ull_turnstile;
    struct ks_queue_entry ull_hash_link;
};
_Static_assert(offsetof(struct ks_ull, ull_owner) == 0x0, "ks_ull.ull_owner offset");
_Static_assert(offsetof(struct ks_ull, ull_key) == 0x8, "ks_ull.ull_key offset");
_Static_assert(offsetof(struct ks_ull, ull_lock) == 0x20, "ks_ull.ull_lock offset");
_Static_assert(offsetof(struct ks_ull, ull_bucket_index) == 0x30, "ks_ull.ull_bucket_index offset");
_Static_assert(offsetof(struct ks_ull, ull_nwaiters) == 0x34, "ks_ull.ull_nwaiters offset");
_Static_assert(offsetof(struct ks_ull, ull_refcount) == 0x38, "ks_ull.ull_refcount offset");
_Static_assert(offsetof(struct ks_ull, ull_opcode) == 0x3C, "ks_ull.ull_opcode offset");
_Static_assert(offsetof(struct ks_ull, ull_turnstile) == 0x40, "ks_ull.ull_turnstile offset");
_Static_assert(offsetof(struct ks_ull, ull_hash_link) == 0x48, "ks_ull.ull_hash_link offset");
_Static_assert(sizeof(struct ks_ull) == 0x58, "ks_ull size");

/* refs: 1 */
struct ks_uu_workq_policy {
    unsigned short qos_req : 4; /* bit offset 0 */
    unsigned short qos_max : 4; /* bit offset 4 */
    unsigned short qos_override : 4; /* bit offset 8 */
    unsigned short qos_bucket : 4; /* bit offset 12 */
};
_Static_assert(sizeof(struct ks_uu_workq_policy) == 0x2, "ks_uu_workq_policy size");

/* refs: 1 */
union ks___tdu {
    struct ks___tds _tds;
    unsigned int _t_dtrace_ft;
};
_Static_assert(offsetof(union ks___tdu, _tds) == 0x0, "ks___tdu._tds offset");
_Static_assert(offsetof(union ks___tdu, _t_dtrace_ft) == 0x0, "ks___tdu._t_dtrace_ft offset");

/* refs: 14 */
struct ks_uthread {
    unsigned long long uu_arg[8];
    int uu_rval[2];
    char uu_cursig;
    _Bool uu_workq_pthread_kill_allowed;
    unsigned short syscall_code;
    int uu_exception;
    long long uu_code;
    long long uu_subcode;
    union {
        struct ks__select_data uus_select_data;
        struct ks_kevent_ctx_s uus_kevent;
        struct ks__kevent_register uus_kevent_register;
        struct ks__kauth uus_kauth;
        struct ks_ksyn_waitq_element uus_kwe;
        struct ks__waitid_data uus_waitid_data;
        struct ks__wait4_data uus_wait4_data;
        struct ks__workq_park_data uus_workq_park_data;
        struct ks__ulock_wait_data uus_ulock_wait_data;
        struct ks__bsdthread_terminate uus_bsdthread_terminate;
        struct ks__exec_data uus_exec_data;
    } uu_save;
    struct ks__select uu_select;
    void *uu_userstate;
    struct ks_select_set *uu_selset;
    int uu_flag;
    unsigned int uu_siglist;
    unsigned int uu_sigwait;
    unsigned int uu_sigmask;
    unsigned int uu_oldmask;
    unsigned long long uu_sigreturn_token;
    unsigned int uu_sigreturn_diversifier;
    int uu_pending_sigreturn;
    struct {
        struct ks_uthread *tqe_next;
        struct ks_uthread **tqe_prev;
    } uu_list;
    struct ks_kaudit_record *uu_ar;
    struct ks_task *uu_aio_task;
    union {
        struct ks_lck_mtx_s *uu_mtx;
        struct ks_knote_lock_ctx *uu_knlock;
    };
    struct ks_lck_spin_s uu_rethrottle_lock;
    struct {
        struct ks_uthread *tqe_next;
        struct ks_uthread **tqe_prev;
    } uu_throttlelist;
    void *uu_throttle_info;
    signed char uu_on_throttlelist;
    _Bool uu_lowpri_window;
    _Bool uu_was_rethrottled;
    _Bool uu_is_throttled;
    _Bool uu_throttle_bc;
    _Bool uu_defer_reclaims;
    unsigned short uu_pri;
    char *uu_wchan;
    int *uu_continuation;
    const char *uu_wmesg;
    struct ks_kern_sigaltstack uu_sigstk;
    struct ks_vnode *uu_vreclaims;
    struct ks_vnode *uu_cdir;
    int uu_dupfd;
    unsigned int uu_network_marks;
    struct ks_workq_threadreq_s *uu_kqr_bound;
    struct {
        struct ks_uthread *tqe_next;
        struct ks_uthread **tqe_prev;
    } uu_workq_entry;
    unsigned long uu_workq_stackaddr;
    unsigned int uu_workq_thport;
    struct ks_uu_workq_policy uu_workq_pri;
    unsigned short uu_workq_flags;
    unsigned char uu_kqueue_override;
    int uu_proc_refcount;
    unsigned int t_dtrace_errno;
    struct ks___siginfo t_dtrace_siginfo;
    unsigned long long t_dtrace_resumepid;
    unsigned char t_dtrace_stop;
    unsigned char t_dtrace_sig;
    union ks___tdu _tdu;
    unsigned long long t_dtrace_pc;
    unsigned long long t_dtrace_npc;
    unsigned long long t_dtrace_scrpc;
    unsigned long long t_dtrace_astpc;
    struct ks_dtrace_ptss_page_entry *t_dtrace_scratch;
    unsigned long long t_dtrace_regv;
    void *t_dtrace_syscall_args;
    char *pth_name;
    struct ks_doc_tombstone *t_tombstone;
    unsigned long long t_fs_private;
    struct ks_os_reason *uu_exit_reason;
};
_Static_assert(offsetof(struct ks_uthread, uu_arg) == 0x0, "ks_uthread.uu_arg offset");
_Static_assert(offsetof(struct ks_uthread, uu_rval) == 0x40, "ks_uthread.uu_rval offset");
_Static_assert(offsetof(struct ks_uthread, uu_cursig) == 0x48, "ks_uthread.uu_cursig offset");
_Static_assert(offsetof(struct ks_uthread, uu_workq_pthread_kill_allowed) == 0x49, "ks_uthread.uu_workq_pthread_kill_allowed offset");
_Static_assert(offsetof(struct ks_uthread, syscall_code) == 0x4A, "ks_uthread.syscall_code offset");
_Static_assert(offsetof(struct ks_uthread, uu_exception) == 0x4C, "ks_uthread.uu_exception offset");
_Static_assert(offsetof(struct ks_uthread, uu_code) == 0x50, "ks_uthread.uu_code offset");
_Static_assert(offsetof(struct ks_uthread, uu_subcode) == 0x58, "ks_uthread.uu_subcode offset");
_Static_assert(offsetof(struct ks_uthread, uu_save) == 0x60, "ks_uthread.uu_save offset");
_Static_assert(offsetof(struct ks_uthread, uu_select) == 0xC8, "ks_uthread.uu_select offset");
_Static_assert(offsetof(struct ks_uthread, uu_userstate) == 0xE0, "ks_uthread.uu_userstate offset");
_Static_assert(offsetof(struct ks_uthread, uu_selset) == 0xE8, "ks_uthread.uu_selset offset");
_Static_assert(offsetof(struct ks_uthread, uu_flag) == 0xF0, "ks_uthread.uu_flag offset");
_Static_assert(offsetof(struct ks_uthread, uu_siglist) == 0xF4, "ks_uthread.uu_siglist offset");
_Static_assert(offsetof(struct ks_uthread, uu_sigwait) == 0xF8, "ks_uthread.uu_sigwait offset");
_Static_assert(offsetof(struct ks_uthread, uu_sigmask) == 0xFC, "ks_uthread.uu_sigmask offset");
_Static_assert(offsetof(struct ks_uthread, uu_oldmask) == 0x100, "ks_uthread.uu_oldmask offset");
_Static_assert(offsetof(struct ks_uthread, uu_sigreturn_token) == 0x108, "ks_uthread.uu_sigreturn_token offset");
_Static_assert(offsetof(struct ks_uthread, uu_sigreturn_diversifier) == 0x110, "ks_uthread.uu_sigreturn_diversifier offset");
_Static_assert(offsetof(struct ks_uthread, uu_pending_sigreturn) == 0x114, "ks_uthread.uu_pending_sigreturn offset");
_Static_assert(offsetof(struct ks_uthread, uu_list) == 0x118, "ks_uthread.uu_list offset");
_Static_assert(offsetof(struct ks_uthread, uu_ar) == 0x128, "ks_uthread.uu_ar offset");
_Static_assert(offsetof(struct ks_uthread, uu_aio_task) == 0x130, "ks_uthread.uu_aio_task offset");
_Static_assert(offsetof(struct ks_uthread, uu_rethrottle_lock) == 0x140, "ks_uthread.uu_rethrottle_lock offset");
_Static_assert(offsetof(struct ks_uthread, uu_throttlelist) == 0x150, "ks_uthread.uu_throttlelist offset");
_Static_assert(offsetof(struct ks_uthread, uu_throttle_info) == 0x160, "ks_uthread.uu_throttle_info offset");
_Static_assert(offsetof(struct ks_uthread, uu_on_throttlelist) == 0x168, "ks_uthread.uu_on_throttlelist offset");
_Static_assert(offsetof(struct ks_uthread, uu_lowpri_window) == 0x169, "ks_uthread.uu_lowpri_window offset");
_Static_assert(offsetof(struct ks_uthread, uu_was_rethrottled) == 0x16A, "ks_uthread.uu_was_rethrottled offset");
_Static_assert(offsetof(struct ks_uthread, uu_is_throttled) == 0x16B, "ks_uthread.uu_is_throttled offset");
_Static_assert(offsetof(struct ks_uthread, uu_throttle_bc) == 0x16C, "ks_uthread.uu_throttle_bc offset");
_Static_assert(offsetof(struct ks_uthread, uu_defer_reclaims) == 0x16D, "ks_uthread.uu_defer_reclaims offset");
_Static_assert(offsetof(struct ks_uthread, uu_pri) == 0x16E, "ks_uthread.uu_pri offset");
_Static_assert(offsetof(struct ks_uthread, uu_wchan) == 0x170, "ks_uthread.uu_wchan offset");
_Static_assert(offsetof(struct ks_uthread, uu_continuation) == 0x178, "ks_uthread.uu_continuation offset");
_Static_assert(offsetof(struct ks_uthread, uu_wmesg) == 0x180, "ks_uthread.uu_wmesg offset");
_Static_assert(offsetof(struct ks_uthread, uu_sigstk) == 0x188, "ks_uthread.uu_sigstk offset");
_Static_assert(offsetof(struct ks_uthread, uu_vreclaims) == 0x1A0, "ks_uthread.uu_vreclaims offset");
_Static_assert(offsetof(struct ks_uthread, uu_cdir) == 0x1A8, "ks_uthread.uu_cdir offset");
_Static_assert(offsetof(struct ks_uthread, uu_dupfd) == 0x1B0, "ks_uthread.uu_dupfd offset");
_Static_assert(offsetof(struct ks_uthread, uu_network_marks) == 0x1B4, "ks_uthread.uu_network_marks offset");
_Static_assert(offsetof(struct ks_uthread, uu_kqr_bound) == 0x1B8, "ks_uthread.uu_kqr_bound offset");
_Static_assert(offsetof(struct ks_uthread, uu_workq_entry) == 0x1C0, "ks_uthread.uu_workq_entry offset");
_Static_assert(offsetof(struct ks_uthread, uu_workq_stackaddr) == 0x1D0, "ks_uthread.uu_workq_stackaddr offset");
_Static_assert(offsetof(struct ks_uthread, uu_workq_thport) == 0x1D8, "ks_uthread.uu_workq_thport offset");
_Static_assert(offsetof(struct ks_uthread, uu_workq_pri) == 0x1DC, "ks_uthread.uu_workq_pri offset");
_Static_assert(offsetof(struct ks_uthread, uu_workq_flags) == 0x1DE, "ks_uthread.uu_workq_flags offset");
_Static_assert(offsetof(struct ks_uthread, uu_kqueue_override) == 0x1E0, "ks_uthread.uu_kqueue_override offset");
_Static_assert(offsetof(struct ks_uthread, uu_proc_refcount) == 0x1E4, "ks_uthread.uu_proc_refcount offset");
_Static_assert(offsetof(struct ks_uthread, t_dtrace_errno) == 0x1E8, "ks_uthread.t_dtrace_errno offset");
_Static_assert(offsetof(struct ks_uthread, t_dtrace_siginfo) == 0x1F0, "ks_uthread.t_dtrace_siginfo offset");
_Static_assert(offsetof(struct ks_uthread, t_dtrace_resumepid) == 0x258, "ks_uthread.t_dtrace_resumepid offset");
_Static_assert(offsetof(struct ks_uthread, t_dtrace_stop) == 0x260, "ks_uthread.t_dtrace_stop offset");
_Static_assert(offsetof(struct ks_uthread, t_dtrace_sig) == 0x261, "ks_uthread.t_dtrace_sig offset");
_Static_assert(offsetof(struct ks_uthread, _tdu) == 0x264, "ks_uthread._tdu offset");
_Static_assert(offsetof(struct ks_uthread, t_dtrace_pc) == 0x270, "ks_uthread.t_dtrace_pc offset");
_Static_assert(offsetof(struct ks_uthread, t_dtrace_npc) == 0x278, "ks_uthread.t_dtrace_npc offset");
_Static_assert(offsetof(struct ks_uthread, t_dtrace_scrpc) == 0x280, "ks_uthread.t_dtrace_scrpc offset");
_Static_assert(offsetof(struct ks_uthread, t_dtrace_astpc) == 0x288, "ks_uthread.t_dtrace_astpc offset");
_Static_assert(offsetof(struct ks_uthread, t_dtrace_scratch) == 0x290, "ks_uthread.t_dtrace_scratch offset");
_Static_assert(offsetof(struct ks_uthread, t_dtrace_regv) == 0x298, "ks_uthread.t_dtrace_regv offset");
_Static_assert(offsetof(struct ks_uthread, t_dtrace_syscall_args) == 0x2A0, "ks_uthread.t_dtrace_syscall_args offset");
_Static_assert(offsetof(struct ks_uthread, pth_name) == 0x2A8, "ks_uthread.pth_name offset");
_Static_assert(offsetof(struct ks_uthread, t_tombstone) == 0x2B0, "ks_uthread.t_tombstone offset");
_Static_assert(offsetof(struct ks_uthread, t_fs_private) == 0x2B8, "ks_uthread.t_fs_private offset");
_Static_assert(offsetof(struct ks_uthread, uu_exit_reason) == 0x2C0, "ks_uthread.uu_exit_reason offset");
_Static_assert(sizeof(struct ks_uthread) == 0x2C8, "ks_uthread size");

/* refs: 2 */
struct ks_vfsops {
    int *vfs_mount;
    int *vfs_start;
    int *vfs_unmount;
    int *vfs_root;
    int *vfs_quotactl;
    int *vfs_getattr;
    int *vfs_sync;
    int *vfs_vget;
    int *vfs_fhtovp;
    int *vfs_vptofh;
    int *vfs_init;
    int *vfs_sysctl;
    int *vfs_setattr;
    int *vfs_ioctl;
    int *vfs_vget_snapdir;
    void *vfs_reserved5;
    void *vfs_reserved4;
    void *vfs_reserved3;
    void *vfs_reserved2;
    void *vfs_reserved1;
};
_Static_assert(offsetof(struct ks_vfsops, vfs_mount) == 0x0, "ks_vfsops.vfs_mount offset");
_Static_assert(offsetof(struct ks_vfsops, vfs_start) == 0x8, "ks_vfsops.vfs_start offset");
_Static_assert(offsetof(struct ks_vfsops, vfs_unmount) == 0x10, "ks_vfsops.vfs_unmount offset");
_Static_assert(offsetof(struct ks_vfsops, vfs_root) == 0x18, "ks_vfsops.vfs_root offset");
_Static_assert(offsetof(struct ks_vfsops, vfs_quotactl) == 0x20, "ks_vfsops.vfs_quotactl offset");
_Static_assert(offsetof(struct ks_vfsops, vfs_getattr) == 0x28, "ks_vfsops.vfs_getattr offset");
_Static_assert(offsetof(struct ks_vfsops, vfs_sync) == 0x30, "ks_vfsops.vfs_sync offset");
_Static_assert(offsetof(struct ks_vfsops, vfs_vget) == 0x38, "ks_vfsops.vfs_vget offset");
_Static_assert(offsetof(struct ks_vfsops, vfs_fhtovp) == 0x40, "ks_vfsops.vfs_fhtovp offset");
_Static_assert(offsetof(struct ks_vfsops, vfs_vptofh) == 0x48, "ks_vfsops.vfs_vptofh offset");
_Static_assert(offsetof(struct ks_vfsops, vfs_init) == 0x50, "ks_vfsops.vfs_init offset");
_Static_assert(offsetof(struct ks_vfsops, vfs_sysctl) == 0x58, "ks_vfsops.vfs_sysctl offset");
_Static_assert(offsetof(struct ks_vfsops, vfs_setattr) == 0x60, "ks_vfsops.vfs_setattr offset");
_Static_assert(offsetof(struct ks_vfsops, vfs_ioctl) == 0x68, "ks_vfsops.vfs_ioctl offset");
_Static_assert(offsetof(struct ks_vfsops, vfs_vget_snapdir) == 0x70, "ks_vfsops.vfs_vget_snapdir offset");
_Static_assert(offsetof(struct ks_vfsops, vfs_reserved5) == 0x78, "ks_vfsops.vfs_reserved5 offset");
_Static_assert(offsetof(struct ks_vfsops, vfs_reserved4) == 0x80, "ks_vfsops.vfs_reserved4 offset");
_Static_assert(offsetof(struct ks_vfsops, vfs_reserved3) == 0x88, "ks_vfsops.vfs_reserved3 offset");
_Static_assert(offsetof(struct ks_vfsops, vfs_reserved2) == 0x90, "ks_vfsops.vfs_reserved2 offset");
_Static_assert(offsetof(struct ks_vfsops, vfs_reserved1) == 0x98, "ks_vfsops.vfs_reserved1 offset");
_Static_assert(sizeof(struct ks_vfsops) == 0xA0, "ks_vfsops size");

/* refs: 1 */
struct ks_vfstable {
    const struct ks_vfsops *vfc_vfsops;
    char vfc_name[15];
    int vfc_typenum;
    int vfc_refcount;
    int vfc_flags;
    int *vfc_mountroot;
    struct ks_vfstable *vfc_next;
    int vfc_reserved1;
    int vfc_reserved2;
    int vfc_vfsflags;
    void *vfc_descptr;
    unsigned int vfc_descsize;
    struct ks_sysctl_oid *vfc_sysctl;
};
_Static_assert(offsetof(struct ks_vfstable, vfc_vfsops) == 0x0, "ks_vfstable.vfc_vfsops offset");
_Static_assert(offsetof(struct ks_vfstable, vfc_name) == 0x8, "ks_vfstable.vfc_name offset");
_Static_assert(offsetof(struct ks_vfstable, vfc_typenum) == 0x18, "ks_vfstable.vfc_typenum offset");
_Static_assert(offsetof(struct ks_vfstable, vfc_refcount) == 0x1C, "ks_vfstable.vfc_refcount offset");
_Static_assert(offsetof(struct ks_vfstable, vfc_flags) == 0x20, "ks_vfstable.vfc_flags offset");
_Static_assert(offsetof(struct ks_vfstable, vfc_mountroot) == 0x28, "ks_vfstable.vfc_mountroot offset");
_Static_assert(offsetof(struct ks_vfstable, vfc_next) == 0x30, "ks_vfstable.vfc_next offset");
_Static_assert(offsetof(struct ks_vfstable, vfc_reserved1) == 0x38, "ks_vfstable.vfc_reserved1 offset");
_Static_assert(offsetof(struct ks_vfstable, vfc_reserved2) == 0x3C, "ks_vfstable.vfc_reserved2 offset");
_Static_assert(offsetof(struct ks_vfstable, vfc_vfsflags) == 0x40, "ks_vfstable.vfc_vfsflags offset");
_Static_assert(offsetof(struct ks_vfstable, vfc_descptr) == 0x48, "ks_vfstable.vfc_descptr offset");
_Static_assert(offsetof(struct ks_vfstable, vfc_descsize) == 0x50, "ks_vfstable.vfc_descsize offset");
_Static_assert(offsetof(struct ks_vfstable, vfc_sysctl) == 0x58, "ks_vfstable.vfc_sysctl offset");
_Static_assert(sizeof(struct ks_vfstable) == 0x60, "ks_vfstable size");

/* refs: 4 */
struct ks_vm_deferred_reclamation_metadata_s {
    struct {
        struct ks_vm_deferred_reclamation_metadata_s *tqe_next;
        struct ks_vm_deferred_reclamation_metadata_s **tqe_prev;
    } vdrm_list;
    struct ks_lck_mtx_s vdrm_lock;
    struct ks_gate vdrm_gate;
    struct ks_task *vdrm_task;
    int vdrm_pid;
    struct ks__vm_map *vdrm_map;
    struct ks_os_refcnt vdrm_refcnt;
    unsigned long long vdrm_ring_addr;
    unsigned long long vdrm_ring_size;
    unsigned int vdrm_buffer_len;
    unsigned long long vdrm_reclaimed_at;
    unsigned int vdrm_waiters;
    unsigned long long vdrm_last_sample_abs;
    unsigned long vdrm_kernel_bytes_reclaimed;
    unsigned long long vdrm_reclaimable_bytes_last;
    unsigned long long vdrm_reclaimable_bytes_wma;
    unsigned char vdrm_is_registered : 1; /* bit offset 1280 */
    unsigned char __unused1 : 7; /* bit offset 1281 */
};
_Static_assert(offsetof(struct ks_vm_deferred_reclamation_metadata_s, vdrm_list) == 0x0, "ks_vm_deferred_reclamation_metadata_s.vdrm_list offset");
_Static_assert(offsetof(struct ks_vm_deferred_reclamation_metadata_s, vdrm_lock) == 0x10, "ks_vm_deferred_reclamation_metadata_s.vdrm_lock offset");
_Static_assert(offsetof(struct ks_vm_deferred_reclamation_metadata_s, vdrm_gate) == 0x20, "ks_vm_deferred_reclamation_metadata_s.vdrm_gate offset");
_Static_assert(offsetof(struct ks_vm_deferred_reclamation_metadata_s, vdrm_task) == 0x38, "ks_vm_deferred_reclamation_metadata_s.vdrm_task offset");
_Static_assert(offsetof(struct ks_vm_deferred_reclamation_metadata_s, vdrm_pid) == 0x40, "ks_vm_deferred_reclamation_metadata_s.vdrm_pid offset");
_Static_assert(offsetof(struct ks_vm_deferred_reclamation_metadata_s, vdrm_map) == 0x48, "ks_vm_deferred_reclamation_metadata_s.vdrm_map offset");
_Static_assert(offsetof(struct ks_vm_deferred_reclamation_metadata_s, vdrm_refcnt) == 0x50, "ks_vm_deferred_reclamation_metadata_s.vdrm_refcnt offset");
_Static_assert(offsetof(struct ks_vm_deferred_reclamation_metadata_s, vdrm_ring_addr) == 0x58, "ks_vm_deferred_reclamation_metadata_s.vdrm_ring_addr offset");
_Static_assert(offsetof(struct ks_vm_deferred_reclamation_metadata_s, vdrm_ring_size) == 0x60, "ks_vm_deferred_reclamation_metadata_s.vdrm_ring_size offset");
_Static_assert(offsetof(struct ks_vm_deferred_reclamation_metadata_s, vdrm_buffer_len) == 0x68, "ks_vm_deferred_reclamation_metadata_s.vdrm_buffer_len offset");
_Static_assert(offsetof(struct ks_vm_deferred_reclamation_metadata_s, vdrm_reclaimed_at) == 0x70, "ks_vm_deferred_reclamation_metadata_s.vdrm_reclaimed_at offset");
_Static_assert(offsetof(struct ks_vm_deferred_reclamation_metadata_s, vdrm_waiters) == 0x78, "ks_vm_deferred_reclamation_metadata_s.vdrm_waiters offset");
_Static_assert(offsetof(struct ks_vm_deferred_reclamation_metadata_s, vdrm_last_sample_abs) == 0x80, "ks_vm_deferred_reclamation_metadata_s.vdrm_last_sample_abs offset");
_Static_assert(offsetof(struct ks_vm_deferred_reclamation_metadata_s, vdrm_kernel_bytes_reclaimed) == 0x88, "ks_vm_deferred_reclamation_metadata_s.vdrm_kernel_bytes_reclaimed offset");
_Static_assert(offsetof(struct ks_vm_deferred_reclamation_metadata_s, vdrm_reclaimable_bytes_last) == 0x90, "ks_vm_deferred_reclamation_metadata_s.vdrm_reclaimable_bytes_last offset");
_Static_assert(offsetof(struct ks_vm_deferred_reclamation_metadata_s, vdrm_reclaimable_bytes_wma) == 0x98, "ks_vm_deferred_reclamation_metadata_s.vdrm_reclaimable_bytes_wma offset");
_Static_assert(sizeof(struct ks_vm_deferred_reclamation_metadata_s) == 0xA8, "ks_vm_deferred_reclamation_metadata_s size");

/* refs: 1 */
struct ks_vm_map_corpse_footprint_header {
    unsigned long cf_size;
    unsigned int cf_last_region;
    unsigned int cfu;
};
_Static_assert(offsetof(struct ks_vm_map_corpse_footprint_header, cf_size) == 0x0, "ks_vm_map_corpse_footprint_header.cf_size offset");
_Static_assert(offsetof(struct ks_vm_map_corpse_footprint_header, cf_last_region) == 0x8, "ks_vm_map_corpse_footprint_header.cf_last_region offset");
_Static_assert(offsetof(struct ks_vm_map_corpse_footprint_header, cfu) == 0xC, "ks_vm_map_corpse_footprint_header.cfu offset");
_Static_assert(sizeof(struct ks_vm_map_corpse_footprint_header) == 0x10, "ks_vm_map_corpse_footprint_header size");

/* refs: 5 */
struct ks_vm_map_store {
    struct {
        struct ks_vm_map_store *rbe_left;
        struct ks_vm_map_store *rbe_right;
        struct ks_vm_map_store *rbe_parent;
    } entry;
};
_Static_assert(offsetof(struct ks_vm_map_store, entry) == 0x0, "ks_vm_map_store.entry offset");
_Static_assert(sizeof(struct ks_vm_map_store) == 0x18, "ks_vm_map_store size");

/* refs: 4 */
struct ks_vm_map_entry {
    struct ks_vm_map_links links;
    struct ks_vm_map_store store;
    union {
        unsigned long vme_object_value;
        struct {
            unsigned long vme_atomic : 1; /* bit offset 0 */
            unsigned long is_sub_map : 1; /* bit offset 1 */
            unsigned long vme_submap : 62; /* bit offset 2 */
        };
        struct {
            unsigned int vme_ctx_atomic : 1; /* bit offset 0 */
            unsigned int vme_ctx_is_sub_map : 1; /* bit offset 1 */
            unsigned int vme_context : 30; /* bit offset 2 */
            unsigned int vme_object_or_delta;
        };
    };
    unsigned long long vme_alias : 12; /* bit offset 512 */
    unsigned long long vme_offset : 52; /* bit offset 524 */
    unsigned long long is_shared : 1; /* bit offset 576 */
    unsigned long long __unused1 : 1; /* bit offset 577 */
    unsigned long long in_transition : 1; /* bit offset 578 */
    unsigned long long needs_wakeup : 1; /* bit offset 579 */
    unsigned long long behavior : 2; /* bit offset 580 */
    unsigned long long needs_copy : 1; /* bit offset 582 */
    unsigned long long protection : 3; /* bit offset 583 */
    unsigned long long used_for_tpro : 1; /* bit offset 586 */
    unsigned long long max_protection : 4; /* bit offset 587 */
    unsigned long long inheritance : 2; /* bit offset 591 */
    unsigned long long use_pmap : 1; /* bit offset 593 */
    unsigned long long no_cache : 1; /* bit offset 594 */
    unsigned long long vme_permanent : 1; /* bit offset 595 */
    unsigned long long superpage_size : 1; /* bit offset 596 */
    unsigned long long zero_wired_pages : 1; /* bit offset 597 */
    unsigned long long used_for_jit : 1; /* bit offset 598 */
    unsigned long long csm_associated : 1; /* bit offset 599 */
    unsigned long long iokit_acct : 1; /* bit offset 600 */
    unsigned long long vme_resilient_codesign : 1; /* bit offset 601 */
    unsigned long long vme_resilient_media : 1; /* bit offset 602 */
    unsigned long long vme_xnu_user_debug : 1; /* bit offset 603 */
    unsigned long long vme_no_copy_on_read : 1; /* bit offset 604 */
    unsigned long long translated_allow_execute : 1; /* bit offset 605 */
    unsigned long long vme_kernel_object : 1; /* bit offset 606 */
    unsigned short wired_count;
    unsigned short user_wired_count;
};
_Static_assert(offsetof(struct ks_vm_map_entry, links) == 0x0, "ks_vm_map_entry.links offset");
_Static_assert(offsetof(struct ks_vm_map_entry, store) == 0x20, "ks_vm_map_entry.store offset");
_Static_assert(offsetof(struct ks_vm_map_entry, wired_count) == 0x4C, "ks_vm_map_entry.wired_count offset");
_Static_assert(offsetof(struct ks_vm_map_entry, user_wired_count) == 0x4E, "ks_vm_map_entry.user_wired_count offset");
_Static_assert(sizeof(struct ks_vm_map_entry) == 0x50, "ks_vm_map_entry size");

/* refs: 6 */
struct ks_vm_page_packed_queue_entry {
    unsigned int next;
    unsigned int prev;
};
_Static_assert(offsetof(struct ks_vm_page_packed_queue_entry, next) == 0x0, "ks_vm_page_packed_queue_entry.next offset");
_Static_assert(offsetof(struct ks_vm_page_packed_queue_entry, prev) == 0x4, "ks_vm_page_packed_queue_entry.prev offset");
_Static_assert(sizeof(struct ks_vm_page_packed_queue_entry) == 0x8, "ks_vm_page_packed_queue_entry size");

/* refs: 5 */
struct ks_vm_object {
    struct ks_vm_page_packed_queue_entry memq;
    struct ks_lck_rw_s Lock;
    union {
        unsigned long long vou_size;
        int vou_cache_pages_to_scan;
    } vo_un1;
    struct ks_vm_page *memq_hint;
    unsigned int ref_count;
    unsigned int resident_page_count;
    unsigned int wired_page_count;
    unsigned int reusable_page_count;
    struct ks_vm_object *vo_copy;
    unsigned long long vo_copy_version;
    struct ks_vm_object *shadow;
    struct ks_memory_object *pager;
    union {
        unsigned long long vou_shadow_offset;
        unsigned long vou_cache_ts;
        struct ks_task *vou_owner;
    } vo_un2;
    unsigned long long paging_offset;
    struct ks_vm_object *pager_control;
    int copy_strategy;
    unsigned short paging_in_progress;
    unsigned short vo_size_delta;
    unsigned int activity_in_progress;
    unsigned int all_wanted : 7; /* bit offset 992 */
    unsigned int pager_created : 1; /* bit offset 999 */
    unsigned int pager_initialized : 1; /* bit offset 1000 */
    unsigned int pager_ready : 1; /* bit offset 1001 */
    unsigned int pager_trusted : 1; /* bit offset 1002 */
    unsigned int can_persist : 1; /* bit offset 1003 */
    unsigned int internal : 1; /* bit offset 1004 */
    unsigned int private : 1; /* bit offset 1005 */
    unsigned int pageout : 1; /* bit offset 1006 */
    unsigned int alive : 1; /* bit offset 1007 */
    unsigned int purgable : 2; /* bit offset 1008 */
    unsigned int purgeable_only_by_kernel : 1; /* bit offset 1010 */
    unsigned int purgeable_when_ripe : 1; /* bit offset 1011 */
    unsigned int shadowed : 1; /* bit offset 1012 */
    unsigned int true_share : 1; /* bit offset 1013 */
    unsigned int terminating : 1; /* bit offset 1014 */
    unsigned int named : 1; /* bit offset 1015 */
    unsigned int shadow_severed : 1; /* bit offset 1016 */
    unsigned int phys_contiguous : 1; /* bit offset 1017 */
    unsigned int nophyscache : 1; /* bit offset 1018 */
    unsigned int for_realtime : 1; /* bit offset 1019 */
    unsigned int no_pager_reason : 3; /* bit offset 1020 */
    unsigned int __object1_unused_bits : 1; /* bit offset 1023 */
    struct ks_queue_entry cached_list;
    unsigned long long last_alloc;
    unsigned long cow_hint;
    int sequential;
    unsigned int pages_created;
    unsigned int pages_used;
    unsigned int wimg_bits : 8; /* bit offset 1376 */
    unsigned int code_signed : 1; /* bit offset 1384 */
    unsigned int transposed : 1; /* bit offset 1385 */
    unsigned int mapping_in_progress : 1; /* bit offset 1386 */
    unsigned int phantom_isssd : 1; /* bit offset 1387 */
    unsigned int volatile_empty : 1; /* bit offset 1388 */
    unsigned int volatile_fault : 1; /* bit offset 1389 */
    unsigned int all_reusable : 1; /* bit offset 1390 */
    unsigned int blocked_access : 1; /* bit offset 1391 */
    unsigned int set_cache_attr : 1; /* bit offset 1392 */
    unsigned int object_is_shared_cache : 1; /* bit offset 1393 */
    unsigned int purgeable_queue_type : 2; /* bit offset 1394 */
    unsigned int purgeable_queue_group : 3; /* bit offset 1396 */
    unsigned int io_tracking : 1; /* bit offset 1399 */
    unsigned int no_tag_update : 1; /* bit offset 1400 */
    unsigned int __object3_unused_bits : 2; /* bit offset 1401 */
    unsigned int __unused_access_tracking : 1; /* bit offset 1403 */
    unsigned int vo_ledger_tag : 3; /* bit offset 1404 */
    unsigned int vo_no_footprint : 1; /* bit offset 1407 */
    unsigned char scan_collisions;
    unsigned char vo_chead_hint : 4; /* bit offset 1416 */
    unsigned char __object4_unused_bits : 4; /* bit offset 1420 */
    unsigned short wire_tag;
    struct ks_queue_entry uplq;
    struct ks_queue_entry objq;
    struct ks_queue_entry task_objq;
    const void *vmo_provenance;
    unsigned int vmo_pl_req_in_progress;
    unsigned int vo_inherit_copy_none : 1; /* bit offset 1952 */
    unsigned int __vo_unused_padding : 31; /* bit offset 1953 */
};
_Static_assert(offsetof(struct ks_vm_object, memq) == 0x0, "ks_vm_object.memq offset");
_Static_assert(offsetof(struct ks_vm_object, Lock) == 0x8, "ks_vm_object.Lock offset");
_Static_assert(offsetof(struct ks_vm_object, vo_un1) == 0x18, "ks_vm_object.vo_un1 offset");
_Static_assert(offsetof(struct ks_vm_object, memq_hint) == 0x20, "ks_vm_object.memq_hint offset");
_Static_assert(offsetof(struct ks_vm_object, ref_count) == 0x28, "ks_vm_object.ref_count offset");
_Static_assert(offsetof(struct ks_vm_object, resident_page_count) == 0x2C, "ks_vm_object.resident_page_count offset");
_Static_assert(offsetof(struct ks_vm_object, wired_page_count) == 0x30, "ks_vm_object.wired_page_count offset");
_Static_assert(offsetof(struct ks_vm_object, reusable_page_count) == 0x34, "ks_vm_object.reusable_page_count offset");
_Static_assert(offsetof(struct ks_vm_object, vo_copy) == 0x38, "ks_vm_object.vo_copy offset");
_Static_assert(offsetof(struct ks_vm_object, vo_copy_version) == 0x40, "ks_vm_object.vo_copy_version offset");
_Static_assert(offsetof(struct ks_vm_object, shadow) == 0x48, "ks_vm_object.shadow offset");
_Static_assert(offsetof(struct ks_vm_object, pager) == 0x50, "ks_vm_object.pager offset");
_Static_assert(offsetof(struct ks_vm_object, vo_un2) == 0x58, "ks_vm_object.vo_un2 offset");
_Static_assert(offsetof(struct ks_vm_object, paging_offset) == 0x60, "ks_vm_object.paging_offset offset");
_Static_assert(offsetof(struct ks_vm_object, pager_control) == 0x68, "ks_vm_object.pager_control offset");
_Static_assert(offsetof(struct ks_vm_object, copy_strategy) == 0x70, "ks_vm_object.copy_strategy offset");
_Static_assert(offsetof(struct ks_vm_object, paging_in_progress) == 0x74, "ks_vm_object.paging_in_progress offset");
_Static_assert(offsetof(struct ks_vm_object, vo_size_delta) == 0x76, "ks_vm_object.vo_size_delta offset");
_Static_assert(offsetof(struct ks_vm_object, activity_in_progress) == 0x78, "ks_vm_object.activity_in_progress offset");
_Static_assert(offsetof(struct ks_vm_object, cached_list) == 0x80, "ks_vm_object.cached_list offset");
_Static_assert(offsetof(struct ks_vm_object, last_alloc) == 0x90, "ks_vm_object.last_alloc offset");
_Static_assert(offsetof(struct ks_vm_object, cow_hint) == 0x98, "ks_vm_object.cow_hint offset");
_Static_assert(offsetof(struct ks_vm_object, sequential) == 0xA0, "ks_vm_object.sequential offset");
_Static_assert(offsetof(struct ks_vm_object, pages_created) == 0xA4, "ks_vm_object.pages_created offset");
_Static_assert(offsetof(struct ks_vm_object, pages_used) == 0xA8, "ks_vm_object.pages_used offset");
_Static_assert(offsetof(struct ks_vm_object, scan_collisions) == 0xB0, "ks_vm_object.scan_collisions offset");
_Static_assert(offsetof(struct ks_vm_object, wire_tag) == 0xB2, "ks_vm_object.wire_tag offset");
_Static_assert(offsetof(struct ks_vm_object, uplq) == 0xB8, "ks_vm_object.uplq offset");
_Static_assert(offsetof(struct ks_vm_object, objq) == 0xC8, "ks_vm_object.objq offset");
_Static_assert(offsetof(struct ks_vm_object, task_objq) == 0xD8, "ks_vm_object.task_objq offset");
_Static_assert(offsetof(struct ks_vm_object, vmo_provenance) == 0xE8, "ks_vm_object.vmo_provenance offset");
_Static_assert(offsetof(struct ks_vm_object, vmo_pl_req_in_progress) == 0xF0, "ks_vm_object.vmo_pl_req_in_progress offset");
_Static_assert(sizeof(struct ks_vm_object) == 0xF8, "ks_vm_object size");

/* refs: 2 */
struct ks_vm_page {
    union {
        struct ks_vm_page_packed_queue_entry vmp_pageq;
        struct ks_vm_page *vmp_snext;
    };
    struct ks_vm_page_packed_queue_entry vmp_specialq;
    struct ks_vm_page_packed_queue_entry vmp_listq;
    unsigned int vmp_next_m;
    unsigned int vmp_object;
    unsigned long long vmp_offset;
    unsigned short vmp_wire_count;
    struct {
        unsigned char vmp_q_state : 4; /* bit offset 0 */
        unsigned char vmp_on_specialq : 2; /* bit offset 4 */
        unsigned char vmp_lopage : 1; /* bit offset 6 */
        unsigned char vmp_canonical : 1; /* bit offset 7 */
    };
    struct {
        unsigned char vmp_gobbled : 1; /* bit offset 0 */
        unsigned char vmp_laundry : 1; /* bit offset 1 */
        unsigned char vmp_no_cache : 1; /* bit offset 2 */
        unsigned char vmp_reference : 1; /* bit offset 3 */
        unsigned char vmp_realtime : 1; /* bit offset 4 */
        unsigned char vmp_iopl_wired : 1; /* bit offset 5 */
        unsigned char __vmp_reserved1 : 1; /* bit offset 6 */
        unsigned char __vmp_reserved2 : 1; /* bit offset 7 */
    };
    unsigned int vmp_busy : 1; /* bit offset 352 */
    unsigned int vmp_wanted : 1; /* bit offset 353 */
    unsigned int vmp_tabled : 1; /* bit offset 354 */
    unsigned int vmp_hashed : 1; /* bit offset 355 */
    unsigned int __vmp_unused : 1; /* bit offset 356 */
    unsigned int vmp_clustered : 1; /* bit offset 357 */
    unsigned int vmp_pmapped : 1; /* bit offset 358 */
    unsigned int vmp_xpmapped : 1; /* bit offset 359 */
    unsigned int vmp_wpmapped : 1; /* bit offset 360 */
    unsigned int vmp_free_when_done : 1; /* bit offset 361 */
    unsigned int vmp_absent : 1; /* bit offset 362 */
    unsigned int vmp_error : 1; /* bit offset 363 */
    unsigned int vmp_dirty : 1; /* bit offset 364 */
    unsigned int vmp_cleaning : 1; /* bit offset 365 */
    unsigned int vmp_precious : 1; /* bit offset 366 */
    unsigned int vmp_overwriting : 1; /* bit offset 367 */
    unsigned int vmp_restart : 1; /* bit offset 368 */
    unsigned int vmp_unusual : 1; /* bit offset 369 */
    unsigned int vmp_cs_validated : 4; /* bit offset 370 */
    unsigned int vmp_cs_tainted : 4; /* bit offset 374 */
    unsigned int vmp_cs_nx : 4; /* bit offset 378 */
    unsigned int vmp_reusable : 1; /* bit offset 382 */
    unsigned int vmp_written_by_kernel : 1; /* bit offset 383 */
};
_Static_assert(offsetof(struct ks_vm_page, vmp_specialq) == 0x8, "ks_vm_page.vmp_specialq offset");
_Static_assert(offsetof(struct ks_vm_page, vmp_listq) == 0x10, "ks_vm_page.vmp_listq offset");
_Static_assert(offsetof(struct ks_vm_page, vmp_next_m) == 0x18, "ks_vm_page.vmp_next_m offset");
_Static_assert(offsetof(struct ks_vm_page, vmp_object) == 0x1C, "ks_vm_page.vmp_object offset");
_Static_assert(offsetof(struct ks_vm_page, vmp_offset) == 0x20, "ks_vm_page.vmp_offset offset");
_Static_assert(offsetof(struct ks_vm_page, vmp_wire_count) == 0x28, "ks_vm_page.vmp_wire_count offset");
_Static_assert(sizeof(struct ks_vm_page) == 0x30, "ks_vm_page size");

/* refs: 2 */
struct ks_vm_shared_region {
    unsigned int sr_ref_count;
    unsigned int sr_slide;
    struct ks_queue_entry sr_q;
    void *sr_root_dir;
    int sr_cpu_type;
    int sr_cpu_subtype;
    struct ks_ipc_port *sr_mem_entry;
    struct ks__vm_map *sr_config_map;
    unsigned long long sr_first_mapping;
    unsigned long long sr_base_address;
    unsigned long long sr_size;
    unsigned long long sr_pmap_nesting_start;
    unsigned long long sr_pmap_nesting_size;
    struct ks_thread_call *sr_timer_call;
    unsigned char sr_uuid[0x10];
    unsigned char sr_page_shift;
    struct ks_thread *sr_mapping_in_progress;
    struct ks_thread *sr_slide_in_progress;
    _Bool sr_64bit;
    _Bool sr_persists;
    _Bool sr_uuid_copied;
    _Bool sr_stale;
    _Bool sr_driverkit;
    _Bool sr_reslide;
    unsigned int sr_num_auth_section;
    unsigned int sr_next_auth_section;
    struct ks_vm_shared_region_slide_info **sr_auth_section;
    unsigned int sr_rsr_version;
    unsigned long long sr_install_time;
    unsigned int sr_id;
    unsigned int sr_images_count;
    struct ks_dyld_uuid_info_64 *sr_images;
    unsigned char sr_aot_uuid[0x10];
    int sr_aot_uuid_copied;
    unsigned long long sr_aot_mapping;
};
_Static_assert(offsetof(struct ks_vm_shared_region, sr_ref_count) == 0x0, "ks_vm_shared_region.sr_ref_count offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_slide) == 0x4, "ks_vm_shared_region.sr_slide offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_q) == 0x8, "ks_vm_shared_region.sr_q offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_root_dir) == 0x18, "ks_vm_shared_region.sr_root_dir offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_cpu_type) == 0x20, "ks_vm_shared_region.sr_cpu_type offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_cpu_subtype) == 0x24, "ks_vm_shared_region.sr_cpu_subtype offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_mem_entry) == 0x28, "ks_vm_shared_region.sr_mem_entry offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_config_map) == 0x30, "ks_vm_shared_region.sr_config_map offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_first_mapping) == 0x38, "ks_vm_shared_region.sr_first_mapping offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_base_address) == 0x40, "ks_vm_shared_region.sr_base_address offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_size) == 0x48, "ks_vm_shared_region.sr_size offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_pmap_nesting_start) == 0x50, "ks_vm_shared_region.sr_pmap_nesting_start offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_pmap_nesting_size) == 0x58, "ks_vm_shared_region.sr_pmap_nesting_size offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_timer_call) == 0x60, "ks_vm_shared_region.sr_timer_call offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_uuid) == 0x68, "ks_vm_shared_region.sr_uuid offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_page_shift) == 0x78, "ks_vm_shared_region.sr_page_shift offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_mapping_in_progress) == 0x80, "ks_vm_shared_region.sr_mapping_in_progress offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_slide_in_progress) == 0x88, "ks_vm_shared_region.sr_slide_in_progress offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_64bit) == 0x90, "ks_vm_shared_region.sr_64bit offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_persists) == 0x91, "ks_vm_shared_region.sr_persists offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_uuid_copied) == 0x92, "ks_vm_shared_region.sr_uuid_copied offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_stale) == 0x93, "ks_vm_shared_region.sr_stale offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_driverkit) == 0x94, "ks_vm_shared_region.sr_driverkit offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_reslide) == 0x95, "ks_vm_shared_region.sr_reslide offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_num_auth_section) == 0x98, "ks_vm_shared_region.sr_num_auth_section offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_next_auth_section) == 0x9C, "ks_vm_shared_region.sr_next_auth_section offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_auth_section) == 0xA0, "ks_vm_shared_region.sr_auth_section offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_rsr_version) == 0xA8, "ks_vm_shared_region.sr_rsr_version offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_install_time) == 0xB0, "ks_vm_shared_region.sr_install_time offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_id) == 0xB8, "ks_vm_shared_region.sr_id offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_images_count) == 0xBC, "ks_vm_shared_region.sr_images_count offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_images) == 0xC0, "ks_vm_shared_region.sr_images offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_aot_uuid) == 0xC8, "ks_vm_shared_region.sr_aot_uuid offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_aot_uuid_copied) == 0xD8, "ks_vm_shared_region.sr_aot_uuid_copied offset");
_Static_assert(offsetof(struct ks_vm_shared_region, sr_aot_mapping) == 0xE0, "ks_vm_shared_region.sr_aot_mapping offset");
_Static_assert(sizeof(struct ks_vm_shared_region) == 0xE8, "ks_vm_shared_region size");

/* refs: 2 */
struct ks_vm_shared_region_slide_info {
    unsigned int si_slide;
    _Bool si_slid;
    _Bool si_ptrauth;
    unsigned long long si_jop_key;
    struct ks_vm_shared_region *si_shared_region;
    unsigned long long si_slid_address;
    unsigned long long si_start;
    unsigned long long si_end;
    struct ks_vm_object *si_slide_object;
    unsigned long long si_slide_info_size;
    union ks_vm_shared_region_slide_info_entry *si_slide_info_entry;
};
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info, si_slide) == 0x0, "ks_vm_shared_region_slide_info.si_slide offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info, si_slid) == 0x4, "ks_vm_shared_region_slide_info.si_slid offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info, si_ptrauth) == 0x5, "ks_vm_shared_region_slide_info.si_ptrauth offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info, si_jop_key) == 0x8, "ks_vm_shared_region_slide_info.si_jop_key offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info, si_shared_region) == 0x10, "ks_vm_shared_region_slide_info.si_shared_region offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info, si_slid_address) == 0x18, "ks_vm_shared_region_slide_info.si_slid_address offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info, si_start) == 0x20, "ks_vm_shared_region_slide_info.si_start offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info, si_end) == 0x28, "ks_vm_shared_region_slide_info.si_end offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info, si_slide_object) == 0x30, "ks_vm_shared_region_slide_info.si_slide_object offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info, si_slide_info_size) == 0x38, "ks_vm_shared_region_slide_info.si_slide_info_size offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info, si_slide_info_entry) == 0x40, "ks_vm_shared_region_slide_info.si_slide_info_entry offset");
_Static_assert(sizeof(struct ks_vm_shared_region_slide_info) == 0x48, "ks_vm_shared_region_slide_info size");

/* refs: 1 */
struct ks_vm_shared_region_slide_info_entry_v1 {
    unsigned int version;
    unsigned int toc_offset;
    unsigned int toc_count;
    unsigned int entry_offset;
    unsigned int entry_count;
    unsigned int entries_size;
};
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v1, version) == 0x0, "ks_vm_shared_region_slide_info_entry_v1.version offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v1, toc_offset) == 0x4, "ks_vm_shared_region_slide_info_entry_v1.toc_offset offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v1, toc_count) == 0x8, "ks_vm_shared_region_slide_info_entry_v1.toc_count offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v1, entry_offset) == 0xC, "ks_vm_shared_region_slide_info_entry_v1.entry_offset offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v1, entry_count) == 0x10, "ks_vm_shared_region_slide_info_entry_v1.entry_count offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v1, entries_size) == 0x14, "ks_vm_shared_region_slide_info_entry_v1.entries_size offset");
_Static_assert(sizeof(struct ks_vm_shared_region_slide_info_entry_v1) == 0x18, "ks_vm_shared_region_slide_info_entry_v1 size");

/* refs: 1 */
struct ks_vm_shared_region_slide_info_entry_v2 {
    unsigned int version;
    unsigned int page_size;
    unsigned int page_starts_offset;
    unsigned int page_starts_count;
    unsigned int page_extras_offset;
    unsigned int page_extras_count;
    unsigned long long delta_mask;
    unsigned long long value_add;
};
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v2, version) == 0x0, "ks_vm_shared_region_slide_info_entry_v2.version offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v2, page_size) == 0x4, "ks_vm_shared_region_slide_info_entry_v2.page_size offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v2, page_starts_offset) == 0x8, "ks_vm_shared_region_slide_info_entry_v2.page_starts_offset offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v2, page_starts_count) == 0xC, "ks_vm_shared_region_slide_info_entry_v2.page_starts_count offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v2, page_extras_offset) == 0x10, "ks_vm_shared_region_slide_info_entry_v2.page_extras_offset offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v2, page_extras_count) == 0x14, "ks_vm_shared_region_slide_info_entry_v2.page_extras_count offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v2, delta_mask) == 0x18, "ks_vm_shared_region_slide_info_entry_v2.delta_mask offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v2, value_add) == 0x20, "ks_vm_shared_region_slide_info_entry_v2.value_add offset");
_Static_assert(sizeof(struct ks_vm_shared_region_slide_info_entry_v2) == 0x28, "ks_vm_shared_region_slide_info_entry_v2 size");

/* refs: 1 */
struct ks_vm_shared_region_slide_info_entry_v3 {
    unsigned int version;
    unsigned int page_size;
    unsigned int page_starts_count;
    unsigned long long value_add;
    unsigned short page_starts[];
};
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v3, version) == 0x0, "ks_vm_shared_region_slide_info_entry_v3.version offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v3, page_size) == 0x4, "ks_vm_shared_region_slide_info_entry_v3.page_size offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v3, page_starts_count) == 0x8, "ks_vm_shared_region_slide_info_entry_v3.page_starts_count offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v3, value_add) == 0x10, "ks_vm_shared_region_slide_info_entry_v3.value_add offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v3, page_starts) == 0x18, "ks_vm_shared_region_slide_info_entry_v3.page_starts offset");
_Static_assert(sizeof(struct ks_vm_shared_region_slide_info_entry_v3) == 0x18, "ks_vm_shared_region_slide_info_entry_v3 size");

/* refs: 1 */
struct ks_vm_shared_region_slide_info_entry_v4 {
    unsigned int version;
    unsigned int page_size;
    unsigned int page_starts_offset;
    unsigned int page_starts_count;
    unsigned int page_extras_offset;
    unsigned int page_extras_count;
    unsigned long long delta_mask;
    unsigned long long value_add;
};
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v4, version) == 0x0, "ks_vm_shared_region_slide_info_entry_v4.version offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v4, page_size) == 0x4, "ks_vm_shared_region_slide_info_entry_v4.page_size offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v4, page_starts_offset) == 0x8, "ks_vm_shared_region_slide_info_entry_v4.page_starts_offset offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v4, page_starts_count) == 0xC, "ks_vm_shared_region_slide_info_entry_v4.page_starts_count offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v4, page_extras_offset) == 0x10, "ks_vm_shared_region_slide_info_entry_v4.page_extras_offset offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v4, page_extras_count) == 0x14, "ks_vm_shared_region_slide_info_entry_v4.page_extras_count offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v4, delta_mask) == 0x18, "ks_vm_shared_region_slide_info_entry_v4.delta_mask offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v4, value_add) == 0x20, "ks_vm_shared_region_slide_info_entry_v4.value_add offset");
_Static_assert(sizeof(struct ks_vm_shared_region_slide_info_entry_v4) == 0x28, "ks_vm_shared_region_slide_info_entry_v4 size");

/* refs: 1 */
struct ks_vm_shared_region_slide_info_entry_v5 {
    unsigned int version;
    unsigned int page_size;
    unsigned int page_starts_count;
    unsigned long long value_add;
    unsigned short page_starts[];
};
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v5, version) == 0x0, "ks_vm_shared_region_slide_info_entry_v5.version offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v5, page_size) == 0x4, "ks_vm_shared_region_slide_info_entry_v5.page_size offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v5, page_starts_count) == 0x8, "ks_vm_shared_region_slide_info_entry_v5.page_starts_count offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v5, value_add) == 0x10, "ks_vm_shared_region_slide_info_entry_v5.value_add offset");
_Static_assert(offsetof(struct ks_vm_shared_region_slide_info_entry_v5, page_starts) == 0x18, "ks_vm_shared_region_slide_info_entry_v5.page_starts offset");
_Static_assert(sizeof(struct ks_vm_shared_region_slide_info_entry_v5) == 0x18, "ks_vm_shared_region_slide_info_entry_v5 size");

/* refs: 2 */
struct ks_vmem {
};

/* refs: 34 */
struct ks_vnode {
    struct ks_lck_mtx_s v_lock;
    struct {
        struct ks_vnode *tqe_next;
        struct ks_vnode **tqe_prev;
    } v_freelist;
    struct {
        struct ks_vnode *tqe_next;
        struct ks_vnode **tqe_prev;
    } v_mntvnodes;
    struct {
        struct ks_namecache *tqh_first;
        struct ks_namecache **tqh_last;
    } v_ncchildren;
    struct {
        struct ks_namecache *lh_first;
    } v_nclinks;
    struct ks_vnode *v_defer_reclaimlist;
    unsigned int v_listflag;
    unsigned int v_flag;
    unsigned short v_lflag;
    unsigned char v_iterblkflags;
    unsigned char v_references;
    int v_kusecount;
    int v_usecount;
    int v_iocount;
    void *v_owner;
    unsigned char v_ext_flag;
    unsigned char v_type;
    unsigned short v_tag;
    unsigned int v_id;
    union {
        struct ks_mount *vu_mountedhere;
        struct ks_socket *vu_socket;
        struct ks_specinfo *vu_specinfo;
        struct ks_fifoinfo *vu_fifoinfo;
        struct ks_ubc_info *vu_ubcinfo;
    } v_un;
    struct ks_buflists v_cleanblkhd;
    struct ks_buflists v_dirtyblkhd;
    struct ks_klist v_knotes;
    struct ks_ucred *v_cred;
    int v_authorized_actions;
    int v_cred_timestamp;
    int v_nc_generation;
    int v_numoutput;
    int v_writecount;
    unsigned int v_holdcount;
    const char *v_name;
    struct ks_vnode *v_parent;
    struct ks_lockf *v_lockf;
    int **v_op;
    struct ks_mount *v_mount;
    void *v_data;
    struct ks_label *v_label;
    struct ks_vnode_resolve *v_resolve;
    struct ks_vnode *v_fmlink;
    struct ks_fl_head v_leases;
};
_Static_assert(offsetof(struct ks_vnode, v_lock) == 0x0, "ks_vnode.v_lock offset");
_Static_assert(offsetof(struct ks_vnode, v_freelist) == 0x10, "ks_vnode.v_freelist offset");
_Static_assert(offsetof(struct ks_vnode, v_mntvnodes) == 0x20, "ks_vnode.v_mntvnodes offset");
_Static_assert(offsetof(struct ks_vnode, v_ncchildren) == 0x30, "ks_vnode.v_ncchildren offset");
_Static_assert(offsetof(struct ks_vnode, v_nclinks) == 0x40, "ks_vnode.v_nclinks offset");
_Static_assert(offsetof(struct ks_vnode, v_defer_reclaimlist) == 0x48, "ks_vnode.v_defer_reclaimlist offset");
_Static_assert(offsetof(struct ks_vnode, v_listflag) == 0x50, "ks_vnode.v_listflag offset");
_Static_assert(offsetof(struct ks_vnode, v_flag) == 0x54, "ks_vnode.v_flag offset");
_Static_assert(offsetof(struct ks_vnode, v_lflag) == 0x58, "ks_vnode.v_lflag offset");
_Static_assert(offsetof(struct ks_vnode, v_iterblkflags) == 0x5A, "ks_vnode.v_iterblkflags offset");
_Static_assert(offsetof(struct ks_vnode, v_references) == 0x5B, "ks_vnode.v_references offset");
_Static_assert(offsetof(struct ks_vnode, v_kusecount) == 0x5C, "ks_vnode.v_kusecount offset");
_Static_assert(offsetof(struct ks_vnode, v_usecount) == 0x60, "ks_vnode.v_usecount offset");
_Static_assert(offsetof(struct ks_vnode, v_iocount) == 0x64, "ks_vnode.v_iocount offset");
_Static_assert(offsetof(struct ks_vnode, v_owner) == 0x68, "ks_vnode.v_owner offset");
_Static_assert(offsetof(struct ks_vnode, v_ext_flag) == 0x70, "ks_vnode.v_ext_flag offset");
_Static_assert(offsetof(struct ks_vnode, v_type) == 0x71, "ks_vnode.v_type offset");
_Static_assert(offsetof(struct ks_vnode, v_tag) == 0x72, "ks_vnode.v_tag offset");
_Static_assert(offsetof(struct ks_vnode, v_id) == 0x74, "ks_vnode.v_id offset");
_Static_assert(offsetof(struct ks_vnode, v_un) == 0x78, "ks_vnode.v_un offset");
_Static_assert(offsetof(struct ks_vnode, v_cleanblkhd) == 0x80, "ks_vnode.v_cleanblkhd offset");
_Static_assert(offsetof(struct ks_vnode, v_dirtyblkhd) == 0x88, "ks_vnode.v_dirtyblkhd offset");
_Static_assert(offsetof(struct ks_vnode, v_knotes) == 0x90, "ks_vnode.v_knotes offset");
_Static_assert(offsetof(struct ks_vnode, v_cred) == 0x98, "ks_vnode.v_cred offset");
_Static_assert(offsetof(struct ks_vnode, v_authorized_actions) == 0xA0, "ks_vnode.v_authorized_actions offset");
_Static_assert(offsetof(struct ks_vnode, v_cred_timestamp) == 0xA4, "ks_vnode.v_cred_timestamp offset");
_Static_assert(offsetof(struct ks_vnode, v_nc_generation) == 0xA8, "ks_vnode.v_nc_generation offset");
_Static_assert(offsetof(struct ks_vnode, v_numoutput) == 0xAC, "ks_vnode.v_numoutput offset");
_Static_assert(offsetof(struct ks_vnode, v_writecount) == 0xB0, "ks_vnode.v_writecount offset");
_Static_assert(offsetof(struct ks_vnode, v_holdcount) == 0xB4, "ks_vnode.v_holdcount offset");
_Static_assert(offsetof(struct ks_vnode, v_name) == 0xB8, "ks_vnode.v_name offset");
_Static_assert(offsetof(struct ks_vnode, v_parent) == 0xC0, "ks_vnode.v_parent offset");
_Static_assert(offsetof(struct ks_vnode, v_lockf) == 0xC8, "ks_vnode.v_lockf offset");
_Static_assert(offsetof(struct ks_vnode, v_op) == 0xD0, "ks_vnode.v_op offset");
_Static_assert(offsetof(struct ks_vnode, v_mount) == 0xD8, "ks_vnode.v_mount offset");
_Static_assert(offsetof(struct ks_vnode, v_data) == 0xE0, "ks_vnode.v_data offset");
_Static_assert(offsetof(struct ks_vnode, v_label) == 0xE8, "ks_vnode.v_label offset");
_Static_assert(offsetof(struct ks_vnode, v_resolve) == 0xF0, "ks_vnode.v_resolve offset");
_Static_assert(offsetof(struct ks_vnode, v_fmlink) == 0xF8, "ks_vnode.v_fmlink offset");
_Static_assert(offsetof(struct ks_vnode, v_leases) == 0x100, "ks_vnode.v_leases offset");
_Static_assert(sizeof(struct ks_vnode) == 0x108, "ks_vnode size");

/* refs: 2 */
struct ks_vnode_attr {
    unsigned long long va_supported;
    unsigned long long va_active;
    int va_vaflags;
    int va_rdev;
    unsigned long long va_nlink;
    unsigned long long va_total_size;
    unsigned long long va_total_alloc;
    unsigned long long va_data_size;
    unsigned long long va_data_alloc;
    unsigned int va_iosize;
    unsigned int va_uid;
    unsigned int va_gid;
    unsigned short va_mode;
    unsigned int va_flags;
    struct ks_kauth_acl *va_acl;
    struct ks_timespec va_create_time;
    struct ks_timespec va_access_time;
    struct ks_timespec va_modify_time;
    struct ks_timespec va_change_time;
    struct ks_timespec va_backup_time;
    unsigned long long va_fileid;
    unsigned long long va_linkid;
    unsigned long long va_parentid;
    unsigned int va_fsid;
    unsigned long long va_filerev;
    unsigned int va_gen;
    unsigned int va_encoding;
    unsigned int va_type;
    char *va_name;
    union ks_guid_t va_uuuid;
    union ks_guid_t va_guuid;
    unsigned long long va_nchildren;
    unsigned long long va_dirlinkcount;
    struct ks_kauth_acl *va_base_acl;
    struct ks_timespec va_addedtime;
    unsigned int va_dataprotect_class;
    unsigned int va_dataprotect_flags;
    unsigned int va_document_id;
    unsigned int va_devid;
    unsigned int va_objtype;
    unsigned int va_objtag;
    unsigned int va_user_access;
    unsigned char va_finderinfo[0x20];
    unsigned long long va_rsrc_length;
    unsigned long long va_rsrc_alloc;
    struct ks_fsid va_fsid64;
    unsigned int va_write_gencount;
    unsigned long long va_private_size;
    unsigned long long va_clone_id;
    unsigned long long va_extflags;
    unsigned long long va_recursive_gencount;
    unsigned long long va_attribution_tag;
    unsigned int va_clone_refcnt;
};
_Static_assert(offsetof(struct ks_vnode_attr, va_supported) == 0x0, "ks_vnode_attr.va_supported offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_active) == 0x8, "ks_vnode_attr.va_active offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_vaflags) == 0x10, "ks_vnode_attr.va_vaflags offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_rdev) == 0x14, "ks_vnode_attr.va_rdev offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_nlink) == 0x18, "ks_vnode_attr.va_nlink offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_total_size) == 0x20, "ks_vnode_attr.va_total_size offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_total_alloc) == 0x28, "ks_vnode_attr.va_total_alloc offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_data_size) == 0x30, "ks_vnode_attr.va_data_size offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_data_alloc) == 0x38, "ks_vnode_attr.va_data_alloc offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_iosize) == 0x40, "ks_vnode_attr.va_iosize offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_uid) == 0x44, "ks_vnode_attr.va_uid offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_gid) == 0x48, "ks_vnode_attr.va_gid offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_mode) == 0x4C, "ks_vnode_attr.va_mode offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_flags) == 0x50, "ks_vnode_attr.va_flags offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_acl) == 0x58, "ks_vnode_attr.va_acl offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_create_time) == 0x60, "ks_vnode_attr.va_create_time offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_access_time) == 0x70, "ks_vnode_attr.va_access_time offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_modify_time) == 0x80, "ks_vnode_attr.va_modify_time offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_change_time) == 0x90, "ks_vnode_attr.va_change_time offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_backup_time) == 0xA0, "ks_vnode_attr.va_backup_time offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_fileid) == 0xB0, "ks_vnode_attr.va_fileid offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_linkid) == 0xB8, "ks_vnode_attr.va_linkid offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_parentid) == 0xC0, "ks_vnode_attr.va_parentid offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_fsid) == 0xC8, "ks_vnode_attr.va_fsid offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_filerev) == 0xD0, "ks_vnode_attr.va_filerev offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_gen) == 0xD8, "ks_vnode_attr.va_gen offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_encoding) == 0xDC, "ks_vnode_attr.va_encoding offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_type) == 0xE0, "ks_vnode_attr.va_type offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_name) == 0xE8, "ks_vnode_attr.va_name offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_uuuid) == 0xF0, "ks_vnode_attr.va_uuuid offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_guuid) == 0x100, "ks_vnode_attr.va_guuid offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_nchildren) == 0x110, "ks_vnode_attr.va_nchildren offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_dirlinkcount) == 0x118, "ks_vnode_attr.va_dirlinkcount offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_base_acl) == 0x120, "ks_vnode_attr.va_base_acl offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_addedtime) == 0x128, "ks_vnode_attr.va_addedtime offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_dataprotect_class) == 0x138, "ks_vnode_attr.va_dataprotect_class offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_dataprotect_flags) == 0x13C, "ks_vnode_attr.va_dataprotect_flags offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_document_id) == 0x140, "ks_vnode_attr.va_document_id offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_devid) == 0x144, "ks_vnode_attr.va_devid offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_objtype) == 0x148, "ks_vnode_attr.va_objtype offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_objtag) == 0x14C, "ks_vnode_attr.va_objtag offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_user_access) == 0x150, "ks_vnode_attr.va_user_access offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_finderinfo) == 0x154, "ks_vnode_attr.va_finderinfo offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_rsrc_length) == 0x178, "ks_vnode_attr.va_rsrc_length offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_rsrc_alloc) == 0x180, "ks_vnode_attr.va_rsrc_alloc offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_fsid64) == 0x188, "ks_vnode_attr.va_fsid64 offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_write_gencount) == 0x190, "ks_vnode_attr.va_write_gencount offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_private_size) == 0x198, "ks_vnode_attr.va_private_size offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_clone_id) == 0x1A0, "ks_vnode_attr.va_clone_id offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_extflags) == 0x1A8, "ks_vnode_attr.va_extflags offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_recursive_gencount) == 0x1B0, "ks_vnode_attr.va_recursive_gencount offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_attribution_tag) == 0x1B8, "ks_vnode_attr.va_attribution_tag offset");
_Static_assert(offsetof(struct ks_vnode_attr, va_clone_refcnt) == 0x1C0, "ks_vnode_attr.va_clone_refcnt offset");
_Static_assert(sizeof(struct ks_vnode_attr) == 0x1C8, "ks_vnode_attr size");

/* refs: 2 */
struct ks_vnode_resolve {
    struct ks_lck_mtx_s vr_lock;
    unsigned long long *vr_resolve_func;
    unsigned long long *vr_unresolve_func;
    unsigned long long *vr_rearm_func;
    void *vr_reclaim_func;
    void *vr_data;
    unsigned int vr_flags;
    unsigned int vr_lastseq;
};
_Static_assert(offsetof(struct ks_vnode_resolve, vr_lock) == 0x0, "ks_vnode_resolve.vr_lock offset");
_Static_assert(offsetof(struct ks_vnode_resolve, vr_resolve_func) == 0x10, "ks_vnode_resolve.vr_resolve_func offset");
_Static_assert(offsetof(struct ks_vnode_resolve, vr_unresolve_func) == 0x18, "ks_vnode_resolve.vr_unresolve_func offset");
_Static_assert(offsetof(struct ks_vnode_resolve, vr_rearm_func) == 0x20, "ks_vnode_resolve.vr_rearm_func offset");
_Static_assert(offsetof(struct ks_vnode_resolve, vr_reclaim_func) == 0x28, "ks_vnode_resolve.vr_reclaim_func offset");
_Static_assert(offsetof(struct ks_vnode_resolve, vr_data) == 0x30, "ks_vnode_resolve.vr_data offset");
_Static_assert(offsetof(struct ks_vnode_resolve, vr_flags) == 0x38, "ks_vnode_resolve.vr_flags offset");
_Static_assert(offsetof(struct ks_vnode_resolve, vr_lastseq) == 0x3C, "ks_vnode_resolve.vr_lastseq offset");
_Static_assert(sizeof(struct ks_vnode_resolve) == 0x40, "ks_vnode_resolve size");

/* refs: 1 */
struct ks_wait4_nocancel_args {
    char pid_l_[0];
    int pid;
    char pid_r_[4];
    char status_l_[0];
    unsigned long long status;
    char status_r_[0];
    char options_l_[0];
    int options;
    char options_r_[4];
    char rusage_l_[0];
    unsigned long long rusage;
    char rusage_r_[0];
};
_Static_assert(offsetof(struct ks_wait4_nocancel_args, pid_l_) == 0x0, "ks_wait4_nocancel_args.pid_l_ offset");
_Static_assert(offsetof(struct ks_wait4_nocancel_args, pid) == 0x0, "ks_wait4_nocancel_args.pid offset");
_Static_assert(offsetof(struct ks_wait4_nocancel_args, pid_r_) == 0x4, "ks_wait4_nocancel_args.pid_r_ offset");
_Static_assert(offsetof(struct ks_wait4_nocancel_args, status_l_) == 0x8, "ks_wait4_nocancel_args.status_l_ offset");
_Static_assert(offsetof(struct ks_wait4_nocancel_args, status) == 0x8, "ks_wait4_nocancel_args.status offset");
_Static_assert(offsetof(struct ks_wait4_nocancel_args, status_r_) == 0x10, "ks_wait4_nocancel_args.status_r_ offset");
_Static_assert(offsetof(struct ks_wait4_nocancel_args, options_l_) == 0x10, "ks_wait4_nocancel_args.options_l_ offset");
_Static_assert(offsetof(struct ks_wait4_nocancel_args, options) == 0x10, "ks_wait4_nocancel_args.options offset");
_Static_assert(offsetof(struct ks_wait4_nocancel_args, options_r_) == 0x14, "ks_wait4_nocancel_args.options_r_ offset");
_Static_assert(offsetof(struct ks_wait4_nocancel_args, rusage_l_) == 0x18, "ks_wait4_nocancel_args.rusage_l_ offset");
_Static_assert(offsetof(struct ks_wait4_nocancel_args, rusage) == 0x18, "ks_wait4_nocancel_args.rusage offset");
_Static_assert(offsetof(struct ks_wait4_nocancel_args, rusage_r_) == 0x20, "ks_wait4_nocancel_args.rusage_r_ offset");
_Static_assert(sizeof(struct ks_wait4_nocancel_args) == 0x20, "ks_wait4_nocancel_args size");

/* refs: 1 */
struct ks_waitid_nocancel_args {
    char idtype_l_[0];
    unsigned int idtype;
    char idtype_r_[4];
    char id_l_[0];
    unsigned int id;
    char id_r_[4];
    char infop_l_[0];
    unsigned long long infop;
    char infop_r_[0];
    char options_l_[0];
    int options;
    char options_r_[4];
};
_Static_assert(offsetof(struct ks_waitid_nocancel_args, idtype_l_) == 0x0, "ks_waitid_nocancel_args.idtype_l_ offset");
_Static_assert(offsetof(struct ks_waitid_nocancel_args, idtype) == 0x0, "ks_waitid_nocancel_args.idtype offset");
_Static_assert(offsetof(struct ks_waitid_nocancel_args, idtype_r_) == 0x4, "ks_waitid_nocancel_args.idtype_r_ offset");
_Static_assert(offsetof(struct ks_waitid_nocancel_args, id_l_) == 0x8, "ks_waitid_nocancel_args.id_l_ offset");
_Static_assert(offsetof(struct ks_waitid_nocancel_args, id) == 0x8, "ks_waitid_nocancel_args.id offset");
_Static_assert(offsetof(struct ks_waitid_nocancel_args, id_r_) == 0xC, "ks_waitid_nocancel_args.id_r_ offset");
_Static_assert(offsetof(struct ks_waitid_nocancel_args, infop_l_) == 0x10, "ks_waitid_nocancel_args.infop_l_ offset");
_Static_assert(offsetof(struct ks_waitid_nocancel_args, infop) == 0x10, "ks_waitid_nocancel_args.infop offset");
_Static_assert(offsetof(struct ks_waitid_nocancel_args, infop_r_) == 0x18, "ks_waitid_nocancel_args.infop_r_ offset");
_Static_assert(offsetof(struct ks_waitid_nocancel_args, options_l_) == 0x18, "ks_waitid_nocancel_args.options_l_ offset");
_Static_assert(offsetof(struct ks_waitid_nocancel_args, options) == 0x18, "ks_waitid_nocancel_args.options offset");
_Static_assert(offsetof(struct ks_waitid_nocancel_args, options_r_) == 0x1C, "ks_waitid_nocancel_args.options_r_ offset");
_Static_assert(sizeof(struct ks_waitid_nocancel_args) == 0x20, "ks_waitid_nocancel_args size");

/* refs: 1 */
struct ks_work_interval_deferred_finish_state {
    unsigned long long instance_id;
    unsigned long long start;
    unsigned long long deadline;
    unsigned long long complexity;
};
_Static_assert(offsetof(struct ks_work_interval_deferred_finish_state, instance_id) == 0x0, "ks_work_interval_deferred_finish_state.instance_id offset");
_Static_assert(offsetof(struct ks_work_interval_deferred_finish_state, start) == 0x8, "ks_work_interval_deferred_finish_state.start offset");
_Static_assert(offsetof(struct ks_work_interval_deferred_finish_state, deadline) == 0x10, "ks_work_interval_deferred_finish_state.deadline offset");
_Static_assert(offsetof(struct ks_work_interval_deferred_finish_state, complexity) == 0x18, "ks_work_interval_deferred_finish_state.complexity offset");
_Static_assert(sizeof(struct ks_work_interval_deferred_finish_state) == 0x20, "ks_work_interval_deferred_finish_state size");

/* refs: 1 */
struct ks_work_interval_auto_join_info {
    struct ks_work_interval_deferred_finish_state deferred_finish_state;
    unsigned int status;
};
_Static_assert(offsetof(struct ks_work_interval_auto_join_info, deferred_finish_state) == 0x0, "ks_work_interval_auto_join_info.deferred_finish_state offset");
_Static_assert(offsetof(struct ks_work_interval_auto_join_info, status) == 0x20, "ks_work_interval_auto_join_info.status offset");
_Static_assert(sizeof(struct ks_work_interval_auto_join_info) == 0x28, "ks_work_interval_auto_join_info size");

/* refs: 1 */
struct ks_work_interval_data {
    unsigned int wid_external_wakeups;
    unsigned int wid_total_wakeups;
    unsigned long long wid_user_time_mach;
    unsigned long long wid_system_time_mach;
    unsigned long long wid_cycles;
    unsigned long long wid_instructions;
};
_Static_assert(offsetof(struct ks_work_interval_data, wid_external_wakeups) == 0x0, "ks_work_interval_data.wid_external_wakeups offset");
_Static_assert(offsetof(struct ks_work_interval_data, wid_total_wakeups) == 0x4, "ks_work_interval_data.wid_total_wakeups offset");
_Static_assert(offsetof(struct ks_work_interval_data, wid_user_time_mach) == 0x8, "ks_work_interval_data.wid_user_time_mach offset");
_Static_assert(offsetof(struct ks_work_interval_data, wid_system_time_mach) == 0x10, "ks_work_interval_data.wid_system_time_mach offset");
_Static_assert(offsetof(struct ks_work_interval_data, wid_cycles) == 0x18, "ks_work_interval_data.wid_cycles offset");
_Static_assert(offsetof(struct ks_work_interval_data, wid_instructions) == 0x20, "ks_work_interval_data.wid_instructions offset");
_Static_assert(sizeof(struct ks_work_interval_data) == 0x28, "ks_work_interval_data size");

/* refs: 2 */
struct ks_work_interval {
    unsigned long long wi_id;
    struct ks_os_refcnt wi_ref_count;
    unsigned int wi_create_flags;
    struct ks_ipc_port *wi_port;
    unsigned long long wi_creator_uniqueid;
    unsigned int wi_creator_pid;
    int wi_creator_pidversion;
    unsigned int wi_wlid_flags;
    unsigned int wi_group_flags;
    struct ks_thread_group *wi_group;
    struct ks_work_interval_auto_join_info wi_auto_join_info;
    struct ks_mpsc_queue_chain wi_deallocate_link;
    unsigned char wi_class;
    unsigned char wi_class_offset;
    struct ks_work_interval_data wi_telemetry_data;
    struct ks_recount_work_interval wi_recount;
};
_Static_assert(offsetof(struct ks_work_interval, wi_id) == 0x0, "ks_work_interval.wi_id offset");
_Static_assert(offsetof(struct ks_work_interval, wi_ref_count) == 0x8, "ks_work_interval.wi_ref_count offset");
_Static_assert(offsetof(struct ks_work_interval, wi_create_flags) == 0xC, "ks_work_interval.wi_create_flags offset");
_Static_assert(offsetof(struct ks_work_interval, wi_port) == 0x10, "ks_work_interval.wi_port offset");
_Static_assert(offsetof(struct ks_work_interval, wi_creator_uniqueid) == 0x18, "ks_work_interval.wi_creator_uniqueid offset");
_Static_assert(offsetof(struct ks_work_interval, wi_creator_pid) == 0x20, "ks_work_interval.wi_creator_pid offset");
_Static_assert(offsetof(struct ks_work_interval, wi_creator_pidversion) == 0x24, "ks_work_interval.wi_creator_pidversion offset");
_Static_assert(offsetof(struct ks_work_interval, wi_wlid_flags) == 0x28, "ks_work_interval.wi_wlid_flags offset");
_Static_assert(offsetof(struct ks_work_interval, wi_group_flags) == 0x2C, "ks_work_interval.wi_group_flags offset");
_Static_assert(offsetof(struct ks_work_interval, wi_group) == 0x30, "ks_work_interval.wi_group offset");
_Static_assert(offsetof(struct ks_work_interval, wi_auto_join_info) == 0x38, "ks_work_interval.wi_auto_join_info offset");
_Static_assert(offsetof(struct ks_work_interval, wi_deallocate_link) == 0x60, "ks_work_interval.wi_deallocate_link offset");
_Static_assert(offsetof(struct ks_work_interval, wi_class) == 0x68, "ks_work_interval.wi_class offset");
_Static_assert(offsetof(struct ks_work_interval, wi_class_offset) == 0x69, "ks_work_interval.wi_class_offset offset");
_Static_assert(offsetof(struct ks_work_interval, wi_telemetry_data) == 0x70, "ks_work_interval.wi_telemetry_data offset");
_Static_assert(offsetof(struct ks_work_interval, wi_recount) == 0x98, "ks_work_interval.wi_recount offset");
_Static_assert(sizeof(struct ks_work_interval) == 0xA0, "ks_work_interval size");

/* refs: 2 */
struct ks_workq_aio_uthread_head {
    struct ks_uthread *tqh_first;
    struct ks_uthread **tqh_last;
};
_Static_assert(offsetof(struct ks_workq_aio_uthread_head, tqh_first) == 0x0, "ks_workq_aio_uthread_head.tqh_first offset");
_Static_assert(offsetof(struct ks_workq_aio_uthread_head, tqh_last) == 0x8, "ks_workq_aio_uthread_head.tqh_last offset");
_Static_assert(sizeof(struct ks_workq_aio_uthread_head) == 0x10, "ks_workq_aio_uthread_head size");

/* refs: 1 */
struct ks_workq_aio_s {
    struct ks_thread_call *wa_death_call;
    struct ks_workq_aio_uthread_head wa_thrunlist;
    struct ks_workq_aio_uthread_head wa_thidlelist;
    struct {
        struct ks_aio_workq_entry *tqh_first;
        struct ks_aio_workq_entry **tqh_last;
    } wa_aioq_entries;
    struct ks_proc *wa_proc;
    unsigned int wa_flags;
    unsigned short wa_nthreads;
    unsigned short wa_thidlecount;
    unsigned short wa_thdying_count;
};
_Static_assert(offsetof(struct ks_workq_aio_s, wa_death_call) == 0x0, "ks_workq_aio_s.wa_death_call offset");
_Static_assert(offsetof(struct ks_workq_aio_s, wa_thrunlist) == 0x8, "ks_workq_aio_s.wa_thrunlist offset");
_Static_assert(offsetof(struct ks_workq_aio_s, wa_thidlelist) == 0x18, "ks_workq_aio_s.wa_thidlelist offset");
_Static_assert(offsetof(struct ks_workq_aio_s, wa_aioq_entries) == 0x28, "ks_workq_aio_s.wa_aioq_entries offset");
_Static_assert(offsetof(struct ks_workq_aio_s, wa_proc) == 0x38, "ks_workq_aio_s.wa_proc offset");
_Static_assert(offsetof(struct ks_workq_aio_s, wa_flags) == 0x40, "ks_workq_aio_s.wa_flags offset");
_Static_assert(offsetof(struct ks_workq_aio_s, wa_nthreads) == 0x44, "ks_workq_aio_s.wa_nthreads offset");
_Static_assert(offsetof(struct ks_workq_aio_s, wa_thidlecount) == 0x46, "ks_workq_aio_s.wa_thidlecount offset");
_Static_assert(offsetof(struct ks_workq_aio_s, wa_thdying_count) == 0x48, "ks_workq_aio_s.wa_thdying_count offset");
_Static_assert(sizeof(struct ks_workq_aio_s) == 0x50, "ks_workq_aio_s size");

/* refs: 1 */
struct ks_workq_threadreq_tailq {
    struct ks_workq_threadreq_s *stqh_first;
    struct ks_workq_threadreq_s **stqh_last;
};
_Static_assert(offsetof(struct ks_workq_threadreq_tailq, stqh_first) == 0x0, "ks_workq_threadreq_tailq.stqh_first offset");
_Static_assert(offsetof(struct ks_workq_threadreq_tailq, stqh_last) == 0x8, "ks_workq_threadreq_tailq.stqh_last offset");
_Static_assert(sizeof(struct ks_workq_threadreq_tailq) == 0x10, "ks_workq_threadreq_tailq size");

/* refs: 3 */
struct ks_workq_uthread_head {
    struct ks_uthread *tqh_first;
    struct ks_uthread **tqh_last;
};
_Static_assert(offsetof(struct ks_workq_uthread_head, tqh_first) == 0x0, "ks_workq_uthread_head.tqh_first offset");
_Static_assert(offsetof(struct ks_workq_uthread_head, tqh_last) == 0x8, "ks_workq_uthread_head.tqh_last offset");
_Static_assert(sizeof(struct ks_workq_uthread_head) == 0x10, "ks_workq_uthread_head size");

/* refs: 1 */
struct ks_workqueue {
    struct ks_thread_call *wq_delayed_call;
    struct ks_thread_call *wq_immediate_call;
    struct ks_thread_call *wq_death_call;
    union {
        struct ks_turnstile *wq_turnstile;
        struct ks_mpsc_queue_chain wq_destroy_link;
    };
    struct ks_lck_ticket_s wq_lock;
    unsigned long long wq_thread_call_last_run;
    struct ks_os_refcnt wq_refcnt;
    unsigned int wq_flags;
    unsigned int wq_fulfilled;
    unsigned int wq_creations;
    unsigned int wq_timer_interval;
    unsigned int wq_event_manager_priority;
    unsigned int wq_reqcount;
    unsigned short wq_thdying_count;
    unsigned short wq_threads_scheduled;
    unsigned short wq_constrained_threads_scheduled;
    unsigned short wq_nthreads;
    unsigned short wq_thidlecount;
    unsigned short wq_thscheduled_count[7];
    struct ks_workq_threadreq_s *wq_event_manager_threadreq;
    unsigned __int128 wq_thactive;
    unsigned long long wq_lastblocked_ts[6];
    struct ks_proc *wq_proc;
    struct ks_uthread *wq_creator;
    void *wq_inheritor;
    struct ks_thread *wq_turnstile_updater;
    struct ks_workq_uthread_head wq_thrunlist;
    struct ks_workq_uthread_head wq_thnewlist;
    struct ks_workq_uthread_head wq_thidlelist;
    struct ks_priority_queue_sched_max wq_overcommit_queue;
    struct ks_priority_queue_sched_max wq_constrained_queue;
    struct ks_priority_queue_sched_max wq_special_queue;
    unsigned char wq_cooperative_queue_scheduled_count[6];
    unsigned short wq_cooperative_queue_best_req_qos : 3; /* bit offset 2416 */
    unsigned short wq_cooperative_queue_has_limited_max_size : 1; /* bit offset 2419 */
    unsigned short wq_exceeded_active_constrained_thread_limit : 1; /* bit offset 2420 */
    unsigned short unused : 11; /* bit offset 2421 */
    struct ks_workq_threadreq_tailq wq_cooperative_queue[6];
};
_Static_assert(offsetof(struct ks_workqueue, wq_delayed_call) == 0x0, "ks_workqueue.wq_delayed_call offset");
_Static_assert(offsetof(struct ks_workqueue, wq_immediate_call) == 0x8, "ks_workqueue.wq_immediate_call offset");
_Static_assert(offsetof(struct ks_workqueue, wq_death_call) == 0x10, "ks_workqueue.wq_death_call offset");
_Static_assert(offsetof(struct ks_workqueue, wq_lock) == 0x20, "ks_workqueue.wq_lock offset");
_Static_assert(offsetof(struct ks_workqueue, wq_thread_call_last_run) == 0x30, "ks_workqueue.wq_thread_call_last_run offset");
_Static_assert(offsetof(struct ks_workqueue, wq_refcnt) == 0x38, "ks_workqueue.wq_refcnt offset");
_Static_assert(offsetof(struct ks_workqueue, wq_flags) == 0x3C, "ks_workqueue.wq_flags offset");
_Static_assert(offsetof(struct ks_workqueue, wq_fulfilled) == 0x40, "ks_workqueue.wq_fulfilled offset");
_Static_assert(offsetof(struct ks_workqueue, wq_creations) == 0x44, "ks_workqueue.wq_creations offset");
_Static_assert(offsetof(struct ks_workqueue, wq_timer_interval) == 0x48, "ks_workqueue.wq_timer_interval offset");
_Static_assert(offsetof(struct ks_workqueue, wq_event_manager_priority) == 0x4C, "ks_workqueue.wq_event_manager_priority offset");
_Static_assert(offsetof(struct ks_workqueue, wq_reqcount) == 0x50, "ks_workqueue.wq_reqcount offset");
_Static_assert(offsetof(struct ks_workqueue, wq_thdying_count) == 0x54, "ks_workqueue.wq_thdying_count offset");
_Static_assert(offsetof(struct ks_workqueue, wq_threads_scheduled) == 0x56, "ks_workqueue.wq_threads_scheduled offset");
_Static_assert(offsetof(struct ks_workqueue, wq_constrained_threads_scheduled) == 0x58, "ks_workqueue.wq_constrained_threads_scheduled offset");
_Static_assert(offsetof(struct ks_workqueue, wq_nthreads) == 0x5A, "ks_workqueue.wq_nthreads offset");
_Static_assert(offsetof(struct ks_workqueue, wq_thidlecount) == 0x5C, "ks_workqueue.wq_thidlecount offset");
_Static_assert(offsetof(struct ks_workqueue, wq_thscheduled_count) == 0x5E, "ks_workqueue.wq_thscheduled_count offset");
_Static_assert(offsetof(struct ks_workqueue, wq_event_manager_threadreq) == 0x70, "ks_workqueue.wq_event_manager_threadreq offset");
_Static_assert(offsetof(struct ks_workqueue, wq_thactive) == 0x80, "ks_workqueue.wq_thactive offset");
_Static_assert(offsetof(struct ks_workqueue, wq_lastblocked_ts) == 0x90, "ks_workqueue.wq_lastblocked_ts offset");
_Static_assert(offsetof(struct ks_workqueue, wq_proc) == 0xC0, "ks_workqueue.wq_proc offset");
_Static_assert(offsetof(struct ks_workqueue, wq_creator) == 0xC8, "ks_workqueue.wq_creator offset");
_Static_assert(offsetof(struct ks_workqueue, wq_inheritor) == 0xD0, "ks_workqueue.wq_inheritor offset");
_Static_assert(offsetof(struct ks_workqueue, wq_turnstile_updater) == 0xD8, "ks_workqueue.wq_turnstile_updater offset");
_Static_assert(offsetof(struct ks_workqueue, wq_thrunlist) == 0xE0, "ks_workqueue.wq_thrunlist offset");
_Static_assert(offsetof(struct ks_workqueue, wq_thnewlist) == 0xF0, "ks_workqueue.wq_thnewlist offset");
_Static_assert(offsetof(struct ks_workqueue, wq_thidlelist) == 0x100, "ks_workqueue.wq_thidlelist offset");
_Static_assert(offsetof(struct ks_workqueue, wq_overcommit_queue) == 0x110, "ks_workqueue.wq_overcommit_queue offset");
_Static_assert(offsetof(struct ks_workqueue, wq_constrained_queue) == 0x118, "ks_workqueue.wq_constrained_queue offset");
_Static_assert(offsetof(struct ks_workqueue, wq_special_queue) == 0x120, "ks_workqueue.wq_special_queue offset");
_Static_assert(offsetof(struct ks_workqueue, wq_cooperative_queue_scheduled_count) == 0x128, "ks_workqueue.wq_cooperative_queue_scheduled_count offset");
_Static_assert(offsetof(struct ks_workqueue, wq_cooperative_queue) == 0x130, "ks_workqueue.wq_cooperative_queue offset");
_Static_assert(sizeof(struct ks_workqueue) == 0x190, "ks_workqueue size");

/* refs: 2 */
struct ks_zone_depot {
    unsigned int zd_full;
    unsigned int zd_empty;
    struct ks_zone_magazine *zd_head;
    struct ks_zone_magazine **zd_tail;
};
_Static_assert(offsetof(struct ks_zone_depot, zd_full) == 0x0, "ks_zone_depot.zd_full offset");
_Static_assert(offsetof(struct ks_zone_depot, zd_empty) == 0x4, "ks_zone_depot.zd_empty offset");
_Static_assert(offsetof(struct ks_zone_depot, zd_head) == 0x8, "ks_zone_depot.zd_head offset");
_Static_assert(offsetof(struct ks_zone_depot, zd_tail) == 0x10, "ks_zone_depot.zd_tail offset");
_Static_assert(sizeof(struct ks_zone_depot) == 0x18, "ks_zone_depot size");

/* refs: 5 */
struct ks_zone_packed_virtual_address {
    unsigned int packed_address;
};
_Static_assert(offsetof(struct ks_zone_packed_virtual_address, packed_address) == 0x0, "ks_zone_packed_virtual_address.packed_address offset");
_Static_assert(sizeof(struct ks_zone_packed_virtual_address) == 0x4, "ks_zone_packed_virtual_address size");

/* refs: 5 */
struct ks_zone {
    struct ks_zone *z_self;
    struct ks_zone_stats *z_stats;
    const char *z_name;
    struct ks_zone_view *z_views;
    struct ks_zone_expand *z_expander;
    unsigned long long z_quo_magic;
    unsigned int z_align_magic;
    unsigned short z_elem_size;
    unsigned short z_elem_offs;
    unsigned short z_chunk_pages;
    unsigned short z_chunk_elems;
    unsigned int z_destroyed : 1; /* bit offset 480 */
    unsigned int z_async_refilling : 1; /* bit offset 481 */
    unsigned int z_depot_cleanup : 1; /* bit offset 482 */
    unsigned int z_expanding_wait : 1; /* bit offset 483 */
    unsigned int z_exhausted_wait : 1; /* bit offset 484 */
    unsigned int z_exhausts : 1; /* bit offset 485 */
    unsigned int z_percpu : 1; /* bit offset 486 */
    unsigned int z_smr : 1; /* bit offset 487 */
    unsigned int z_permanent : 1; /* bit offset 488 */
    unsigned int z_nocaching : 1; /* bit offset 489 */
    unsigned int collectable : 1; /* bit offset 490 */
    unsigned int no_callout : 1; /* bit offset 491 */
    unsigned int z_destructible : 1; /* bit offset 492 */
    unsigned int _reserved : 8; /* bit offset 493 */
    unsigned int z_kasan_fakestacks : 1; /* bit offset 501 */
    unsigned int z_kasan_quarantine : 1; /* bit offset 502 */
    unsigned int z_tags_sizeclass : 6; /* bit offset 503 */
    unsigned int z_uses_tags : 1; /* bit offset 509 */
    unsigned int z_log_on : 1; /* bit offset 510 */
    unsigned int z_tbi_tag : 1; /* bit offset 511 */
    unsigned char z_cacheline1[0] __attribute__((aligned(64)));
    struct ks_zone_cache *z_pcpu_cache;
    struct ks_zone_depot z_recirc;
    union ks_hw_lck_ticket_s z_recirc_lock;
    unsigned int z_recirc_full_min;
    unsigned int z_recirc_full_wma;
    unsigned int z_recirc_empty_min;
    unsigned int z_recirc_empty_wma;
    unsigned int z_recirc_cont_cur;
    unsigned int z_recirc_cont_wma;
    unsigned short z_depot_size;
    unsigned short z_depot_limit;
    unsigned char z_cacheline2[0] __attribute__((aligned(64)));
    union ks_hw_lck_ticket_s z_lock;
    unsigned int z_wired_max;
    unsigned int z_wired_hwm;
    unsigned int z_wired_cur;
    unsigned int z_wired_empty;
    unsigned int z_va_cur;
    struct ks_zone_packed_virtual_address z_pageq_empty;
    struct ks_zone_packed_virtual_address z_pageq_partial;
    struct ks_zone_packed_virtual_address z_pageq_full;
    struct ks_zone_packed_virtual_address z_pageq_va;
    unsigned int z_elems_free;
    unsigned int z_elems_avail;
    unsigned int z_elems_rsv;
    unsigned int z_array_size_class;
    struct ks_zone *z_kt_next;
    unsigned char z_cacheline3[0] __attribute__((aligned(64)));
} __attribute__((aligned(64)));
_Static_assert(offsetof(struct ks_zone, z_self) == 0x0, "ks_zone.z_self offset");
_Static_assert(offsetof(struct ks_zone, z_stats) == 0x8, "ks_zone.z_stats offset");
_Static_assert(offsetof(struct ks_zone, z_name) == 0x10, "ks_zone.z_name offset");
_Static_assert(offsetof(struct ks_zone, z_views) == 0x18, "ks_zone.z_views offset");
_Static_assert(offsetof(struct ks_zone, z_expander) == 0x20, "ks_zone.z_expander offset");
_Static_assert(offsetof(struct ks_zone, z_quo_magic) == 0x28, "ks_zone.z_quo_magic offset");
_Static_assert(offsetof(struct ks_zone, z_align_magic) == 0x30, "ks_zone.z_align_magic offset");
_Static_assert(offsetof(struct ks_zone, z_elem_size) == 0x34, "ks_zone.z_elem_size offset");
_Static_assert(offsetof(struct ks_zone, z_elem_offs) == 0x36, "ks_zone.z_elem_offs offset");
_Static_assert(offsetof(struct ks_zone, z_chunk_pages) == 0x38, "ks_zone.z_chunk_pages offset");
_Static_assert(offsetof(struct ks_zone, z_chunk_elems) == 0x3A, "ks_zone.z_chunk_elems offset");
_Static_assert(offsetof(struct ks_zone, z_cacheline1) == 0x40, "ks_zone.z_cacheline1 offset");
_Static_assert(offsetof(struct ks_zone, z_pcpu_cache) == 0x40, "ks_zone.z_pcpu_cache offset");
_Static_assert(offsetof(struct ks_zone, z_recirc) == 0x48, "ks_zone.z_recirc offset");
_Static_assert(offsetof(struct ks_zone, z_recirc_lock) == 0x60, "ks_zone.z_recirc_lock offset");
_Static_assert(offsetof(struct ks_zone, z_recirc_full_min) == 0x64, "ks_zone.z_recirc_full_min offset");
_Static_assert(offsetof(struct ks_zone, z_recirc_full_wma) == 0x68, "ks_zone.z_recirc_full_wma offset");
_Static_assert(offsetof(struct ks_zone, z_recirc_empty_min) == 0x6C, "ks_zone.z_recirc_empty_min offset");
_Static_assert(offsetof(struct ks_zone, z_recirc_empty_wma) == 0x70, "ks_zone.z_recirc_empty_wma offset");
_Static_assert(offsetof(struct ks_zone, z_recirc_cont_cur) == 0x74, "ks_zone.z_recirc_cont_cur offset");
_Static_assert(offsetof(struct ks_zone, z_recirc_cont_wma) == 0x78, "ks_zone.z_recirc_cont_wma offset");
_Static_assert(offsetof(struct ks_zone, z_depot_size) == 0x7C, "ks_zone.z_depot_size offset");
_Static_assert(offsetof(struct ks_zone, z_depot_limit) == 0x7E, "ks_zone.z_depot_limit offset");
_Static_assert(offsetof(struct ks_zone, z_cacheline2) == 0x80, "ks_zone.z_cacheline2 offset");
_Static_assert(offsetof(struct ks_zone, z_lock) == 0x80, "ks_zone.z_lock offset");
_Static_assert(offsetof(struct ks_zone, z_wired_max) == 0x84, "ks_zone.z_wired_max offset");
_Static_assert(offsetof(struct ks_zone, z_wired_hwm) == 0x88, "ks_zone.z_wired_hwm offset");
_Static_assert(offsetof(struct ks_zone, z_wired_cur) == 0x8C, "ks_zone.z_wired_cur offset");
_Static_assert(offsetof(struct ks_zone, z_wired_empty) == 0x90, "ks_zone.z_wired_empty offset");
_Static_assert(offsetof(struct ks_zone, z_va_cur) == 0x94, "ks_zone.z_va_cur offset");
_Static_assert(offsetof(struct ks_zone, z_pageq_empty) == 0x98, "ks_zone.z_pageq_empty offset");
_Static_assert(offsetof(struct ks_zone, z_pageq_partial) == 0x9C, "ks_zone.z_pageq_partial offset");
_Static_assert(offsetof(struct ks_zone, z_pageq_full) == 0xA0, "ks_zone.z_pageq_full offset");
_Static_assert(offsetof(struct ks_zone, z_pageq_va) == 0xA4, "ks_zone.z_pageq_va offset");
_Static_assert(offsetof(struct ks_zone, z_elems_free) == 0xA8, "ks_zone.z_elems_free offset");
_Static_assert(offsetof(struct ks_zone, z_elems_avail) == 0xAC, "ks_zone.z_elems_avail offset");
_Static_assert(offsetof(struct ks_zone, z_elems_rsv) == 0xB0, "ks_zone.z_elems_rsv offset");
_Static_assert(offsetof(struct ks_zone, z_array_size_class) == 0xB4, "ks_zone.z_array_size_class offset");
_Static_assert(offsetof(struct ks_zone, z_kt_next) == 0xB8, "ks_zone.z_kt_next offset");
_Static_assert(offsetof(struct ks_zone, z_cacheline3) == 0xC0, "ks_zone.z_cacheline3 offset");
_Static_assert(sizeof(struct ks_zone) == 0xC0, "ks_zone size");

/* refs: 1 */
struct ks_zone_cache {
    union ks_hw_lck_ticket_s zc_depot_lock;
    unsigned short zc_alloc_cur;
    unsigned short zc_free_cur;
    unsigned long *zc_alloc_elems;
    unsigned long *zc_free_elems;
    struct ks_zone_depot zc_depot;
    struct ks_smr *zc_smr;
    void *zc_free;
} __attribute__((aligned(64)));
_Static_assert(offsetof(struct ks_zone_cache, zc_depot_lock) == 0x0, "ks_zone_cache.zc_depot_lock offset");
_Static_assert(offsetof(struct ks_zone_cache, zc_alloc_cur) == 0x4, "ks_zone_cache.zc_alloc_cur offset");
_Static_assert(offsetof(struct ks_zone_cache, zc_free_cur) == 0x6, "ks_zone_cache.zc_free_cur offset");
_Static_assert(offsetof(struct ks_zone_cache, zc_alloc_elems) == 0x8, "ks_zone_cache.zc_alloc_elems offset");
_Static_assert(offsetof(struct ks_zone_cache, zc_free_elems) == 0x10, "ks_zone_cache.zc_free_elems offset");
_Static_assert(offsetof(struct ks_zone_cache, zc_depot) == 0x18, "ks_zone_cache.zc_depot offset");
_Static_assert(offsetof(struct ks_zone_cache, zc_smr) == 0x30, "ks_zone_cache.zc_smr offset");
_Static_assert(offsetof(struct ks_zone_cache, zc_free) == 0x38, "ks_zone_cache.zc_free offset");
_Static_assert(sizeof(struct ks_zone_cache) == 0x40, "ks_zone_cache size");

/* refs: 1 */
struct ks_zone_expand {
    struct ks_zone_expand *ze_next;
    struct ks_thread *ze_thread;
    _Bool ze_pg_wait;
    _Bool ze_vm_priv;
    _Bool ze_clear_priv;
};
_Static_assert(offsetof(struct ks_zone_expand, ze_next) == 0x0, "ks_zone_expand.ze_next offset");
_Static_assert(offsetof(struct ks_zone_expand, ze_thread) == 0x8, "ks_zone_expand.ze_thread offset");
_Static_assert(offsetof(struct ks_zone_expand, ze_pg_wait) == 0x10, "ks_zone_expand.ze_pg_wait offset");
_Static_assert(offsetof(struct ks_zone_expand, ze_vm_priv) == 0x11, "ks_zone_expand.ze_vm_priv offset");
_Static_assert(offsetof(struct ks_zone_expand, ze_clear_priv) == 0x12, "ks_zone_expand.ze_clear_priv offset");
_Static_assert(sizeof(struct ks_zone_expand) == 0x18, "ks_zone_expand size");

/* refs: 3 */
struct ks_zone_magazine {
    struct ks_zone_magazine *zm_next;
    unsigned long zm_seq;
    unsigned long zm_elems[0];
};
_Static_assert(offsetof(struct ks_zone_magazine, zm_next) == 0x0, "ks_zone_magazine.zm_next offset");
_Static_assert(offsetof(struct ks_zone_magazine, zm_seq) == 0x8, "ks_zone_magazine.zm_seq offset");
_Static_assert(offsetof(struct ks_zone_magazine, zm_elems) == 0x10, "ks_zone_magazine.zm_elems offset");
_Static_assert(sizeof(struct ks_zone_magazine) == 0x10, "ks_zone_magazine size");

/* refs: 3 */
struct ks_zone_stats {
    unsigned long long zs_mem_allocated;
    unsigned long long zs_mem_freed;
    unsigned long long zs_alloc_fail;
    unsigned int zs_alloc_rr;
    unsigned int zs_alloc_not_early;
};
_Static_assert(offsetof(struct ks_zone_stats, zs_mem_allocated) == 0x0, "ks_zone_stats.zs_mem_allocated offset");
_Static_assert(offsetof(struct ks_zone_stats, zs_mem_freed) == 0x8, "ks_zone_stats.zs_mem_freed offset");
_Static_assert(offsetof(struct ks_zone_stats, zs_alloc_fail) == 0x10, "ks_zone_stats.zs_alloc_fail offset");
_Static_assert(offsetof(struct ks_zone_stats, zs_alloc_rr) == 0x18, "ks_zone_stats.zs_alloc_rr offset");
_Static_assert(offsetof(struct ks_zone_stats, zs_alloc_not_early) == 0x1C, "ks_zone_stats.zs_alloc_not_early offset");
_Static_assert(sizeof(struct ks_zone_stats) == 0x20, "ks_zone_stats size");

/* refs: 2 */
struct ks_zone_view {
    struct ks_zone *zv_zone;
    struct ks_zone_stats *zv_stats;
    const char *zv_name;
    struct ks_zone_view *zv_next;
};
_Static_assert(offsetof(struct ks_zone_view, zv_zone) == 0x0, "ks_zone_view.zv_zone offset");
_Static_assert(offsetof(struct ks_zone_view, zv_stats) == 0x8, "ks_zone_view.zv_stats offset");
_Static_assert(offsetof(struct ks_zone_view, zv_name) == 0x10, "ks_zone_view.zv_name offset");
_Static_assert(offsetof(struct ks_zone_view, zv_next) == 0x18, "ks_zone_view.zv_next offset");
_Static_assert(sizeof(struct ks_zone_view) == 0x20, "ks_zone_view size");

/* refs: 2 */
union ks_vm_shared_region_slide_info_entry {
    struct {
        unsigned int version;
        unsigned int page_size;
    };
    struct ks_vm_shared_region_slide_info_entry_v1 v1;
    struct ks_vm_shared_region_slide_info_entry_v2 v2;
    struct ks_vm_shared_region_slide_info_entry_v3 v3;
    struct ks_vm_shared_region_slide_info_entry_v4 v4;
    struct ks_vm_shared_region_slide_info_entry_v5 v5;
};
_Static_assert(offsetof(union ks_vm_shared_region_slide_info_entry, v1) == 0x0, "ks_vm_shared_region_slide_info_entry.v1 offset");
_Static_assert(offsetof(union ks_vm_shared_region_slide_info_entry, v2) == 0x0, "ks_vm_shared_region_slide_info_entry.v2 offset");
_Static_assert(offsetof(union ks_vm_shared_region_slide_info_entry, v3) == 0x0, "ks_vm_shared_region_slide_info_entry.v3 offset");
_Static_assert(offsetof(union ks_vm_shared_region_slide_info_entry, v4) == 0x0, "ks_vm_shared_region_slide_info_entry.v4 offset");
_Static_assert(offsetof(union ks_vm_shared_region_slide_info_entry, v5) == 0x0, "ks_vm_shared_region_slide_info_entry.v5 offset");

typedef unsigned char ks_Byte;
typedef unsigned char ks_Bytef;
typedef struct ks_CEAccelerationElement ks_CEAccelerationElement_t;
typedef struct ks__CEContextInfo ks_CEContextInfo_t;
typedef unsigned char ks_CEContextType_t;
typedef struct ks__CEContext ks_CEContext_t;
typedef unsigned int ks_CEFormatVersion_t;
typedef void *ks_CERuntimeAbort;
typedef void **ks_CERuntimeAllocIndex;
typedef void *ks_CERuntimeFree;
typedef void *ks_CERuntimeFreeIndex;
typedef _Bool *ks_CERuntimeInternalStatus;
typedef void *ks_CERuntimeLog;
typedef void **ks_CERuntimeMalloc;
typedef const struct ks_CERuntime *ks_CERuntime_t;
typedef unsigned int ks_CMSDigestType_t;
typedef unsigned long long ks_CMSPolicyFlags_t;
typedef struct ks__CMSValidation ks_CMSValidation_t;
typedef struct ks__CSBuffer ks_CSBuffer_t;
typedef struct ks__CSCodeDirectorySafe ks_CSCodeDirectorySafe_t;
typedef struct ks__CSCodeDirectory ks_CSCodeDirectory_t;
typedef struct ks__CSConfigCallerSignature ks_CSConfigCallerSignature_t;
typedef struct ks__CSConfigCompilationService ks_CSConfigCompilationService_t;
typedef struct ks__CSConfigEnvironmentState ks_CSConfigEnvironmentState_t;
typedef struct ks__CSConfigFeatureSet ks_CSConfigFeatureSet_t;
typedef struct ks__CSConfigLocalSigning ks_CSConfigLocalSigning_t;
typedef struct ks__CSConfigOSPolicy ks_CSConfigOSPolicy_t;
typedef struct ks__CSConfigProvisioningProfiles ks_CSConfigProvisioningProfiles_t;
typedef struct ks__CSConfigTrustCaches ks_CSConfigTrustCaches_t;
typedef struct ks__CSConfig ks_CSConfig_t;
typedef struct ks__CSMutableBuffer ks_CSMutableBuffer_t;
typedef struct ks__CSProfileProperties ks_CSProfileProperties_t;
typedef unsigned char ks_CSRestrictedModePerms_t;
typedef struct ks__CSSuperBlobIndex ks_CSSuperBlobIndex_t;
typedef struct ks__CSSuperBlobSafe ks_CSSuperBlobSafe_t;
typedef struct ks__CSSuperBlob ks_CSSuperBlob_t;
typedef unsigned char ks_CSTrust_t;
typedef struct ks___CodeDirectory ks_CS_CodeDirectory;
typedef struct ks___SC_GenericBlob ks_CS_GenericBlob;
typedef unsigned int ks_CT_uint32_t;
typedef unsigned long long ks_CT_uint64_t;
typedef unsigned int ks_CoreTrustDigestType;
typedef unsigned long long ks_CoreTrustPolicyFlags;
typedef struct ks__CEContext ks_EntitlementsContext_t;
typedef struct ks_CERuntime ks_EntitlementsRuntime_t;
typedef struct ks_IOSKMemoryBufferSpec ks_IOSKMemoryBufferSpec;
typedef struct ks_IOSKRegionSpec ks_IOSKRegionSpec;
typedef struct ks__CEContext ks_ProfileContext_t;
typedef struct ks__ProfileValidation ks_ProfileValidation_t;
typedef struct ks__SignatureValidation ks_SignatureValidation_t;
typedef struct ks__TCReturn ks_TCReturn_t;
typedef unsigned long long ks_TXMAddressSpaceFlags_t;
typedef unsigned short ks_TXMAddressSpaceIDType_t;
typedef struct ks__TXMAddressSpaceID ks_TXMAddressSpaceID_t;
typedef unsigned short ks_TXMAddressSpaceIdentifier_t;
typedef struct ks__TXMAddressSpace ks_TXMAddressSpace_t;
typedef struct ks__TXMCodeRegionRBTree ks_TXMCodeRegionRBTree_t;
typedef struct ks__TXMCodeRegion ks_TXMCodeRegion_t;
typedef struct ks__TXMCodeSignature ks_TXMCodeSignature_t;
typedef unsigned int ks_TXMReferenceCount_t;
typedef struct ks__TXMSlabObject ks_TXMSlabObject_t;
typedef struct ks__TXMTaggedPointer ks_TXMTaggedPointer_t;
typedef unsigned __int128 ks_TXMWidePointer_t;
typedef unsigned char ks_TryLock_t;
typedef unsigned int ks__4state_markov_packet_loss_state;
typedef unsigned char ks__TXMCodeRegion_properties_type;
typedef unsigned char ks__TryLock;
typedef struct ks___kern_channel_ring *ks___bounds_safety__counted_by__0;
typedef struct ks_soflow_hash_head *ks___bounds_safety__counted_by__16;
typedef unsigned char *ks___bounds_safety__counted_by__app_data_length;
typedef struct ks_bpf_insn *ks___bounds_safety__counted_by__bd_filter_len;
typedef unsigned char *ks___bounds_safety__counted_by__bytes_count;
typedef struct ks___slot_desc *ks___bounds_safety__counted_by__ckr_ksds_cnt;
typedef unsigned long long *ks___bounds_safety__counted_by__ckr_scratch_cnt;
typedef struct ks_slot_ctx *ks___bounds_safety__counted_by__ckr_slot_ctxs_cnt;
typedef struct ks_mbuf **ks___bounds_safety__counted_by__ckr_tx_pool_count;
typedef struct ks___slot_desc *ks___bounds_safety__counted_by__ckr_usds_cnt;
typedef struct ks_heap_elem ks___bounds_safety__counted_by__limit[];
typedef struct ks___kern_channel_ring *ks___bounds_safety__counted_by__na_all_rings_cnt;
typedef struct ks___kern_channel_ring *ks___bounds_safety__counted_by__na_alloc_free_rings_cnt;
typedef struct ks___kern_channel_ring *ks___bounds_safety__counted_by__na_event_rings_cnt;
typedef struct ks___kern_channel_ring *ks___bounds_safety__counted_by__na_large_buf_alloc_rings_cnt;
typedef struct ks_nexus_upipe_adapter **ks___bounds_safety__counted_by__na_max_pipes;
typedef struct ks___kern_channel_ring *ks___bounds_safety__counted_by__na_rx_rings_cnt;
typedef unsigned long long *ks___bounds_safety__counted_by__na_scratch_cnt;
typedef struct ks_slot_ctx *ks___bounds_safety__counted_by__na_slot_ctxs_cnt;
typedef struct ks___kern_channel_ring *ks___bounds_safety__counted_by__na_tx_rings_cnt;
typedef struct ks_nx_netif_mit *ks___bounds_safety__counted_by__nifna_rx_mit_count;
typedef struct ks_nx_netif_mit *ks___bounds_safety__counted_by__nifna_tx_mit_count;
typedef struct ks_kern_nexus_netif_llink_qset_init *ks___bounds_safety__counted_by__nli_num_qsets;
typedef struct ks_flow_divert_trie_node *ks___bounds_safety__counted_by__nodes_count;
typedef struct ks_nx_port_info *ks___bounds_safety__counted_by__nx_num_ports;
typedef struct ks_kern_pbufpool_u_bft_bkt *ks___bounds_safety__counted_by__pp_u_bft_hash_table_size;
typedef struct ks_kern_pbufpool_u_bkt *ks___bounds_safety__counted_by__pp_u_hash_table_size;
typedef struct ks_skmem_cpu_cache ks___bounds_safety__counted_by__skm_cpu_cache_count[];
typedef struct ks_skmem_bufctl_bkt *ks___bounds_safety__counted_by__skm_hash_size;
typedef struct ks_sksegment_bkt *ks___bounds_safety__counted_by__skr_hash_size;
typedef unsigned char *ks___bounds_safety__counted_by__token_key_size;
typedef void *ks___bounds_safety__sized_by__bc_lim;
typedef unsigned short *ks___bounds_safety__sized_by__child_maps_size;
typedef void *ks___bounds_safety__sized_by__memory_size;
typedef unsigned long long *ks___bounds_safety__sized_by__nx_ports_bmap_size;
typedef void *ks___bounds_safety__sized_by__nxb_key_len;
typedef void *ks___bounds_safety__sized_by__nxv_adv_size;
typedef unsigned long long *ks___bounds_safety__sized_by__skr_seg_bmap_size;
typedef int ks___darwin_dev_t;
typedef unsigned int ks___darwin_gid_t;
typedef unsigned int ks___darwin_id_t;
typedef unsigned short ks___darwin_mode_t;
typedef unsigned int ks___darwin_natural_t;
typedef long long ks___darwin_off_t;
typedef int ks___darwin_pid_t;
typedef unsigned int ks___darwin_sigset_t;
typedef int ks___darwin_suseconds_t;
typedef long ks___darwin_time_t;
typedef unsigned int ks___darwin_uid_t;
typedef unsigned char ks___darwin_uuid_t[0x10];
typedef int ks___int32_t;
typedef long long ks___int64_t;
typedef struct ks___smrq_link_t ks___smrq_link_t;
typedef struct ks___smrq_slink_t ks___smrq_slink_t;
typedef unsigned __int128 ks___uint128_t;
typedef unsigned short ks___uint16_t;
typedef unsigned int ks___uint32_t;
typedef unsigned long long ks___uint64_t;
typedef unsigned char ks___uint8_t;
typedef struct ks_aes_encrypt_ctx ks_aes_encrypt_ctx;
typedef struct ks_affinity_set *ks_affinity_set_t;
typedef unsigned int ks_aio_entry_flags_t;
typedef void **ks_alloc_func;
typedef struct ks_arm64_uexc_region_t ks_arm64_uexc_region_t;
typedef struct ks_arm_amx_saved_state ks_arm_amx_saved_state_t;
typedef struct ks_arm_context ks_arm_context_t;
typedef struct ks_arm_debug_aggregate_state ks_arm_debug_state_t;
typedef struct ks_arm_neon_saved_state ks_arm_neon_saved_state_t;
typedef struct ks_arm_saved_state ks_arm_saved_state_t;
typedef struct ks_arm_state_hdr ks_arm_state_hdr_t;
typedef unsigned int ks_ast_t;
typedef _Atomic _Bool ks_atomic_bool;
typedef unsigned long long ks_au_asflgs_t;
typedef int ks_au_asid_t;
typedef unsigned int ks_au_class_t;
typedef unsigned char ks_au_ctlmode_t;
typedef struct ks_au_evclass_map ks_au_evclass_map_t;
typedef unsigned short ks_au_event_t;
typedef struct ks_au_expire_after ks_au_expire_after_t;
typedef struct ks_audit_fstat ks_au_fstat_t;
typedef unsigned int ks_au_id_t;
typedef struct ks_au_mask ks_au_mask_t;
typedef struct ks_au_qctrl64 ks_au_qctrl64_t;
typedef struct ks_au_qctrl ks_au_qctrl_t;
typedef struct ks_audit_stat ks_au_stat_t;
typedef struct ks_au_tid_addr ks_au_tid_addr_t;
typedef struct ks_au_tid ks_au_tid_t;
typedef struct ks_audit_token_t ks_audit_token_t;
typedef struct ks_auditinfo_addr ks_auditinfo_addr_t;
typedef struct ks_auditinfo ks_auditinfo_t;
typedef struct ks_auditpinfo_addr ks_auditpinfo_addr_t;
typedef struct ks_auditpinfo ks_auditpinfo_t;
typedef unsigned long long ks_bitmap_t;
typedef unsigned char ks_block_hint_t;
typedef int ks_boolean_t;
typedef unsigned int ks_bpf_u_int32;
typedef unsigned int ks_btref_t;
typedef struct ks_buf *ks_buf_t;
typedef char *ks_caddr_t;
typedef struct ks___bounds_safety__wide_ptr_bidi_indexable_4 ks_caddr_t___bidi_indexable;
typedef unsigned int ks_cc_impl;
typedef unsigned int ks_cc_impl_t;
typedef unsigned char ks_cc_t;
typedef struct ks_cccbc_ctx ks_cccbc_ctx;
typedef struct ks_ccder_read_blob ks_ccder_read_blob;
typedef unsigned long ks_ccder_tag;
typedef unsigned char ks_cfil_crypto_key[0x20];
typedef unsigned int ks_ch_endpoint_t;
typedef struct ks_channel_ring_error_stats ks_channel_ring_error_stats;
typedef struct ks_channel_ring_stats ks_channel_ring_stats;
typedef struct ks_channel_ring_user_stats ks_channel_ring_user_stats;
typedef struct ks_circle_queue_head ks_circle_queue_head_t;
typedef struct ks__class_queue_ ks_class_queue_t;
typedef struct ks_classq_pkt ks_classq_pkt_t;
typedef unsigned int ks_classq_pkt_type;
typedef unsigned int ks_classq_pkt_type_t;
typedef unsigned int ks_classq_state;
typedef unsigned int ks_classq_state_t;
typedef unsigned int ks_classq_type;
typedef unsigned int ks_classq_type_t;
typedef unsigned long ks_clock_sec_t;
typedef int ks_cluster_type_t;
typedef unsigned long long ks_clutch_cpu_data_t;
typedef unsigned __int128 ks_clutch_cpu_data_wide_t;
typedef struct ks_coalition *ks_coalition_t;
typedef char ks_command_t[0x11];
typedef unsigned long long *ks_counter_t;
typedef int ks_cpu_subtype_t;
typedef int ks_cpu_type_t;
typedef unsigned long long ks_cpumap_t;
typedef unsigned int ks_cpx_flags_t;
typedef struct ks_ucred ks_cred_t;
typedef void *ks_cs_md_final;
typedef void *ks_cs_md_init;
typedef void *ks_cs_md_update;
typedef unsigned long ks_cyclic_id_t;
typedef long long ks_daddr64_t;
typedef int ks_daddr_t;
typedef unsigned char ks_darwin_gpu_role_t;
typedef struct ks_der_vm_context ks_der_vm_context_t;
typedef int ks_dev_t;
typedef unsigned int ks_dif_instr_t;
typedef int *ks_dlil_input_func;
typedef int *ks_dlil_output_func;
typedef struct ks_dof_helper ks_dof_helper_t;
typedef struct ks_dtrace_action ks_dtrace_action_t;
typedef unsigned int ks_dtrace_activity;
typedef unsigned int ks_dtrace_activity_t;
typedef unsigned short ks_dtrace_actkind_t;
typedef unsigned int ks_dtrace_aggid_t;
typedef struct ks_dtrace_aggregation ks_dtrace_aggregation_t;
typedef struct ks_dtrace_attribute ks_dtrace_attribute_t;
typedef struct ks_dtrace_buffer ks_dtrace_buffer_t;
typedef unsigned int ks_dtrace_cacheid_t;
typedef unsigned char ks_dtrace_class_t;
typedef struct ks_dtrace_cred ks_dtrace_cred_t;
typedef struct ks_dtrace_difo ks_dtrace_difo_t;
typedef struct ks_dtrace_diftype ks_dtrace_diftype_t;
typedef struct ks_dtrace_difv ks_dtrace_difv_t;
typedef struct ks_dtrace_dstate_percpu ks_dtrace_dstate_percpu_t;
typedef unsigned int ks_dtrace_dstate_state;
typedef unsigned int ks_dtrace_dstate_state_t;
typedef struct ks_dtrace_dstate ks_dtrace_dstate_t;
typedef struct ks_dtrace_dynhash ks_dtrace_dynhash_t;
typedef struct ks_dtrace_dynvar ks_dtrace_dynvar_t;
typedef struct ks_dtrace_ecb ks_dtrace_ecb_t;
typedef unsigned int ks_dtrace_epid_t;
typedef struct ks_dtrace_format ks_dtrace_format_t;
typedef unsigned long long ks_dtrace_genid_t;
typedef struct ks_dtrace_helper_action ks_dtrace_helper_action_t;
typedef struct ks_dtrace_helper_provider ks_dtrace_helper_provider_t;
typedef unsigned int ks_dtrace_id_t;
typedef struct ks_dtrace_key ks_dtrace_key_t;
typedef long long ks_dtrace_optval_t;
typedef struct ks_dtrace_pattr ks_dtrace_pattr_t;
typedef struct ks_dtrace_pops ks_dtrace_pops_t;
typedef struct ks_dtrace_ppriv ks_dtrace_ppriv_t;
typedef struct ks_dtrace_predicate ks_dtrace_predicate_t;
typedef struct ks_dtrace_probe ks_dtrace_probe_t;
typedef struct ks_dtrace_provider ks_dtrace_provider_t;
typedef struct ks_dtrace_recdesc ks_dtrace_recdesc_t;
typedef unsigned int ks_dtrace_speculation_state;
typedef unsigned int ks_dtrace_speculation_state_t;
typedef struct ks_dtrace_speculation ks_dtrace_speculation_t;
typedef unsigned char ks_dtrace_stability_t;
typedef struct ks_dtrace_state ks_dtrace_state_t;
typedef struct ks_dtrace_statvar ks_dtrace_statvar_t;
typedef struct ks_dtrace_tuple ks_dtrace_tuple_t;
typedef struct ks_dtrace_vstate ks_dtrace_vstate_t;
typedef int ks_errno_t;
typedef unsigned long long ks_event64_t;
typedef int ks_exception_behavior_t;
typedef unsigned int ks_exception_mask_t;
typedef int ks_exception_type_t;
typedef unsigned int ks_file_type_t;
typedef unsigned char ks_filedesc_flags_t;
typedef unsigned short ks_fileproc_flags_t;
typedef unsigned int ks_fileproc_vflags_t;
typedef unsigned int ks_flowadv_idx_t;
typedef void *ks_free_func;
typedef struct ks_fsid ks_fsid_t;
typedef unsigned int ks_fsw_tso_mode_t;
typedef struct ks_gate ks_gate_t;
typedef unsigned int ks_gid_t;
typedef unsigned long long ks_guardid_t;
typedef union ks_guid_t ks_guid_t;
typedef long long ks_hrtime_t;
typedef union ks_hw_lck_ticket_s ks_hw_lck_ticket_t;
typedef unsigned int ks_id_t;
typedef unsigned int ks_idtype_t;
typedef struct ks_if_nexus_flowswitch ks_if_nexus_flowswitch;
typedef struct ks_if_nexus_netif ks_if_nexus_netif;
typedef struct ks_ifcq_sysctl_oid ks_ifcq_oid_t;
typedef int *ks_ifnet_add_proto_func;
typedef int *ks_ifnet_check_multi;
typedef int *ks_ifnet_ctl_func;
typedef int *ks_ifnet_del_proto_func;
typedef int *ks_ifnet_demux_func;
typedef void *ks_ifnet_detach_notify_cb_t;
typedef void *ks_ifnet_detached_func;
typedef void *ks_ifnet_event_func;
typedef unsigned int ks_ifnet_family_t;
typedef int *ks_ifnet_framer_extended_func;
typedef int *ks_ifnet_framer_func;
typedef void *ks_ifnet_fsw_rx_cb_t;
typedef void *ks_ifnet_input_poll_func;
typedef unsigned char ks_ifnet_interface_advisory_direction;
typedef unsigned char ks_ifnet_interface_advisory_interface_type;
typedef unsigned char ks_ifnet_interface_advisory_notification_type_cell;
typedef union ks_ifnet_interface_advisory_notification_type_t ks_ifnet_interface_advisory_notification_type_t;
typedef unsigned char ks_ifnet_interface_advisory_notification_type_wifi;
typedef int ks_ifnet_interface_advisory_rate_trend;
typedef unsigned char ks_ifnet_interface_advisory_version;
typedef unsigned char ks_ifnet_interface_advisory_wifi_freq_band;
typedef int *ks_ifnet_ioctl_func;
typedef unsigned int ks_ifnet_model_t;
typedef int *ks_ifnet_output_func;
typedef int *ks_ifnet_pre_enqueue_func;
typedef int *ks_ifnet_set_bpf_tap;
typedef void *ks_ifnet_start_func;
typedef unsigned int ks_ifnet_subfamily_t;
typedef unsigned int ks_in_addr_t;
typedef unsigned short ks_in_port_t;
typedef short ks_int16_t;
typedef int ks_int32_t;
typedef long long ks_int64_t;
typedef signed char ks_int8_t;
typedef int ks_integer_t;
typedef struct ks_io_stat_info *ks_io_stat_info_t;
typedef unsigned int ks_ipc_entry_num_t;
typedef struct ks_ipc_entry_table *ks_ipc_entry_table_t;
typedef struct ks_ipc_importance_task *ks_ipc_importance_task_t;
typedef unsigned char ks_ipc_kmsg_keep_alive_t;
typedef struct ks_ipc_kmsg *ks_ipc_kmsg_t;
typedef unsigned char ks_ipc_kmsg_type_t;
typedef unsigned long long ks_ipc_label_t;
typedef unsigned int ks_ipc_object_bits_t;
typedef unsigned short ks_ipc_object_copyin_flags_t;
typedef unsigned char ks_ipc_object_state_t;
typedef struct ks_ipc_object *ks_ipc_object_t;
typedef unsigned char ks_ipc_object_type_t;
typedef struct ks_ipc_port_request_table *ks_ipc_port_request_table_t;
typedef struct ks_ipc_port *ks_ipc_port_t;
typedef unsigned long ks_ipc_port_timestamp_t;
typedef unsigned int ks_ipc_table_elems_t;
typedef struct ks_ipc_voucher *ks_ipc_voucher_t;
typedef unsigned char ks_ipv6_router_mode_t;
typedef unsigned char ks_is_telemetry_t;
typedef unsigned int ks_kauth_ace_rights_t;
typedef int ks_kauth_action_t;
typedef struct ks_ucred *ks_kauth_cred_t;
typedef unsigned long long ks_kcd_cd_flag_t;
typedef unsigned long long ks_kcd_compression_type_t;
typedef struct ks_kcdata_descriptor *ks_kcdata_descriptor_t;
typedef unsigned long long ks_kern_nexus_netif_llink_id_t;
typedef int ks_kern_packet_svc_class_t;
typedef unsigned long long ks_kern_packet_t;
typedef int ks_kern_return_t;
typedef int ks_key_t;
typedef unsigned short ks_kn_status_t;
typedef unsigned char ks_kq_index_t;
typedef unsigned short ks_kq_state_t;
typedef unsigned long long ks_kqueue_id_t;
typedef struct ks__lck_grp_stat_ ks_lck_grp_stat_t;
typedef struct ks__lck_grp_stats_ ks_lck_grp_stats_t;
typedef struct ks__lck_grp_ ks_lck_grp_t;
typedef union ks_lck_mtx_state ks_lck_mtx_state_t;
typedef struct ks_lck_mtx_s ks_lck_mtx_t;
typedef struct ks_lck_rw_s ks_lck_rw_t;
typedef union ks_lck_rw_word_t ks_lck_rw_word_t;
typedef struct ks_lck_spin_s ks_lck_spin_t;
typedef struct ks_lck_ticket_s ks_lck_ticket_t;
typedef long long ks_ledger_amount_t;
typedef void *ks_ledger_callback_t;
typedef struct ks_ledger *ks_ledger_t;
typedef void *ks_m_ext_free_func_t;
typedef long long ks_mach_exception_code_t;
typedef long long ks_mach_exception_data_type_t;
typedef long long ks_mach_exception_subcode_t;
typedef void *ks_mach_msg_continue_t;
typedef unsigned long long ks_mach_msg_option64_t;
typedef unsigned char ks_mach_msg_qos_t;
typedef struct ks_mach_msg_recv_bufs_t ks_mach_msg_recv_bufs_t;
typedef int ks_mach_msg_return_t;
typedef unsigned int ks_mach_msg_size_t;
typedef unsigned int ks_mach_msg_type_name_t;
typedef unsigned long ks_mach_port_context_t;
typedef unsigned int ks_mach_port_mscount_t;
typedef unsigned int ks_mach_port_name_t;
typedef unsigned int ks_mach_port_rights_t;
typedef unsigned int ks_mach_port_seqno_t;
typedef struct ks_ipc_port *ks_mach_port_t;
typedef unsigned long long ks_mach_vm_address_t;
typedef unsigned long long ks_mach_vm_offset_t;
typedef unsigned int ks_mach_vm_reclaim_count_t;
typedef unsigned long long ks_mach_vm_size_t;
typedef unsigned int ks_mach_voucher_attr_value_reference_t;
typedef struct ks_vm_object *ks_memory_object_control_t;
typedef int ks_memory_object_copy_strategy_t;
typedef struct ks_memory_object *ks_memory_object_t;
typedef unsigned int ks_mit_mode_t;
typedef unsigned int ks_mo_ipc_object_bits_t;
typedef unsigned short ks_mode_t;
typedef struct ks_mount *ks_mount_t;
typedef unsigned int ks_natural_t;
typedef unsigned int ks_netem_model_t;
typedef unsigned int ks_nexus_adapter_type_t;
typedef unsigned int ks_nexus_advisory_type_t;
typedef unsigned int ks_nexus_meta_subtype_t;
typedef unsigned int ks_nexus_meta_type_t;
typedef unsigned short ks_nexus_port_size_t;
typedef unsigned short ks_nexus_port_t;
typedef unsigned int ks_nexus_stats_type_t;
typedef int ks_nexus_type_t;
typedef unsigned int ks_obj_idx_t;
typedef long long ks_off_t;
typedef unsigned int ks_os_ref_atomic_t;
typedef unsigned int ks_os_ref_count_t;
typedef struct ks_os_refcnt ks_os_refcnt_t;
typedef unsigned int ks_packet_trace_id_t;
typedef unsigned short ks_packet_trace_tag_t;
typedef unsigned int ks_path_operation;
typedef char ks_pbufpool_name_t[0x40];
typedef unsigned int ks_pending_io_t;
typedef int ks_persona_type_t;
typedef int ks_pid_t;
typedef void ks_pkt_copy_from_mbuf_t;
typedef void ks_pkt_copy_from_pkt_t;
typedef void ks_pkt_copy_to_mbuf_t;
typedef struct ks__pktsched_pkt_ ks_pktsched_pkt_t;
typedef unsigned long long ks_pmap_paddr_t;
typedef struct ks_pmap *ks_pmap_t;
typedef char ks_proc_name_t[0x21];
typedef struct ks_proc_ro *ks_proc_ro_t;
typedef struct ks_proc *ks_proc_t;
typedef struct ks_processor_set *ks_processor_set_t;
typedef struct ks_processor *ks_processor_t;
typedef int *ks_proto_media_detached;
typedef void *ks_proto_media_event;
typedef int *ks_proto_media_input;
typedef int *ks_proto_media_input_v2;
typedef int *ks_proto_media_ioctl;
typedef int *ks_proto_media_preout;
typedef int *ks_proto_media_resolve_multi;
typedef int *ks_proto_media_send_arp;
typedef unsigned int ks_protocol_family_t;
typedef unsigned int ks_pset_cluster_type_t;
typedef union ks_pset_execution_time_t ks_pset_execution_time_t;
typedef unsigned char ks_pset_id_t;
typedef unsigned long long ks_pset_map_t;
typedef struct ks_pset_node *ks_pset_node_t;
typedef unsigned long long ks_pt_entry_t;
typedef long long *ks_qaddr_t;
typedef long long ks_quad_t;
typedef struct ks_queue_entry ks_queue_chain_t;
typedef struct ks_queue_entry *ks_queue_entry_t;
typedef struct ks_queue_entry ks_queue_head_t;
typedef struct ks_queue_entry *ks_queue_t;
typedef unsigned int ks_recount_level_t;
typedef unsigned long long ks_resolver_result_t;
typedef unsigned int ks_ring_id_t;
typedef unsigned long long ks_rlim_t;
typedef struct ks_rt_queue_pri_t ks_rt_queue_pri_t;
typedef struct ks_rusage_info_v6 ks_rusage_info_current;
typedef unsigned char ks_sa_family_t;
typedef unsigned long long *ks_scalable_counter_t;
typedef unsigned int ks_sched_bucket_t;
typedef union ks_sched_clutch_bucket_cpu_data ks_sched_clutch_bucket_cpu_data_t;
typedef union ks_sched_clutch_counter_time ks_sched_clutch_counter_time_t;
typedef union ks_sched_clutch_edge ks_sched_clutch_edge;
typedef unsigned int ks_sched_mode_t;
typedef union ks_sched_pset_search_order_t ks_sched_pset_search_order_t;
typedef struct ks_security_token_t ks_security_token_t;
typedef unsigned int ks_sfi_class_id_t;
typedef unsigned int ks_sflt_handle;
typedef struct ks___siginfo ks_siginfo_t;
typedef unsigned int ks_sigset_t;
typedef struct ks_lck_spin_s ks_simple_lock_data_t;
typedef unsigned long ks_size_t;
typedef unsigned int ks_skmem_arena_type_t;
typedef unsigned int ks_skmem_region_id_t;
typedef unsigned int ks_slot_idx_t;
typedef void *ks_smr_cb_t;
typedef struct ks_smr_clock_t ks_smr_clock_t;
typedef unsigned long ks_smr_seq_t;
typedef struct ks_smr *ks_smr_t;
typedef unsigned long long ks_so_gen_t;
typedef unsigned long ks_speed_t;
typedef unsigned char ks_task_control_port_options_t;
typedef unsigned int ks_task_exc_guard_behavior_t;
typedef unsigned int ks_task_memlimit_flags_t;
typedef struct ks_task_restartable_range_t ks_task_restartable_range_t;
typedef struct ks_task_security_config ks_task_security_config_s;
typedef struct ks_task *ks_task_t;
typedef struct ks_task_watcher ks_task_watch_t;
typedef unsigned long ks_tcflag_t;
typedef struct ks_thread_call ks_thread_call_data_t;
typedef unsigned short ks_thread_call_flags_t;
typedef void *ks_thread_call_func_t;
typedef unsigned short ks_thread_call_index_t;
typedef void *ks_thread_call_param_t;
typedef struct ks_thread_call *ks_thread_call_t;
typedef void *ks_thread_continue_t;
typedef struct ks_thread_group *ks_thread_group_qos_t;
typedef unsigned char ks_thread_qos_t;
typedef union ks_thread_rr_state ks_thread_rr_state_t;
typedef unsigned char ks_thread_snapshot_wait_flags;
typedef int ks_thread_state_flavor_t;
typedef struct ks_thread *ks_thread_t;
typedef unsigned short ks_thread_tag_t;
typedef unsigned int ks_thread_work_interval_flags_t;
typedef long ks_time_t;
typedef struct ks_timer_call *ks_timer_call_t;
typedef struct ks_timer ks_timer_data_t;
typedef unsigned long long *ks_trigger_vnode_rearm_callback_t;
typedef void *ks_trigger_vnode_reclaim_callback_t;
typedef unsigned long long *ks_trigger_vnode_resolve_callback_t;
typedef unsigned long long *ks_trigger_vnode_unresolve_callback_t;
typedef unsigned long long ks_tt_entry_t;
typedef void *ks_turnstile_inheritor_t;
typedef unsigned char ks_turnstile_update_flags;
typedef unsigned char ks_turnstile_update_flags_t;
typedef unsigned int ks_txrx;
typedef unsigned int ks_uInt;
typedef unsigned long ks_uLong;
typedef unsigned char ks_u_char;
typedef unsigned int ks_u_int;
typedef unsigned short ks_u_int16_t;
typedef unsigned int ks_u_int32_t;
typedef unsigned long long ks_u_int64_t;
typedef unsigned char ks_u_int8_t;
typedef unsigned long ks_u_long;
typedef unsigned long long ks_u_quad_t;
typedef unsigned short ks_u_short;
typedef unsigned int ks_uid_t;
typedef unsigned int ks_uint;
typedef unsigned short ks_uint16_t;
typedef unsigned int ks_uint32_t;
typedef unsigned long long ks_uint64_t;
typedef unsigned char ks_uint8_t;
typedef unsigned int ks_uint_t;
typedef unsigned long ks_uintptr_t;
typedef unsigned int ks_uio_seg;
typedef struct ks_ulk_t ks_ulk_t;
typedef unsigned int ks_ulk_type;
typedef struct ks_lck_spin_s ks_ull_lock_t;
typedef unsigned long long ks_user_addr_t;
typedef unsigned long long ks_user_size_t;
typedef long long ks_user_ssize_t;
typedef unsigned long long ks_user_ulong_t;
typedef struct ks_lck_spin_s ks_usimple_lock_data_t;
typedef unsigned char ks_uuid_t[0x10];
typedef struct ks_vfs_context *ks_vfs_context_t;
typedef void ks_vfs_trigger_callback_t;
typedef unsigned long ks_vm_address_t;
typedef struct ks_vm_deferred_reclamation_metadata_s *ks_vm_deferred_reclamation_metadata_t;
typedef struct ks_vm_extmod_statistics ks_vm_extmod_statistics_data_t;
typedef unsigned long long ks_vm_map_address_t;
typedef struct ks_vm_map_entry *ks_vm_map_entry_t;
typedef unsigned long long ks_vm_map_offset_t;
typedef const void *ks_vm_map_serial_t;
typedef unsigned long long ks_vm_map_size_t;
typedef struct ks__vm_map *ks_vm_map_t;
typedef unsigned long long ks_vm_object_id_t;
typedef unsigned long long ks_vm_object_offset_t;
typedef struct ks__vm_object_query_data_ ks_vm_object_query_data_t;
typedef unsigned long long ks_vm_object_size_t;
typedef struct ks_vm_object *ks_vm_object_t;
typedef unsigned long ks_vm_offset_t;
typedef unsigned int ks_vm_page_object_t;
typedef unsigned int ks_vm_page_packed_t;
typedef unsigned char ks_vm_page_q_state_t;
typedef struct ks_vm_page_packed_queue_entry ks_vm_page_queue_chain_t;
typedef struct ks_vm_page_packed_queue_entry ks_vm_page_queue_head_t;
typedef unsigned char ks_vm_page_specialq_t;
typedef union ks_vm_shared_region_slide_info_entry *ks_vm_shared_region_slide_info_entry_t;
typedef struct ks_vm_shared_region_slide_info *ks_vm_shared_region_slide_info_t;
typedef unsigned long ks_vm_size_t;
typedef unsigned short ks_vm_tag_t;
typedef struct ks_vmem ks_vmem_t;
typedef struct ks__vmobject_list_output_ *ks_vmobject_list_output_t;
typedef struct ks_vnode_resolve *ks_vnode_resolve_t;
typedef struct ks_vnode *ks_vnode_t;
typedef unsigned int ks_vnode_verify_kind_t;
typedef void *ks_voidpf;
typedef unsigned int ks_vtype;
typedef int ks_wait_result_t;
typedef unsigned int ks_waitq_flags_t;
typedef struct ks_waitq_link_list_entry ks_waitq_link_list_t;
typedef union ks_waitq_t ks_waitq_t;
typedef unsigned int ks_waitq_type_t;
typedef unsigned char ks_wi_class_t;
typedef unsigned int ks_work_interval_auto_join_status_t;
typedef unsigned int ks_workq_state_flags_t;
typedef struct ks_workq_threadreq_s ks_workq_threadreq_s;
typedef struct ks_workq_threadreq_s *ks_workq_threadreq_t;
typedef unsigned char ks_workq_tr_flags_t;
typedef unsigned char ks_workq_tr_state_t;
typedef unsigned __int128 ks_wq_thactive_t;
typedef struct ks_z_stream_s ks_z_stream;
typedef struct ks_zone_magazine *ks_zone_magazine_t;
typedef struct ks_zone_packed_virtual_address ks_zone_pva_t;
typedef void *ks_zone_smr_free_cb_t;
typedef struct ks_zone_stats *ks_zone_stats_t;
typedef struct ks_zone *ks_zone_t;
typedef struct ks_zone_view *ks_zone_view_t;
typedef unsigned int ks_zoneid_t;

#endif
